var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var FileIcons = (function () {
            function FileIcons() {
            }
            FileIcons.forExtension = function (ext) {
                switch (ext) {
                    case "css": return FileIcons.Css;
                    case "gif":
                    case "jpg":
                    case "jpeg":
                    case "png":
                    case "ico": return FileIcons.Image;
                    case "js": return FileIcons.Javascript;
                    case "json": return FileIcons.JSON;
                    case "hbs": return FileIcons.Handlebars;
                    case "md": return FileIcons.Markdown;
                    default: return FileIcons.File;
                }
            };
            FileIcons.Api = { glyph: "'", color: "4", font: "toolbox" };
            FileIcons.Model = { glyph: ">", color: "1", font: "toolbox" };
            FileIcons.ModelExposed = { glyph: "&", color: "1", font: "toolbox" };
            FileIcons.Component = { glyph: "]", color: "8", font: "toolbox" };
            FileIcons.File = { glyph: "0", color: "6", font: "toolbox" };
            FileIcons.Template = { glyph: ")", color: "0", font: "toolbox" };
            FileIcons.Css = { glyph: "`", color: "3", font: "toolbox" };
            FileIcons.Image = { glyph: "f", color: "4", font: "toolbox" };
            FileIcons.Javascript = { glyph: "R", color: "5", font: "toolbox" };
            FileIcons.JSON = { glyph: "6", color: "5", font: "toolbox" };
            FileIcons.Handlebars = { glyph: ")", color: "6", font: "toolbox" };
            FileIcons.Markdown = { glyph: "u", color: "6", font: "toolbox" };
            return FileIcons;
        })();
        IDE.FileIcons = FileIcons;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var IDEModels = (function () {
            function IDEModels() {
            }
            IDEModels.add = function (type) {
                var def = type.prototype.define.apply();
                type.prototype.modelDef = def;
                this._list[def.name] = def;
            };
            IDEModels.get = function (name) {
                return this._list[name];
            };
            IDEModels._list = {};
            return IDEModels;
        })();
        IDE.IDEModels = IDEModels;
        var IDERoutes = (function () {
            function IDERoutes() {
            }
            IDERoutes.add = function (path, viewModelConstructor, view) {
                this._list[path] = new IDE.IDERoute(path, viewModelConstructor, view);
            };
            IDERoutes.get = function (path) {
                return this._list[path];
            };
            IDERoutes._list = {};
            return IDERoutes;
        })();
        IDE.IDERoutes = IDERoutes;
        var IDETemplateDefinitions = (function () {
            function IDETemplateDefinitions() {
            }
            IDETemplateDefinitions.add = function (path, def) {
                this._list[path] = def;
            };
            IDETemplateDefinitions.get = function (path) {
                return this._list[path];
            };
            IDETemplateDefinitions._list = {};
            return IDETemplateDefinitions;
        })();
        IDE.IDETemplateDefinitions = IDETemplateDefinitions;
        var IDECompiledTemplates = (function () {
            function IDECompiledTemplates() {
            }
            IDECompiledTemplates.add = function (path, template) {
                this._list[path] = template;
            };
            IDECompiledTemplates.get = function (path) {
                return this._list[path];
            };
            IDECompiledTemplates._list = {};
            return IDECompiledTemplates;
        })();
        IDE.IDECompiledTemplates = IDECompiledTemplates;
        var IDEInstance = (function () {
            function IDEInstance() {
                this.models = IDEModels;
                this.routes = IDERoutes;
                this.templates = IDECompiledTemplates;
                this.templateDefinitions = IDETemplateDefinitions;
                this.elementSnippets = new Retool.Helpers.HelperLocator();
                this.canvases = new Retool.Canvases();
            }
            IDEInstance.prototype.init = function () {
                var ideApp = new Retool.Application("ide");
                this.ideApp = ideApp;
                ideApp.helpers = Retool.Runtime.helpers;
                this.dialogCanvas = new IDE.IDEDialog();
                this.canvases.add(this.dialogCanvas);
                IDE.activeDesigner.attributeView = new IDE.ElementAttributeView();
                this.canvases.add(IDE.activeDesigner.attributeView);
                this.compileTemplates();
            };
            IDEInstance.prototype.render = function (path, id, params) {
                var route = this.routes.get(path);
                if (route) {
                    var viewModel = new route.viewModelConstructor(id, params);
                    viewModel.actions = viewModel;
                    var template;
                    if (route.view == "inspector") {
                        template = viewModel.build_property_template();
                        IDE.activeDesigner.attributeView.show(template, viewModel);
                    }
                    else if (route.view == "dialog") {
                        var dialog = this.dialogCanvas;
                        template = this.templates.get(path);
                        var context = Retool.RenderingContext.createRoot(dialog, template, viewModel);
                        dialog.context = context;
                        dialog.render(null);
                    }
                }
            };
            IDEInstance.prototype.compileTemplates = function () {
                var list = this.templateDefinitions._list;
                var helpers = this.ideApp.helpers;
                for (var key in list) {
                    var def = list[key];
                    var file = new Retool.FileSystem.File(key, def);
                    var template = IDE.TemplateCompiler.compile(this.sourceApp, file, helpers, Retool.App);
                    this.templates.add(key, template);
                }
            };
            IDEInstance.prototype.refreshCurrentAppPage = function () {
                var canvas = this.getAppCanvas();
                if (canvas) {
                    canvas.reload();
                }
            };
            IDEInstance.prototype.appLoaded = function (appGlobal) {
                Retool.App = appGlobal;
                IDE.Ide.sourceApp = Retool.App.currentApp;
                IDE.activeDesigner.toolbox.refreshAll();
            };
            IDEInstance.prototype.displayError = function (e) {
                var error;
                if (e instanceof Retool.VM.VMError) {
                    error = e;
                }
                else {
                    error = new Retool.VM.VMError(e);
                }
                var target = $('#rto-ide-error');
                Retool.ErrorRenderer.render({ error: error, targetElement: target });
            };
            IDEInstance.prototype.getAppCanvas = function () {
                return Retool.App.mainCanvas;
            };
            return IDEInstance;
        })();
        IDE.IDEInstance = IDEInstance;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        IDE.Ide = new IDE.IDEInstance();
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Folders = (function () {
            function Folders() {
            }
            Folders.isRestricted = function (filename) {
                var root = Folders.getRoot(filename);
                if (root == "models" || root == "api" || root == "components") {
                    return true;
                }
                return false;
            };
            Folders.getRoot = function (filename) {
                var i = filename.indexOf("/");
                if (i != 1) {
                    return filename.substr(0, i);
                }
                return "";
            };
            return Folders;
        })();
        IDE.Folders = Folders;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttributeList = (function (_super) {
                __extends(AttributeList, _super);
                function AttributeList() {
                    _super.apply(this, arguments);
                    this.settings = { "container": true, label: "fieldset", glyph: "i", tourstop: true };
                    this.allowableChildren = ['input', 'block', 'inline', 'datafield', 'button', 'fieldset', 'column'];
                }
                AttributeList.prototype.renderStartTag = function (writer) {
                    writer.startTag("fieldset", this.computeStartTagClass(writer.component));
                };
                AttributeList.prototype.renderContent = function (w) {
                    w.writeTag("table", null);
                    var attr = w.component.attr;
                    w.renderChildComponents(attr.children, function (component) {
                        var css = "";
                        if (component.attr.isNote) {
                            var text = component.getFieldValue();
                            if (text && text.length > 42) {
                                css = "expanded";
                            }
                        }
                        w.writeTag("tr", css);
                        w.writeTag("td", "label").write(component.helper.getLabel(component));
                        if (component.attr.isNote) {
                            w.writeTag("div", "pip").writeTag("a", "", { href: "#", tabIndex: "-1" }).write("</a></div>");
                        }
                        w.write("</td>");
                        w.writeTag("td", "value");
                        w.render(component);
                        w.write("</td></tr>");
                    });
                    w.write("</table>");
                };
                return AttributeList;
            })(Retool.Helpers.HelperBase);
            Helpers.AttributeList = AttributeList;
            Retool.Runtime.helpers.add("ds-attriblist", new AttributeList());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttribBase = (function (_super) {
                __extends(AttribBase, _super);
                function AttribBase() {
                    _super.apply(this, arguments);
                    this.settings = { "container": true, label: "input", tourstop: true, isInput: true };
                }
                AttribBase.prototype.renderContent = function (writer) {
                    var component = writer.component;
                    var fieldErrors = component.context.getFieldErrors(component.attr.value);
                    var locked = component.attr.locked || (component.fieldDefinition && component.fieldDefinition.locked);
                    if (!locked) {
                        locked = component.context.getFieldIsLocked(component.attr.value);
                    }
                    var value = component.getFieldValue();
                    if (locked) {
                        this.renderLocked(writer, value, fieldErrors);
                    }
                    else {
                        this.renderInputElement(writer, value, fieldErrors);
                    }
                    this.renderFieldErrors(writer, fieldErrors);
                    component.localData.renderedValue = value;
                };
                AttribBase.prototype.renderLocked = function (writer, value, fieldErrors) {
                    var c = writer.component;
                    writer.write("<p>");
                    if (c.attr.isDrop) {
                        writer.writeTag("a", "related-rec-link", { href: "#" }).text(this.toDisplay(c, value)).write('</a>');
                    }
                    else {
                        var value = this.toDisplay(c, value);
                        if (value) {
                            writer.text(value);
                        }
                        else {
                            writer.write("&nbsp;");
                        }
                    }
                    writer.write("</p>");
                };
                AttribBase.prototype.renderInputElement = function (writer, value, fieldErrors) {
                    // needs to be implemented on each class
                };
                AttribBase.prototype.toDisplay = function (c, value) {
                    if (value) {
                        return value;
                    }
                    return "";
                };
                AttribBase.prototype.renderFieldErrors = function (w, fieldErrors) {
                    if (fieldErrors) {
                        w.write("<div").writeAttr("class", "retool-field-errors").write(">"); // no writer prefixing (always retool-field-errors)
                        this.renderFieldErrorsContent(w, fieldErrors);
                        w.write('</div>');
                    }
                    else {
                        w.component.localData.renderedErrorVersion = 0;
                    }
                };
                AttribBase.prototype.renderFieldErrorsContent = function (writer, fieldErrors) {
                    var component = writer.component;
                    if (fieldErrors) {
                        for (var i = 0; i < fieldErrors.length; i++) {
                            writer.write("<small").writeAttr("class", "retool-error").write(">"); // no writer formatting of class always "retool-error"
                            writer.text(fieldErrors[i]).write("</small>");
                        }
                        component.localData.renderedErrorVersion = component.context.getErrorVersion();
                    }
                    else {
                        component.localData.renderedErrorVersion = 0;
                    }
                };
                AttribBase.prototype.renderChangesErrors = function (component, inputElem) {
                    var fieldErrors = component.context.getFieldErrors(component.attr.value);
                    var errorsElem = component.getElement('.retool-field-errors');
                    if (fieldErrors) {
                        if (!errorsElem.length) {
                            inputElem.after('<div class="retool-field-errors"></div>');
                            errorsElem = component.getElement('.retool-field-errors');
                        }
                        inputElem.addClass("retool-error");
                        var w = new Retool.Writer();
                        w.component = component;
                        this.renderFieldErrorsContent(w, fieldErrors);
                        w.writeToElements(errorsElem);
                        errorsElem.show();
                    }
                    else {
                        inputElem.removeClass("retool-error");
                        errorsElem.hide();
                        component.localData.renderedErrorVersion = 0;
                    }
                };
                AttribBase.prototype.fieldValuesAreEqual = function (a, b) {
                    return a == b;
                };
                AttribBase.prototype.requiresRender = function (component) {
                    if (component.attr.value) {
                        var field = component.attr.value;
                        var value = component.getFieldValue();
                        var context = component.context;
                        if (!this.fieldValuesAreEqual(value, component.localData.renderedValue)) {
                            return true;
                        }
                        if (component.localData.renderedErrorVersion) {
                            // if was previously rendered with error and no longer has error, or error version is different then re-render
                            if (!context.hasErrors(field) || component.localData.renderedErrorVersion != context.getErrorVersion()) {
                                return true;
                            }
                        }
                        else {
                            if (context.hasErrors(field)) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                AttribBase.prototype.onclick = function (event) {
                    var target = $(event.domEvent.target);
                    event.handled = false;
                };
                AttribBase.prototype.map = function (element, compiler) {
                    element.isDrop = false;
                    if (element.droptype) {
                        element.isDrop = true;
                    }
                };
                AttribBase.prototype.getInspectorInfo = function (element) {
                    var info = {};
                    if (element.value) {
                        info.text = element.value;
                    }
                    return info;
                };
                return AttribBase;
            })(Retool.Helpers.HelperBase);
            Helpers.AttribBase = AttribBase;
            Retool.Runtime.helpers.add("ds-attribbase", new AttribBase());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttribTextBase = (function (_super) {
                __extends(AttribTextBase, _super);
                function AttribTextBase() {
                    _super.apply(this, arguments);
                }
                AttribTextBase.prototype.renderStartTag = function (writer) {
                    writer.startTag("div", this.computeStartTagClass(writer.component));
                };
                AttribTextBase.prototype.computeStartTagClass = function (c) {
                    return c.computeClass("input");
                };
                AttribTextBase.prototype.renderInputElement = function (writer, value, fieldErrors) {
                    var c = writer.component;
                    var attr = c.attr;
                    if (attr.isDrop) {
                        writer.writeTag("div", "input-drp");
                        if (attr.droptype == "generic") {
                            var drop = new IDE.GenericAutoComplete(c, null);
                            drop.dropItems = attr.dropItems;
                            c.localData.dropRenderer = drop;
                        }
                        else {
                            c.localData.dropRenderer = Retool.getStaticAutoComplete(attr.droptype, c);
                        }
                    }
                    var prefix = c.getAttr('prefix');
                    if (prefix) {
                        writer.writeTag("div", "prefix").text(prefix).write('</div>');
                    }
                    if (attr.encrypted) {
                        writer.write('<input type="password"');
                    }
                    else {
                        writer.write('<input type="text"');
                    }
                    if (attr.placeholder) {
                        writer.writeAttr("placeholder", attr.placeholder);
                    }
                    if (fieldErrors) {
                        writer.writeAttr("class", "error");
                    }
                    var displayValue = this.toDisplay(c, value);
                    writer.writeAttr("value", displayValue);
                    writer.write('/>');
                    if (attr.isDrop) {
                        c.localData.dropDisplayValue = displayValue;
                        writer.writeTag("div", "input-drpbtn", { "data-drpbtn": "true" }).write('<div><a href="#" tabindex="-1"></a></div></div>');
                        writer.write('</div>');
                    }
                    if (attr.suffix) {
                        writer.writeTag("div", "suffix").text(attr.suffix).write('</div>');
                    }
                };
                AttribTextBase.prototype.toDisplay = function (c, value) {
                    if (!value)
                        return "";
                    var attr = c.attr;
                    if (attr.isDrop) {
                        var staticList = c.localData.dropRenderer;
                        if (staticList) {
                            return staticList.toDisplay(value);
                        }
                    }
                    return value;
                };
                AttribTextBase.prototype.renderChanges = function (component) {
                    var value = component.getFieldValue();
                    var inputElem = component.getElement("input");
                    if (inputElem.length) {
                        inputElem.val(this.toDisplay(component, value));
                        this.renderChangesErrors(component, inputElem);
                    }
                    else {
                        var w = new Retool.Writer();
                        w.component = component;
                        this.renderLocked(w, value, null);
                        w.writeToElement(component.getElement());
                    }
                    component.localData.renderedValue = value;
                    return false;
                };
                AttribTextBase.prototype.onblur = function (event) {
                    var c = event.component;
                    this.formatLostFocus(c);
                    var target = $(event.domEvent.target);
                    var inputElem = c.getElement("input");
                    var allowNonDropValue = c.attr.allowNonDrop;
                    // var inputElem = target.is("input") ? target : target.find("input").first();
                    if (c.attr.isDrop) {
                        if (inputElem.val()) {
                            if (c.localData.dropDisplayValue && !allowNonDropValue) {
                                inputElem.val(c.localData.dropDisplayValue); // reset the value
                                return;
                            }
                        }
                        else {
                            c.setFieldValue("");
                            c.localData.dropDisplayValue = "";
                            // c.setRelatedDropText(c.attr.value,"");
                            return;
                        }
                    }
                    var value = inputElem.val();
                    if (value != c.beforeEditValue) {
                        var dataValue = c.setFieldValue(value);
                        event.valueChanged(c);
                        if (c.attr.onchange) {
                            c.attr.onchange.apply(c);
                        }
                        c.localData.renderedValue = dataValue;
                        c.beforeEditValue = value;
                    }
                };
                AttribTextBase.prototype.onkeypress = function (event) {
                    var c = event.component;
                    if (c.attr.isDrop) {
                        var autoComplete = Retool.getAutoComplete(c.getElement());
                        autoComplete.sendKey(c, event.domEvent);
                    }
                };
                AttribTextBase.prototype.onkeydown = function (event) {
                    var c = event.component;
                    if (c.attr.isDrop) {
                        var autoComplete = Retool.getAutoComplete(c.getElement());
                        autoComplete.sendKey(c, event.domEvent);
                    }
                };
                AttribTextBase.prototype.setValueFromDrop = function (c, data) {
                    var inputElem = c.getElement("input");
                    inputElem.val(data.text);
                    c.localData.dropDisplayValue = data.text;
                    // c.setRelatedDropText(c.attr.value,data.text);
                    c.setFieldValue(data.value);
                    if (c.attr.onchange) {
                        c.attr.onchange.apply(c);
                    }
                    c.localData.renderedValue = data.value;
                    c.beforeEditValue = data.text;
                    var event = new Retool.ComponentEvent(c, null);
                    event.callComponentMethod("onchange");
                    inputElem.focus();
                };
                AttribTextBase.prototype.onfocus = function (event) {
                    var target = $(event.domEvent.target);
                    var inputElem = target.is("input") ? target : target.find("input").first();
                    if (inputElem.length) {
                        var value = inputElem.val();
                        event.component.beforeEditValue = value;
                        if (event.component.attr.isDrop) {
                            event.component.localData.dropDisplayValue = value;
                        }
                    }
                };
                AttribTextBase.prototype.formatLostFocus = function (c) {
                    if (c.attr.lowercase) {
                        var inputElem = c.getElement("input");
                        var value = inputElem.val();
                        value = value.toLowerCase();
                        inputElem.val(value);
                    }
                    else if (c.attr.uppercase) {
                        var inputElem = c.getElement("input");
                        var value = inputElem.val();
                        value = value.toUpperCase();
                        inputElem.val(value);
                    }
                };
                AttribTextBase.prototype.onkeyup = function (event) {
                    if (event.component.attr.isDrop) {
                        var inputElem = event.component.getElement("input");
                        var value = inputElem.val();
                        var autoComplete = Retool.getAutoComplete(inputElem);
                        autoComplete.sendKeyUp(event.component, event.domEvent, value);
                    }
                    else if (event.component.attr.onkeyup) {
                        var inputElem = event.component.getElement("input");
                        var value = inputElem.val();
                        event.component.attr.onkeyup.apply(value, [event]);
                    }
                };
                AttribTextBase.prototype.onclick = function (event) {
                    if (event.component.attr.isDrop) {
                        event.keepDropOpen();
                        var target = $(event.domEvent.target);
                        event.domEvent.preventDefault();
                        var drpbtn = target.closest('[data-drpbtn]');
                        if (drpbtn.length) {
                            var autoComplete = Retool.getAutoComplete(target);
                            autoComplete.show(event.component);
                            event.component.getElement("input").focus();
                            return;
                        }
                    }
                    _super.prototype.onclick.call(this, event);
                };
                AttribTextBase.prototype.getAutoCompleteModelDef = function (c) {
                    var relationship = IDE.Ide.sourceApp.getFieldRelationship(c.context.modelDef, c.attr.value);
                    var relatedModelDef = IDE.Ide.sourceApp.models.getDefinition(relationship.model);
                    return relatedModelDef;
                };
                return AttribTextBase;
            })(Helpers.AttribBase);
            Helpers.AttribTextBase = AttribTextBase;
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttribCheckbox = (function (_super) {
                __extends(AttribCheckbox, _super);
                function AttribCheckbox() {
                    _super.apply(this, arguments);
                    this.suppressLabel = true;
                }
                AttribCheckbox.prototype.renderStartTag = function (writer) {
                    writer.startTag("div", this.computeStartTagClass(writer.component));
                };
                AttribCheckbox.prototype.computeStartTagClass = function (c) {
                    return c.computeClass("input checkbox");
                };
                AttribCheckbox.prototype.renderInputElement = function (writer, value, fieldErrors) {
                    writer.write('<input type="checkbox"');
                    if (value && value != "0") {
                        writer.write(' checked="checked"');
                    }
                    writer.write('>').writeTag("span", "checkbox-label").text(writer.component.getFieldLabel()).write('</span>');
                    if (value && value != "0") {
                        writer.write('<span class="rto-glyph rto-toolbox">7</span>');
                    }
                    else {
                        writer.write('<span class="rto-glyph rto-toolbox">&nbsp;</span>');
                    }
                };
                AttribCheckbox.prototype.renderLocked = function (writer, value, fieldErrors) {
                    writer.write("<p>");
                    if (value && value != "0") {
                        writer.write("Yes");
                    }
                    else {
                        writer.write("No");
                    }
                    writer.write("</p>");
                };
                AttribCheckbox.prototype.renderChanges = function (component) {
                    var value = component.getFieldValue();
                    var inputElem = component.getElement("input").get(0);
                    var span = component.getElement("span.rto-glyph");
                    if (value && value != "0") {
                        inputElem.checked = true;
                        span.html("7");
                    }
                    else {
                        inputElem.checked = false;
                        span.html("&nbsp;");
                    }
                    component.localData.renderedValue = value;
                    return false;
                };
                AttribCheckbox.prototype.onclick = function (event) {
                    var component = event.component;
                    var value;
                    var refresh = false;
                    var target = event.domEvent.target;
                    if (target.tagName == "INPUT") {
                        var input = $('#' + component.getElementId() + " input").get(0);
                        value = input.checked;
                    }
                    else {
                        if (event.domEvent.target.tagName != "SPAN")
                            return;
                        var fieldValue = component.getFieldValue();
                        value = (fieldValue && fieldValue != "0");
                        value = !value;
                    }
                    if (value) {
                        component.setFieldValue(1);
                    }
                    else {
                        component.setFieldValue(0);
                    }
                    event.valueChanged(component);
                    if (component.attr.onchange) {
                        component.attr.onchange.apply(component);
                    }
                    this.renderChanges(component);
                };
                return AttribCheckbox;
            })(Helpers.AttribBase);
            Helpers.AttribCheckbox = AttribCheckbox;
            Retool.Runtime.helpers.add("ds-attrib_checkbox", new AttribCheckbox());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttribCheckToggle = (function (_super) {
                __extends(AttribCheckToggle, _super);
                function AttribCheckToggle() {
                    _super.apply(this, arguments);
                }
                AttribCheckToggle.prototype.computeStartTagClass = function (c) {
                    return c.computeClass("input toggle");
                };
                AttribCheckToggle.prototype.renderInputElement = function (writer, value, fieldErrors) {
                    if (value && value != "0") {
                        writer.write('<span class="rto-glyph rto-toolbox">7</span>');
                    }
                    else {
                        writer.write('<span class="rto-glyph rto-toolbox">&nbsp;</span>');
                    }
                };
                AttribCheckToggle.prototype.renderLocked = function (writer, value, fieldErrors) {
                    writer.write("<p>");
                    if (value && value != "0") {
                        writer.write("Yes");
                    }
                    else {
                        writer.write("No");
                    }
                    writer.write("</p>");
                };
                AttribCheckToggle.prototype.renderChanges = function (component) {
                    var value = component.getFieldValue();
                    var span = component.getElement("span");
                    if (value && value != "0") {
                        span.html("7");
                    }
                    else {
                        span.html("&nbsp;");
                    }
                    component.localData.renderedValue = value;
                    return false;
                };
                return AttribCheckToggle;
            })(Helpers.AttribCheckbox);
            Helpers.AttribCheckToggle = AttribCheckToggle;
            Retool.Runtime.helpers.add("ds-attrib_check_toggle", new AttribCheckToggle());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttribText = (function (_super) {
                __extends(AttribText, _super);
                function AttribText() {
                    _super.apply(this, arguments);
                }
                return AttribText;
            })(Helpers.AttribTextBase);
            Helpers.AttribText = AttribText;
            Retool.Runtime.helpers.add("ds-attrib_text", new AttribText());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttribTextArea = (function (_super) {
                __extends(AttribTextArea, _super);
                function AttribTextArea() {
                    _super.apply(this, arguments);
                }
                AttribTextArea.prototype.renderStartTag = function (writer) {
                    writer.startTag("div", this.computeStartTagClass(writer.component));
                };
                AttribTextArea.prototype.computeStartTagClass = function (c) {
                    return c.computeClass("c-inp txtarea");
                };
                AttribTextArea.prototype.renderInputElement = function (writer, value, fieldErrors) {
                    writer.write("<textarea");
                    if (fieldErrors) {
                        writer.writeAttr("class", "error");
                    }
                    var c = writer.component;
                    if (c.attr.placeholder) {
                        writer.writeAttr("placeholder", c.attr.placeholder);
                    }
                    writer.write('>');
                    if (value) {
                        writer.text(value);
                    }
                    writer.write("</textarea>");
                };
                AttribTextArea.prototype.renderChanges = function (component) {
                    var value = component.getFieldValue();
                    var inputElem = component.getElement("textarea");
                    inputElem.val(value);
                    component.localData.renderedValue = value;
                    this.renderChangesErrors(component, inputElem);
                    return false;
                };
                AttribTextArea.prototype.onblur = function (event) {
                    var target = $(event.domEvent.target);
                    var inputElem = target.is("textarea") ? target : target.find("textarea").first;
                    var value = inputElem.val();
                    var c = event.component;
                    if (value != c.beforeEditValue) {
                        c.setFieldValue(value);
                        event.valueChanged(c);
                        if (c.attr.onchange) {
                            c.attr.onchange.apply(c);
                        }
                        c.localData.renderedValue = value;
                        c.beforeEditValue = value;
                    }
                };
                AttribTextArea.prototype.onfocus = function (event) {
                    var target = $(event.domEvent.target);
                    var inputElem = target.is("textarea") ? target : target.find("textarea").first;
                    var value = inputElem.val();
                    event.component.beforeEditValue = value;
                };
                AttribTextArea.prototype.onkeypress = function (event) {
                    var de = event.domEvent;
                    var c = event.component;
                    if (!c.attr.singleLine && de.which == 13) {
                        event.stopPropagation();
                    }
                    else {
                        event.handled = false;
                    }
                    var target = $(event.domEvent.target);
                    var inputElem = target.is("textarea") ? target : target.find("textarea").first;
                    var value = inputElem.val();
                    if (value.length > 42) {
                        $(target).closest('tr').addClass("rto-large-block");
                    }
                };
                return AttribTextArea;
            })(Helpers.AttribBase);
            Helpers.AttribTextArea = AttribTextArea;
            Retool.Runtime.helpers.add("ds-attrib_textarea", new AttribTextArea());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttribRichText = (function (_super) {
                __extends(AttribRichText, _super);
                function AttribRichText() {
                    _super.apply(this, arguments);
                    this.areaInstances = {};
                }
                AttribRichText.prototype.renderStartTag = function (writer) {
                    writer.startTag("div", this.computeStartTagClass(writer.component));
                };
                AttribRichText.prototype.computeStartTagClass = function (c) {
                    return c.computeClass("c-inp richtext");
                };
                AttribRichText.prototype.renderInputElement = function (writer, value, fieldErrors) {
                    var self = this, c = writer.component;
                    writer.addAfterRender(function () {
                        var areaInstance = self.areaInstances[c.attr.attrName];
                        if (!self.helperRegistered) {
                            CodeMirror.registerHelper("hint", "richtext", AttribRichText.getHints);
                            IDE.CodeMirrorMixedMode.initialize();
                            self.helperRegistered = true;
                        }
                        if (!areaInstance) {
                            areaInstance = {
                                container: $('<div class="rto-richtext-editor rto-code-editor">'),
                                element: $('<textarea>'),
                                editor: undefined,
                                component: undefined,
                                hintTimeout: undefined,
                                hintFunction: undefined,
                                getHints: self.getCSSHints.bind(self),
                                getPrefixInfo: self.getCSSPrefixInfo.bind(self),
                                hideLintErrorDisplay: function () {
                                }
                            };
                            areaInstance.container.append(areaInstance.element);
                            areaInstance.editor = CodeMirror.fromTextArea(areaInstance.element[0], {
                                mode: 'mixedmode',
                                theme: 'dark',
                                lineWrapping: true,
                                viewportMargin: Infinity,
                                extraKeys: {
                                    Tab: false,
                                    'Shift-Tab': false,
                                    Enter: false
                                }
                            });
                            areaInstance.hintFunction = function () {
                                CodeMirror.showHint(areaInstance.editor, CodeMirror.hint.richtext, {
                                    retoolCodeEditorInstance: areaInstance,
                                    container: $('body')[0]
                                });
                            };
                            areaInstance.editor.on('change', function (editor) {
                                var value = areaInstance.component.getFieldValue(), newValue = editor.getValue();
                                if (value != newValue) {
                                    areaInstance.component.localData.renderedValue = newValue;
                                    areaInstance.component.setFieldValue(newValue);
                                    (areaInstance.component.context.canvas).model.dirty = true;
                                    $('#rto-attributes-apply').removeClass('rto-inactive');
                                }
                            });
                            areaInstance.editor.on('keyup', function (editor, e) {
                                self.editorKeyup(e, editor, areaInstance);
                            });
                            self.areaInstances[c.attr.attrName] = areaInstance;
                        }
                        areaInstance.component = c;
                        c.getElement().append(areaInstance.container);
                        areaInstance.editor.setValue(value || "");
                        areaInstance.editor.execCommand("goDocEnd");
                    });
                };
                AttribRichText.prototype.editorKeyup = function (e, editor, areaInstance) {
                    if (!editor.state.completionActive) {
                        //on keyup we need to ignore key codes already defined in codemirror-retool-show-hint.js
                        var popupKeyCodes = {
                            "9": "tab",
                            "13": "enter",
                            "27": "escape",
                            "33": "pageup",
                            "34": "pagedown",
                            "35": "end",
                            "36": "home",
                            "38": "up",
                            "40": "down"
                        };
                        if (!popupKeyCodes[(e.keyCode || e.which).toString()]) {
                            // because we can register multiple keypresses before .state.completionActive is registered
                            // we must kill the previous attempt at suggestions and create a new request.
                            this.updateHints(areaInstance);
                        }
                    }
                };
                AttribRichText.prototype.updateHints = function (areaInstance) {
                    if (areaInstance.hintTimeout) {
                        clearTimeout(areaInstance.hintTimeout);
                    }
                    areaInstance.hintTimeout = setTimeout(areaInstance.hintFunction);
                };
                AttribRichText.prototype.getCSSPrefixInfo = function (editor) {
                    var tokenRegex = /[:@\s]/, cur = editor.getCursor(), line = editor.getLine(cur.line), nextToken = line.substring(cur.ch).search(tokenRegex), end = nextToken == -1 ? line.length : nextToken + cur.ch, lastToken = line.substring(0, cur.ch).split("").reverse().join("").search(tokenRegex), start = lastToken == -1 ? 0 : end - lastToken - (end - cur.ch), prefix = start == 0 ? line.substring(0, end) : line.substring(0, start), filter = line.substring(start, end);
                    return {
                        prefix: prefix,
                        filter: filter,
                        line: cur.line,
                        from: CodeMirror.Pos(cur.line, start),
                        to: CodeMirror.Pos(cur.line, end)
                    };
                };
                AttribRichText.prototype.getCSSHints = function (editor, areaInstance) {
                    var prefixInfo = this.getCSSPrefixInfo(editor);
                    var list = [];
                    if (!prefixInfo.filter) {
                        return null;
                    }
                    for (var i = 0; i < IDE.bootstrapClasses.length; i++) {
                        var value = IDE.bootstrapClasses[i];
                        list.push({ text: value, className: "cssclass" });
                    }
                    list.push({
                        text: 'text',
                        displayText: 'text',
                        parameters: '(params)'
                    });
                    return {
                        list: list,
                        filter: prefixInfo.filter,
                        prefix: prefixInfo.prefix,
                        from: prefixInfo.from,
                        to: prefixInfo.to
                    };
                };
                AttribRichText.getHints = function (editor, options) {
                    var areaInstance = options.retoolCodeEditorInstance;
                    if (areaInstance.getHints) {
                        return areaInstance.getHints(editor, areaInstance);
                    }
                };
                return AttribRichText;
            })(Helpers.AttribBase);
            Helpers.AttribRichText = AttribRichText;
            Retool.Runtime.helpers.add("ds-attrib_richtext", new AttribRichText());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttribTitleSize = (function (_super) {
                __extends(AttribTitleSize, _super);
                function AttribTitleSize() {
                    _super.apply(this, arguments);
                }
                AttribTitleSize.prototype.renderStartTag = function (writer) {
                    writer.startTag("div", this.computeStartTagClass(writer.component));
                };
                AttribTitleSize.prototype.computeStartTagClass = function (c) {
                    return c.computeClass("c-inp-heading-size");
                };
                AttribTitleSize.prototype.renderInputElement = function (w, value, fieldErrors) {
                    if (!value) {
                        value = "1";
                    }
                    for (var i = 1; i <= 6; i++) {
                        var selected = (i.toString() == value) ? " selected" : "";
                        w.writeTag("div", selected).writeTag("div", "size" + i).write("H" + i + "</div></div>");
                    }
                };
                AttribTitleSize.prototype.renderLocked = function (writer, value, fieldErrors) {
                    if (value) {
                        value = value;
                    }
                    writer.write("<p>");
                    writer.text(value);
                    writer.write("</p>");
                };
                AttribTitleSize.prototype.onclick = function (event) {
                    var c = event.component;
                    var target = event.domEvent.target;
                    var div = $(target).closest('.rto-c-inp-heading-size > div');
                    if (div.length) {
                        var value = (div.index() + 1).toString();
                        c.setFieldValue(value);
                        event.valueChanged(c);
                        c.refresh();
                        c.raise({ componentName: "btnUpdate", methodName: "onclick", event: event });
                    }
                    event.domEvent.preventDefault();
                };
                return AttribTitleSize;
            })(Helpers.AttribBase);
            Helpers.AttribTitleSize = AttribTitleSize;
            Retool.Runtime.helpers.add("ds-attrib_titlesize", new AttribTitleSize());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttributeForm = (function (_super) {
                __extends(AttributeForm, _super);
                function AttributeForm() {
                    _super.apply(this, arguments);
                    this.settings = { componentClass: "form" };
                }
                AttributeForm.prototype.renderStartTag = function (writer) {
                    writer.startTag("div", this.computeStartTagClass(writer.component), { "data-default-btn-container": "true" });
                };
                AttributeForm.prototype.computeStartTagClass = function (c) {
                    return c.computeClass("attributes-form prop-list");
                };
                AttributeForm.prototype.renderContent = function (w) {
                    var c = w.component;
                    w.write('<div id="' + c.getElementId() + '_errors" style="display:none" ></div>');
                    w.writeTag("div", "attrib-toolbar row");
                    this.renderToolbar(w, c);
                    w.write('</div>');
                    w.writeTag("div", null, { id: "attributes-scroll" });
                    w.renderChildren();
                    w.write('</div>');
                    // w.resizeDesigner = true;
                };
                AttributeForm.prototype.renderToolbar = function (w, c) {
                    var attr = c.attr;
                    if (attr.toolbar && attr.toolbar.length) {
                        w.writeTag("ul", "button-group radius left");
                        w.renderChildComponents(attr.toolbar);
                        w.write('</ul>');
                    }
                    w.writeTag("ul", "button-group radius right");
                    w.write('<li>').writeTag("a", "button small default inactive", { href: "#", "data-default-btn": "true", id: "attributes-apply" }).write('Apply</a></li>');
                    w.write('<li>').writeTag("a", "button small secondary delete", { href: "#" }).write('Delete</a></li>');
                    w.write('</ul>');
                };
                AttributeForm.prototype.onclick = function (e) {
                    var target = $(e.domEvent.target);
                    var c = e.component;
                    if (target.hasClass('rto-default')) {
                        c.raise({ methodName: "onclick", componentName: "btnUpdate", event: e });
                    }
                    else if (target.hasClass('rto-delete')) {
                        c.raise({ componentName: "btnDelete", methodName: "onclick", event: e });
                    }
                    e.domEvent.preventDefault();
                };
                AttributeForm.prototype.closeDialog = function (c) {
                    var w = c.getView().createWriter();
                    w.component = c;
                    this.renderToolbar(w, c);
                    w.writeToElement(c.getElement(".rto-attrib-toolbar"));
                };
                AttributeForm.prototype.renderDialog = function (component, writer, dialog) {
                    writer.render(dialog);
                    writer.writeToElement(component.getElement(".rto-attrib-toolbar"));
                };
                return AttributeForm;
            })(Retool.Helpers.FormBase);
            Helpers.AttributeForm = AttributeForm;
            Retool.Runtime.helpers.add("ds-attributeform", new AttributeForm());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var DialogForm = (function (_super) {
                __extends(DialogForm, _super);
                function DialogForm() {
                    _super.apply(this, arguments);
                    this.settings = { "container": true, "toolbox": false, label: "form", dropKind: "block", glyph: "r", tourstop: true, expandOnCreate: true, category: "", componentClass: "form" };
                    this.allowableChildren = ['block', 'inline', 'fieldset', 'titlebar', 'editbar', 'row', 'table', 'relationship', 'tabs'];
                }
                DialogForm.prototype.renderStartTag = function (writer) {
                    writer.startTag("div", this.computeStartTagClass(writer.component), { role: "form", "data-default-btn-container": "true" });
                };
                DialogForm.prototype.computeStartTagClass = function (c) {
                    return c.computeClass("dialog-form");
                };
                DialogForm.prototype.renderInner = function (writer) {
                    var cls = "edit ";
                    writer.renderChildren();
                    var component = writer.component;
                    var focus;
                    if (writer.setFocusTo) {
                        focus = function () {
                            $("#" + writer.setFocusTo).focus();
                        };
                    }
                    else {
                        focus = function () {
                            $("#" + component.getElementId() + " input:visible:enabled:first").focus();
                        };
                    }
                    writer.addAfterRender(function () {
                        setTimeout(focus, 300);
                    });
                };
                return DialogForm;
            })(Retool.Helpers.FormBase);
            Helpers.DialogForm = DialogForm;
            Retool.Runtime.helpers.add("ds-dialog-form", new DialogForm());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var CustomComponentPropertyDef = (function (_super) {
                __extends(CustomComponentPropertyDef, _super);
                function CustomComponentPropertyDef() {
                    _super.apply(this, arguments);
                    this.settings = { "toolbox": true, label: "#property", dropKind: "block", glyph: "f", tourstop: true, category: "helpers", helper: true };
                }
                CustomComponentPropertyDef.prototype.buildEditor = function (builder) {
                    builder.addTextProp("label", "Label");
                    builder.addTextProp("type", "Type");
                };
                CustomComponentPropertyDef.prototype.getInspectorInfo = function (element) {
                    var info = {};
                    info.name = element.name;
                    return info;
                };
                return CustomComponentPropertyDef;
            })(Retool.Helpers.HelperBase);
            Helpers.CustomComponentPropertyDef = CustomComponentPropertyDef;
            Retool.Runtime.helpers.add("_propdef", new CustomComponentPropertyDef());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Helpers;
        (function (Helpers) {
            var AttributeTool = (function (_super) {
                __extends(AttributeTool, _super);
                function AttributeTool() {
                    _super.apply(this, arguments);
                    this.settings = { "container": true, label: "div", dropKind: "block", glyph: "f", tourstop: true };
                    this.allowableChildren = ['block', 'inline', 'table', 'buttonbar'];
                }
                AttributeTool.prototype.renderStartTag = function (writer) {
                    writer.startTag("li", this.computeStartTagClass(writer.component));
                };
                AttributeTool.prototype.renderContent = function (w) {
                    var c = w.component;
                    w.writeTag("a", "button small secondary", { href: "#" }).text(c.attr.text).write('</a>');
                };
                AttributeTool.prototype.onclick = function (event) {
                    var component = event.component;
                    var handled;
                    if (component.attr.name) {
                        component.raise({ methodName: "onclick", event: event });
                        handled = true;
                    }
                    this.afterClick(event, handled);
                };
                return AttributeTool;
            })(Retool.Helpers.HelperBase);
            Helpers.AttributeTool = AttributeTool;
            Retool.Runtime.helpers.add("ds-tool", new AttributeTool());
        })(Helpers = IDE.Helpers || (IDE.Helpers = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CodeEditor = (function () {
            function CodeEditor(options) {
                this.lintErrors = {};
                this.lintGutterClass = 'CodeMirror-lintmarkers';
                this.lintGutterMarkerClass = 'lint-marker';
                this.lintErrorDetailClass = 'jshint-error-details';
                this.active = false;
                this.mode = "javascript";
                this.initialized = false;
                this.currentFlashLine = -1;
                this.options = options;
            }
            CodeEditor.prototype.initialize = function () {
                var options = this.options;
                this.container = $('#' + options.id);
                this.element = this.container.get(0);
                var instance = this;
                var codeMirrorOptions = {};
                if (!this.container.length) {
                    throw 'element ' + options.id + ' does not exist, unable to create new CodeEditor';
                }
                if (options.boundingBoxId) {
                    this.widgetContainer = $('#' + options.boundingBoxId);
                    if (!this.widgetContainer.length) {
                        throw 'widget container id set to ' + options.boundingBoxId + ' but element does not exist, using container.';
                    }
                }
                if (!this.widgetContainer) {
                    this.widgetContainer = this.container;
                }
                this.mode = options.mode;
                codeMirrorOptions.mode = "text/typescript";
                codeMirrorOptions.theme = "dark";
                if (this.mode == "css") {
                    codeMirrorOptions.mode = "text/css";
                    codeMirrorOptions.theme = "dark-css";
                }
                // we set different codeMirror options depending on if we are in a singleLine mode or not
                if (!options.singleLine) {
                    codeMirrorOptions.lineNumbers = true;
                    codeMirrorOptions.styleActiveLine = true;
                    codeMirrorOptions.gutters = ["rto-code-breakpoints", "CodeMirror-linenumbers", this.lintGutterClass,];
                    codeMirrorOptions.extraKeys = {
                        "Ctrl-S": function (instance) {
                            if (options.save) {
                                options.save(instance.getValue());
                            }
                        },
                        "Cmd-S": function (instance) {
                            if (options.save) {
                                options.save(instance.getValue());
                            }
                        },
                        "Ctrl-R": function (instance) {
                            IDE.Ide.refreshCurrentAppPage();
                        },
                        "Cmd-R": function (instance) {
                            IDE.Ide.refreshCurrentAppPage();
                        }
                    };
                }
                else {
                    // we set the viewportMargin to Infinity based on this example
                    // http://codemirror.net/demo/resize.html
                    codeMirrorOptions.viewportMargin = Infinity;
                    // we disable lineWrapping in prompt mode because the container which the prompt lives in
                    // will likely have it's own scrolling.
                    codeMirrorOptions.lineWrapping = true;
                    // in singleLine mode we only want to be able to have one line so:
                    codeMirrorOptions.extraKeys = {
                        Enter: function (cm) {
                            // the user can pass in a function for onEnterKey so that they can get the code at the prompt
                            // also, we always clear out the value of the code editor after enter when in singleLine mode
                            if (options.onEnterKey) {
                                options.onEnterKey(cm.getValue());
                            }
                            cm.setValue('');
                        },
                        Up: function (cm) {
                            //allow the user to keep a history of input commands and pass them in when the up key is entered
                            if (options.onReplay) {
                                cm.setValue(options.onReplay());
                                instance.focusToEnd();
                            }
                        },
                        Tab: function (cm) {
                            instance.updateHints();
                        }
                    };
                }
                // create the instance of CodeMirror
                this.editor = new CodeMirror(this.element, codeMirrorOptions);
                this.editor.on("gutterClick", function (cm, n) {
                    var info = cm.lineInfo(n);
                    cm.setGutterMarker(n, "rto-code-breakpoints", info.gutterMarkers ? null : instance.makeBreakpoint());
                    if (instance.file) {
                        instance.file.breakPoints = instance.getBreakPoints();
                    }
                });
                // we can use autocomplete hinting if we are in javascript mode
                if (options.onGetSuggestions) {
                    CodeMirror.registerHelper("hint", "retool", CodeEditor.getHints);
                    var hintOptions = {};
                    if (this.mode == "javascript") {
                        hintOptions.closeCharcters = /[)\[\]{};:>,]/;
                    }
                    this.hintFunction = function () {
                        CodeMirror.showHint(instance.editor, CodeMirror.hint.retool, {
                            container: $('body')[0],
                            retoolCodeEditorInstance: instance
                        });
                    };
                }
                // when we hover over the lines we display the current error at this position
                // TODO: this may not be the desired behavior.  perhaps we only want to show the
                // 		 error when we put the cursor on this line.
                // TODO: this might make more sense if we do this in renderLine event of the editor
                //       this code adds events to all lines and not just the visible ones.
                this.container.on("mouseover", ".CodeMirror-lines,.CodeMirror-gutters", function (e) {
                    instance.updatePosition(e.pageX, e.pageY);
                });
                // bind the escape key to hide any lint errors.  otherwise, check the current position
                // and if we have changed lines since we last checked then update the errors we are displaying for the current line
                // TODO: decide whether we should do this on the editor or the container.
                // 		 not sure if it matters or not.
                this.container.on("keyup", function (e) {
                    switch (e.keyCode || e.which) {
                        case 27:
                            if (!options.singleLine && instance.mode == "javascript") {
                                instance.hideLintErrorDisplay();
                            }
                            break;
                        default:
                            var pos = instance.editor.cursorCoords(instance.editor.getCursor());
                            instance.updatePosition(pos.left, pos.top);
                    }
                });
                // user can use the onChange function get the new value of the code editor.
                this.editor.on('change', function () {
                    if (options.onChange) {
                        options.onChange(instance.getValue());
                    }
                    if (!options.singleLine && instance.mode == "javascript") {
                        // reset hinting whenever the code editor window changes				
                        clearTimeout(instance.lintTimeout);
                        instance.lintTimeout = setTimeout(function () {
                            instance.updateLints();
                        }, 500);
                    }
                });
                this.editor.on("contextmenu", function (cm, e) {
                    e.preventDefault();
                    var doc = cm.doc;
                    var cursor = cm.coordsChar({ left: e.x, top: e.y });
                    var lineText = doc.getLine(cursor.line);
                    var m = lineText.indexOf("Models.");
                    if (m != -1) {
                        var name = lineText.substr(m + 7);
                        var i = name.indexOf('.');
                        if (i != -1) {
                            name = name.substr(0, i);
                        }
                        var modelFile = IDE.Ide.sourceApp.models.getFile(name);
                        if (modelFile) {
                            var editor = IDE.activeDesigner.getModelCodeSection();
                            if (editor) {
                                editor.loadFile(modelFile);
                                if (IDE.activeDesigner.footer.visible) {
                                    IDE.activeDesigner.footer.select(editor.id);
                                }
                            }
                        }
                    }
                    return;
                });
                // TODO: look at using the onInputRead function as per this example.  Might allow us to remove
                // double check in codemirror-retool-show-hint.js when doing replaceRange
                // http://jsfiddle.net/u26mK/8/
                if (this.hintFunction) {
                    this.editor.on("keyup", function (cm, event) {
                        if (!instance.editor.state.completionActive) {
                            //on keyup we need to ignore key codes already defined in codemirror-retool-show-hint.js
                            var popupKeyCodes = {
                                "9": "tab",
                                "13": "enter",
                                "27": "escape",
                                "33": "pageup",
                                "34": "pagedown",
                                "35": "end",
                                "36": "home",
                                "38": "up",
                                "40": "down"
                            };
                            if (!popupKeyCodes[(event.keyCode || event.which).toString()]) {
                                // because we can register multiple keypresses before .state.completionActive is registered
                                // we must kill the previous attempt at suggestions and create a new request.
                                instance.updateHints();
                            }
                        }
                    });
                }
                this.initialized = true;
            };
            CodeEditor.prototype.makeBreakpoint = function () {
                var marker = document.createElement("div");
                marker.className = "rto-code-breakpoint";
                //marker.innerHTML = "";
                marker.innerHTML = "<div></div>";
                return marker;
            };
            CodeEditor.prototype.clearCurrentDebugLine = function () {
                if (this.debugInfo) {
                    if (this.debugInfo.lineNo != -1) {
                        this.editor.removeLineClass(this.debugInfo.lineNo, "background", "rto-debug-active-line");
                    }
                }
                this.debugInfo = null;
            };
            CodeEditor.prototype.setCurrentDebugLine = function (proc, lineNo) {
                this.clearCurrentDebugLine();
                if (!this.debugInfo) {
                    this.debugInfo = { lineNo: -1, proc: proc };
                }
                this.debugInfo.lineNo = lineNo;
                this.debugInfo.proc = proc;
                this.editor.addLineClass(lineNo, "background", "rto-debug-active-line");
                this.editor.scrollIntoView({ line: lineNo, ch: 0 }, 70);
            };
            CodeEditor.prototype.getBreakPoints = function () {
                var n = this.editor.lineCount();
                var count = 0;
                var breakPoints = {};
                for (var i = 0; i < n; i++) {
                    var line = this.editor.lineInfo(i);
                    if (line.gutterMarkers && line.gutterMarkers["rto-code-breakpoints"]) {
                        breakPoints[(i + 1).toString()] = true;
                        count++;
                    }
                }
                if (count) {
                    return breakPoints;
                }
                return null;
            };
            CodeEditor.prototype.isInitialized = function () {
                return this.initialized;
            };
            CodeEditor.prototype.setValue = function (value) {
                if (this.editor) {
                    this.editor.setValue(value);
                    this.editor.clearHistory();
                }
            };
            CodeEditor.prototype.setMode = function (mode) {
                this.editor.setOption('mode', mode);
            };
            CodeEditor.prototype.getValue = function () {
                return this.editor.getValue();
            };
            CodeEditor.prototype.setSize = function (width, height) {
                this.editor.setSize(width, height);
                this.updateLintErrorDisplay(this.editor.getCursor().line);
                if (this.editor.state.completionActive && this.editor.state.completionActive.widget) {
                    this.editor.state.completionActive.widget.setPosition();
                }
            };
            CodeEditor.prototype.closeCompletions = function () {
                if (this.editor.state.completionActive) {
                    this.editor.state.completionActive.close();
                }
            };
            CodeEditor.prototype.focus = function () {
                this.editor.focus();
            };
            CodeEditor.prototype.focusToEnd = function () {
                var lineIndex = this.editor.lineCount() - 1;
                var charIndex = this.editor.getLine(lineIndex).length;
                var pos = { line: lineIndex, ch: charIndex };
                this.editor.setCursor(pos);
                this.editor.focus();
            };
            CodeEditor.prototype.scrollToLineContaining = function (code, options) {
                var caseInsensitive;
                if (options) {
                    caseInsensitive = options.caseInsensitive;
                }
                var lineIndex = this.findCodeLine(code, caseInsensitive);
                if (lineIndex != -1) {
                    this.scrollToLine(lineIndex + 1, options);
                }
            };
            CodeEditor.prototype.scrollToLine = function (lineIndex, options) {
                var pos = { line: lineIndex - 1, ch: 0 };
                var scrollPos = pos;
                var scrollInfo = this.editor.getScrollInfo();
                var topPos = this.editor.coordsChar({ left: 0, top: scrollInfo.top }, "local");
                var bottomPos = this.editor.coordsChar({ left: 0, top: scrollInfo.top + scrollInfo.clientHeight }, "local");
                var bottomMargin = 150;
                this.editor.setCursor(pos);
                if (options) {
                    if (options.select) {
                        if (options.select.start) {
                            this.editor.setSelection({
                                line: pos.line + options.select.start,
                                ch: options.select.ch || 1
                            }, {
                                line: pos.line + options.select.start + (options.select.count - 1 || 0),
                                ch: 999
                            });
                        }
                    }
                }
                this.editor.scrollIntoView(scrollPos, bottomMargin);
                if (options && options.flash) {
                    if (this.currentFlashLine != -1) {
                        this.editor.removeLineClass(this.currentFlashLine, "text", "cm-flash");
                    }
                    this.editor.addLineClass(pos.line, "text", "cm-flash");
                    this.currentFlashLine = pos.line;
                    var self = this;
                    setTimeout(function () {
                        self.editor.removeLineClass(pos.line, "text", "cm-flash");
                    }, 1100);
                }
                this.focus();
            };
            CodeEditor.prototype.activate = function () {
                if (!this.initialized) {
                    this.initialize();
                    this.filename = null;
                }
                this.active = true;
            };
            CodeEditor.prototype.deactivate = function () {
            };
            CodeEditor.prototype.toggleCodeSnippets = function () {
                console.log('toggleCodeSnippets in CodeEditor not implemented');
            };
            CodeEditor.prototype.hideDropPlaceHolder = function () {
                console.log('hideDropPlaceHolder in CodeEditor not implemeneted');
            };
            CodeEditor.prototype.findCodeLine = function (search, caseInsenstive) {
                if (caseInsenstive) {
                    search = search.toLowerCase();
                }
                var lines = this.getValue().split('\n');
                if (lines) {
                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i];
                        if (line) {
                            if (caseInsenstive) {
                                if (line.toLowerCase().indexOf(search) != -1) {
                                    return i;
                                }
                            }
                            else if (line.indexOf(search) != -1) {
                                return i;
                            }
                        }
                    }
                }
                return -1;
            };
            CodeEditor.getHints = function (editor, options) {
                var instance = options.retoolCodeEditorInstance;
                var prefixInfo = instance.getPrefixInfo(editor, options);
                var found = [];
                if (prefixInfo) {
                    if (prefixInfo.prefix && instance.options.onGetSuggestions) {
                        var suggestions = instance.options.onGetSuggestions(prefixInfo.prefix);
                        if (suggestions) {
                            for (var i = 0; i < suggestions.length; i++) {
                                var item = suggestions[i];
                                var displayText = item.text;
                                var value;
                                if (item.value) {
                                    value = item.value;
                                }
                                else {
                                    value = displayText;
                                    if (item.parameters == "()") {
                                        value += item.parameters;
                                    }
                                    else if (item.parameters) {
                                        value += "(";
                                    }
                                }
                                found.push({ text: value, displayText: displayText, parameters: item.parameters, icon: item.icon, className: item.className });
                            }
                        }
                    }
                    var hints = {
                        list: found,
                        filter: prefixInfo.filter,
                        prefix: prefixInfo.prefix,
                        from: prefixInfo.from,
                        to: prefixInfo.to
                    };
                    return hints;
                }
            };
            CodeEditor.prototype.getPrefixInfo = function (editor, options) {
                if (this.mode == "javascript") {
                    return this.getJavascriptPrefixInfo(editor, options);
                }
                else if (this.mode == "console") {
                    return this.getConsolePrefixInfo(editor, options);
                }
            };
            CodeEditor.prototype.getConsolePrefixInfo = function (editor, options) {
                var tokenRegex = /[:@\s]/;
                var cur = editor.getCursor();
                var line = editor.getLine(cur.line);
                var nextToken = line.substring(cur.ch).search(tokenRegex);
                var end = nextToken == -1 ? line.length : nextToken + cur.ch;
                var lastToken = line.substring(0, cur.ch).split("").reverse().join("").search(tokenRegex);
                var start = lastToken == -1 ? 0 : end - lastToken - (end - cur.ch);
                var prefix = start == 0 ? line.substring(0, end) : line.substring(0, start);
                var filter = line.substring(start, end);
                return {
                    prefix: prefix,
                    filter: filter,
                    line: cur.line,
                    from: CodeMirror.Pos(cur.line, start),
                    to: CodeMirror.Pos(cur.line, end)
                };
            };
            CodeEditor.prototype.getJavascriptPrefixInfo = function (editor, options) {
                var getToken = function (e, cur) {
                    return e.getTokenAt(cur);
                };
                var instance = options.retoolCodeEditorInstance;
                var Pos = CodeMirror.Pos;
                // Find the token at the cursor
                var cur = editor.getCursor();
                var token = getToken(editor, cur);
                var tprop = token;
                token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;
                // If it's not a 'word-style' token, ignore the token.
                if (!/^[\w$_]*$/.test(token.string)) {
                    token = tprop = {
                        start: cur.ch,
                        end: cur.ch,
                        string: "",
                        state: token.state,
                        type: token.string == "." ? "property" : null
                    };
                }
                while (tprop.type == "property") {
                    tprop = getToken(editor, Pos(cur.line, tprop.start));
                    if (tprop.string != ".")
                        return;
                    tprop = getToken(editor, Pos(cur.line, tprop.start));
                    if (tprop.string == ')') {
                        var level = 1;
                        do {
                            tprop = getToken(editor, Pos(cur.line, tprop.start));
                            switch (tprop.string) {
                                case ')':
                                    level++;
                                    break;
                                case '(':
                                    level--;
                                    break;
                                default: break;
                            }
                        } while (level > 0);
                        tprop = getToken(editor, Pos(cur.line, tprop.start));
                        if (tprop.type.indexOf("variable") === 0)
                            tprop.type = "function";
                        else
                            return; // no clue
                    }
                    if (!context)
                        var context = [];
                    context.push(tprop);
                }
                var fullIdentifier = instance.getFullIdentifierFromContext(token, context);
                var prefix;
                var filter;
                if (fullIdentifier) {
                    var segments = fullIdentifier.split('.');
                    if (segments.length > 1) {
                        filter = segments.pop();
                        prefix = segments.join('.') + '.';
                    }
                    else {
                        prefix = segments[0];
                        filter = prefix;
                    }
                }
                return {
                    prefix: prefix,
                    filter: filter,
                    line: cur.line,
                    from: Pos(cur.line, token.start),
                    to: Pos(cur.line, token.end)
                };
            };
            CodeEditor.prototype.getFullIdentifierFromContext = function (token, context) {
                var identifier;
                if (context) {
                    // If this is a property, see if it belongs to some object we can
                    // find in the current environment.
                    var obj = context.pop();
                    if (obj.type == null) {
                    }
                    else if (obj.type.indexOf("variable") === 0) {
                        identifier = this.buildIdentifier(context, obj.string, token.string);
                    }
                    else if (obj.type == "keyword" && obj.string == "this") {
                        identifier = this.buildIdentifier(context, obj.string, token.string);
                    }
                    else if (obj.type == "string") {
                        identifier = this.buildIdentifier(context, obj.string, token.string);
                    }
                    else if (obj.type == "atom") {
                    }
                    else if (obj.type == "function") {
                    }
                }
                else {
                    identifier = this.buildIdentifier(context, token.string);
                }
                return identifier;
            };
            CodeEditor.prototype.buildIdentifier = function (context, v, p) {
                var identifier = v;
                if (context) {
                    for (var i = context.length - 1; i >= 0; i--) {
                        identifier += '.' + context[i].string;
                    }
                }
                if (p !== undefined) {
                    identifier += '.' + p;
                }
                return identifier;
            };
            CodeEditor.prototype.updatePosition = function (x, y, moveToCoords) {
                var pos = this.editor.coordsChar({ left: x, top: y });
                if (moveToCoords) {
                    this.editor.setCursor(pos);
                    this.editor.focus();
                }
                if (this.lastErrorDisplayLine !== pos.line) {
                    this.lastErrorDisplayLine = pos.line;
                    this.updateLintErrorDisplay(pos.line);
                }
            };
            CodeEditor.prototype.showLintErrorDisplay = function () {
                var errorDetails = this.container.children('.' + this.lintErrorDetailClass);
                if (this.lintErrors[this.lastErrorDisplayLine] && !errorDetails.length) {
                    this.updateLintErrorDisplay(this.lintErrorDetailClass);
                }
                else {
                    this.widgetContainer.children('.' + this.lintErrorDetailClass).show();
                }
            };
            CodeEditor.prototype.hideLintErrorDisplay = function () {
                this.widgetContainer.children('.' + this.lintErrorDetailClass).hide();
            };
            CodeEditor.prototype.updateLintErrorDisplay = function (line) {
                if (!this.active)
                    return;
                var lintPos = this.editor.charCoords({ line: line, ch: 0 }, "window");
                var containerBox;
                this.widgetContainer.children('.' + this.lintErrorDetailClass).remove();
                if (this.lintErrors[line]) {
                    var msg = $('<div>');
                    msg.addClass(this.lintErrorDetailClass);
                    var errorHtml = '';
                    for (var i = 0; i < this.lintErrors[line].length; i++) {
                        var err = this.lintErrors[line][i];
                        if (i > 0) {
                            errorHtml += '<br>';
                        }
                        errorHtml += err.reason;
                        // only show first 2 errrors
                        if (i == 1)
                            break;
                    }
                    msg.html(errorHtml);
                    containerBox = this.widgetContainer.get(0).getBoundingClientRect();
                    msg.css('left', (this.editor.getScrollInfo().left + lintPos.left - containerBox.left) + 'px');
                    this.widgetContainer.append(msg);
                    if (lintPos.bottom + msg.outerHeight() > containerBox.bottom) {
                        msg.css('top', lintPos.top - containerBox.top - msg.outerHeight() + 'px');
                    }
                    else {
                        msg.css('top', lintPos.bottom - containerBox.top + 'px');
                    }
                    var instance = this;
                    // this allows you to click through the popup to focus the line that it's covering
                    // by passing true to update position we allow it to set the cursor position.
                    msg.on("click", function (e) {
                        instance.updatePosition(e.pageX, e.pageY, true);
                    });
                }
            };
            CodeEditor.prototype.updateHints = function () {
                if (this.hintTimeout) {
                    clearTimeout(this.hintTimeout);
                }
                var instance = this;
                // we pass the instance of our CodeEditor class to CodeMirror in the options parameter and CodeMirror
                // will pass it through back to our showHint function as defined above in CodeMirror.registerHelper							
                this.hintTimeout = setTimeout(this.hintFunction, 100);
            };
            CodeEditor.prototype.updateLints = function () {
                var instance = this;
                this.editor.operation(function () {
                    // clear gutter markers that indicate there is an error on the line
                    instance.editor.clearGutter(instance.lintGutterClass);
                    // reset our previously calculated errors
                    instance.lintErrors = {};
                    JSHINT(instance.getValue(), { smarttabs: true, esnext: true });
                    for (var i = 0; i < JSHINT.errors.length; i++) {
                        var err = JSHINT.errors[i];
                        if (!err)
                            continue;
                        var lineOffset = err.line - 1;
                        // keep track of all the errors for each line
                        if (!instance.lintErrors[lineOffset]) {
                            instance.lintErrors[lineOffset] = [];
                        }
                        instance.lintErrors[lineOffset].push(err);
                        instance.editor.setGutterMarker(lineOffset, instance.lintGutterClass, instance.createLintGutterMarker().get(0));
                    }
                    if (!instance.editor.state.completionActive) {
                        instance.updateLintErrorDisplay(instance.editor.getCursor().line);
                    }
                });
            };
            CodeEditor.prototype.createLintGutterMarker = function () {
                var marker = $('<div>');
                marker.addClass(this.lintGutterMarkerClass);
                // put a blank space in the div so it doesn't collapse;
                marker.html('&nbsp;');
                return marker;
            };
            return CodeEditor;
        })();
        IDE.CodeEditor = CodeEditor;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ComponentTreeLocation = (function () {
            function ComponentTreeLocation(parent, nextSibling) {
                this.parent = parent;
                this.nextSibling = nextSibling;
            }
            return ComponentTreeLocation;
        })();
        IDE.ComponentTreeLocation = ComponentTreeLocation;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CommandBase = (function () {
            function CommandBase() {
            }
            CommandBase.prototype.removeFromParent = function (parent, element) {
                for (var i = 0; i < parent.children.length; i++) {
                    if (parent.children[i].id == element.id) {
                        parent.children.splice(i, 1);
                        return;
                    }
                }
            };
            CommandBase.prototype.insertIntoParent = function (parent, nextSibling, element) {
                if (nextSibling) {
                    for (var i = 0; i < parent.children.length; i++) {
                        if (parent.children[i].id == nextSibling.id) {
                            parent.children.splice(i, 0, element);
                            return;
                        }
                    }
                }
                else {
                    if (!parent.children) {
                        parent.children = [];
                    }
                    parent.children.push(element);
                }
            };
            CommandBase.prototype.removeBlock = function (parent, startElement, uptoElement) {
                var children = parent.children;
                var startIndex = this.getElementIndex(children, startElement);
                var endIndex;
                if (uptoElement) {
                    endIndex = this.getElementIndex(children, uptoElement);
                }
                else {
                    endIndex = children.length;
                }
                return children.splice(startIndex, endIndex - startIndex);
            };
            CommandBase.prototype.insertBlock = function (parent, nextSibling, block) {
                var children;
                if (!parent.children) {
                    children = parent.children = [];
                }
                else {
                    children = parent.children;
                }
                var index;
                if (nextSibling) {
                    index = this.getElementIndex(children, nextSibling);
                }
                else {
                    index = children.length;
                }
                children.splice.apply(children, [index, 0].concat(block));
            };
            CommandBase.prototype.getElementIndex = function (children, element) {
                for (var i = 0; i < children.length; i++) {
                    if (children[i].id == element.id) {
                        return i;
                    }
                }
                return -1;
            };
            CommandBase.prototype.redo = function (template) {
            };
            CommandBase.prototype.undo = function (template) {
            };
            CommandBase.prototype.isInspectorContent = function (template, element) {
                return IDE.activeDesigner.isInspectorContent(template, element);
            };
            CommandBase.prototype.do = function (template) {
                this.redo(template);
            };
            return CommandBase;
        })();
        IDE.CommandBase = CommandBase;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var MoveCommand = (function (_super) {
            __extends(MoveCommand, _super);
            function MoveCommand(origin, destination, element) {
                _super.call(this);
                this.origin = origin;
                this.destination = destination;
                this.element = element;
            }
            MoveCommand.prototype.redo = function (template) {
                this.removeFromParent(this.origin.parent, this.element);
                this.insertIntoParent(this.destination.parent, this.destination.nextSibling, this.element);
            };
            MoveCommand.prototype.undo = function (template) {
                this.removeFromParent(this.destination.parent, this.element);
                this.insertIntoParent(this.origin.parent, this.origin.nextSibling, this.element);
            };
            return MoveCommand;
        })(IDE.CommandBase);
        IDE.MoveCommand = MoveCommand;
        var MoveClosingTagCommand = (function (_super) {
            __extends(MoveClosingTagCommand, _super);
            function MoveClosingTagCommand(origin, destination, element) {
                _super.call(this);
                this.origin = origin;
                this.destination = destination;
                this.element = element;
            }
            MoveClosingTagCommand.prototype.redo = function (template) {
                if (this.destination.parent == this.element) {
                    // moving closing tag into children
                    // children below the drop point get moved to the parent container
                    var block = this.removeBlock(this.element, this.destination.nextSibling, null);
                    this.insertBlock(this.origin.parent, this.origin.nextSibling, block);
                }
                else if (this.destination.parent == this.origin.parent) {
                    // moving closing tag over a sibling
                    // any siblings between drop point and element are added as children
                    var block = this.removeBlock(this.origin.parent, this.origin.nextSibling, this.destination.nextSibling);
                    this.insertBlock(this.element, null, block);
                }
            };
            MoveClosingTagCommand.prototype.undo = function (template) {
                if (this.destination.parent == this.element) {
                    // moving closing tag into children
                    // children below the drop point get moved to the parent container
                    var block = this.removeBlock(this.origin.parent, this.destination.nextSibling, this.origin.nextSibling);
                    this.insertBlock(this.element, null, block);
                }
                else if (this.destination.parent == this.origin.parent) {
                    // moving closing tag over a sibling
                    // any siblings between drop point and element are added as children
                    var block = this.removeBlock(this.element, this.origin.nextSibling, null);
                    this.insertBlock(this.origin.parent, this.destination.nextSibling, block);
                }
            };
            return MoveClosingTagCommand;
        })(IDE.CommandBase);
        IDE.MoveClosingTagCommand = MoveClosingTagCommand;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ToolDropCommand = (function (_super) {
            __extends(ToolDropCommand, _super);
            function ToolDropCommand(destination, element) {
                _super.call(this);
                this.destination = destination;
                this.element = element;
            }
            ToolDropCommand.prototype.redo = function (template) {
                this.insertIntoParent(this.destination.parent, this.destination.nextSibling, this.element);
                this.assignIdToClone(this.element);
            };
            ToolDropCommand.prototype.undo = function (template) {
                this.removeFromParent(this.destination.parent, this.element);
                if (this.isInspectorContent(template, this.element)) {
                    IDE.activeDesigner.closeAttributesPanel();
                }
            };
            ToolDropCommand.prototype.assignIdToClone = function (clone) {
                clone.id = IDE.activeDesigner.getUniqueIdInView();
                if (clone.children) {
                    for (var i = 0; i < clone.children.length; i++) {
                        this.assignIdToClone(clone.children[i]);
                    }
                }
            };
            return ToolDropCommand;
        })(IDE.CommandBase);
        IDE.ToolDropCommand = ToolDropCommand;
        var SnippetDropCommand = (function (_super) {
            __extends(SnippetDropCommand, _super);
            function SnippetDropCommand(destination, block) {
                _super.call(this);
                this.destination = destination;
                this.block = block;
            }
            SnippetDropCommand.prototype.redo = function (template) {
                this.insertBlock(this.destination.parent, this.destination.nextSibling, this.block);
                this.assignIdToBlock(this.block);
            };
            SnippetDropCommand.prototype.undo = function (template) {
                this.removeBlock(this.destination.parent, this.block[0], this.destination.nextSibling);
                IDE.activeDesigner.closeAttributesPanel();
            };
            SnippetDropCommand.prototype.assignIdToBlock = function (block) {
                for (var i = 0; i < block.length; i++) {
                    var elem = block[i];
                    this.assignIdToClone(elem);
                }
            };
            SnippetDropCommand.prototype.assignIdToClone = function (clone) {
                clone.id = IDE.activeDesigner.getUniqueIdInView();
                if (clone.children) {
                    for (var i = 0; i < clone.children.length; i++) {
                        this.assignIdToClone(clone.children[i]);
                    }
                }
            };
            return SnippetDropCommand;
        })(IDE.CommandBase);
        IDE.SnippetDropCommand = SnippetDropCommand;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var DeleteCommand = (function (_super) {
            __extends(DeleteCommand, _super);
            function DeleteCommand(origin, element) {
                _super.call(this);
                this.origin = origin;
                this.element = element;
            }
            DeleteCommand.prototype.redo = function (template) {
                this.removeFromParent(this.origin.parent, this.element);
                if (this.isInspectorContent(template, this.element)) {
                    IDE.activeDesigner.closeAttributesPanel();
                }
            };
            DeleteCommand.prototype.undo = function (template) {
                this.insertIntoParent(this.origin.parent, this.origin.nextSibling, this.element);
            };
            return DeleteCommand;
        })(IDE.CommandBase);
        IDE.DeleteCommand = DeleteCommand;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CommandStack = (function () {
            function CommandStack() {
                this.commands = [];
                this.commandIndex = -1;
            }
            CommandStack.prototype.add = function (command) {
                if ((this.commands.length - 1) > this.commandIndex) {
                    this.commands.splice(this.commandIndex + 1, this.commands.length - (this.commandIndex + 1));
                }
                this.commands.push(command);
                this.commandIndex = this.commands.length - 1;
            };
            CommandStack.prototype.undo = function () {
                if (this.canUndo()) {
                    var command = this.commands[this.commandIndex];
                    this.commandIndex--;
                    return command;
                }
                return null;
            };
            CommandStack.prototype.redo = function () {
                if (this.canRedo()) {
                    this.commandIndex++;
                    return this.commands[this.commandIndex];
                }
            };
            CommandStack.prototype.canUndo = function () {
                return this.commandIndex > -1;
            };
            CommandStack.prototype.canRedo = function () {
                return (this.commandIndex + 1) < this.commands.length;
            };
            return CommandStack;
        })();
        IDE.CommandStack = CommandStack;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var SetAttributesCommand = (function (_super) {
            __extends(SetAttributesCommand, _super);
            function SetAttributesCommand(element, newValues) {
                _super.call(this);
                this.element = element;
                this.newValues = newValues;
            }
            SetAttributesCommand.prototype.redo = function (template) {
                this.applyChanges();
                if (this.isInspectorContent(template, this.element)) {
                    IDE.activeDesigner.showAttributes({ item: this.element });
                }
            };
            SetAttributesCommand.prototype.applyChanges = function () {
                this.undoValues = {};
                for (var key in this.newValues) {
                    this.undoValues[key] = this.element[key];
                    this.element[key] = this.newValues[key];
                }
            };
            SetAttributesCommand.prototype.undo = function (template) {
                for (var key in this.undoValues) {
                    this.element[key] = this.undoValues[key];
                }
                if (this.isInspectorContent(template, this.element)) {
                    IDE.activeDesigner.showAttributes({ item: this.element });
                }
            };
            SetAttributesCommand.prototype.do = function (template) {
                this.applyChanges();
            };
            return SetAttributesCommand;
        })(IDE.CommandBase);
        IDE.SetAttributesCommand = SetAttributesCommand;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var DesignerRenderer = (function () {
            function DesignerRenderer() {
            }
            DesignerRenderer.prototype.render = function () {
                // this.renderDesignerToolbar(w);
                IDE.activeDesigner.viewInspector = new IDE.ViewInspector();
                IDE.activeDesigner.toolbox = new IDE.Toolbox.Renderer();
                IDE.activeDesigner.attributesPanel = new IDE.AttributesPanel();
                IDE.activeDesigner.footer = new IDE.Footer();
                var w = new Retool.Writer("ds");
                var css = (Retool.App.loaded) ? "" : "empty";
                if (IDE.activeDesigner.anchorBottom) {
                    css += " docked-bottom";
                }
                w.writeTag("div", css, { id: "ide" });
                var style = (IDE.activeDesigner.visible) ? "" : "display:none";
                w.writeTag("div", "", { id: "panels", style: style });
                this.renderVerticalSplitter(w, "designerTopSizer");
                w.write('<div id="rto-panels-nav">');
                this.renderNavbar(w);
                w.write("</div>");
                w.write('<div id="rto-panels-inner">');
                w.write('<div id="rto-ds" class="rto-ds rto-docked"></div>');
                IDE.activeDesigner.footer.render(w);
                w.write('</div>');
                w.write('<div id="rto-designerScreenSplitter"></div>');
                w.write('<div id="rto-ide-error"></div>');
                w.write('</div>'); // rto-panels
                w.write('</div>'); // rto-ide
                if (Retool.App.loaded) {
                    w.writeTag("div", "toggle-ide open", { id: "ide-toggle-btn" }).write('</div>');
                }
                //w.appendToElement("body");
                w.writeToElement("body");
                w = new Retool.Writer("ds");
                IDE.activeDesigner.viewInspector.render(w);
                //this.renderThemeChooser();
                w.writeToElement("#" + Retool.makeDomId('ds'));
                $('body').append('<div id="rto-designer-bar"></div>');
                IDE.activeDesigner.footer.initializeSections();
                IDE.activeDesigner.attachEvents();
                IDE.activeDesigner.viewInspector.attachEvents();
                $(window).resize(function () {
                    IDE.activeDesigner.resize();
                });
                IDE.activeDesigner.toolbox.attachEvents();
                $(Retool.makeDomId('expandDesigner')).show();
                var designerWidth = 400;
                var explorerWidth = 175;
                if ($(window).width() > 1600) {
                    designerWidth = 400;
                    explorerWidth = 175;
                }
                if (window.opener) {
                    return;
                }
                this.createAppContainer();
                //this.loadProject();
            };
            DesignerRenderer.prototype.loadProject = function (afterCopy) {
                var self = this;
                Retool.loadEnvironment(function success() {
                    /*
                    if (setUrl){
                        // window.history.replaceState(null,null,"/" + App.accountId + "/" + App.projectId);
                    }
                    */
                    var app;
                    if (!afterCopy && app.volume.isEmpty()) {
                        var importer = new IDE.Util.ProjectImporter();
                        importer.copyBase("basic", function (err) {
                            if (err) {
                                IDE.Ide.displayError(err);
                            }
                            else {
                                self.loadProject(true);
                            }
                        });
                        return;
                    }
                    $('#rto-ide').removeClass('rto-empty');
                    self.createAppContainer();
                    IDE.activeDesigner.toolbox.refreshAll();
                    if (!$('#rto-toggle-id').length) {
                        var w = new Retool.Writer("ds");
                        w.writeTag("div", "toggle-ide open", { id: "ide-toggle-btn" }).write('</div>');
                        w.appendToElement("body");
                    }
                }, function (err) {
                    if (err.name == "requires_signin") {
                    }
                    else {
                        IDE.Ide.displayError(err);
                    }
                });
            };
            DesignerRenderer.prototype.refreshNavbar = function () {
                var w = new Retool.Writer("ds");
                this.renderNavbar(w);
                w.writeToElement('#rto-panels-nav');
            };
            DesignerRenderer.prototype.renderNavbar = function (w) {
                //var signedIn = (Ide.user && Ide.user.username);
                var signedIn = true;
                w.writeTag("div", "panels-nav-lt");
                w.writeTag("ul", "nav");
                if (!signedIn) {
                    w.writeTag("li", null).writeTag("a", "signin", { href: "#", "data-item": "signin" }).text("Log In").write('</a></li>');
                    w.writeTag("li", null).writeTag("a", "signin", { href: "#", "data-item": "signup" }).text("Sign Up").write('</a></li>');
                }
                else {
                    var theme = Retool.App.themeDescription;
                    w.writeTag("span", "project-name", { id: "current-path" }).text(theme).write('</span>');
                }
                // w.writeTag("li",null).writeTag("a",null,{href:"#","data-item":"lessons",tooltip:"Lessons"}).writeTag("span","glyph toolbox").write("U</span></a></li>");
                // w.write('<a href="#" data-item="signout" class="rto-small">').text("Sign out").write('</a>');
                w.write("</ul>");
                w.write('</div>');
                w.writeTag("div", "panels-nav-rt");
                w.writeTag("ul", "nav");
                if (signedIn) {
                    w.writeTag("li", null).writeTag("a", null, { href: "#", "data-item": "refresh", tooltip: "Refresh page" }).writeTag("span", "glyph toolbox").write("-</span></a></li>");
                    w.writeTag("li", null).writeTag("a", null, { href: "#", "data-item": "desktop", tooltip: "Desktop" }).writeTag("span", "glyph toolbox").write("*</span></a></li>");
                    w.writeTag("li", null).writeTag("a", null, { href: "#", "data-item": "tablet", tooltip: "Tablet" }).writeTag("span", "glyph toolbox").write("+</span></a></li>");
                    w.writeTag("li", null).writeTag("a", null, { href: "#", "data-item": "mobile", tooltip: "Mobile" }).writeTag("span", "glyph toolbox").write(",</span></a></li>");
                    //w.writeTag("li",null).writeTag("a",null,{href:"#","data-item":"settings",tooltip:"Settings & Tools"}).writeTag("span","glyph toolbox").write("6</span></a></li>");
                    // var src = Ide.user.avatar_url || "";
                    w.writeTag("li", "!dropdown").writeTag("a", "", { href: "#", "data-item": "account", "tooltip": "My account" });
                    w.writeTag("span", "glyph toolbox").write("6<span>");
                    //w.writeTag("img",null,{src:src});
                    w.write('</a>');
                    w.writeTag("ul", "!dropdown-menu !pull-right");
                    w.writeTag('li', null).writeTag("a", null, { href: "#", "data-item": "signout" }).text("Sign out").write('</a></li>');
                    w.writeTag('li', null).writeTag("a", null, { href: "#", "data-item": "build" }).text("Build project").write('</a></li>');
                    w.writeTag('li', null).writeTag("a", null, { href: "#", "data-item": "myaccount" }).text("My account").write('</a></li>');
                    w.writeTag('li', null).writeTag("a", null, { href: "#", "data-item": "import-theme" }).text("Import theme").write('</a></li>');
                    w.writeTag('li', null).writeTag("a", null, { href: "#", "data-item": "copy-base-project" }).text("Install base project").write('</a></li>');
                    w.write('</ul>');
                    w.write('</li>');
                }
                w.write("</ul>");
                w.write("</div>");
                w.writeTag("div", "toggle-ide close").write('</div>');
            };
            DesignerRenderer.prototype.renderThemeChooser = function () {
                var w = new Retool.Writer("ds");
                w.writeTag("div", null, { id: "theme-chooser" });
                w.writeTag("div", null, { "data-id": "theme.css" }).text("Pro").write("</div>");
                w.writeTag("div", null, { "data-id": "retool-std.css" }).text("Cool Blue").write("</div>");
                w.writeTag("div", null, { "data-id": "none.css" }).text("Bootstrap Basic").write("</div>");
                w.write('</div>');
                w.appendToElement('body');
            };
            DesignerRenderer.prototype.renderVerticalSplitter = function (w, id) {
                w.writeTag("div", null, { id: id }).writeTag("div", "dragblocker").write("</div>").writeTag("div", "vertical-handle").write('<div></div></div></div>');
            };
            DesignerRenderer.prototype.createAppContainer = function () {
                $('#retool-app').remove();
                var src = window.location.pathname + "?_";
                $('body').prepend('<div id="rto-app-container"><iframe src="' + src + '"></iframe></div>');
                $('body iframe').on('load', function () {
                    window.history.pushState(null, '', this.contentWindow.location.pathname);
                });
                // light cms
                IDE.activeDesigner.updatePanelWidths();
                if (IDE.activeDesigner.anchorBottom) {
                }
                return;
                var appDoc = $('#rto-app-container iframe').get(0).contentWindow.document;
                appDoc.open("text/html", "replace");
                var host = "/";
                /* load stylesheets -> production mode
                var file = App.getFile("templates/site/layouts/default.tpl");
                var stylesheets = [];
                if (file){
                    var appTemplate = <ITemplateDefinition>file.getContent();
                    if (appTemplate.elements){
                        for(var i = 0; i < appTemplate.elements.length;i++){
                            if (appTemplate.elements[i].kind == "stylesheet"){
                                stylesheets.push(appTemplate.elements[i].href);
                            }
                        }
                    }
                }
                */
                var w = new Retool.Writer();
                w.write('<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head>');
                // w.write('<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700" rel="stylesheet" type="text/css">');
                w.write('<link href="' + host + 'assets/stylesheets/retool-runtime.css" rel="stylesheet" type="text/css">');
                w.write('<link href="' + host + 'assets/stylesheets/c3.min.css" rel="stylesheet" type="text/css">');
                w.write('<script language="JavaScript" src="' + host + 'assets/javascripts/jquery-1.10.2.min.js"></script>' + '<script language="JavaScript" src="' + host + 'assets/javascripts/bootstrap-3-0.min.js"></script>' + '<script language="JavaScript" src="' + host + 'assets/javascripts/retool-client.js?ver=' + Retool.App.version + '"></script>' + '<script language="JavaScript" src="' + host + 'assets/javascripts/chart.js?ver=' + Retool.App.version + '"></script>' + '<script language="JavaScript" src="' + host + 'assets/javascripts/d3.min.js?ver=' + Retool.App.version + '"></script>' + '<script language="JavaScript" src="' + host + 'assets/javascripts/c3.js?ver=' + Retool.App.version + '"></script>' + '</head>' + '<body><div id="retool-app" class="retool-app"><div id="retool-initializing">Loading...</div></div>' + '<script>jQuery(document).ready(function(){Retool.ready({});});</script></body></html>');
                appDoc.write(w.getStream());
                appDoc.close();
                // this.createLessonContainer();
            };
            DesignerRenderer.prototype.createLessonContainer = function () {
                $('body').prepend('<div id="rto-lesson-panel" class="rto-lesson-panel" style="display:none"><iframe></iframe></div>');
                var appDoc = $('#rto-lesson-panel iframe').get(0).contentWindow.document;
                appDoc.open("text/html", "replace");
                var host = "/";
                /* load stylesheets -> production mode
                var file = App.getFile("templates/site/layouts/default.tpl");
                var stylesheets = [];
                if (file){
                    var appTemplate = <ITemplateDefinition>file.getContent();
                    if (appTemplate.elements){
                        for(var i = 0; i < appTemplate.elements.length;i++){
                            if (appTemplate.elements[i].kind == "stylesheet"){
                                stylesheets.push(appTemplate.elements[i].href);
                            }
                        }
                    }
                }
                */
                var w = new Retool.Writer();
                w.write('<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head>');
                // w.write('<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700" rel="stylesheet" type="text/css">');
                w.write('<link href="' + host + 'assets/stylesheets/retool-runtime.css" rel="stylesheet" type="text/css">');
                w.write('<script language="JavaScript" src="' + host + 'assets/javascripts/jquery-1.10.2.min.js"></script>' + '<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>' + '<script language="JavaScript" src="' + host + 'assets/javascripts/retool-client.js?ver=' + Retool.App.version + '"></script>' + '<link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600,700" rel="stylesheet" type="text/css">' + '<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,400italic,600italic,700italic" rel="stylesheet" type="text/css">' + '<link rel="stylesheet" type="text/css" href="' + host + 'assets/stylesheets/retool-lessons.css">' + '</head>' + '<body><div id="retool-app" class="retool-app"><div id="retool-initializing">Loading...</div></div>' + '<script>jQuery(document).ready(function(){Retool.ready({lessons:true});});</script></body></html>');
                appDoc.write(w.getStream());
                appDoc.close();
            };
            return DesignerRenderer;
        })();
        IDE.DesignerRenderer = DesignerRenderer;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ModelBuilder = (function () {
            function ModelBuilder() {
            }
            ModelBuilder.prototype.addFieldToModel = function (modelDef, fieldName, fieldDefinition) {
                var existing = modelDef.fields[fieldName];
                if (existing) {
                }
                modelDef.fields[fieldName] = fieldDefinition;
            };
            ModelBuilder.destroyField = function (file, fieldName) {
                var model = file.getContent();
                var fieldDef = model.fields[fieldName];
                if (fieldDef) {
                    delete model.fields[fieldName];
                }
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.destroyRelationship = function (file, relationshipName) {
                var model = file.getContent();
                var relationshipDef = model.relationships[relationshipName];
                if (relationshipDef) {
                    delete model.relationships[relationshipName];
                }
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.destroyIndex = function (file, indexName) {
                var model = file.getContent();
                var indexDef = model.indexes[indexName];
                if (indexDef) {
                    delete model.indexes[indexName];
                }
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.fieldTypes = function () {
                return ["string", "boolean", "date", "datetime", "email", "money", "text", "number", "phone", "picklist", "url", "objectid"];
            };
            ModelBuilder.fieldTypeListValues = function () {
                return "string=String,boolean=Boolean,date=Date,datetime=DateTime,email=Email,money=Money,objectid=Object ID,text=Text,number=Number,phone=Phone,picklist=Picklist,url=Url";
            };
            ModelBuilder.createEmpty = function () {
                var modelDef = {
                    name: null,
                    db_table: null,
                    fields: {},
                    relationships: {},
                    indexes: {},
                    key: "",
                    recordname: null,
                    label: "",
                    route: null,
                    trackRevisions: false,
                    access: "all",
                    source_code: "",
                    type: "model"
                };
                return modelDef;
            };
            ModelBuilder.validateField = function (errors, modelDef, field) {
                if (field.belongs_to) {
                    var belongsToModelDef = IDE.Ide.sourceApp.models.getDefinition(field.belongs_to);
                    if (!belongsToModelDef) {
                        errors.addFieldError("belongs_to", "Invalid collection id");
                    }
                }
            };
            ModelBuilder.validateFields = function (errors, modelDef, fields) {
                var namesLower = {};
                for (var fieldName in modelDef.fields) {
                    namesLower[fieldName.toLowerCase()] = 1;
                }
                for (var relationshipName in modelDef.relationships) {
                    namesLower[relationshipName.toLowerCase()] = 1;
                }
                var dupCheck = {};
                for (var i = 0; i < fields.length; i++) {
                    var field = fields[i];
                    var name = $.trim(field.name).replace(/\*$/g, '');
                    if (name) {
                        if (!IDE.DesignerTools.isValidId(name)) {
                            errors.add("Field name '" + name + "' " + IDE.DesignerTools.invalidIdMessage());
                        }
                        var fieldType = field.type;
                        if (!fieldType) {
                            errors.add("Type Error: Invalid field type on field: " + name);
                        }
                        else {
                            var dot = fieldType.indexOf('.');
                            if (dot == -1) {
                                if (!IDE.fieldTypes[fieldType]) {
                                    errors.add("Type Error: Invalid field type on field: " + name);
                                }
                            }
                            else {
                                var relatedModelDef = IDE.Ide.sourceApp.models.getDefinition(fieldType);
                                if (!relatedModelDef) {
                                    errors.add("Type Error: Invalid field type on field: " + name);
                                }
                                var autoRelationshipName = ModelBuilder.getRelationshipNameFromFieldName(name);
                                if (!autoRelationshipName) {
                                    errors.add("Expected " + name + " to be " + name + "_id for a relationship");
                                }
                                else {
                                    if (namesLower[autoRelationshipName.toLowerCase()]) {
                                        errors.add("Duplicate Error: A field named " + autoRelationshipName + " already exists in this collection");
                                    }
                                    else if (dupCheck[autoRelationshipName.toLowerCase()]) {
                                        errors.add("Duplicate Error: Field " + autoRelationshipName + " has been declared more than once.");
                                    }
                                    else {
                                        dupCheck[autoRelationshipName.toLowerCase()] = 1;
                                    }
                                }
                            }
                        }
                        if (namesLower[name.toLowerCase()]) {
                            errors.add("Duplicate Error: A field named " + name + " already exists in this collection");
                        }
                        else if (dupCheck[name.toLowerCase()]) {
                            errors.add("Duplicate Error: Field " + name + " has been declared more than once.");
                        }
                        else {
                            dupCheck[name.toLowerCase()] = 1;
                        }
                    }
                }
            };
            ModelBuilder.getRelationshipNameFromFieldName = function (fieldName) {
                if (fieldName.length > 3 && fieldName.substr(fieldName.length - 3) == "_id") {
                    return fieldName.substr(0, fieldName.length - 3);
                }
                return null;
            };
            ModelBuilder.createFields = function (modelDef, fieldDefs, relationshipDefs, fields) {
                var fieldDef;
                var fieldsNeedingColumnNames = [];
                for (var i = 0; i < fields.length; i++) {
                    var field = fields[i];
                    var name = $.trim(field.name);
                    if (name) {
                        fieldDef = ModelBuilder.newField();
                        fieldDef.required = (name.indexOf('*') != -1);
                        name = name.replace(/\*$/g, '');
                        fieldDef.name = name;
                        fieldDef.label = $.trim(Retool.Inflection.titleize(name));
                        var type = field.type;
                        if (!type) {
                            fieldDef.type = "string";
                        }
                        else {
                            var dot = type.indexOf('.');
                            if (dot == -1) {
                                fieldDef.type = type;
                            }
                            else {
                                fieldDef.type = "objectid";
                                fieldDef.belongs_to = type;
                                var autoRelationshipName = ModelBuilder.getRelationshipNameFromFieldName(name);
                                if (autoRelationshipName) {
                                    fieldDef.label = $.trim(Retool.Inflection.titleize(autoRelationshipName));
                                    var relationship = { name: autoRelationshipName, type: "belongs_to", foreignKey: name, model: fieldDef.belongs_to, label: fieldDef.label };
                                    relationshipDefs.push(relationship);
                                }
                            }
                        }
                        var fieldType = IDE.fieldTypes[fieldDef.type];
                        if (fieldType && fieldType.hasSize) {
                            var size;
                            try {
                                size = parseInt(field.size, 10);
                            }
                            catch (e) {
                                size = fieldType.defaultSize;
                            }
                            fieldDef.size = size;
                        }
                        fieldDefs.push(fieldDef);
                        if (!field.db_column) {
                            if (name == "id") {
                                fieldDef.db_column = "id";
                            }
                            else {
                                fieldsNeedingColumnNames.push(fieldDef);
                            }
                        }
                    }
                }
                var dbColumnNames = ModelBuilder.getAvailDbColumnNames(modelDef, fieldsNeedingColumnNames.length);
                for (var i = 0; i < fieldsNeedingColumnNames.length; i++) {
                    fieldDef = fieldsNeedingColumnNames[i];
                    fieldDef.db_column = dbColumnNames[i];
                }
            };
            ModelBuilder.newField = function () {
                return {
                    name: null,
                    type: "string",
                    default_value: null,
                    db_column: null,
                    label: "",
                    access: ""
                };
            };
            ModelBuilder.newRelationship = function () {
                return {
                    name: null,
                    type: null,
                    foreignKey: null,
                    model: null,
                    label: null
                };
            };
            ModelBuilder.validateRelationship = function (errors, model, relationship) {
                if (errors.required("name", relationship.name, "Name is required")) {
                    if (!IDE.DesignerTools.isValidId(relationship.name)) {
                        errors.addFieldError("name", "Relationship name " + IDE.DesignerTools.invalidIdMessage());
                    }
                }
                if (relationship.model) {
                    var modelDef = IDE.Ide.sourceApp.models.getDefinition(relationship.model);
                    if (!modelDef) {
                        errors.addFieldError("model", "Invalid collection name");
                    }
                }
                if (relationship.foreignKey) {
                    var fieldDef = model.fields[relationship.foreignKey];
                    if (!fieldDef) {
                        errors.addFieldError("foreign_key", "Foreign key is not valid");
                    }
                }
            };
            ModelBuilder.validateIndex = function (errors, model, index) {
                if (errors.required("name", index.name, "Name is required")) {
                    if (!IDE.DesignerTools.isValidId(index.name)) {
                        errors.addFieldError("name", "Index name " + IDE.DesignerTools.invalidIdMessage());
                    }
                }
                if (errors.required("keys", index.keys, "Keys are required")) {
                }
            };
            ModelBuilder.addRelationship = function (file, relationship) {
                var model = file.getContent();
                var errors = new Retool.ValidationError();
                ModelBuilder.validateRelationship(errors, model, relationship);
                var existing = model.relationships[relationship.name];
                if (existing) {
                    errors.addFieldError("name", "Duplicate Error: A relationship with this name is already defined");
                }
                var fieldDef = model.fields[relationship.name];
                if (fieldDef) {
                    errors.addFieldError("name", "Duplicate Error: A field with this name is already defined, name must be unique across fields and relationships");
                }
                errors.throwIfAny();
                model.relationships[relationship.name] = relationship;
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.addIndex = function (file, index) {
                var model = file.getContent();
                var errors = new Retool.ValidationError();
                ModelBuilder.validateIndex(errors, model, index);
                if (!model.indexes) {
                    model.indexes = {};
                }
                var existing = model.indexes[index.name];
                if (existing) {
                    errors.addFieldError("name", "Duplicate Error: A index with this name is already defined");
                }
                errors.throwIfAny();
                model.indexes[index.name] = index;
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.addFields = function (file, fields) {
                var fieldDefs = [];
                var relationshipDefs = [];
                var modelDef = file.getContent();
                var errors = new Retool.ValidationError();
                ModelBuilder.validateFields(errors, modelDef, fields);
                errors.throwIfAny();
                ModelBuilder.createFields(modelDef, fieldDefs, relationshipDefs, fields);
                for (var i = 0; i < fieldDefs.length; i++) {
                    var fieldDef = fieldDefs[i];
                    modelDef.fields[fieldDef.name] = fieldDef;
                }
                for (var i = 0; i < relationshipDefs.length; i++) {
                    var relationshipDef = relationshipDefs[i];
                    modelDef.relationships[relationshipDef.name] = relationshipDef;
                }
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.getName = function (model) {
                return model.name;
            };
            ModelBuilder.update = function (file) {
                var model = file.getContent();
                var errors = ModelBuilder.validate(model, false);
                errors.throwIfAny();
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.updateField = function (file, field) {
                var errors = new Retool.ValidationError();
                var model = file.getContent();
                ModelBuilder.validateField(errors, model, field);
                errors.throwIfAny();
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.updateRelationship = function (file, relationship) {
                var errors = new Retool.ValidationError();
                var model = file.getContent();
                ModelBuilder.validateRelationship(errors, model, relationship);
                errors.throwIfAny();
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.updateIndex = function (file, index) {
                var errors = new Retool.ValidationError();
                var model = file.getContent();
                ModelBuilder.validateIndex(errors, model, index);
                errors.throwIfAny();
                IDE.activeDesigner.saveFile(file, true);
            };
            ModelBuilder.validate = function (model, create) {
                var ValidationError = new ValidationError();
                var name = ModelBuilder.getName(model);
                if (ValidationError.required("name", name, "Collection name is required")) {
                    var db = null; // DatabaseLocator.getDefinitionForName(appName);	
                    if (db == null) {
                        ValidationError.addFieldError("name", "Collection name contains an unknown database id");
                    }
                    if (!IDE.DesignerTools.isValidId(name)) {
                        ValidationError.addFieldError("name", "Collection name " + IDE.DesignerTools.invalidIdMessage());
                    }
                }
                return ValidationError;
            };
            ModelBuilder.destroy = function (file) {
                IDE.activeDesigner.deleteFile(file);
            };
            ModelBuilder.prototype.createInverseRelationship = function (model, relationship) {
                var referenceModel = IDE.Ide.sourceApp.models.getDefinition(relationship.model);
                var inverseRelationshipId = IDE.DesignerTools.stripNonAlpha(model.name.toLowerCase());
                if (!referenceModel.relationships[inverseRelationshipId]) {
                    var inverseRelationship = {
                        name: inverseRelationshipId,
                        type: "has_many",
                        model: model.name,
                        foreignKey: relationship.foreignKey,
                        label: inverseRelationshipId
                    };
                    referenceModel.relationships[inverseRelationshipId] = inverseRelationship;
                    return { model: referenceModel, relationship: inverseRelationship };
                }
                return null;
            };
            ModelBuilder.getAvailDbColumnNames = function (model, count) {
                var prefix = "f";
                var index = 1;
                var maxIndex = 200;
                var map = ModelBuilder.buildDbColumnMap(model);
                var result = [];
                while (index <= maxIndex) {
                    var fieldName;
                    if (index < 10) {
                        fieldName = prefix + "00" + index.toString();
                    }
                    else if (index < 100) {
                        fieldName = prefix + "0" + index.toString();
                    }
                    else {
                        fieldName = prefix + index.toString();
                    }
                    if (!map[fieldName]) {
                        result.push(fieldName);
                        count--;
                        if (count == 0) {
                            return result;
                        }
                    }
                    index++;
                }
                // too many fields;
                return null;
            };
            ModelBuilder.buildDbColumnMap = function (model) {
                // build a hash of all the db column names in the model def
                var map = {};
                for (var id in model.fields) {
                    var field = model.fields[id];
                    map[field.db_column] = 1;
                }
                return map;
            };
            ModelBuilder.generateDefaultCode = function (collectionName) {
                var code = "function find(params){\n  return db.<<collection>>.find().sort(params.sort);\n}\n\n";
                code += "function get(params){\n  return db.<<collection>>.findOne(params.id);\n}\n\n";
                code += "function create(params){\n  return db.<<collection>>.insert(params.model);\n}\n\n";
                code += "function update(params){\n  return db.<<collection>>.update(params.model);\n}\n\n";
                code += "function destroy(params){\n  return db.<<collection>>.remove(params.id);\n}\n\n";
                code += "function count(params){\n  return db.<<collection>>.count();\n}\n\n";
                code += "function droplist(params){\n  return db.<<collection>>.find(db.startsWith({name:params.filter})).sort({name:1});\n}\n\n";
                return code.replace(/<<collection>>/g, collectionName);
            };
            return ModelBuilder;
        })();
        IDE.ModelBuilder = ModelBuilder;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var DesignerTools = (function () {
            function DesignerTools() {
            }
            DesignerTools.convertLabelToFieldName = function (label) {
                var fieldName = DesignerTools.stripNonAlphaNumeric(label.toLowerCase());
                if (fieldName.length && (fieldName[0] >= '0' && fieldName[0] <= '9')) {
                    fieldName = "fld" + fieldName;
                }
                return fieldName;
            };
            DesignerTools.stripNonAlphaNumeric = function (value) {
                var newValue = "";
                for (var i = 0; i < value.length; i++) {
                    var ch = value[i];
                    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
                        newValue += ch;
                    }
                    else if (ch == "_" || ch == " ") {
                        newValue += "_";
                    }
                }
                return newValue;
            };
            DesignerTools.stripNonAlpha = function (value) {
                var newValue = "";
                for (var i = 0; i < value.length; i++) {
                    var ch = value[i];
                    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                        newValue += ch;
                    }
                    else if (ch == "_" || ch == " ") {
                        newValue += "_";
                    }
                }
                return newValue;
            };
            DesignerTools.makeValidAppUrlPath = function (value) {
                var valid = "";
                for (var i = 0; i < value.length; i++) {
                    if (value[i] == ' ' && valid.length > 5) {
                        return valid;
                    }
                    if (value[i] >= 'a' && value[i] <= 'z') {
                        valid += value[i];
                    }
                    else if (value[i] >= 'A' && value[i] <= 'Z') {
                        valid += value[i].toLowerCase();
                    }
                    if (valid.length >= 12) {
                        return valid;
                    }
                }
                return valid;
            };
            DesignerTools.isValidAlpha = function (value, allowUpperCase, extraChars) {
                for (var i = 0; i < value.length; i++) {
                    if (value[i] >= 'a' && value[i] <= 'z') {
                    }
                    else if (allowUpperCase && value[i] >= 'A' && value[i] <= 'Z') {
                    }
                    else if (extraChars && extraChars.indexOf(value[i]) != -1) {
                    }
                    else {
                        return false;
                    }
                }
                return true;
            };
            DesignerTools.isValidAlphaNumeric = function (value, allowUpperCase, extraChars) {
                var c;
                for (var i = 0; i < value.length; i++) {
                    c = value[i];
                    if (c >= 'a' && c <= 'z') {
                    }
                    else if (c >= '0' && c <= '9' && i > 0) {
                    }
                    else if (allowUpperCase && c >= 'A' && c <= 'Z') {
                    }
                    else if (extraChars && extraChars.indexOf(c) != -1) {
                    }
                    else {
                        return false;
                    }
                }
                return true;
            };
            DesignerTools.isValidId = function (value) {
                if (!value) {
                    return false;
                }
                return DesignerTools.isValidAlphaNumeric(value, true, ['_']);
            };
            DesignerTools.isValidTemplateName = function (value) {
                if (!value) {
                    return false;
                }
                return DesignerTools.isValidAlphaNumeric(value, true, ['_', '-']);
            };
            DesignerTools.isValidFilename = function (value) {
                var name = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(value);
                var ext = Retool.FileSystem.PathInfo.getExtension(value);
                if (ext && !DesignerTools.isValidAlphaNumeric(ext)) {
                    return false;
                }
                if (!name) {
                    return false;
                }
                var segments = name.split('/');
                for (var i = 0; i < segments.length; i++) {
                    if (!DesignerTools.isValidAlphaNumeric(segments[i], true, ['_', '-'])) {
                        return false;
                    }
                }
                return true;
            };
            DesignerTools.startsWith = function (value, check) {
                if (!value) {
                    return false;
                }
                return (value.length >= check.length && value.substr(0, check.length) == check);
            };
            DesignerTools.findFirst = function (collection, condition) {
                for (var key in collection) {
                    var item = collection[key];
                    if (condition(item)) {
                        return key;
                    }
                }
                return null;
            };
            DesignerTools.invalidIdMessage = function () {
                return "contains invalid characters, only A..Z,0..9,_ are allowed and must not start with a digit";
            };
            DesignerTools.eliminateExistingFiles = function (files) {
                var newFiles = [];
                for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    if (!IDE.Ide.sourceApp.getFile(file.getFullName())) {
                        newFiles.push(file);
                    }
                }
                return newFiles;
            };
            DesignerTools.copyFile = function (fromFile, toFile) {
                var file = IDE.Ide.sourceApp.getFile(fromFile);
                if (!file) {
                    throw "Cannot find file:" + fromFile;
                }
                var content = {};
                var fileContent = file.getContent();
                if (fileContent) {
                    for (var key in fileContent) {
                        content[key] = fileContent[key];
                    }
                }
                var newFile = new Retool.FileSystem.File(toFile, content);
                IDE.Ide.sourceApp.addFile(newFile);
                IDE.activeDesigner.saveFile(newFile, true);
            };
            DesignerTools.downloadFile = function (href) {
                var w = new Retool.Writer();
                w.write('<a').writeAttr("id", "get-file").writeAttr("href", href).write('>Get File</a>');
                $('body').append(w.getStream());
                $('#get-file').get(0).click();
                $('#get-file').remove();
            };
            DesignerTools.downloadEcho = function (options) {
                var self = this;
                var request = new Retool.Request({ type: "data" });
                request.add({ className: "EchoFile", method: "getToken", args: { "content": btoa(options.content), "content_disposition": "attachment" }, success: function (data) {
                    //var href = Url.createGetPath("/system/echofile/" + options.filename + "?token=" + encodeURIComponent(data.result.token));
                    var href;
                    var w = new Retool.Writer();
                    w.write('<a').writeAttr("id", "get-file").writeAttr("href", href).write('>Get File</a>');
                    $('body').append(w.getStream());
                    $('#get-file').get(0).click();
                    $('#get-file').remove();
                    if (options.success) {
                        options.success();
                    }
                }, error: function (data) {
                    if (options.error) {
                        options.error(data);
                    }
                } });
                request.execute();
            };
            DesignerTools.stringifyCompressed = function (value) {
                return JSON.stringify(value, function (key, value) {
                    if (key && !value) {
                        return undefined;
                    }
                    ;
                    if (key && key[0] == "_")
                        return undefined;
                    return value;
                });
            };
            DesignerTools.compress = function (value) {
                if (value) {
                    return JSON.parse(DesignerTools.stringifyCompressed(value));
                }
                return value;
            };
            DesignerTools.build = function () {
                var request = new Retool.Request({ type: "data" });
                request.add({ className: "ProjectFiles", method: "build", success: function (data) {
                    var result = data.result;
                }, error: function (err) {
                } });
                request.execute();
            };
            return DesignerTools;
        })();
        IDE.DesignerTools = DesignerTools;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewBuilder = (function () {
            function ViewBuilder(name) {
                this.stack = [];
                this.nextId = 1;
                this.definition = { "name": name, elements: [] };
            }
            ViewBuilder.prototype.createTableContentForModel = function (modelDef, options) {
                if (!options) {
                    options = {};
                }
                var fields = [];
                var count = 0;
                var i = 0;
                for (var fieldName in modelDef.fields) {
                    if (fieldName != Retool.modelIDName && fieldName != options.skipField) {
                        fields.push(fieldName);
                        count++;
                        if (count >= 4) {
                            break;
                        }
                    }
                }
                this.indent();
                {
                    this.add({ kind: "tbody" });
                    this.indent();
                    this.add({ kind: "tr" });
                    this.indent();
                    for (var i = 0; i < fields.length; i++) {
                        this.add({ kind: "td", value: fields[i] });
                    }
                    this.outdent();
                    this.outdent();
                }
                this.outdent();
            };
            ViewBuilder.update = function (file) {
                var view = file.getContent();
                var errors = ViewBuilder.validate(view, false);
                errors.throwIfAny();
                IDE.activeDesigner.saveFile(file, true);
            };
            ViewBuilder.validate = function (m, create) {
                var ValidationError = new ValidationError();
                if (ValidationError.required("name", m.name, "Template name is required")) {
                    if (!IDE.DesignerTools.isValidTemplateName(m.name)) {
                        ValidationError.addFieldError("name", "Template name " + IDE.DesignerTools.invalidIdMessage());
                    }
                }
                return ValidationError;
            };
            ViewBuilder.destroy = function (file) {
                IDE.activeDesigner.deleteFile(file);
            };
            ViewBuilder.prototype.getAvailId = function () {
                return (this.nextId++).toString();
            };
            ViewBuilder.prototype.add = function (element) {
                if (!element.id) {
                    element.id = this.getAvailId();
                }
                if (this.current) {
                    if (!this.current.children) {
                        this.current.children = [];
                    }
                    this.current.children.push(element);
                }
                else {
                    this.definition.elements.push(element);
                }
                this.last = element;
            };
            ViewBuilder.prototype.indent = function () {
                if (this.current) {
                    this.stack.push(this.current);
                }
                this.current = this.last;
            };
            ViewBuilder.prototype.outdent = function () {
                if (this.stack.length) {
                    this.current = this.stack.pop();
                }
                else {
                    this.current = null;
                }
            };
            ViewBuilder.prototype.getDefinition = function () {
                return this.definition;
            };
            return ViewBuilder;
        })();
        IDE.ViewBuilder = ViewBuilder;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    /*!
     * inflection
     * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
     * MIT Licensed
     *
     * @fileoverview
     * A port of inflection-js to node.js module.
     */
    var Inflection = (function () {
        function Inflection() {
        }
        Inflection._apply_rules = function (str, rules, skip, override) {
            if (override) {
                str = override;
            }
            else {
                var ignore = (Inflection.indexOf(skip, str.toLowerCase()) > -1);
                if (!ignore) {
                    var i = 0;
                    var j = rules.length;
                    for (; i < j; i++) {
                        if (str.match(rules[i][0])) {
                            if (rules[i][1] !== undefined) {
                                str = str.replace(rules[i][0], rules[i][1]);
                            }
                            break;
                        }
                    }
                }
            }
            return str;
        };
        Inflection.indexOf = function (arr, item, fromIndex, compareFunc) {
            if (!fromIndex) {
                fromIndex = -1;
            }
            var index = -1;
            var i = fromIndex;
            var j = arr.length;
            for (; i < j; i++) {
                if (arr[i] === item || compareFunc && compareFunc(arr[i], item)) {
                    index = i;
                    break;
                }
            }
            return index;
        };
        /**
     * This function adds pluralization support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @param {String} plural Overrides normal output with said String.(optional)
     * @returns {String} Singular English language nouns are returned in plural form.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.pluralize( 'person' ); // === 'people'
     *     inflection.pluralize( 'octopus' ); // === "octopi"
     *     inflection.pluralize( 'Hat' ); // === 'Hats'
     *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
     */
        Inflection.pluralize = function (str, plural) {
            return Inflection._apply_rules(str, Inflection.plural_rules, Inflection.uncountable_words, plural);
        };
        /**
         * This function adds singularization support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {String} singular Overrides normal output with said String.(optional)
         * @returns {String} Plural English language nouns are returned in singular form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.singularize( 'people' ); // === 'person'
         *     inflection.singularize( 'octopi' ); // === "octopus"
         *     inflection.singularize( 'Hats' ); // === 'Hat'
         *     inflection.singularize( 'guys', 'person' ); // === 'person'
         */
        Inflection.singularize = function (str, singular) {
            return Inflection._apply_rules(str, Inflection.singular_rules, Inflection.uncountable_words, singular);
        };
        /**
         * This function adds camelization support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Boolean} lowFirstLetter Default is to capitalize the first letter of the results.(optional)
         *                                 Passing true will lowercase it.
         * @returns {String} Lower case underscored words will be returned in camel case.
         *                  additionally '/' is translated to '::'
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
         *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
         */
        Inflection.camelize = function (str, lowFirstLetter) {
            var str_path = str.toLowerCase().split('/');
            var i = 0;
            var j = str_path.length;
            for (; i < j; i++) {
                var str_arr = str_path[i].split('_');
                var initX = ((lowFirstLetter && i + 1 === j) ? (1) : (0));
                var k = initX;
                var l = str_arr.length;
                for (; k < l; k++) {
                    str_arr[k] = str_arr[k].charAt(0).toUpperCase() + str_arr[k].substring(1);
                }
                str_path[i] = str_arr.join('');
            }
            return str_path.join('::');
        };
        /**
         * This function adds underscore support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Boolean} allUpperCase Default is to lowercase and add underscore prefix.(optional)
         *                  Passing true will return as entered.
         * @returns {String} Camel cased words are returned as lower cased and underscored.
         *                  additionally '::' is translated to '/'.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
         *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
         *     inflection.underscore( 'MP', true ); // === 'MP'
         */
        Inflection.underscore = function (str, allUpperCase) {
            if (allUpperCase && str === str.toUpperCase())
                return str;
            var str_path = str.split('::');
            var i = 0;
            var j = str_path.length;
            for (; i < j; i++) {
                str_path[i] = str_path[i].replace(Inflection.uppercase, '_$1');
                str_path[i] = str_path[i].replace(Inflection.underbar_prefix, '');
            }
            return str_path.join('/').toLowerCase();
        };
        /**
         * This function adds humanize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Boolean} lowFirstLetter Default is to capitalize the first letter of the results.(optional)
         *                                 Passing true will lowercase it.
         * @returns {String} Lower case underscored words will be returned in humanized form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.humanize( 'message_properties' ); // === 'Message properties'
         *     inflection.humanize( 'message_properties', true ); // === 'message properties'
         */
        Inflection.humanize = function (str, lowFirstLetter) {
            str = str.toLowerCase();
            str = str.replace(Inflection.id_suffix, '');
            str = str.replace(Inflection.underbar, ' ');
            if (!lowFirstLetter) {
                str = Inflection.capitalize(str);
            }
            return str;
        };
        /**
         * This function adds capitalization support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} All characters will be lower case and the first will be upper.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
         *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
         */
        Inflection.capitalize = function (str) {
            str = str.toLowerCase();
            return str.substring(0, 1).toUpperCase() + str.substring(1);
        };
        /**
         * This function adds dasherization support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Replaces all spaces or underbars with dashes.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
         *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
         */
        Inflection.dasherize = function (str) {
            return str.replace(Inflection.space_or_underbar, '-');
        };
        /**
         * This function adds titleize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Capitalizes words as you would for a book title.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
         *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
         */
        Inflection.titleize = function (str) {
            str = str.toLowerCase().replace(Inflection.underbar, ' ');
            var str_arr = str.split(' ');
            var i = 0;
            var j = str_arr.length;
            for (; i < j; i++) {
                var d = str_arr[i].split('-');
                var k = 0;
                var l = d.length;
                for (; k < l; k++) {
                    if (Inflection.indexOf(Inflection.non_titlecased_words, d[k].toLowerCase()) < 0) {
                        d[k] = Inflection.capitalize(d[k]);
                    }
                }
                str_arr[i] = d.join('-');
            }
            str = str_arr.join(' ');
            str = str.substring(0, 1).toUpperCase() + str.substring(1);
            return str;
        };
        /**
         * This function adds demodulize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Removes module names leaving only class names.(Ruby style)
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
         */
        Inflection.demodulize = function (str) {
            var str_arr = str.split('::');
            return str_arr[str_arr.length - 1];
        };
        /**
         * This function adds tableize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Return camel cased words into their underscored plural form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
         */
        Inflection.tableize = function (str) {
            str = Inflection.underscore(str);
            str = Inflection.pluralize(str);
            return str;
        };
        /**
         * This function adds classification support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Underscored plural nouns become the camel cased singular form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
         */
        Inflection.classify = function (str) {
            str = Inflection.camelize(str);
            str = Inflection.singularize(str);
            return str;
        };
        /**
         * This function adds foreign key support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @param {Boolean} dropIdUbar Default is to seperate id with an underbar at the end of the class name,
                                       you can pass true to skip it.(optional)
         * @returns {String} Underscored plural nouns become the camel cased singular form.
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
         *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
         */
        Inflection.foreign_key = function (str, dropIdUbar) {
            str = Inflection.demodulize(str);
            str = Inflection.underscore(str) + ((dropIdUbar) ? ('') : ('_')) + 'id';
            return str;
        };
        /**
         * This function adds ordinalize support to every String object.
         * @public
         * @function
         * @param {String} str The subject string.
         * @returns {String} Return all found numbers their sequence like "22nd".
         * @example
         *
         *     var inflection = require( 'inflection' );
         *
         *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
         */
        Inflection.ordinalize = function (str) {
            var str_arr = str.split(' ');
            var i = 0;
            var j = str_arr.length;
            for (; i < j; i++) {
                var k = parseInt(str_arr[i], 10);
                if (!isNaN(k)) {
                    var ltd = str_arr[i].substring(str_arr[i].length - 2);
                    var ld = str_arr[i].substring(str_arr[i].length - 1);
                    var suf = 'th';
                    if (ltd != '11' && ltd != '12' && ltd != '13') {
                        if (ld === '1') {
                            suf = 'st';
                        }
                        else if (ld === '2') {
                            suf = 'nd';
                        }
                        else if (ld === '3') {
                            suf = 'rd';
                        }
                    }
                    str_arr[i] += suf;
                }
            }
            return str_arr.join(' ');
        };
        Inflection.uncountable_words = [
            'equipment',
            'information',
            'rice',
            'money',
            'species',
            'series',
            'fish',
            'sheep',
            'moose',
            'deer',
            'news'
        ];
        /**
         * @description These rules translate from the singular form of a noun to its plural form.
         * @private
         */
        Inflection.plural_rules = [
            [new RegExp('(m)en$', 'gi')],
            [new RegExp('(pe)ople$', 'gi')],
            [new RegExp('(child)ren$', 'gi')],
            [new RegExp('([ti])a$', 'gi')],
            [new RegExp('((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$', 'gi')],
            [new RegExp('(hive)s$', 'gi')],
            [new RegExp('(tive)s$', 'gi')],
            [new RegExp('(curve)s$', 'gi')],
            [new RegExp('([lr])ves$', 'gi')],
            [new RegExp('([^fo])ves$', 'gi')],
            [new RegExp('([^aeiouy]|qu)ies$', 'gi')],
            [new RegExp('(s)eries$', 'gi')],
            [new RegExp('(m)ovies$', 'gi')],
            [new RegExp('(x|ch|ss|sh)es$', 'gi')],
            [new RegExp('([m|l])ice$', 'gi')],
            [new RegExp('(bus)es$', 'gi')],
            [new RegExp('(o)es$', 'gi')],
            [new RegExp('(shoe)s$', 'gi')],
            [new RegExp('(cris|ax|test)es$', 'gi')],
            [new RegExp('(octop|vir)i$', 'gi')],
            [new RegExp('(alias|status)es$', 'gi')],
            [new RegExp('^(ox)en', 'gi')],
            [new RegExp('(vert|ind)ices$', 'gi')],
            [new RegExp('(matr)ices$', 'gi')],
            [new RegExp('(quiz)zes$', 'gi')],
            [new RegExp('(m)an$', 'gi'), '$1en'],
            [new RegExp('(pe)rson$', 'gi'), '$1ople'],
            [new RegExp('(child)$', 'gi'), '$1ren'],
            [new RegExp('^(ox)$', 'gi'), '$1en'],
            [new RegExp('(ax|test)is$', 'gi'), '$1es'],
            [new RegExp('(octop|vir)us$', 'gi'), '$1i'],
            [new RegExp('(alias|status)$', 'gi'), '$1es'],
            [new RegExp('(bu)s$', 'gi'), '$1ses'],
            [new RegExp('(buffal|tomat|potat)o$', 'gi'), '$1oes'],
            [new RegExp('([ti])um$', 'gi'), '$1a'],
            [new RegExp('sis$', 'gi'), 'ses'],
            [new RegExp('(?:([^f])fe|([lr])f)$', 'gi'), '$1$2ves'],
            [new RegExp('(hive)$', 'gi'), '$1s'],
            [new RegExp('([^aeiouy]|qu)y$', 'gi'), '$1ies'],
            [new RegExp('(x|ch|ss|sh)$', 'gi'), '$1es'],
            [new RegExp('(matr|vert|ind)ix|ex$', 'gi'), '$1ices'],
            [new RegExp('([m|l])ouse$', 'gi'), '$1ice'],
            [new RegExp('(quiz)$', 'gi'), '$1zes'],
            [new RegExp('s$', 'gi'), 's'],
            [new RegExp('$', 'gi'), 's']
        ];
        /**
         * @description These rules translate from the plural form of a noun to its singular form.
         * @private
         */
        Inflection.singular_rules = [
            [new RegExp('(m)an$', 'gi')],
            [new RegExp('(pe)rson$', 'gi')],
            [new RegExp('(child)$', 'gi')],
            [new RegExp('^(ox)$', 'gi')],
            [new RegExp('(ax|test)is$', 'gi')],
            [new RegExp('(octop|vir)us$', 'gi')],
            [new RegExp('(alias|status)$', 'gi')],
            [new RegExp('(bu)s$', 'gi')],
            [new RegExp('(buffal|tomat|potat)o$', 'gi')],
            [new RegExp('([ti])um$', 'gi')],
            [new RegExp('sis$', 'gi')],
            [new RegExp('(?:([^f])fe|([lr])f)$', 'gi')],
            [new RegExp('(hive)$', 'gi')],
            [new RegExp('([^aeiouy]|qu)y$', 'gi')],
            [new RegExp('(x|ch|ss|sh)$', 'gi')],
            [new RegExp('(matr|vert|ind)ix|ex$', 'gi')],
            [new RegExp('([m|l])ouse$', 'gi')],
            [new RegExp('(quiz)$', 'gi')],
            [new RegExp('(m)en$', 'gi'), '$1an'],
            [new RegExp('(pe)ople$', 'gi'), '$1rson'],
            [new RegExp('(child)ren$', 'gi'), '$1'],
            [new RegExp('([ti])a$', 'gi'), '$1um'],
            [new RegExp('((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$', 'gi'), '$1$2sis'],
            [new RegExp('(hive)s$', 'gi'), '$1'],
            [new RegExp('(tive)s$', 'gi'), '$1'],
            [new RegExp('(curve)s$', 'gi'), '$1'],
            [new RegExp('([lr])ves$', 'gi'), '$1f'],
            [new RegExp('([^fo])ves$', 'gi'), '$1fe'],
            [new RegExp('([^aeiouy]|qu)ies$', 'gi'), '$1y'],
            [new RegExp('(s)eries$', 'gi'), '$1eries'],
            [new RegExp('(m)ovies$', 'gi'), '$1ovie'],
            [new RegExp('(x|ch|ss|sh)es$', 'gi'), '$1'],
            [new RegExp('([m|l])ice$', 'gi'), '$1ouse'],
            [new RegExp('(bus)es$', 'gi'), '$1'],
            [new RegExp('(o)es$', 'gi'), '$1'],
            [new RegExp('(shoe)s$', 'gi'), '$1'],
            [new RegExp('(cris|ax|test)es$', 'gi'), '$1is'],
            [new RegExp('(octop|vir)i$', 'gi'), '$1us'],
            [new RegExp('(alias|status)es$', 'gi'), '$1'],
            [new RegExp('^(ox)en', 'gi'), '$1'],
            [new RegExp('(vert|ind)ices$', 'gi'), '$1ex'],
            [new RegExp('(matr)ices$', 'gi'), '$1ix'],
            [new RegExp('(quiz)zes$', 'gi'), '$1'],
            [new RegExp('ss$', 'gi'), 'ss'],
            [new RegExp('s$', 'gi'), '']
        ];
        /**
         * @description This is a list of words that should not be capitalized for title case.
         * @private
         */
        Inflection.non_titlecased_words = [
            'and',
            'or',
            'nor',
            'a',
            'an',
            'the',
            'so',
            'but',
            'to',
            'of',
            'at',
            'by',
            'from',
            'into',
            'on',
            'onto',
            'off',
            'out',
            'in',
            'over',
            'with',
            'for'
        ];
        /**
         * @description These are regular expressions used for converting between String formats.
         * @private
         */
        Inflection.id_suffix = new RegExp('(_ids|_id)$', 'g');
        Inflection.underbar = new RegExp('_', 'g');
        Inflection.space_or_underbar = new RegExp('[\ _]', 'g');
        Inflection.uppercase = new RegExp('([A-Z])', 'g');
        Inflection.underbar_prefix = new RegExp('^_');
        return Inflection;
    })();
    Retool.Inflection = Inflection;
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewGenerator = (function () {
            function ViewGenerator() {
            }
            ViewGenerator.prototype.generateIndexView = function (options) {
                var vb = new IDE.ViewBuilder("index");
                if (this.modelDef) {
                    vb.add({ kind: "div", cssclass: "list-header" });
                    vb.indent();
                    vb.add({ kind: "row" });
                    vb.indent();
                    vb.add({ kind: "column" });
                    vb.indent();
                    vb.add({ kind: "input", type: "text", variable: "search", placeholder: "search", name: "txtSearch" });
                    vb.outdent();
                    vb.add({ kind: "column" });
                    vb.indent();
                    vb.add({ kind: "buttonpanel" });
                    vb.indent();
                    vb.add({ kind: "button", name: "btnCreate", cssclass: "btn-link", text: "Create new " + this.modelDef.label, icon: "plus" });
                    vb.outdent();
                    vb.outdent();
                    vb.outdent();
                    vb.outdent();
                    var pluralLabel = Retool.Inflection.pluralize(this.modelDef.label);
                    vb.add({ kind: "h3", text: pluralLabel });
                    vb.add({ kind: "table", "cssclass": "table-hover" });
                    vb.createTableContentForModel(this.modelDef);
                }
                else {
                    var text = (options.index_message || "Index view");
                    vb.add({ kind: "h2", text: text });
                }
                vb.definition.source_code = "function db_fetch(id,options){\n  return collection.find();\n}\n";
                return vb.definition;
            };
            ViewGenerator.prototype.generateFormPartial = function (options) {
                var vb = new IDE.ViewBuilder("_form");
                vb.add({ kind: "fieldset", "horizontal": false, "cssclass": "edit" });
                if (this.modelDef) {
                    var modelName = IDE.ModelBuilder.getName(this.modelDef);
                    vb.indent();
                    for (var fieldName in this.modelDef.fields) {
                        if (fieldName != Retool.modelIDName) {
                            vb.add({ kind: "input", value: fieldName });
                            var field = this.modelDef.fields[fieldName];
                            if (field.belongs_to) {
                            }
                        }
                    }
                    vb.outdent();
                }
                return vb.definition;
            };
            ViewGenerator.prototype.generateDropList = function (options) {
                var vb = new IDE.ViewBuilder("_droplist");
                if (this.modelDef) {
                    var recordName = this.modelDef.recordname;
                    vb.add({ kind: "fielddroplist", "filterFields": recordName });
                    vb.indent();
                    vb.add({ kind: "datafield", value: recordName });
                    vb.outdent();
                }
                return vb.definition;
            };
            ViewGenerator.prototype.generateNewView = function (options) {
                var vb = new IDE.ViewBuilder("new");
                vb.definition.showInRecordPanel = true;
                vb.add({ "kind": "form", "editMode": true });
                vb.indent();
                vb.add({ kind: "buttonpanel" });
                vb.indent();
                vb.add({ kind: "button", name: "btnSave", text: "Create", cssclass: "btn-primary", defaultButton: true });
                vb.add({ kind: "button", name: "btnCancel", text: "Cancel", cssclass: "btn-link" });
                vb.outdent();
                vb.outdent();
                vb.definition.source_code = "function db_fetch(id,options){\n  return {};\n}\n\nfunction db_save(doc){\n  collection.create(doc);\n}\n";
                return vb.definition;
            };
            ViewGenerator.prototype.generateEditView = function (options) {
                var vb = new IDE.ViewBuilder("edit");
                vb.definition.showInRecordPanel = true;
                vb.add({ "kind": "form", "editMode": true });
                vb.indent();
                vb.add({ kind: "buttonpanel" });
                vb.indent();
                vb.add({ kind: "button", name: "btnSave", text: "Save", cssclass: "btn-primary", defaultButton: true });
                vb.add({ kind: "button", name: "btnCancel", text: "Cancel", cssclass: "btn-link" });
                vb.outdent();
                if (this.modelDef) {
                    vb.add({ kind: "h3" });
                    vb.indent();
                    vb.add({ kind: "text", text: "Edit " + this.modelDef.label + ":" });
                    vb.add({ kind: "strong" });
                    vb.indent();
                    vb.add({ kind: "datafield", value: this.modelDef.recordname });
                    vb.outdent();
                    vb.outdent();
                    vb.add({ "kind": "partial", "view": "_form" });
                }
                vb.outdent();
                vb.definition.source_code = "function db_fetch(id,options){\n  return collection.findById(id);\n}\n\nfunction db_save(doc){\n  collection.findByIdAndUpdate(doc.id,doc);\n}\n";
                return vb.definition;
            };
            ViewGenerator.prototype.generateShowView = function (options) {
                var vb = new IDE.ViewBuilder("show");
                vb.definition.showInRecordPanel = true;
                vb.add({ "kind": "form", "editMode": false });
                vb.indent();
                vb.add({ "kind": "buttonpanel" });
                vb.indent();
                vb.add({ kind: "button", name: "btnEdit", text: "Edit", cssclass: "btn-link", icon: "pencil" });
                vb.add({ kind: "button", name: "btnDelete", text: "Delete", cssclass: "btn-link", icon: "remove" });
                vb.outdent();
                vb.add({ kind: "br" });
                var label = (this.modelDef) ? (this.modelDef.label + " Info") : "Info";
                if (this.modelDef) {
                    vb.add({ kind: "h2" });
                    vb.indent();
                    vb.add({ kind: "datafield", value: this.modelDef.recordname });
                    vb.outdent();
                }
                else {
                    vb.add({ kind: "h2", text: label });
                }
                vb.add({ kind: "br" });
                vb.add({ kind: "fieldset", "horizontal": "true" });
                if (this.modelDef) {
                    vb.indent();
                    for (var fieldName in this.modelDef.fields) {
                        if (fieldName != Retool.modelIDName) {
                            vb.add({ kind: "input", value: fieldName });
                        }
                    }
                    vb.outdent();
                }
                vb.outdent();
                vb.definition.source_code = "function db_fetch(id,options){\n  return collection.findById(id);\n}\n";
                return vb.definition;
            };
            ViewGenerator.prototype.generateStandard = function (options) {
                var views = [];
                if (options.index) {
                    views.push(this.generateIndexView(options));
                }
                if (options.new_) {
                    views.push(this.generateNewView(options));
                }
                if (options.edit) {
                    views.push(this.generateEditView(options));
                }
                if (options.new_ || options.edit) {
                    views.push(this.generateFormPartial(options));
                }
                if (options.show) {
                    views.push(this.generateShowView(options));
                }
                if (options.droplist) {
                    views.push(this.generateDropList(options));
                }
                if (this.modelDef) {
                    for (var i = 0; i < views.length; i++) {
                        var view = views[i];
                        view.model = this.modelDef.name;
                    }
                }
                return views;
            };
            ViewGenerator.prototype.createFile = function (viewPath, viewDef) {
                var file = new Retool.FileSystem.File(viewPath + "/" + viewDef.name + ".view", viewDef);
                return file;
            };
            ViewGenerator.prototype.generateNavLayout = function (options) {
                var vb = new IDE.ViewBuilder("_nav");
                vb.add({ kind: "navbarnav" });
                return vb.definition;
            };
            ViewGenerator.prototype.generateBases = function (application) {
                var views = [];
                var view;
                var code;
                code = 'function btnCreate_onclick(e){\n  e.redirect("new");\n}\n';
                views.push({ "name": "index", elements: [], source_code: code });
                code = 'function btnSave_onclick(e){\n  e.model = controller.update(e.model);\n  e.redirect(e.model._id);\n}\n';
                code += "\nfunction btnCancel_onclick(e){\n  e.redirect(e.model._id);\n}\n";
                views.push({ "name": "edit", elements: [], source_code: code });
                code = 'function btnSave_onclick(e){\n  e.model = controller.create(e.model);\n  e.redirect(e.model._id);\n}\n';
                code += "\nfunction btnCancel_onclick(e){\n  e.close();\n}\n";
                views.push({ "name": "new", elements: [], source_code: code });
                code = 'function btnEdit_onclick(e){\n  e.redirect(e.model._id + "/edit");\n}\n';
                code += '\nfunction btnDelete_onclick(e){\n  if (confirm("Delete this record?",{buttonText:"Delete",css:"danger"})){\n    controller.destroy(e.model._id);\n    e.close();\n  }\n}\n';
                views.push({ "name": "show", elements: [], source_code: code });
                return views;
            };
            return ViewGenerator;
        })();
        IDE.ViewGenerator = ViewGenerator;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewInspector = (function () {
            function ViewInspector() {
                this.stateCache = {};
                this.clipboard = new IDE.Clipboard();
            }
            ViewInspector.prototype.render = function (w) {
                w.writeTag("div", null, { id: "inspector-container" });
                //	w.writeTag("div",null,{id:"designerTop"});
                w.writeTag("div", "ide-panel", { id: "designerTL" });
                //w.writeTag("div","designer-content toolbox",{id:"toolbox-content"});
                //w.write('<div style="display:block">');
                IDE.activeDesigner.toolbox.render(w);
                //w.write('</div>');
                // w.write('</div>');
                w.write('</div>');
                w.writeTag("div", "ide-panel", { id: "designerTR" });
                w.writeTag("div", "panel-sizer").write("</div>");
                w.writeTag("div", null, { id: "viewInspectorTitle" }).write('</div>');
                w.writeTag("div", null, { id: "viewInspectorContent" }).write('</div>');
                if (!$('#rto-outliner').length) {
                    $('body').append('<div id="rto-outliner" style="display:none"></div>');
                }
                w.write('</div>');
                // w.write('</div>'); // designerTop
                w.writeTag("div", "ide-panel", { id: "designerBottom" });
                // w.writeTag("a","ide-panel-close",{href:"#"}).write("&times;").write('</a>');
                IDE.activeDesigner.renderer.renderVerticalSplitter(w, "designerTBHandle");
                w.writeTag("div", "panel-sizer").write("</div>");
                IDE.activeDesigner.attributesPanel.render(w);
                w.write('</div>'); //designerBottom
                w.write('</div>');
            };
            ViewInspector.prototype.renderTitle = function (w) {
                var isApplication = false;
                var templateName = "";
                if (templateName) {
                    w.writeTag("span", "glyph toolbox color0").write(")</span> ");
                }
                var template = IDE.activeDesigner.sourceTemplate;
                if (template) {
                    var text = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(template.file.getFullName());
                    w.text(text);
                }
                w.writeTag("div", "toolbar");
                this.renderToolbar(w);
                w.write('</div>');
            };
            ViewInspector.prototype.renderToolbar = function (w) {
                w.write('<a href="#" data-url="go:designer.undo" tooltip="undo"');
                if (!IDE.activeDesigner.canUndo()) {
                    w.writeClass("disabled");
                }
                w.write('>').writeTag("span", "glyph toolbox").write('.</span></a>');
                w.write('<a href="#" data-url="go:designer.redo" tooltip="redo"');
                if (!IDE.activeDesigner.canRedo()) {
                    w.writeClass("disabled");
                }
                w.write('>').writeTag("span", "glyph toolbox").write('/</span></a>');
                w.write('<a href="#" data-url="go:designer.copy" tooltip="copy to clipboard"');
                if (!IDE.activeDesigner.canCopy()) {
                    w.writeClass("disabled");
                }
                w.write('>').writeTag("span", "glyph toolbox").write('0</span></a>');
            };
            ViewInspector.prototype.refreshToolbar = function () {
                var w = new Retool.Writer("ds");
                this.renderToolbar(w);
                w.writeToElement('#' + Retool.makeDomId('viewInspectorTitle') + ' .' + w.makeClass('toolbar'));
            };
            ViewInspector.prototype.renderContent = function (w) {
                var view = IDE.activeDesigner.sourceTemplate;
                w.writeTag("ul", null, { id: "view-inspector" });
                if (view) {
                    this.renderViewElements(w, view.definition.elements);
                    w.writeTag("li", null, { id: "view-append", "data-rto-kind": "form" }).writeTag("div", "item").write('&nbsp;</div></li>');
                }
                w.write('</ul>');
            };
            ViewInspector.prototype.refresh = function (preserveState) {
                var state;
                if (this.currentTemplateName) {
                    this.stateCache[this.currentTemplateName] = this.getStateSnapshot();
                }
                var w = new Retool.Writer("ds");
                this.renderTitle(w);
                w.writeToElement('#' + Retool.makeDomId('viewInspectorTitle'));
                w = new Retool.Writer("ds");
                this.renderContent(w);
                w.writeToElement('#' + Retool.makeDomId('viewInspectorContent'));
                this.attachDragEvents();
                if (IDE.activeDesigner.sourceTemplate) {
                    this.currentTemplateName = IDE.activeDesigner.sourceTemplate.file.getFullName();
                    if (this.currentTemplateName) {
                        state = this.stateCache[this.currentTemplateName];
                        if (state) {
                            this.applyStateSnapshot(state);
                        }
                    }
                }
            };
            ViewInspector.prototype.renderViewElements = function (w, collection) {
                if (!collection) {
                    return;
                }
                for (var i = 0; i < collection.length; i++) {
                    var element = collection[i];
                    var kind = element.kind;
                    var helper = IDE.Ide.sourceApp.helpers.get(kind);
                    var settings = {};
                    if (helper && helper.settings) {
                        settings = helper.settings;
                    }
                    var viewItemId = "view-" + element.id;
                    var itemDropKind = settings.dropKind || kind;
                    if (settings.container) {
                        w.writeTag("li", "expandable", { id: viewItemId, "data-rto-kind": itemDropKind }).write('<div></div>');
                    }
                    else {
                        var liCls = (kind == "else") ? "else" : null;
                        w.writeTag("li", liCls, { id: viewItemId, "data-rto-kind": itemDropKind });
                    }
                    w.writeTag("div", "selectable");
                    w.writeTag("a", "delete", { href: "#" }).write("&times;</a>");
                    var itemCls = (settings.command) ? " command" : "";
                    w.writeTag("div", "element-syntax item" + itemCls, { draggable: "true" });
                    var elem = this.renderElement(w, element);
                    var label = elem.label;
                    w.write('</div>');
                    w.writeTag("div", "ext").write('</div>');
                    w.write('</div>');
                    if (settings.container) {
                        w.writeTag("div", "pip").write('<a href="#"></a></div>');
                        w.write('<ul>');
                        if (element.children) {
                            this.renderViewElements(w, element.children);
                        }
                        w.write('</ul>');
                        w.writeTag("div", "item closing selectable" + itemCls, { draggable: true });
                        ;
                        if (label[0] == "#") {
                            w.text("/").writeTag("span", "kind").text(label.substr(1)).write('</span>').text("");
                        }
                        else {
                            w.text("</").writeTag("span", "kind").text(label).write('</span>').text(">");
                        }
                        w.write("</div>");
                    }
                    w.write('</li>');
                }
            };
            ViewInspector.prototype.renderElement = function (w, element) {
                var kind = element.kind;
                var helper = IDE.Ide.sourceApp.helpers.get(kind);
                if (!helper) {
                    helper = IDE.Ide.sourceApp.helpers.get("div");
                }
                var itemText = "";
                var itemTextClass = "";
                var itemLiteral = "";
                var info = helper.getInspectorInfo(element);
                var settings = {};
                if (helper && helper.settings) {
                    settings = helper.settings;
                }
                var label = (settings.label) ? settings.label : kind;
                var itemLink;
                if (info) {
                    if (info.variable) {
                        itemText = info.variable;
                        itemTextClass = "variable";
                    }
                    else if (info.expression) {
                        itemText = info.expression;
                        itemTextClass = "field";
                        var anaylzer = new IDE.MethodAnalyzer(info.expression);
                        var first = anaylzer.getFirstCall();
                        if (first) {
                            var methodName = first.methodName;
                            if (first.target) {
                                methodName = first.target + "." + methodName;
                            }
                            itemLink = { action: "code-method", value: methodName };
                        }
                    }
                    else if (info.field) {
                        itemText = info.field;
                        itemTextClass = "field";
                    }
                    if (info.literal) {
                        itemLiteral = info.literal;
                    }
                }
                if (kind != "text") {
                    if (label[0] == "#") {
                        //w.write("<i>#</i>");
                        w.writeTag("span", "kind").text(label.substr(1)).write('</span>');
                    }
                    else {
                        w.text("<");
                        w.writeTag("span", "kind").text(label).write('</span>');
                    }
                }
                if (itemText) {
                    w.writeTag("span", "caption " + itemTextClass);
                    if (itemLink) {
                        var linkAttr = { href: "#", "rto-data-action": itemLink.action, "rto-data-value": itemLink.value };
                        w.writeTag("a", null, linkAttr).text(itemText).write("</a>");
                    }
                    else {
                        w.text(itemText);
                    }
                    w.write('</span>');
                }
                else {
                }
                if (element.field) {
                    w.writeTag("span", "caption kind").write('as</span>');
                    w.writeTag("span", "caption field").text(element.var).write('</span>');
                }
                if (kind == "r-foreach") {
                    w.writeTag("span", "caption field").text(element.var).write('<span>');
                    w.writeTag("span", "caption kind").write('in</span>');
                    w.writeTag("span", "caption field").text(element.obj).write('</span>');
                }
                if (element.name) {
                    w.writeTag("span", "caption name").text(element.name).write('</span>');
                }
                if (element.path) {
                    w.writeTag("span", "caption href").text(element.path).write('</span>');
                }
                if (element.href) {
                    w.writeTag("span", "caption href");
                    if (settings.isTemplateRoot) {
                        w.writeTag("a", "filelink", { "data-rto-partial": element.href }).text(element.href).write('</a>');
                    }
                    else {
                        w.text(element.href);
                    }
                    w.write("</span>");
                }
                if (element.src) {
                    w.writeTag("span", "caption href").text(element.src).write('</span>');
                }
                if (element.cssclass) {
                    w.writeTag("span", "caption cssclass").text(element.cssclass).write('</span>');
                }
                if (element.role) {
                    w.writeTag("span", "caption role").text(element.role).write('</span>');
                }
                if (info.fileLink) {
                    var currentViewFile = IDE.activeDesigner.sourceTemplate.file;
                    w.write(' ').writeTag("a", "filelink", { "data-rto-partial": info.fileLink }).text(info.path).write('</a>');
                }
                if (kind != "text") {
                    if (label[0] == "#") {
                        w.write('');
                    }
                    else {
                        w.text(">");
                    }
                }
                if (itemLiteral) {
                    if (itemLiteral.length > 40) {
                        itemLiteral = itemLiteral.substr(0, 40) + "...";
                    }
                    this.renderExpression(w, null, itemLiteral);
                }
                else if (label[0] != "#" && element.children && element.children.length) {
                    var firstChild = element.children[0];
                    if (firstChild.kind == "text") {
                        this.renderExpression(w, "text-node", firstChild.text);
                    }
                }
                return { label: label };
            };
            ViewInspector.prototype.renderExpression = function (w, cssClass, expression) {
                var encoded = Retool.Html.escape(expression);
                // encoded = encoded.replace(/\{\{/g,"<i>{{<em>").replace(/\}\}/g,"</em>}}</i>"); // todo must have matched closing tags use split
                w.writeTag("span", "caption literal " + (cssClass || "")).write(encoded).write('</span>');
            };
            ViewInspector.prototype.hideOutliner = function () {
                $('#rto-outliner').hide();
                this.currentOutlinerElemId = null;
            };
            ViewInspector.prototype.onMouseMove = function (e) {
                var inspectorItem = $(document.elementFromPoint(e.clientX, e.clientY)).closest("[id^='rto-view-']");
                if (inspectorItem.length) {
                    var inspectorElem = inspectorItem.get(0);
                    this.showOutliner(inspectorElem.id.substr(9));
                }
                else if (this.currentOutlinerElemId) {
                    this.hideOutliner();
                }
            };
            ViewInspector.prototype.deleteOnClick = function (e, $this) {
                var id = this.getIdFromElement($this);
                this.deleteItem(id, IDE.activeDesigner.sourceTemplate);
                IDE.activeDesigner.closeAttributesPanel();
                IDE.activeDesigner.refreshViewInspector(true);
                IDE.activeDesigner.refreshView();
            };
            ViewInspector.prototype.deleteItem = function (id, template) {
                var location = IDE.activeDesigner.getComponentLocation(template.wrapper, id);
                var pointer = IDE.activeDesigner.getElementPointer(template, id);
                var command = new IDE.DeleteCommand(location, pointer.element);
                command.do(template);
                IDE.activeDesigner.commandStack.add(command);
                IDE.activeDesigner.saveFile(template.file);
            };
            ViewInspector.prototype.showOutliner = function (viewItemId) {
                if (viewItemId == this.currentOutlinerElemId) {
                    return; // same item 
                }
                // return; // todo fix for sep window;
                var canvas = IDE.Ide.getAppCanvas();
                if (!canvas) {
                    return;
                }
                var component = canvas.findComponentByDefinitionId(viewItemId, IDE.activeDesigner.sourceTemplate);
                if (component) {
                    var pageItem = component.getElement();
                    if (pageItem.length) {
                        var pos = pageItem.offset();
                        var appContainerOffset = $('#rto-app-container > iframe').offset();
                        pos.top += appContainerOffset.top;
                        pos.left += appContainerOffset.left;
                        pos.top -= Retool.App.document.body.scrollTop;
                        pos.left -= Retool.App.document.body.scrollLeft;
                        var width = pageItem.outerWidth();
                        var height = pageItem.outerHeight();
                        if (height < 2) {
                            height = 2;
                        }
                        if (width < 10) {
                            width = 10;
                        }
                        var kind = component.attr.kind;
                        if (component.customComponent) {
                            kind = component.customComponent.attr.kind;
                        }
                        if (kind == "h") {
                            kind += component.attr.size;
                        }
                        var content = "<p>&lt;" + kind + "&gt;</p><div></div>";
                        if (width && height) {
                            $('#rto-outliner').css('top', pos.top).css('left', pos.left).css('width', width).css('height', height).html(content).show();
                        }
                        else {
                            $('#rto-outliner').hide(); // item is not visible
                        }
                        this.currentOutlinerElemId = viewItemId;
                        return;
                    }
                }
                this.hideOutliner();
            };
            ViewInspector.prototype.getIdFromElement = function ($this) {
                var li = $this.closest('li');
                var fullId = li.prop('id').split('-');
                var id = fullId[2];
                return id;
            };
            ViewInspector.prototype.attachEvents = function () {
                var self = this;
                $('#rto-viewInspectorContent').on('click', '.rto-pip', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    var li = $(this).closest('li');
                    li.toggleClass('rto-expanded');
                    if (e.shiftKey) {
                        if (li.hasClass('rto-expanded')) {
                            li.find('.rto-expandable').addClass('rto-expanded');
                        }
                        else {
                            li.find('.rto-expandable').removeClass('rto-expanded');
                        }
                    }
                });
                $('#rto-viewInspectorContent').on('click', '.rto-item', function (e) {
                    var $this = $(this);
                    var aTag = $(e.target).closest('a');
                    if (aTag.length) {
                        if (aTag.hasClass('rto-delete')) {
                            self.deleteOnClick(e, $this);
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                        var action = aTag.attr('rto-data-action');
                        var value = aTag.attr('rto-data-value');
                        if (action == "code-method") {
                            self.showCodeMethod(value);
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }
                    var id = self.getIdFromElement($this);
                    IDE.activeDesigner.showAttributesForId({ id: id });
                });
                $('#rto-viewInspectorContent').on('click', '.rto-delete', function (e) {
                    var $this = $(this);
                    self.deleteOnClick(e, $this);
                    e.preventDefault();
                    e.stopPropagation();
                    var id = self.getIdFromElement($this);
                    IDE.activeDesigner.showAttributesForId({ id: id });
                });
                var self = this;
                var mouseItemId;
                $('#rto-viewInspectorContent').on('click', '[data-rto-partial]', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    var partial = $(this).data('rto-partial');
                    var canvas = IDE.Ide.getAppCanvas();
                    var url = Retool.Url.canvas(canvas).href(partial);
                    IDE.activeDesigner.showPartial(url);
                });
                $('#rto-viewInspectorContent').on('mousemove', function (e) {
                    self.onMouseMove(e);
                });
                $('#rto-viewInspectorContent').on('mouseleave', function (e) {
                    self.hideOutliner();
                });
                $('#rto-attributes-content').on('input', function (e) {
                    IDE.activeDesigner.attributeView.model.dirty = true;
                    $('#rto-attributes-apply').removeClass('rto-inactive');
                });
                this.attachDragEvents();
            };
            ViewInspector.prototype.showCodeMethod = function (name) {
                var segments = name.split('.');
                var file;
                var methodName;
                if (segments.length == 3) {
                    var modelId = segments[0] + "." + segments[1];
                    methodName = segments[2];
                    file = IDE.Ide.sourceApp.models.getFile(modelId);
                }
                if (file) {
                    var filename = file.getFullName();
                    IDE.activeDesigner.gotoCodeLine({ filename: filename, methodName: methodName });
                }
            };
            ViewInspector.prototype.attachDragEvents = function () {
                var designer = IDE.activeDesigner;
                $('#rto-view-inspector .rto-item').bind('dragstart', designer.elementDragStart).bind('dragover', designer.elementDragOver).bind('dragenter', designer.elementDragEnter).bind('dragleave', designer.elementDragLeave).bind('dragend', designer.elementDragEnd).bind('drop', designer.elementDrop);
            };
            ViewInspector.prototype.copy = function () {
                if (IDE.activeDesigner.attributeView.isElementEdit()) {
                    var elemId = IDE.activeDesigner.attributeView.model.get("id");
                    var pointer = IDE.activeDesigner.getElementPointer(IDE.activeDesigner.sourceTemplate, elemId);
                    if (pointer) {
                        var element = pointer.element;
                        this.clipboard.add(this.copyElement(element));
                        IDE.activeDesigner.toolbox.refreshClipboard();
                    }
                }
            };
            ViewInspector.prototype.copyElement = function (source) {
                var clone = {};
                for (var key in source) {
                    if (key == "children") {
                        var children = [];
                        clone["children"] = children;
                        for (var i = 0; i < source.children.length; i++) {
                            children.push(this.copyElement(source.children[i]));
                        }
                    }
                    else {
                        clone[key] = source[key];
                    }
                }
                clone.id = null;
                return clone;
            };
            ViewInspector.prototype.copyElementArray = function (elements) {
                var clone = [];
                for (var i = 0; i < elements.length; i++) {
                    clone.push(this.copyElement(elements[i]));
                }
                return clone;
            };
            ViewInspector.prototype.getStateSnapshot = function () {
                var expanded = $('#rto-view-inspector li.rto-expanded');
                var expandedList = [];
                expanded.each(function () {
                    expandedList.push(this.id);
                });
                var selectedList = [];
                var selected = $('#rto-view-inspector li.rto-selected');
                selected.each(function () {
                    selectedList.push(this.id);
                });
                return { expanded: expandedList, selected: selectedList };
            };
            ViewInspector.prototype.applyStateSnapshot = function (snapshot) {
                if (snapshot.expanded) {
                    var expandedList = snapshot.expanded;
                    for (var i = 0; i < expandedList.length; i++) {
                        $('#' + expandedList[i]).addClass("rto-expanded");
                    }
                }
                if (snapshot.selected) {
                    var selectedList = snapshot.selected;
                    for (var i = 0; i < selectedList.length; i++) {
                        $('#' + selectedList[i]).addClass("rto-selected");
                    }
                }
            };
            ViewInspector.prototype.showElement = function (id) {
                this.collapseAll();
                var w = new Retool.Writer('ds');
                var $item = $('#rto-view-' + id);
                if (!$item.length) {
                    return;
                }
                $item.parents('.' + w.makeClass('expandable')).addClass(w.makeClass('expanded'));
                if ($item.is('.' + w.makeClass('expandable'))) {
                    $item.addClass(w.makeClass('expanded'));
                    ;
                }
                var viewInspectorElem = $item[0];
                var scrollContainer = $('#rto-viewInspectorContent')[0];
                Retool.Page.scrollElementIntoView(viewInspectorElem, scrollContainer);
            };
            ViewInspector.prototype.collapseAll = function () {
                var w = new Retool.Writer("ds");
                $('#rto-view-inspector .rto-expanded').removeClass('rto-expanded'); // collapse all 
            };
            return ViewInspector;
        })();
        IDE.ViewInspector = ViewInspector;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var AttributesPanel = (function () {
            function AttributesPanel() {
            }
            AttributesPanel.prototype.render = function (w) {
                w.writeTag("div", null, { id: "attributes-title" });
                w.write('</div>');
                w.writeTag("div", null, { id: "attributes" });
                w.writeTag("div", null, { id: "attributes-content" });
                w.write('</div>');
                w.write('</div>'); // #attributes
            };
            return AttributesPanel;
        })();
        IDE.AttributesPanel = AttributesPanel;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var DropCommandFactory = (function () {
            function DropCommandFactory() {
            }
            DropCommandFactory.create = function (dropLocation, source, callback) {
                if (!source) {
                    return;
                }
                var factory = new DropCommandFactory();
                factory.source = source;
                factory.dropLocation = dropLocation;
                factory.createCommand(callback);
                if (factory.command) {
                    callback(factory);
                }
            };
            DropCommandFactory.prototype.createCommand = function (callback) {
                var type = this.source.type;
                if (type == "template") {
                    this.createForView();
                }
                else if (type == "element" || type == "helper") {
                    this.createForToolboxItem();
                }
                else if (type == "component") {
                    this.createForComponent();
                }
                else if (type == "field") {
                    this.createForField();
                }
                else if (type == "relationship") {
                    this.createForRelationship();
                }
                else if (type == "dom-element") {
                    this.createForElement();
                }
                else if (type == "model") {
                }
                else if (type == "arraymodel") {
                    this.createForArrayModel(callback);
                }
                else if (type == "value") {
                    this.createForValue();
                }
                else if (type == "clipboard") {
                    this.createForClipboard();
                }
                else if (type == "objectmodel") {
                    this.createForObjectModel();
                }
                else if (type == "file") {
                    this.createForFile();
                }
                else if (type == "image") {
                    this.createForImage();
                }
                else if (type == "app") {
                    this.createForApp();
                }
            };
            DropCommandFactory.prototype.createForElement = function () {
                // move existing element
                var view = IDE.activeDesigner.sourceTemplate;
                var elemId = this.source.id.substr(9); // remove rto-view-
                var pointer = IDE.activeDesigner.getElementPointer(view, elemId);
                this.affectedElement = pointer.element;
                var currentLocation = IDE.activeDesigner.getComponentLocation(view.wrapper, elemId);
                if (this.source.isClosing) {
                    this.command = new IDE.MoveClosingTagCommand(currentLocation, this.dropLocation, this.affectedElement);
                }
                else {
                    this.command = new IDE.MoveCommand(currentLocation, this.dropLocation, this.affectedElement);
                }
            };
            DropCommandFactory.prototype.createForClipboard = function () {
                var viewInspector = IDE.activeDesigner.viewInspector;
                var clipboardElement = viewInspector.clipboard.get(this.source.name);
                if (!clipboardElement) {
                    return;
                }
                this.elementAdded = true;
                if (Array.isArray(clipboardElement)) {
                    var block = viewInspector.copyElementArray(clipboardElement);
                    this.command = new IDE.SnippetDropCommand(this.dropLocation, block);
                }
                else {
                    this.affectedElement = viewInspector.copyElement(clipboardElement);
                    this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                }
            };
            DropCommandFactory.prototype.createForToolboxItem = function () {
                // toolbox component item
                this.elementAdded = true;
                var kind = this.source.name;
                if (kind && kind[0] == "_") {
                    var snippet = IDE.Ide.elementSnippets.get(kind);
                    var block = snippet.createFromToolbox(null);
                }
                else {
                    this.affectedElement = { kind: kind };
                    var helper = IDE.Ide.sourceApp.helpers.get(kind);
                    if (helper) {
                        helper.createFromToolbox(this.affectedElement);
                    }
                    this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                }
            };
            DropCommandFactory.prototype.createForComponent = function () {
                this.elementAdded = true;
                var name = this.source.name;
                var app = IDE.Ide.sourceApp;
                var kind = app.components.filenameToName(name);
                this.affectedElement = { kind: kind };
                var helper = app.helpers.get(kind);
                if (helper) {
                    helper.createFromToolbox(this.affectedElement);
                }
                this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
            };
            DropCommandFactory.prototype.createForObjectModel = function () {
                var name = this.source.name;
                var sourceTemplate = IDE.activeDesigner.sourceTemplate.definition;
                var dataContext;
                var elem = { kind: "r-with", obj: name };
                var fieldset = { kind: "fieldset", horizontal: true };
                elem.children = [fieldset];
                var viewModel = IDE.Ide.getAppCanvas().viewModel;
                var objectValue = viewModel.get(name);
                if (objectValue) {
                    var attributes = objectValue.getAttributes();
                    var children = [];
                    for (var key in attributes) {
                        children.push({ kind: "static", value: key });
                    }
                    fieldset.children = children;
                }
                this.affectedElement = elem;
                this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                this.elementAdded = true;
            };
            DropCommandFactory.prototype.createForArrayModel = function (callback) {
                var name = this.source.name;
                var self = this;
                var create = function (targetType) {
                    var sourceTemplate = IDE.activeDesigner.sourceTemplate.definition;
                    var dataContext;
                    var elem;
                    if (targetType == "ul") {
                        elem = { kind: "ul" };
                        var each = { kind: "r-foreach", obj: name };
                        elem.children = [each];
                        var li = { kind: "li" };
                        each.children = [li];
                        var viewModel = IDE.Ide.getAppCanvas().viewModel;
                        var arrayValue = viewModel.get(name);
                        if (arrayValue) {
                            var row = arrayValue.getRow(0);
                            if (row) {
                                var children = [];
                                var attributes = row.getAttributes();
                                var c = 0;
                                var text = "";
                                for (var key in attributes) {
                                    if (text) {
                                        text += " ";
                                    }
                                    text += "{{" + key + "}}";
                                    if (++c > 2) {
                                        break;
                                    }
                                }
                                children.push({ kind: "text", text: text });
                            }
                            li.children = children;
                        }
                    }
                    else if (targetType == "table") {
                        elem = { kind: "table" };
                        elem.children = [{ kind: "r-foreach", obj: name }];
                    }
                    else if (targetType == "each") {
                        elem = { kind: "r-foreach", obj: name };
                    }
                    else {
                        return;
                    }
                    self.affectedElement = elem;
                    self.command = new IDE.ToolDropCommand(self.dropLocation, self.affectedElement);
                    self.elementAdded = true;
                    callback(self);
                };
                var dropTypes = [
                    { name: "Table", tag: "<table>", id: "table" },
                    { name: "Unordered list", tag: "<ul>", id: "ul" },
                    { name: "Each loop", tag: "#each", id: "each" }
                ];
                IDE.Ide.render("drop-as/ask", null, { propname: name, callback: create, items: new Retool.ArrayModel(dropTypes, { modelDef: null }) });
                return;
            };
            DropCommandFactory.prototype.createForValue = function () {
                var segments = this.source.name.split('.');
                var name;
                if (segments.length > 2 && segments[1] == "0") {
                    name = segments.slice(2).join('.');
                }
                else {
                    name = segments.join('.');
                }
                this.createValueElement(name);
            };
            DropCommandFactory.prototype.createForField = function () {
                var segments = this.source.name.split('.');
                var modelId = segments[0] + "." + segments[1];
                var fieldName = segments.slice(2).join('.');
                this.createValueElement(fieldName);
            };
            DropCommandFactory.prototype.createValueElement = function (propName) {
                var parent = this.dropLocation.parent;
                var scopeName = this.getScopeName(parent);
                if (scopeName) {
                    propName = scopeName + "." + propName;
                }
                else {
                    propName = "this." + propName;
                }
                var parentKind = parent.kind;
                var elem = {};
                if (parentKind == "tr") {
                    elem.kind = "td";
                    elem.text = "{{" + propName + "}}";
                }
                else if (parentKind == "thead") {
                    elem.kind = "th";
                    elem.value = propName;
                }
                else if (this.isChildOfFormGroup(parent)) {
                    elem.kind = "input";
                    //elem.kind = "static";
                    elem.value = propName;
                }
                else {
                    elem.kind = "text";
                    elem.text = "{{" + propName + "}}";
                }
                this.affectedElement = elem;
                var helper = IDE.Ide.sourceApp.helpers.get(elem.kind);
                if (helper) {
                    helper.createFromToolbox(this.affectedElement);
                }
                this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                this.elementAdded = true;
            };
            DropCommandFactory.prototype.getScopeName = function (element) {
                while (element) {
                    if (element.var) {
                        return element.var;
                    }
                    element = IDE.activeDesigner.getParentElement(element);
                }
                return null;
            };
            DropCommandFactory.prototype.createDataField = function (modelName, fieldName) {
                var app = IDE.Ide.sourceApp;
                var modelDef = app.models.getDefinition(modelName);
                var field = app.getField(modelDef, fieldName);
                var relationship = app.getRelationship(modelDef, fieldName);
                var kind;
                if (field) {
                }
                else if (relationship) {
                    kind = "table";
                    var relatedModelDef = app.models.getDefinition(relationship.model);
                    this.affectedElement = { kind: kind, relationship: fieldName };
                    var viewBuilder = new IDE.ViewBuilder("");
                    viewBuilder.add(this.affectedElement);
                    viewBuilder.createTableContentForModel(relatedModelDef, { titleSize: "5", skipField: relationship.foreignKey });
                }
                var helper = app.helpers.get(kind);
                if (helper) {
                    helper.createFromToolbox(this.affectedElement);
                }
                this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                this.elementAdded = true;
            };
            DropCommandFactory.prototype.isChildOfFormGroup = function (element) {
                while (element) {
                    if (element.kind == "formgroup") {
                        return true;
                    }
                    element = IDE.activeDesigner.getParentElement(element);
                }
                return false;
            };
            DropCommandFactory.prototype.createForRelationship = function () {
                var segments = this.source.name.split('.');
                var modelId = segments[0] + "." + segments[1];
                var relationshipId = segments[2];
                var modelDef = IDE.Ide.sourceApp.models.getDefinition(modelId);
                var relationshipDef = modelDef.relationships[relationshipId];
                if (relationshipDef && relationshipDef.type == "has_many") {
                    this.affectedElement = { "kind": "table", "relationship": relationshipId };
                    var relatedModelDef = IDE.Ide.sourceApp.models.getDefinition(relationshipDef.model);
                    var viewBuilder = new IDE.ViewBuilder("");
                    viewBuilder.add(this.affectedElement);
                    viewBuilder.createTableContentForModel(relatedModelDef, { titleSize: "5" });
                    this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                }
                this.elementAdded = true;
            };
            DropCommandFactory.prototype.createForFile = function () {
                var filename = this.source.name;
                var ext = Retool.FileSystem.PathInfo.getExtension(filename);
                var file = IDE.Ide.sourceApp.getFile(filename);
                if (file) {
                    var segments = file.path.split('/');
                    if (ext == "css") {
                        var href = "/" + file.getFullName();
                        this.affectedElement = { kind: "r-stylesheet", href: href };
                        this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                        this.elementAdded = true;
                    }
                    else if (ext == "md" || ext == "txt") {
                        var src = "/" + file.getFullName();
                        this.affectedElement = { kind: "r-content", src: src };
                        this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                        this.elementAdded = true;
                    }
                    else if (ext == "png" || ext == "gif" || ext == "jpg" || ext == "jpeg") {
                        var src = "/" + file.getFullName();
                        this.affectedElement = { kind: "img", src: src };
                        this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                        this.elementAdded = true;
                    }
                }
            };
            DropCommandFactory.prototype.createForImage = function () {
                var filename = this.source.name;
                var file = IDE.Ide.sourceApp.getFile(filename);
                if (file) {
                    this.affectedElement = { kind: "img", src: "images/" + file.name };
                    this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                    this.elementAdded = true;
                }
            };
            DropCommandFactory.prototype.createForView = function () {
                var filename = this.source.name;
                var url = Retool.Url.filename(filename);
                var label = url.templateName;
                var path = url.templateName;
                if (url.templatePath) {
                    path = url.templatePath + "/" + path;
                }
                var parentKind = this.dropLocation.parent.kind;
                var isLink = false;
                label = Retool.Inflection.titleize(label);
                if (parentKind == "navbarnav") {
                    this.affectedElement = { kind: "navbaritem", href: path, text: label };
                }
                else if (parentKind == "navbaruserdrop") {
                    this.affectedElement = { kind: "menuitem", href: path, text: label };
                    isLink = true;
                }
                else if (parentKind == "navpills") {
                    this.affectedElement = { kind: "navpillsitem", href: path, text: label };
                    isLink = true;
                }
                else if (parentKind == "ul") {
                    this.affectedElement = { kind: "li", href: path, text: label, showActive: "exact" };
                }
                else {
                    this.affectedElement = { kind: "a", href: path, text: label };
                }
                this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                this.elementAdded = true;
            };
            DropCommandFactory.prototype.createForApp = function () {
                var name = this.source.name.toLowerCase();
                var parentKind = this.dropLocation.parent.kind;
                var text = this.source.name;
                if (parentKind == "ul") {
                    this.affectedElement = { kind: "li", href: "/" + name, children: [{ kind: "a", text: text }] };
                }
                else {
                    this.affectedElement = { kind: "a", href: "/" + name, text: text };
                }
                this.command = new IDE.ToolDropCommand(this.dropLocation, this.affectedElement);
                this.elementAdded = true;
            };
            return DropCommandFactory;
        })();
        IDE.DropCommandFactory = DropCommandFactory;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Clipboard = (function () {
            function Clipboard() {
                this.maxSize = 10;
                this.elements = [];
            }
            Clipboard.prototype.add = function (element) {
                if (this.elements.length >= this.maxSize) {
                    this.elements.pop();
                }
                this.elements.unshift(element);
            };
            Clipboard.prototype.clear = function () {
                this.elements = [];
            };
            Clipboard.prototype.get = function (index) {
                index = parseInt(index);
                if (index < this.elements.length) {
                    return this.elements[index];
                }
                return null;
            };
            return Clipboard;
        })();
        IDE.Clipboard = Clipboard;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Util;
        (function (Util) {
            var DeployPackageBuilder = (function () {
                function DeployPackageBuilder(options) {
                    if (options) {
                        this.siteMapUrl = options.siteMapUrl;
                    }
                }
                DeployPackageBuilder.prototype.build = function () {
                    var list = [];
                    var self = this;
                    IDE.Ide.sourceApp.volume.root.forEachFolder(function (folder) {
                        if (folder.name == "apps") {
                            self.exportApps(folder, list);
                        }
                        else {
                            Retool.App.exportFolder(folder, list);
                        }
                    });
                    var models = [];
                    var controllers = [];
                    var emails = [];
                    var reports = [];
                    var clientAppFiles = [];
                    for (var i = 0; i < list.length; i++) {
                        var file = list[i];
                        var ext = Retool.FileSystem.PathInfo.getExtension(file.id);
                        if (ext == "model") {
                            models.push(file.value);
                        }
                        else if (ext == "controller") {
                            controllers.push(file.value);
                        }
                        else if (ext == "email") {
                            emails.push(file.value);
                        }
                        else if (ext == "report") {
                            reports.push(file.value);
                        }
                        var appFileContent;
                        if (ext == "controller" || ext == "model") {
                            appFileContent = this.removeSourceCode(file.value);
                        }
                        else {
                            appFileContent = file.value;
                        }
                        clientAppFiles.push({ id: file.id, value: appFileContent });
                    }
                    var pkg = {
                        "packages": {}
                    };
                    var appPkg = {
                        assets: [
                            {
                                "id": "app.js",
                                "content": "Retool.loadApplication(" + IDE.DesignerTools.stringifyCompressed(clientAppFiles) + ");"
                            },
                            {
                                "id": "models.js.private",
                                "content": JSON.stringify(models)
                            },
                            {
                                "id": "controllers.js.private",
                                "content": JSON.stringify(controllers)
                            },
                            {
                                "id": "emails.js.private",
                                "content": JSON.stringify(emails)
                            },
                            {
                                "id": "reports.js.private",
                                "content": JSON.stringify(reports)
                            }
                        ]
                    };
                    var cssFile = IDE.Ide.sourceApp.getFile("css/site.css");
                    if (cssFile) {
                        appPkg.assets.push({ id: "app.css", content: cssFile.getContent().css });
                    }
                    pkg.packages["app"] = appPkg;
                    var staticPagesBuilder = new IDE.StaticPagesPackageBuilder();
                    staticPagesBuilder.siteMapBaseUrl = this.siteMapUrl;
                    var staticPagesPkg = staticPagesBuilder.build();
                    pkg.packages["static_pages"] = staticPagesPkg;
                    return pkg;
                };
                DeployPackageBuilder.prototype.removeSourceCode = function (content) {
                    if (content) {
                        var newContent = {};
                        for (var key in content) {
                            if (key != "source_code") {
                                newContent[key] = content[key];
                            }
                        }
                        return newContent;
                    }
                    return null;
                };
                DeployPackageBuilder.prototype.exportApps = function (appsFolder, list) {
                    appsFolder.forEachFolder(function (folder) {
                        Retool.App.exportFolder(folder, list);
                    });
                };
                DeployPackageBuilder.prototype.exportSite = function () {
                    var list = [];
                    IDE.Ide.sourceApp.volume.root.forEachFolder(function (folder) {
                        Retool.App.exportFolder(folder, list);
                    });
                    return list;
                };
                DeployPackageBuilder.prototype.send = function (options) {
                    var request = new Retool.Request({ type: "schema" });
                    request.add({ className: "Util", method: "deploy", args: options, success: function (response) {
                        if (options.success) {
                            options.success(response);
                        }
                    }, error: function (response) {
                        if (options.error) {
                            options.error(response);
                        }
                    }, exception: function (response) {
                        if (options.error) {
                            options.error(response);
                        }
                        else {
                            Retool.displayException(Retool.VM.VMError.fromResponse(response));
                        }
                    } });
                    request.execute();
                };
                return DeployPackageBuilder;
            })();
            Util.DeployPackageBuilder = DeployPackageBuilder;
        })(Util = IDE.Util || (IDE.Util = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var StaticPagesPackageBuilder = (function () {
            function StaticPagesPackageBuilder() {
            }
            StaticPagesPackageBuilder.prototype.build = function () {
                var app;
                var folder = app.getFolder("/apps/website/views/pages");
                var appRoute = "website/pages/";
                var assets = [];
                var self = this;
                var urlList = [];
                if (folder) {
                    folder.forEachFile(function (file) {
                        var ext = Retool.FileSystem.PathInfo.getExtension(file.name);
                        if (ext == "view" && file.name[0] != "_") {
                            var viewName = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(file.name);
                            var url = Retool.Url.domain(Retool.App.FRONTEND_DOMAIN).href(appRoute + viewName);
                            var html = self.renderPage(url);
                            assets.push({ id: viewName + ".html", content: html });
                            urlList.push(viewName);
                        }
                    });
                }
                var siteMap = this.buildSiteMap(urlList);
                assets.push({ id: "sitemap.xml", content: siteMap });
                var pkg = {
                    assets: assets
                };
                return pkg;
            };
            StaticPagesPackageBuilder.prototype.renderPage = function (url) {
                /*
                var viewMap = getTemplate(url.controllerPath + "/" + url.action);
                var controller = createController(url);
                controller.view = viewMap;
    
                var writer = new Writer();
                writer.staticPageMode = true;
                var root = writer.createRootComponent({element:controller.view.wrapper,controller:controller,viewEvents:VM.ViewEvents.createForView(viewMap.sourceFile,controller)});
                writer.render(root);
                var viewContent = writer.getStream();
    
                var layoutTemplate = getLayoutForUrl(url);
                var layoutRenderer = new LayoutRenderer(mainViewContainer);
                return this.renderLayout(layoutTemplate,viewContent,viewMap.definition);
                */
                return null;
            };
            StaticPagesPackageBuilder.prototype.renderLayout = function (layoutTemplate, layoutContent, view) {
                var w = new Retool.Writer();
                w.staticPageMode = true;
                var templateViewModel = new Retool.ViewModel(null, null);
                w.write('<html xmlns=\"http://www.w3.org/1999/xhtml\"><head>');
                var title = (view.title || view.name);
                w.write('<title>').text(title).write('</title>');
                w.write('</head><body>');
                var context = new Retool.RenderingContext(null, templateViewModel, null, null);
                var root = w.createRootComponent({ element: layoutTemplate.wrapper, context: context });
                w.component = root;
                w.component.children = [];
                w.component.id = "t";
                w.renderChildren();
                w.write('</body></html>');
                return w.getStream();
            };
            StaticPagesPackageBuilder.prototype.buildSiteMap = function (urlList) {
                var lastMod = new Date().toISOString();
                var changeFreq = "daily";
                var baseUrl = this.siteMapBaseUrl;
                if (baseUrl.length && baseUrl[baseUrl.length - 1] != "/") {
                    baseUrl += "/";
                }
                var w = new Retool.Writer();
                w.write('<?xml version="1.0" encoding="UTF-8"?>');
                w.write('<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">');
                for (var i = 0; i < urlList.length; i++) {
                    var viewName = urlList[i];
                    w.write('<url>');
                    var loc = (viewName == "index") ? baseUrl : baseUrl + viewName;
                    w.write('<loc>').text(loc).write('</loc>');
                    w.write('<lastmod>').text(lastMod).write('</lastmod>');
                    w.write('<changefreq>').text(changeFreq).write('</changefreq>');
                    w.write('</url>');
                }
                w.write('</urlset>');
                return w.getStream();
            };
            return StaticPagesPackageBuilder;
        })();
        IDE.StaticPagesPackageBuilder = StaticPagesPackageBuilder;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var FileSaveQueue = (function () {
            function FileSaveQueue() {
                this.files = {};
                this.queueDelay = 5000;
            }
            FileSaveQueue.prototype.add = function (file) {
                var filename = file.getFullName();
                this.files[filename] = file;
                this.hasFiles = true;
                // if first file start the timer
                if (!this.timer) {
                    this.startTimer();
                }
            };
            FileSaveQueue.prototype.addFiles = function (files) {
                for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    var filename = file.getFullName();
                    this.files[filename] = file;
                }
                this.hasFiles = true;
                if (!this.timer) {
                    this.startTimer();
                }
            };
            FileSaveQueue.prototype.startTimer = function () {
                var self = this;
                this.timer = setTimeout(function () {
                    self.timer = null;
                    self.writeQueue();
                }, this.queueDelay);
            };
            FileSaveQueue.prototype.deleteFile = function (file) {
                if (this.timer) {
                    clearTimeout(this.timer);
                }
                if (!this.filesToDelete) {
                    this.filesToDelete = {};
                }
                var filename = file.getFullName();
                delete this.files[filename];
                this.filesToDelete[filename] = file;
                this.hasFiles = true;
                this.writeQueue();
            };
            FileSaveQueue.prototype.deleteFiles = function (files) {
                if (this.timer) {
                    clearTimeout(this.timer);
                }
                if (!this.filesToDelete) {
                    this.filesToDelete = {};
                }
                for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    var filename = file.getFullName();
                    delete this.files[filename];
                    this.filesToDelete[filename] = file;
                }
                this.hasFiles = true;
                this.writeQueue();
            };
            FileSaveQueue.prototype.flush = function (callback) {
                if (this.hasFiles) {
                    var options = {};
                    if (callback) {
                        options.success = function () {
                            callback(null);
                        };
                    }
                    this.writeQueue(options);
                    return;
                }
                if (callback) {
                    callback(null);
                }
            };
            FileSaveQueue.prototype.writeQueue = function (options) {
                if (this.timer) {
                    clearTimeout(this.timer);
                }
                IDE.activeDesigner.fileSaveQueue = new FileSaveQueue(); // any future adds go to a new queue
                // write requests
                var request = this.createRequest();
                var requestOptions = {};
                if (options) {
                    requestOptions.done = options.success;
                }
                request.execute(requestOptions);
            };
            FileSaveQueue.prototype.createRequest = function () {
                var request = new Retool.Request({ type: "schema" });
                var self = this;
                for (var key in this.files) {
                    var file = this.files[key];
                    var args = { "name": file.getFullName(), "content": IDE.DesignerTools.compress(file.getContent()) };
                    request.add({ className: "ProjectFiles", method: "update", args: args, success: function (data) {
                    }, error: function (data) {
                        self.handleError("save", file.getFullName(), data);
                    } });
                }
                if (this.filesToDelete) {
                    for (var key in this.filesToDelete) {
                        var file = this.filesToDelete[key];
                        IDE.Ide.sourceApp.removeFile(file);
                        request.add({ className: "ProjectFiles", method: "destroy", args: { "name": file.getFullName() }, success: function (data) {
                        }, error: function (data) {
                            self.handleError("delete", file.getFullName(), data);
                        } });
                    }
                }
                return request;
            };
            FileSaveQueue.prototype.handleError = function (action, filename, err) {
                if (err.name == "requires_ide_permissions") {
                    IDE.Ide.displayError("Unable to " + action + " file:" + filename + ", you are not currently signed in");
                }
                else {
                    var msg;
                    if (err.error) {
                        err = err.error;
                    }
                    if (err.messages && err.messages.length) {
                        msg = err.messages[0];
                    }
                    else {
                        msg = err;
                    }
                    IDE.Ide.displayError("Unable to " + action + " file:" + filename + ", " + msg);
                }
            };
            FileSaveQueue.prototype.mergeQueue = function () {
                if (this.timer) {
                    clearTimeout(this.timer);
                }
                IDE.activeDesigner.fileSaveQueue = new FileSaveQueue(); // any future adds go to a new queue
                var request = this.createRequest();
                return request;
            };
            return FileSaveQueue;
        })();
        IDE.FileSaveQueue = FileSaveQueue;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ImportUtils = (function () {
            function ImportUtils() {
            }
            ImportUtils.importFilePkg = function (options) {
                var content = options.content;
                if (!content || !content.root) {
                    options.error("Not a file package.");
                    return;
                }
                var fullPath = content.root;
                var app;
                var existingFolder = app.getFolder(fullPath);
                if (existingFolder) {
                    if (!options.overwrite) {
                        options.error('Cannot import, folder: **' + fullPath + "** already exists");
                        return;
                    }
                }
                else {
                    var newFolder = app.volume.createFolder(fullPath);
                }
                var savedFileList = ImportUtils.importFiles(content.files, options.overwrite);
                options.success(savedFileList);
            };
            ImportUtils.importFiles = function (files, overwrite) {
                var filesToSave = [];
                for (var i = 0; i < files.length; i++) {
                    var pkgFile = files[i];
                    var file = new Retool.FileSystem.File(pkgFile.id, pkgFile.value);
                    filesToSave.push(file);
                }
                var app;
                IDE.activeDesigner.saveFileBatch(filesToSave);
                for (var i = 0; i < filesToSave.length; i++) {
                    var newFile = filesToSave[i];
                    app.addFile(newFile, overwrite);
                    console.log("Creating " + newFile.path + "/" + newFile.name + " ...");
                }
                return filesToSave;
            };
            ImportUtils.importFilePkgFromUrl = function (params) {
                ImportUtils.getFile({ url: params.url, success: function (data) {
                    var json = JSON.stringify(data);
                    var replaced = ImportUtils.replace(json, "*|AppName|*", params.siteName);
                    var content = JSON.parse(replaced);
                    var overwrite = false;
                    if (content.root && content.root == "shared") {
                        overwrite = true;
                    }
                    ImportUtils.importFilePkg({ content: content, success: function () {
                        params.success();
                    }, error: function (err) {
                        params.error(err);
                    }, overwrite: overwrite });
                }, error: function (err) {
                    params.error(err);
                } });
            };
            ImportUtils.replace = function (source, search, replace) {
                var regExp = new RegExp(search.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"), "g");
                return source.replace(regExp, replace);
            };
            ImportUtils.initSite = function (params) {
                var files = new ImportFileList();
                //files.add("shared.js");
                files.add("apps-website.js");
                files.add("apps-common.js");
                files.add("apps-bug.js");
                files.import(params);
            };
            ImportUtils.getFile = function (params) {
                var settings = {
                    "type": "GET",
                    "url": params.url,
                    "dataType": 'json',
                    "contentType": params.contentType,
                    crossDomain: true,
                    processData: false,
                    cache: false,
                    success: function (data, a, xhr) {
                        params.success(data);
                    },
                    error: function (xhr, b, c) {
                        var msg = b + " " + c;
                        params.error(msg);
                    }
                };
                $.ajax(settings);
            };
            return ImportUtils;
        })();
        IDE.ImportUtils = ImportUtils;
        var ImportFileList = (function () {
            function ImportFileList() {
                this._files = [];
                this.current = 0;
            }
            ImportFileList.prototype.add = function (filename) {
                this._files.push(filename);
            };
            ImportFileList.prototype.import = function (params) {
                var staticPath = "";
                if (this.current < this._files.length) {
                    var file = this._files[this.current];
                    var url = staticPath + "/apps/" + file;
                    var self = this;
                    ImportUtils.importFilePkgFromUrl({ url: url, siteName: params.siteName, success: function () {
                        self.current++;
                        self.import(params);
                    }, error: function (err) {
                        alert(err);
                    } });
                }
                else {
                    params.success();
                }
            };
            return ImportFileList;
        })();
        IDE.ImportFileList = ImportFileList;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Testing = (function (_super) {
            __extends(Testing, _super);
            function Testing() {
                _super.call(this, null);
            }
            Testing.getTestFile = function (file) {
                var name = Testing.getTestFileName(file);
                if (name) {
                    return IDE.Ide.sourceApp.getFile(name);
                }
                return null;
            };
            Testing.getOrCreateTestFile = function (file) {
                var testFile = Testing.getTestFile(file);
                if (testFile) {
                    return testFile;
                }
                var testFilename = Testing.getTestFileName(file);
                var app;
                if (testFilename) {
                    testFile = new Retool.FileSystem.File(testFilename, { source_code: "" });
                    app.addFile(testFile);
                    return testFile;
                }
                return null;
            };
            Testing.getTestFileName = function (file) {
                var name = file.getFullName();
                if (name.length > 4 && name.substr(0, 5) == "apps/") {
                    return "tests/" + name.substr(5);
                }
                return null;
            };
            Testing.runControllerTests = function (filename, done) {
                var request = new Retool.Request("data");
                request.add({ className: "TestRuninner", method: "call", args: { filename: filename }, success: function (data) {
                    done(null, data);
                }, error: function (err) {
                    done(err);
                } });
                request.execute();
            };
            Testing.prototype.vm_runController = function (params) {
                var section = IDE.activeDesigner.footer.getSection("controller-test");
                var sourceFile = section.sourceFile;
                params.args = [sourceFile.getFullName()];
                this.vm_run(params);
            };
            Testing.prototype.vm_run = function (params) {
                var filename = params.args[0];
                var async = params.proc.pause();
                $('#rto-explorer .rto-test-fixture-results').html('Running tests ...');
                Testing.runControllerTests(filename, function (err, data) {
                    if (err) {
                        async.exception(err);
                    }
                    else {
                        var w = new Retool.Writer("ds");
                        if (data.before && data.before.error) {
                            w.writeTag("span", "label label-danger").text("FAIL").write('</span>');
                            w.text("Error execute before()");
                            w.writeTag("div", "test-errors");
                            for (var i = 0; i < data.before.error.messages.length; i++) {
                                w.write('<p>').text(data.before.error.messages[i]).write('</p>');
                            }
                            w.write("</div>");
                        }
                        else {
                            var methods = data.methods;
                            for (var methodName in methods) {
                                var result = methods[methodName];
                                w.writeTag("div", "test");
                                if (result.status == "pass") {
                                    w.writeTag("span", "label label-success").text("PASS").write('</span>');
                                    w.text(methodName);
                                }
                                else {
                                    w.writeTag("span", "label label-danger").text("FAIL").write('</span>');
                                    w.text(methodName);
                                    w.writeTag("div", "test-errors");
                                    for (var i = 0; i < result.error.messages.length; i++) {
                                        w.write('<p>').text(result.error.messages[i]).write('</p>');
                                    }
                                    w.write("</div>");
                                }
                                w.write('</div>');
                            }
                            if (data.after && data.after.error) {
                                w.writeTag("span", "label label-danger").text("FAIL").write('</span>');
                                w.text("Error executing after()");
                                w.writeTag("div", "test-errors");
                                for (var i = 0; i < data.after.error.messages.length; i++) {
                                    w.write('<p>').text(data.after.error.messages[i]).write('</p>');
                                }
                                w.write("</div>");
                            }
                            if (data.milliseconds) {
                                w.writeTag("p", "test-time").text("Total run time: " + data.milliseconds + " ms").write('</p>');
                            }
                        }
                        $('#rto-explorer .rto-test-fixture-results').html(w.getStream());
                        async.resume(data);
                    }
                });
            };
            return Testing;
        })(Retool.VM.ObjectBase);
        IDE.Testing = Testing;
        Retool.VM.addType("Testing", null, new Testing());
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var TutorialContainer = (function (_super) {
            __extends(TutorialContainer, _super);
            function TutorialContainer() {
                _super.apply(this, arguments);
            }
            TutorialContainer.prototype.initialize = function () {
                var w = new Retool.Writer();
                w.writeTag("div", null, { id: "tutorial", style: "display:none" });
                w.writeTag("a", "close container-close", { href: "#" }).write('&times;</a>');
                w.writeTag("div", null, { id: "layout-" + this.id }).writeTag("div", null, { id: "content-" + this.id }).write('</div></div>');
                w.write("</div>");
                var self = this;
                w.appendToElement('body');
                $('#retool-tutorial' + self.id).on('click', '.container-close', function (event) {
                    event.preventDefault();
                });
                w = new Retool.Writer();
                w.writeTag("div", null, { id: "targeter", style: "display:none" }).write('</div>');
                w.appendToElement('body');
                this.attachEvents();
            };
            TutorialContainer.prototype.onactivate = function () {
                var container = $('#retool-tutorial');
                container.show();
            };
            TutorialContainer.prototype.onMouseMove = function (e) {
                var item = $(document.elementFromPoint(e.clientX, e.clientY)).closest("li").get(0);
                if (item) {
                    var container = Retool.App.canvases.get("t");
                    var component = container.getComponent(item.id);
                    if (component && component.attr.tourtext) {
                        this.showTargeter(component.attr.tourtext);
                        return;
                    }
                }
                this.hideTargeter();
            };
            TutorialContainer.prototype.showTargeter = function (selector) {
                if (selector == this.currentTargeter) {
                    return;
                }
                var pageItem = $(selector);
                if (pageItem.length) {
                    var pos = pageItem.offset();
                    var width = pageItem.outerWidth();
                    var height = pageItem.outerHeight();
                    if (height < 2) {
                        height = 2;
                    }
                    var self = this;
                    if (width) {
                        var left = pos.left;
                        var top = pos.top;
                        if (height < 40) {
                            top = top - (40 - height) / 2;
                        }
                        /*
                        if (width > 40){
                            left += (width-40)/2;
                        }
                        */
                        $('#retool-targeter').css('top', top - 10).css('left', left - 10).css('width', 60).css('height', 60).show();
                        if (!this.targeterTimer) {
                            this.targeterTimer = setInterval(function () {
                                self.flicker();
                            }, 300);
                        }
                        this.currentTargeter = selector;
                        return;
                    }
                }
                this.hideTargeter();
            };
            TutorialContainer.prototype.flicker = function () {
                this.flickerOn = !this.flickerOn;
                if (this.flickerOn) {
                    $('#retool-targeter').addClass("targeter-big");
                    $('#retool-targeter').show();
                    this.bigTargeter = !this.bigTargeter;
                }
                else {
                    $('#retool-targeter').removeClass("targeter-big");
                }
            };
            TutorialContainer.prototype.hideTargeter = function () {
                $('#retool-targeter').hide();
                if (this.targeterTimer) {
                    clearInterval(this.targeterTimer);
                    this.targeterTimer = null;
                }
                this.flickerOn = false;
                this.currentTargeter = null;
            };
            TutorialContainer.prototype.attachEvents = function () {
                var explorer = $('#retool-tutorial');
                var self = this;
                explorer.on("click", "[id^='rt-']", function (event) {
                    if (event.shiftKey) {
                        event.preventDefault();
                        Retool.raise(this, "onshiftclick", event);
                    }
                    else {
                        Retool.raise(this, "onclick", event);
                    }
                });
                explorer.on("blur", "[id^='rt-']", function (event) {
                    Retool.raise(this, "onblur", event);
                });
                explorer.on("focus", "[id^='rt-']", function (event) {
                    Retool.raise(this, "onfocus", event);
                });
                explorer.on("keypress", "[id^='rt-']", function (event) {
                    Retool.raise(this, "onkeypress", event);
                });
                explorer.on("keydown", "[id^='rt-']", function (event) {
                    Retool.raise(this, "onkeydown", event);
                });
                explorer.on("keyup", "[id^='rt-']", function (event) {
                    Retool.raise(this, "onkeyup", event);
                });
                explorer.on("change", "[id^='rt-']", function (event) {
                    Retool.raise(this, "onchange", event);
                });
                explorer.on('click', function (event) {
                    Retool.hideDropLists();
                });
                explorer.on("click", '.alert .close', function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    $(this).closest('.alert').remove();
                });
                explorer.on("click", '[data-toggle-class]', function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    var className = $(this).data('toggle-class');
                    $(this).closest('[data-toggle-target]').toggleClass(className);
                });
                explorer.on('focus', '[data-clickonfocus]', function (event) {
                    this.click();
                });
                explorer.on('mousemove', function (e) {
                    self.onMouseMove(e);
                });
                explorer.on('mouseleave', function (e) {
                    self.hideTargeter();
                });
            };
            return TutorialContainer;
        })(Retool.PageView);
        IDE.TutorialContainer = TutorialContainer;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var DragElement = (function () {
            function DragElement(options) {
                this.id = options.id;
                this.name = options.name;
                this.type = options.type;
                this.dropKind = options.dropKind;
                this.isClosing = options.isClosing;
            }
            return DragElement;
        })();
        IDE.DragElement = DragElement;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var TemplateModifier = (function () {
            function TemplateModifier() {
            }
            TemplateModifier.renameScope = function (def, oldName, newName) {
                TemplateModifier.forEachElement(def.elements, function (elem) {
                    if (elem.obj == oldName) {
                        elem.obj = newName;
                    }
                });
            };
            TemplateModifier.forEachElement = function (elements, func) {
                for (var i = 0; i < elements.length; i++) {
                    var elem = elements[i];
                    func(elem);
                    if (elem.children) {
                        TemplateModifier.forEachElement(elem.children, func);
                    }
                }
            };
            TemplateModifier.findElementByRole = function (def, role) {
                return TemplateModifier.findElement(def.elements, function (elem) {
                    return elem.role == role;
                });
            };
            TemplateModifier.findElement = function (elements, match) {
                if (elements) {
                    for (var i = 0; i < elements.length; i++) {
                        var elem = elements[i];
                        if (match(elem)) {
                            return elem;
                        }
                        if (elem.children) {
                            var found = TemplateModifier.findElement(elem.children, match);
                            if (found) {
                                return found;
                            }
                        }
                    }
                }
            };
            return TemplateModifier;
        })();
        IDE.TemplateModifier = TemplateModifier;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var User = (function () {
            function User() {
            }
            return User;
        })();
        IDE.User = User;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CodeCompletePopup = (function () {
            function CodeCompletePopup(prefix) {
                this.prefix = prefix;
                this.codeCompleteFilter = "";
            }
            CodeCompletePopup.create = function (prefix, left, top) {
                var popup = new CodeCompletePopup(prefix);
                popup.show();
                popup.baseLeft = left;
                popup.baseTop = top;
                popup.positionDrop();
                return popup;
            };
            CodeCompletePopup.prototype.getDrop = function () {
                return $('#rto-code-complete');
            };
            CodeCompletePopup.prototype.positionDrop = function () {
                var left = this.baseLeft;
                var top = this.baseTop;
                var windowHeight = $(window).height();
                var drop = this.getDrop();
                drop.show();
                var dropHeight = drop.height();
                if ((top + dropHeight) > windowHeight) {
                    top = top - dropHeight - 24;
                }
                drop.css('left', left + "px").css('top', top + "px");
            };
            CodeCompletePopup.prototype.setFirstToCurrent = function () {
                var drop = this.getDrop();
                drop.find('li.rto-current').removeClass('rto-current');
                drop.find('li:visible').first().addClass('rto-current');
            };
            CodeCompletePopup.prototype.setCurrentTo = function (li) {
                var drop = this.getDrop();
                drop.find('li.rto-current').removeClass('rto-current');
                li.addClass('rto-current');
            };
            CodeCompletePopup.prototype.onkey = function (keycode) {
                var drop = this.getDrop();
                var anyVisible = drop.find('li:rto-visible').length > 0;
                if (keycode == 40) {
                    if (anyVisible) {
                        this.move(1);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                if (keycode == 38) {
                    if (anyVisible) {
                        this.move(-1);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            };
            CodeCompletePopup.prototype.move = function (increment) {
                var drop = this.getDrop();
                var ul = drop.find('ul')[0];
                if (ul.childNodes.length == 0) {
                    return;
                }
                var current = drop.find('li.rto-current');
                if (current.length) {
                    var index = current.index();
                    var newIndex = index + increment;
                    if (newIndex < 0) {
                        newIndex = 0;
                    }
                    if (newIndex > (ul.childNodes.length - 1)) {
                        newIndex = ul.childNodes.length - 1;
                    }
                    current.removeClass('rto-current');
                    if (increment > 0) {
                        var newCurrent = current.nextAll(':visible:first');
                        if (newCurrent.length == 0) {
                            newCurrent = drop.find('li:visible:last');
                        }
                    }
                    else {
                        var newCurrent = current.prevAll(':visible:first');
                        if (newCurrent.length == 0) {
                            newCurrent = drop.find('li:visible:first');
                        }
                    }
                    newCurrent.addClass('rto-current');
                    if (newCurrent.length) {
                        Retool.Page.scrollElementIntoView(newCurrent[0], drop[0]);
                    }
                }
                else if (increment > 0) {
                    var first = drop.find('li:visible').first();
                    first.addClass('rto-current');
                    Retool.Page.scrollElementIntoView(first[0], drop[0]);
                }
            };
            CodeCompletePopup.prototype.show = function () {
                if (this.prefix.length && this.prefix[this.prefix.length - 1] == ".") {
                    this.codeCompleteFilter = "";
                }
                else {
                    this.codeCompleteFilter = this.prefix;
                }
                var w = new Retool.Writer("ds");
                w.write('<div id="rto-code-complete">');
                w.write('<ul>');
                var list = this.getPropertyList();
                for (var i = 0; i < list.length; i++) {
                    var listItem = list[i];
                    w.write('<li').writeAttr("data-value", listItem.value).write('>').text(listItem.text);
                    if (listItem.parameters) {
                        w.writeTag("span", "param").text(listItem.parameters).write('</span>');
                    }
                    w.write('</li>');
                }
                w.write('</ul>');
                w.write('</div>');
                var self = this;
                $('#rto-code-complete').remove();
                w.appendToElement('body');
                if (this.codeCompleteFilter) {
                    this.applyFilter(this.codeCompleteFilter);
                }
                else {
                    this.setFirstToCurrent();
                }
                $('#rto-code-complete').on('click', 'li', function (e) {
                    self.setCurrentTo($(this));
                    self.onRowClick();
                    e.stopPropagation();
                    e.preventDefault();
                });
            };
            CodeCompletePopup.prototype.getPropertyList = function () {
                var modelDef = null; // todo: get model from somewhere
                var modelName;
                if (modelDef) {
                    modelName = modelDef.id.split('.')[1];
                    if (this.prefix == "doc.") {
                        var list = [];
                        //var modelDef = App.models.getDefinition(modelName);
                        if (modelDef) {
                            for (var fieldName in modelDef.fields) {
                                list.push({ value: fieldName, text: fieldName });
                            }
                            list.push({ value: "db", text: "db" });
                            list.sort(function (a, b) {
                                if (a.text > b.text) {
                                    return 1;
                                }
                                else if (a.text < b.text) {
                                    return -1;
                                }
                                ;
                                return 0;
                            });
                        }
                        return list;
                    }
                }
                if (this.prefix == "Retool.") {
                    list = [];
                    var allTypes = Retool.VM.getAllTypes();
                    for (var key in allTypes) {
                        list.push({ value: key, text: key });
                    }
                    return list;
                }
                else if (this.prefix == "Retool.Dialogs.") {
                    list = [];
                    list.push({ value: "confirm", text: "confirm" });
                    list.push({ value: "input", text: "input" });
                    return list;
                }
                else if (this.prefix.length && this.prefix[0] >= "A" && this.prefix[0] <= "Z") {
                    list = [];
                    list.push({ value: "CRM", text: "CRM" });
                    list.push({ value: "Retool", text: "Retool" });
                    list.push({ value: "Sales", text: "Sales" });
                    return list;
                }
                else if (this.prefix == "this.") {
                    list = [];
                    list.push({ value: "name", text: "name" });
                    list.push({ value: "phone", text: "phone" });
                    return list;
                }
                else if (this.prefix == "controller.") {
                    list = [];
                    list.push({ value: "destroy", text: "destroy" });
                    list.push({ value: "show", text: "show" });
                    return list;
                }
                else if (this.prefix.length && this.prefix.indexOf('.') == -1) {
                    list = [];
                    //  list.push({value:"if (confirm('Proceed?')){\n  // add code here\n}",text:"confirm(code)"});
                    list.push({ value: "dynamicValue", text: "dynamicValue" });
                    if (modelName) {
                        list.push({ value: modelName, text: modelName });
                    }
                    return list;
                }
                else if (this.prefix.length >= 4 && this.prefix.substr(this.prefix.length - 4) == ".db.") {
                    list = [];
                    list.push({ value: "destroy()", text: "destroy()" });
                    list.push({ value: "save()", text: "save()" });
                    return list;
                }
                else {
                    list = [];
                    list.push({ value: "indexOf", text: "indexOf" });
                    list.push({ value: "length", text: "length" });
                    return list;
                }
            };
            CodeCompletePopup.prototype.getFilter = function () {
                return this.codeCompleteFilter;
            };
            CodeCompletePopup.prototype.setFilter = function (filter) {
                this.codeCompleteFilter = filter;
                this.applyFilter(filter);
            };
            CodeCompletePopup.prototype.getCurrentValue = function () {
                var drop = this.getDrop();
                var current = drop.find('li.rto-current');
                if (current.length) {
                    return current.data('value');
                }
                else {
                    return "";
                }
            };
            CodeCompletePopup.prototype.onRowClick = function () {
                //activeDesigner.codeEditor.intellisenseClose();
            };
            CodeCompletePopup.prototype.applyFilter = function (value) {
                var drop = this.getDrop();
                var items = drop.find('li');
                value = $.trim(value).toLowerCase();
                var len = value.length;
                var visibleCount = 0;
                items.each(function () {
                    var item = $(this);
                    var text = item.data("value").toLowerCase();
                    if (text.length >= len) {
                        if (text.substr(0, len) == value) {
                            item.show();
                            visibleCount++;
                        }
                        else {
                            item.hide();
                        }
                    }
                    else {
                        item.hide();
                    }
                });
                this.setFirstToCurrent();
                if (visibleCount == 0) {
                    this.getDrop().hide();
                }
                else {
                    this.positionDrop();
                }
            };
            CodeCompletePopup.forModel = function (model, prototype) {
                var list = [];
                if (model) {
                    for (var fieldName in model.fields) {
                        list.push({ text: fieldName, value: fieldName, icon: { color: "2", symbol: "L" } });
                    }
                }
                if (prototype) {
                    list.push({ text: "count", value: "count(", parameters: "(conditions)" });
                    list.push({ text: "distinct", value: "distinct(", parameters: "(field,conditions)" });
                    list.push({ text: "find", value: "find(", parameters: "(conditions)" });
                    list.push({ text: "findById", value: "findById(", parameters: "(id,populate)" });
                    list.push({ text: "save", value: "save(", parameters: "()" });
                    list.push({ text: "findByIdAndRemove", value: "findByIdAndRemove(", parameters: "(id)" });
                    list.push({ text: "findByIdAndUpdate", value: "findByIdAndUpdate(", parameters: "(id,update)" });
                    list.push({ text: "model", value: "model(", parameters: "(data)" });
                    list.push({ text: "validate", value: "validate(", parameters: "()" });
                    list.push({ text: "beforeSave", value: "beforeSave(", parameters: "()" });
                    list.push({ text: "beforeRemove", value: "beforeRemove(", parameters: "()" });
                    list.push({ text: "create", value: "create(", parameters: "(doc)" });
                    list.push({ text: "afterSave", value: "afterSave(", parameters: "()" });
                    list.push({ text: "afterRemove", value: "afterRemove(", parameters: "()" });
                    list.push({ text: "updateFields", value: "updateFields(", parameters: "(data)" });
                    list.push({ text: "where", value: "where(", parameters: "(field)" });
                    for (var methodName in prototype.methods) {
                        var method = prototype.methods[methodName];
                        var parameters = CodeCompletePopup.buildParameterString(method);
                        list.push({ text: methodName, value: methodName + "(", parameters: parameters });
                    }
                }
                CodeCompletePopup.sort(list);
                return list;
            };
            CodeCompletePopup.forController = function (controller, prototype) {
                var list = [];
                if (prototype) {
                    for (var methodName in prototype.methods) {
                        var method = prototype.methods[methodName];
                        var parameters = CodeCompletePopup.buildParameterString(method);
                        list.push({ text: methodName, value: methodName + "(", parameters: parameters });
                    }
                }
                CodeCompletePopup.sort(list);
                return list;
            };
            CodeCompletePopup.buildParameterString = function (method) {
                var parameters = "";
                if (method.params) {
                    for (var i = 0; i < method.params.length; i++) {
                        var param = method.params[i];
                        if (parameters.length) {
                            parameters += ",";
                        }
                        parameters += param.name;
                    }
                }
                return "(" + parameters + ")";
            };
            CodeCompletePopup.forStatic = function (prefix) {
                var segments = prefix.split('.');
                if (segments.length == 1) {
                    var list = [];
                    var types = Retool.VM.getAllTypes();
                    for (var name in types) {
                        list.push({ text: name, value: name });
                    }
                    return list;
                }
                if (segments.length == 2) {
                    /*
                    var list = [];
                    var vmType = vmTypes[segments[0]];
                    if (vmType && vmType.getCodeHints){
                        list = vmType.getCodeHints();
                    }
                    var app = applicationLocator.getDefinitionForName(segments[0]);
                    if (app){
                        
                        var folder = mainVolume.getFolder("apps/" + segments[0].toLowerCase() + "/models");
                        if (folder){
                            
                            folder.forEachFile(function(file){
                                var info = file.getInfo();
                                if (info.extension == "model"){
                                    var modelDef = <IModelDefinition>file.getContent();
                                    var modelId = modelDef.id;
                                    var nameSegments = modelId.split('.');
                                    if (nameSegments.length > 0){
                                        var modelName = nameSegments[1];
                                        if (modelName){
                                            modelName = modelName[0].toUpperCase() + modelName.substr(1);
                                            list.push({text:modelName,value:modelName});
                                        }
                                        
                                    }
                                }
                            });
                            return list;
                        }
                    }
                    */
                    return list;
                }
                if (segments.length == 3) {
                    var modelFile = IDE.Ide.sourceApp.models.getFile(segments[0] + '.' + segments[1]);
                    if (modelFile) {
                        var modelDef = modelFile.getContent();
                        var modelPrototype = Retool.ViewModel.tryCompile(modelFile);
                        return CodeCompletePopup.forModel(null, modelPrototype);
                    }
                }
                return null;
            };
            CodeCompletePopup.forStaticType = function (prefix) {
                var segments = prefix.split('.');
                var typeName = segments[0];
                var type = Retool.VM.getType(typeName);
                if (!type) {
                    return null;
                }
                var staticInstance = type.staticInstance;
                if (!staticInstance)
                    return null;
                if (staticInstance.codeComplete) {
                    return staticInstance.codeComplete();
                }
                return null;
            };
            CodeCompletePopup.sort = function (list) {
                list.sort(function (a, b) {
                    if (a.text > b.text) {
                        return 1;
                    }
                    else if (a.text < b.text) {
                        return -1;
                    }
                    ;
                    return 0;
                });
            };
            return CodeCompletePopup;
        })();
        IDE.CodeCompletePopup = CodeCompletePopup;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CodeCompleteListBuilder = (function (_super) {
            __extends(CodeCompleteListBuilder, _super);
            function CodeCompleteListBuilder() {
                _super.call(this, null);
            }
            CodeCompleteListBuilder.prototype.getNonPrefixList = function () {
                var list = [];
                list.push("this");
                list.push("Page");
                list.push("Number");
                list.push("String");
                list.push("Date");
                list.push("Math");
                list.sort();
                var out = [];
                for (var i = 0; i < list.length; i++) {
                    out.push({ text: list[i] });
                }
                return out;
            };
            CodeCompleteListBuilder.prototype.compileExpression = function (expression) {
                var exprClass = IDE.JavascriptCompiler.compileClass("", "function e(){return " + expression + ";}");
                return exprClass.methods["e"];
            };
            CodeCompleteListBuilder.prototype.addCodeCompleteToStaticType = function (obj) {
                if (obj._getHints)
                    return;
                var out = [];
                var names = Object.getOwnPropertyNames(obj);
                names.sort();
                for (var i = 0; i < names.length; i++) {
                    if (names[i][0] != "_") {
                        if (obj[names[i]] instanceof Function) {
                            out.push({ text: names[i], parameters: "()" });
                        }
                        else {
                            out.push({ text: names[i] });
                        }
                    }
                }
                obj._getHints = function (hints) {
                    return out;
                };
            };
            CodeCompleteListBuilder.prototype.buildForVMStatics = function () {
                var types = Retool.VM.getAllTypes();
                for (var key in types) {
                    var s = types[key];
                    if (s.staticInstance) {
                        this.addCodeCompleteToStaticType(s.staticInstance);
                    }
                }
            };
            return CodeCompleteListBuilder;
        })(Retool.VM.ObjectBase);
        IDE.CodeCompleteListBuilder = CodeCompleteListBuilder;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var TemplateCodeComplete = (function (_super) {
            __extends(TemplateCodeComplete, _super);
            function TemplateCodeComplete() {
                _super.apply(this, arguments);
            }
            TemplateCodeComplete.prototype.getHints = function (template, prefix, sourceCode) {
                this.template = template;
                this.sourceCode = sourceCode;
                var self = this;
                if (prefix && prefix[prefix.length - 1] == ".") {
                    prefix = prefix.substr(0, prefix.length - 1); // remove trailing .
                    var target;
                    try {
                        var canvas = IDE.Ide.getAppCanvas();
                        var method = this.compileExpression(prefix);
                        if (!method)
                            return null;
                        var proc = Retool.VM.createProcess(canvas);
                        proc.sync = true;
                        proc.isCodeComplete = true;
                        var c = new Retool.ViewModel(canvas, template);
                        c._getHints = function () {
                            return self.codeComplete();
                        };
                        target = proc.start({ target: c, methodInfo: method });
                    }
                    catch (e) {
                        return null;
                    }
                    if (target && target._getHints) {
                        var hints = new IDE.HintList(target._getHints());
                        return hints.toArray();
                    }
                    return null;
                }
                else {
                    return this.getNonPrefixList();
                }
            };
            TemplateCodeComplete.prototype.codeComplete = function () {
                this.compiled = this.compileTemplateCode(this.sourceCode);
                var hints = new IDE.TemplateHints(this.template, this.compiled);
                return hints.get();
            };
            TemplateCodeComplete.prototype.compileTemplateCode = function (sourceCode) {
                var compiledCode;
                try {
                    if (sourceCode) {
                        var compileOptions = {};
                        var program = Retool.App.ide.compileProgram(sourceCode, compileOptions);
                        compiledCode = program.getPrototype();
                    }
                }
                catch (e) {
                }
                return compiledCode;
            };
            TemplateCodeComplete.prototype.getNonPrefixList = function () {
                var list = _super.prototype.getNonPrefixList.call(this);
                list.push({ text: "$$app" });
                list.push({ text: "$$main" });
                list.push({ text: "$$modal" });
                list.push({ text: "$$target" });
                list.push({ text: "$$this" });
                list.push({ text: "Api" });
                list.push({ text: "Models" });
                return list;
            };
            return TemplateCodeComplete;
        })(IDE.CodeCompleteListBuilder);
        IDE.TemplateCodeComplete = TemplateCodeComplete;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var HintList = (function () {
            function HintList(items) {
                this.items = items || [];
            }
            HintList.prototype.add = function (item) {
                this.items.push(item);
            };
            HintList.prototype.sortCompare = function (a, b) {
                var ta = a.text.toLowerCase();
                var tb = b.text.toLowerCase();
                if (ta[0] == "$" && tb[0] != "$")
                    return 1;
                if (ta[0] != "$" && tb[0] == "$")
                    return -1;
                if (ta > tb)
                    return 1;
                if (ta < tb)
                    return -1;
                return 0;
            };
            HintList.prototype.sort = function () {
                this.items.sort(this.sortCompare);
            };
            HintList.prototype.concat = function (list) {
                this.items = this.items.concat(list.items);
            };
            HintList.prototype.toArray = function () {
                // first pre-process any
                var items = this.items;
                var out = new HintList();
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    if (item.include) {
                        if (item.include == "models") {
                            out.addModels();
                        }
                        else if (item.include == "api") {
                            out.addControllers();
                        }
                    }
                    else {
                        out.add(item);
                    }
                }
                out.sort();
                return out.items;
            };
            HintList.prototype.addModels = function () {
                var folder = IDE.Ide.sourceApp.getFolder("models");
                var self = this;
                var icon = IDE.FileIcons.Model;
                if (folder) {
                    folder.forEachFile(function (file) {
                        var def = file.getContent();
                        self.add({ text: def.name, icon: icon });
                    }, { sorted: true });
                }
            };
            HintList.prototype.addControllers = function () {
                var folder = IDE.Ide.sourceApp.getFolder("api");
                var self = this;
                var icon = IDE.FileIcons.Api;
                if (folder) {
                    folder.forEachFile(function (file) {
                        var def = file.getContent();
                        self.add({ text: def.name, icon: icon });
                    }, { sorted: true });
                }
            };
            HintList.getMethods = function (sourceCode, options) {
                var list = [];
                options = options || {};
                var program = Retool.App.ide.compileProgram(sourceCode, {});
                var proto = program.getPrototype();
                var includePrivate = options.includePrivate;
                if (proto) {
                    for (var methodName in proto.methods) {
                        if (includePrivate || methodName[0] != "_") {
                            var method = proto.methods[methodName];
                            var plist = "";
                            if (method.params) {
                                var p = [];
                                for (var i = 0; i < method.params.length; i++) {
                                    p.push(method.params[i].name);
                                }
                                plist = p.join(',');
                            }
                            list.push({ text: methodName, parameters: "(" + plist + ")" });
                        }
                    }
                }
                return list;
            };
            return HintList;
        })();
        IDE.HintList = HintList;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var TemplateHints = (function () {
            function TemplateHints(template, compiled) {
                this.template = template;
                this.compiled = compiled;
            }
            TemplateHints.prototype.get = function () {
                var hints = this.getCodeItems();
                this.addElements(hints);
                return hints.toArray();
            };
            TemplateHints.prototype.addElements = function (hints) {
                var def = this.template.definition;
                var map = {};
                if (def.elements) {
                    for (var i = 0; i < def.elements.length; i++) {
                        var elem = def.elements[i];
                        this.addElementNames(elem, map);
                    }
                }
                for (var key in map) {
                    hints.add({ text: "$" + key, className: "cc-element" });
                }
            };
            TemplateHints.prototype.addElementNames = function (elem, map) {
                if (elem.name) {
                    map[elem.name] = 1;
                }
                if (elem.children) {
                    for (var i = 0; i < elem.children.length; i++) {
                        this.addElementNames(elem.children[i], map);
                    }
                }
            };
            TemplateHints.prototype.getCodeItems = function () {
                var list = new IDE.HintList();
                list.add({ text: "app" });
                list.add({ text: "params" });
                if (!this.compiled)
                    return list;
                var map = {};
                for (var methodName in this.compiled.methods) {
                    list.add({ text: methodName, parameters: "()" });
                    var method = this.compiled.methods[methodName];
                    this.addThisSetProperties(method, map);
                }
                if (this.compiled.constructorMethod) {
                    this.addThisSetProperties(this.compiled.constructorMethod, map);
                }
                for (var key in map) {
                    list.add({ text: key });
                }
                list.sort();
                return list;
            };
            TemplateHints.prototype.addThisSetProperties = function (method, map) {
                var instructions = method.instructions;
                for (var i = 0; i < instructions.length; i++) {
                    var op = instructions[i];
                    if (op.opcode == "stthisprop") {
                        map[op.name] = 1;
                    }
                }
            };
            return TemplateHints;
        })();
        IDE.TemplateHints = TemplateHints;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var ToolRenderer = (function () {
                function ToolRenderer() {
                }
                ToolRenderer.prototype.renderTool = function (w, options) {
                    var attrib = { "data-rto-kind": options.dropKind, "data-rto-name": options.name, "data-rto-type": options.type };
                    w.writeTag("li", (options.expandable) ? "expandable" : null, attrib);
                    if (options.expandable) {
                        w.writeTag("div", "pip").write('<a href="#"></a></div>');
                    }
                    var attribs = (options.dropKind) ? { draggable: true } : null;
                    var css = "toolbox-item";
                    if (options.css) {
                        css += " " + options.css;
                    }
                    w.writeTag("div", css, attribs);
                    if (options.icon) {
                        w.writeTag("span", "glyph " + options.icon.font + ' color' + options.icon.color).write(options.icon.glyph).write("</span>");
                    }
                    if (options.renderContent) {
                        options.renderContent(w);
                    }
                    else {
                        w.text(options.text);
                        if (options.subText) {
                            w.writeTag("span", "sub-text").text(options.subText).write('</span>');
                        }
                    }
                    w.write('</div>');
                    w.write('</li>');
                };
                ToolRenderer.prototype.attachDragEvents = function (elem) {
                    if (elem.attr("draggable")) {
                        elem.bind('dragstart', IDE.activeDesigner.elementDragStart).bind('dragend', IDE.activeDesigner.elementDragEnd);
                    }
                    elem.find('[draggable]').bind('dragstart', IDE.activeDesigner.elementDragStart).bind('dragend', IDE.activeDesigner.elementDragEnd);
                };
                ToolRenderer.prototype.buildMenu = function (w, dropmenu) {
                    w.writeTag("div", "dropdown app-drop");
                    w.writeTag("a", "btn-app-drop ", { href: "#", "data-action": "dropdown" }).writeTag("span", "glyph toolbox").text("3").write('</span></a>');
                    w.writeTag("div", "dropdown-menu pull-right");
                    for (var i = 0; i < dropmenu.length; i++) {
                        var menuItem = dropmenu[i];
                        w.writeTag("div", null).writeTag("a", null, { href: "#", "data-action": menuItem.name }).text(menuItem.text).write("</a></div>");
                    }
                    w.write("</div>");
                    w.write("</div>");
                };
                return ToolRenderer;
            })();
            Toolbox.ToolRenderer = ToolRenderer;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var Folder = (function (_super) {
                __extends(Folder, _super);
                function Folder(name, text) {
                    _super.call(this);
                    this.nativeTypes = {
                        "/": { type: "template", dropKind: "helper", icon: IDE.FileIcons.Template },
                        "admin": { type: "template", dropKind: "helper", icon: IDE.FileIcons.Template },
                        "frontend": { type: "template", dropKind: "helper", icon: IDE.FileIcons.Template },
                        "components": { type: "component", dropKind: "helper", icon: IDE.FileIcons.Component }
                    };
                    this.protectedFolders = {
                        "models": Toolbox.ModelsFolder,
                        "api": Toolbox.ControllersFolder
                    };
                    this.folderActions = {
                        "/": [{ text: "+ new file", type: "add-file", name: "", dropKind: null, css: "add-button" }],
                        "admin/*": [{ text: "+ new template", type: "add-template", name: "", dropKind: null, css: "add-button" }],
                        "frontend/*": [{ text: "+ new template", type: "add-template", name: "", dropKind: null, css: "add-button" }],
                        "components/*": [{ text: "+ new component", type: "add-component", name: "", dropKind: null, css: "add-button" }],
                        "assets/css/*": [{ text: "+ upload file", type: "upload-asset", name: "", css: "add-button" }, { text: "+ new file", type: "add-file", name: "", dropKind: null, css: "add-button" }],
                        "assets/fonts/*": [{ text: "+ upload file", type: "upload-asset", name: "", css: "add-button" }],
                        "assets/images/*": [{ text: "+ upload file", type: "upload-asset", name: "", css: "add-button" }],
                        "assets/js/*": [{ text: "+ upload file", type: "upload-asset", name: "", css: "add-button" }, { text: "+ new file", type: "add-file", name: "", dropKind: null, css: "add-button" }],
                        "content/*": [{ text: "+ new file", type: "add-file", name: "", dropKind: null, css: "add-button" }]
                    };
                    this.name = name;
                    this.id = name.replace(/\//g, '___');
                    this.text = text;
                    if (!this.name) {
                        this.root = "/";
                    }
                    else {
                        var segments = this.name.split("/");
                        this.root = segments[0];
                    }
                }
                Folder.prototype.init = function () {
                };
                Folder.prototype.renderHeader = function (w) {
                    var match = this.name + "/";
                    for (var key in this.folderActions) {
                        var i = key.indexOf("*");
                        var include;
                        if (i == -1) {
                            include = (key == match);
                        }
                        else {
                            include = (key.substr(0, key.length - 1) == match.substr(0, key.length - 1));
                        }
                        if (include) {
                            var actions = this.folderActions[key];
                            if (actions) {
                                for (var j = 0; j < actions.length; j++) {
                                    var action = actions[j];
                                    action.name = this.name;
                                    this.renderTool(w, action);
                                }
                            }
                        }
                    }
                    /*
                    var actions = this.folderActions[this.root];
                    if (actions){
                        for(var i = 0; i < actions.length; i++){
                            var action = actions[i];
                            action.name = this.name;
                            this.renderTool(w,action);
                        }
                    }
                    else {
                        this.renderTool(w,{text:"+ new file",type:"add-file",name:this.name,dropKind:null,css:"add-button"})
                    }
                    */
                };
                Folder.prototype.renderFile = function (w, file) {
                    if (file.getIsNative()) {
                        var type = this.nativeTypes[this.root];
                        var name = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(file.name);
                        var options = { text: name, name: file.getFullName() };
                        if (type) {
                            options.type = type.type;
                            options.dropKind = type.dropKind;
                            options.icon = type.icon;
                        }
                        this.renderTool(w, options);
                    }
                    else {
                        var ext = Retool.FileSystem.PathInfo.getExtension(file.name);
                        var icon = IDE.FileIcons.forExtension(ext);
                        this.renderTool(w, { text: file.name, type: "file", name: file.getFullName(), dropKind: "helper", icon: icon });
                    }
                };
                Folder.prototype.renderFooter = function (w) {
                };
                Folder.prototype.renderContent = function (w) {
                    this.renderHeader(w);
                    var folder = IDE.Ide.sourceApp.getFolder(this.name);
                    var self = this;
                    if (folder) {
                        folder.forEachFolder(function (subFolder) {
                            var subName = (self.name) ? self.name + "/" + subFolder.name : subFolder.name;
                            var protectedType = self.protectedFolders[subName];
                            if (protectedType) {
                                self.renderChild(w, new protectedType(subName, subFolder.name));
                            }
                            else {
                                self.renderChild(w, new Folder(subName, subFolder.name));
                            }
                        }, { sorted: true });
                        folder.forEachFile(function (file) {
                            self.renderFile(w, file);
                        }, { sorted: true });
                    }
                };
                Folder.prototype.renderChild = function (w, folder) {
                    this.children = this.children || [];
                    this.children.push(folder);
                    folder.render(w);
                };
                Folder.prototype.render = function (w) {
                    this.init();
                    var attrib = { "id": "tboxfld-" + this.id };
                    if (this.dropKind) {
                        attrib["data-rto-kind"] = this.dropKind;
                    }
                    if (this.type) {
                        attrib["data-rto-type"] = this.type;
                    }
                    if (this.dataName) {
                        attrib["data-rto-name"] = this.dataName;
                    }
                    var css = "expandable";
                    if (!this.dropKind) {
                        css += " folder";
                    }
                    var isExpanded;
                    if (this.id && isExpanded) {
                        css += " expanded";
                    }
                    w.writeTag("li", css, attrib);
                    w.writeTag("div", "pip").write('<a href="#"></a></div>');
                    if (this.dropKind) {
                        w.writeTag("div", "toolbox-folder toolbox-item toolbox-ds-item", { draggable: true });
                    }
                    else {
                        w.writeTag("div", "toolbox-folder");
                    }
                    if (this.icon) {
                        var iconFont = this.icon.font || "toolbox";
                        w.writeTag("span", "glyph " + iconFont + " color" + this.icon.color).text(this.icon.glyph).write(' </span> ');
                    }
                    w.text(this.text);
                    if (this.dropmenu) {
                    }
                    w.write('</div>');
                    w.writeTag("ul", "toolbox-items");
                    this.renderContent(w);
                    w.write('</ul>');
                    w.write('</li>');
                };
                Folder.prototype.refresh = function () {
                    var w = new Retool.Writer("ds");
                    var id = "rto-tboxfld-" + this.id;
                    this.render(w);
                    var elem = $('#' + id);
                    var snapshot = this.getStateSnapshot(elem);
                    elem.replaceWith(w.getStream());
                    elem = $('#' + id);
                    this.applyStateSnapshot(snapshot);
                    this.attachDragEvents(elem);
                };
                Folder.prototype.getStateSnapshot = function (elem) {
                    var expandedList = [];
                    if (elem.hasClass("rto-expanded")) {
                        expandedList.push(elem.attr("id"));
                    }
                    var expanded = elem.find('li.rto-expanded');
                    expanded.each(function () {
                        expandedList.push(this.id);
                    });
                    return { expanded: expandedList };
                };
                Folder.prototype.applyStateSnapshot = function (snapshot) {
                    if (snapshot.expanded) {
                        var expandedList = snapshot.expanded;
                        for (var i = 0; i < expandedList.length; i++) {
                            $('#' + expandedList[i]).addClass("rto-expanded");
                        }
                    }
                };
                return Folder;
            })(Toolbox.ToolRenderer);
            Toolbox.Folder = Folder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var Renderer = (function () {
                function Renderer() {
                    this.actions = new Toolbox.ToolboxActions();
                }
                Renderer.prototype.render = function (w) {
                    this.renderToolbar(w);
                    w.writeTag("div", "", { id: "toolbox" });
                    this.componentsSection = new Toolbox.ComponentsSection("components");
                    this.componentsSection.render(w);
                    this.appsSection = new Toolbox.AppsSection("apps");
                    this.appsSection.render(w);
                    this.dataPropertiesSection = new Toolbox.DataPropertiesSection("dataprop");
                    this.dataPropertiesSection.render(w);
                    this.clipboardSection = new Toolbox.ClipboardSection("clipboard");
                    this.clipboardSection.render(w);
                    w.write('<input type="file" id="file-add-asset" class="retool-file-upload">');
                    w.write('</div>');
                };
                Renderer.prototype.renderToolbar = function (w) {
                    w.writeTag("div", null, { id: "toolbox-toolbar" });
                    w.writeTag("a", "inactive", { "data-name": "apps", tooltip: "Applications", toolpos: "right" }).writeTag("span", "glyph toolbox color6").text("@").write('</span></a>');
                    w.writeTag("a", "inactive", { "data-name": "dataprop", tooltip: "Template Data" }).writeTag("span", "glyph toolbox color1").text("R").write('</span></a>');
                    w.writeTag("a", "active", { "data-name": "components", tooltip: "Components" }).writeTag("span", "glyph toolbox color8").text("]").write('</span></a>');
                    w.writeTag("a", "inactive", { "data-name": "clipboard", tooltip: "Clipboard" }).writeTag("span", "glyph toolbox ").text("D").write('</span></a>');
                    w.write('</div>');
                };
                Renderer.prototype.showClipboard = function () {
                    $('#rto-toolbox-toolbar a[data-name="clipboard"]').get(0).click();
                };
                Renderer.prototype.refreshComponents = function () {
                    this.componentsSection.refresh();
                };
                Renderer.prototype.refreshDataProperties = function () {
                    this.dataPropertiesSection.refresh();
                };
                Renderer.prototype.refreshAll = function () {
                    this.refreshDataProperties();
                    this.appsSection.refresh();
                    this.refreshComponents();
                };
                Renderer.prototype.fileAdded = function (file) {
                    this.refreshFile(file, "added");
                };
                Renderer.prototype.fileUpdated = function (file) {
                    this.refreshFile(file, "updated");
                };
                Renderer.prototype.fileDeleted = function (file) {
                    this.refreshFile(file, "deleted");
                };
                Renderer.prototype.refreshFile = function (file, action) {
                    this.appsSection.refreshFile(file, action);
                };
                Renderer.prototype.onViewChange = function () {
                    this.refreshDataProperties();
                };
                Renderer.prototype.refreshClipboard = function () {
                    this.clipboardSection.refresh();
                };
                Renderer.prototype.renderModelRelatedFields = function (li) {
                    var modelFolder = new Toolbox.ModelFolder("related", "related", null);
                    modelFolder.renderRelatedFields(li);
                    return;
                };
                Renderer.prototype.onToolboxItemClick = function (e, elem) {
                    e.preventDefault();
                    e.stopPropagation();
                    var li = $(elem).closest('li');
                    var type = li.data("rto-type");
                    var $target = $(e.target).closest('a');
                    if ($target.length && $target.data("action") == "dropdown") {
                        $target.closest('.rto-dropdown').toggleClass('open');
                        return;
                    }
                    if (type) {
                        this.actions.execute(type, li.data("rto-name"));
                        return;
                    }
                };
                Renderer.prototype.onFolderClick = function (e, elem) {
                    var li = $(elem).closest('li');
                    if (li.length) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (li.children('ul').length == 0) {
                            var type = li.data("rto-type");
                            if (type == "relationship") {
                                this.renderModelRelatedFields(li);
                            }
                            else if (type == "objectmodel" || type == "arraymodel" || type == "object" || type == "array") {
                                this.dataPropertiesSection.renderObjectChildProperties(li);
                            }
                        }
                        if (!$(elem).hasClass('rto-pip') && (li.data('rto-type') == "model" || li.data("rto-type") == "app")) {
                            return; // no toggle
                        }
                        li.toggleClass("rto-expanded");
                    }
                };
                Renderer.prototype.onToolbarClick = function (e, elem) {
                    e.preventDefault();
                    e.stopPropagation();
                    var name = $(elem).data('name');
                    if (name == "dataprop") {
                        // if controller already active then ... refire loadModel?
                        this.refreshDataProperties();
                    }
                    $('#rto-toolbox-toolbar a').attr('class', "rto-inactive");
                    $(elem).attr('class', "rto-active");
                    $('#rto-toolbox > section').hide();
                    $('#rto-toolbox-' + name).show();
                };
                Renderer.prototype.attachEvents = function () {
                    var self = this;
                    this.componentsSection.attachEvents();
                    this.appsSection.attachEvents();
                    this.dataPropertiesSection.attachEvents();
                    this.clipboardSection.attachEvents();
                    $('#rto-toolbox').on('click', '.rto-toolbox-item', function (e) {
                        self.onToolboxItemClick(e, this);
                    });
                    $('#rto-toolbox').on('click', '.rto-pip,.rto-toolbox-folder', function (e) {
                        self.onFolderClick(e, this);
                    });
                    $('#rto-toolbox-toolbar').on('click', 'a', function (e) {
                        self.onToolbarClick(e, this);
                    });
                };
                return Renderer;
            })();
            Toolbox.Renderer = Renderer;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var ToolboxActions = (function () {
                function ToolboxActions() {
                    this.actions = {
                        "model": this.showModel,
                        "controller": this.showController,
                        "field": this.showField,
                        "relationship": this.showRelationship,
                        "template": this.showTemplate,
                        "css": this.showCss,
                        "image": this.showImage,
                        "add-template": this.addTemplate,
                        "add-model": this.addModel,
                        "add-controller": this.addController,
                        "add-css": this.addCss,
                        "add-fields": this.addFields,
                        "add-relationship": this.addRelationship,
                        "upload-asset": this.uploadAsset,
                        "upload-css": this.uploadCss,
                        "element": this.element,
                        "add-component": this.addComponent,
                        "component": this.showComponent,
                        "file": this.showGenericFile,
                        "add-file": this.addFile
                    };
                    this.editContent = ['js', 'css', 'json', 'hbs', 'md', 'html', 'txt'];
                }
                ToolboxActions.prototype.execute = function (action, dataName) {
                    var method = this.actions[action];
                    if (!method) {
                        IDE.Ide.displayError("Unknown toolbox action: " + action);
                        return;
                    }
                    try {
                        method.apply(this, [dataName]);
                    }
                    catch (err) {
                        IDE.Ide.displayError(err);
                    }
                };
                ToolboxActions.prototype.showModel = function (modelId) {
                    var modelFile = IDE.Ide.sourceApp.models.getFile(modelId);
                    if (modelFile) {
                        IDE.Ide.render("model/edit", modelId);
                        var editor = IDE.activeDesigner.getModelCodeSection();
                        if (editor) {
                            editor.loadFile(modelFile);
                            if (IDE.activeDesigner.footer.visible) {
                                IDE.activeDesigner.footer.select(editor.id);
                            }
                        }
                    }
                };
                ToolboxActions.prototype.showController = function (id) {
                    var controllerFile = IDE.Ide.sourceApp.controllers.getFile(id);
                    if (controllerFile) {
                        IDE.Ide.render("controller/edit", id);
                        var editor = IDE.activeDesigner.getControllerCodeSection();
                        if (editor) {
                            editor.loadFile(controllerFile);
                            if (IDE.activeDesigner.footer.visible) {
                                IDE.activeDesigner.footer.select(editor.id);
                            }
                        }
                    }
                };
                ToolboxActions.prototype.showField = function (fieldId) {
                    IDE.Ide.render("field/edit", fieldId);
                };
                ToolboxActions.prototype.showRelationship = function (relationshipId) {
                    IDE.Ide.render("relationship/edit", relationshipId);
                };
                ToolboxActions.prototype.showTemplate = function (filename) {
                    var app = IDE.Ide.sourceApp;
                    var file = app.getFile(filename);
                    if (file) {
                        var template = app.templates.getByFilename(filename);
                        var url = Retool.Url.filename(filename);
                        var navigate = true;
                        // 
                        if (navigate) {
                            var url = Retool.Url.filename(filename);
                            var displayUrl = url.toDisplay();
                            if (url.templateName) {
                                IDE.activeDesigner.navigateApp(url);
                            }
                        }
                        else {
                            IDE.activeDesigner.attachToViewContainer({ template: template });
                        }
                        IDE.Ide.render("template/edit", filename);
                    }
                };
                ToolboxActions.prototype.showComponent = function (filename) {
                    IDE.Ide.render("component/edit", filename);
                    var template = IDE.Ide.sourceApp.components.getByFilename(filename);
                    IDE.activeDesigner.attachToViewContainer({ template: template });
                };
                ToolboxActions.prototype.showCss = function (cssFileName, options) {
                    var cssFile = IDE.Ide.sourceApp.getFile(cssFileName);
                    if (cssFile) {
                        IDE.Ide.render("css/edit", cssFile.getFullName());
                        var cssEditor = IDE.activeDesigner.getCssEditor();
                        if (cssEditor) {
                            cssEditor.loadFile(cssFile);
                            IDE.activeDesigner.footer.select(cssEditor.id);
                        }
                    }
                };
                ToolboxActions.prototype.showGenericFile = function (filename, options) {
                    var file = IDE.Ide.sourceApp.getFile(filename);
                    options = options || {};
                    if (file) {
                        var ext = Retool.FileSystem.PathInfo.getExtension(file.getFullName());
                        if (ext == "css") {
                            return this.showCss(filename, options);
                        }
                        if (!options.contentOnly) {
                            IDE.Ide.render("generic-file/edit", file.getFullName());
                        }
                        var ext = Retool.FileSystem.PathInfo.getExtension(filename);
                        var genericEditor = IDE.activeDesigner.getGenericEditor();
                        if (genericEditor) {
                            if (this.editContent.indexOf(ext) != -1) {
                                genericEditor.loadFile(file);
                                IDE.activeDesigner.footer.select(genericEditor.id);
                            }
                            else {
                                genericEditor.loadFile(null);
                            }
                        }
                    }
                };
                ToolboxActions.prototype.showImage = function (imageFileName) {
                    var imageFile = IDE.Ide.sourceApp.getFile(imageFileName);
                    if (imageFile) {
                        IDE.Ide.render("image/edit", imageFile.name);
                    }
                };
                ToolboxActions.prototype.addTemplate = function (folder) {
                    IDE.Ide.render("template/create", null, { folder: folder });
                };
                ToolboxActions.prototype.addComponent = function () {
                    IDE.Ide.render("component/create", null);
                };
                ToolboxActions.prototype.addModel = function (app) {
                    IDE.Ide.render("model/create", null, { userApp: app });
                };
                ToolboxActions.prototype.addController = function (app) {
                    IDE.Ide.render("controller/create", null, { userApp: app });
                };
                ToolboxActions.prototype.addFields = function (modelId) {
                    IDE.Ide.render("model/create", modelId, { addfields: true });
                };
                ToolboxActions.prototype.addRelationship = function (modelId) {
                    IDE.Ide.render("relationship/create", modelId);
                };
                ToolboxActions.prototype.addCss = function () {
                    IDE.Ide.render("css/create", null);
                };
                ToolboxActions.prototype.addFile = function (folder) {
                    IDE.Ide.render("generic-file/create", null, { folder: folder });
                };
                ToolboxActions.prototype.uploadAsset = function (folder) {
                    var self = this;
                    var uploader = new IDE.Util.FileUploader({ type: "binary" });
                    uploader.getFile(function (file, content) {
                        var filename = file.name.toLowerCase().replace(/ /g, '-');
                        uploader.sendData({
                            contentType: "application/octet-stream",
                            url: Retool.App.apiHost + "projectfiles.upload_asset?name=" + encodeURIComponent(folder + "/" + filename),
                            data: new DataView(content),
                            success: function (data) {
                                if (data.error) {
                                    IDE.Ide.displayError(data.error);
                                    return;
                                }
                                var localContent;
                                var ext = Retool.FileSystem.PathInfo.getExtension(filename);
                                if (ext == "css" || ext == "js") {
                                    localContent = data.result;
                                }
                                var newFile = new Retool.FileSystem.File(folder + "/" + filename, localContent);
                                IDE.Ide.sourceApp.addFile(newFile, true); // overwrite is ok
                                // activeDesigner.saveFile(newFile,true);
                                IDE.activeDesigner.toolbox.fileAdded(newFile);
                            },
                            error: function (err) {
                                IDE.Ide.displayError(err);
                            }
                        });
                    });
                };
                ToolboxActions.prototype.uploadCss = function (folder) {
                    var self = this;
                    var uploader = new IDE.Util.FileUploader({ type: "text" });
                    uploader.getFile(function (file, content) {
                        var newFile = new Retool.FileSystem.File(folder + "/" + file.name, content);
                        IDE.Ide.sourceApp.addFile(newFile, true); // overwrite is ok
                        IDE.activeDesigner.saveFile(newFile, true);
                        IDE.activeDesigner.toolbox.fileAdded(newFile);
                    });
                };
                ToolboxActions.prototype.element = function () {
                    // do nothing, called when click occurs on component in toolbox
                };
                return ToolboxActions;
            })();
            Toolbox.ToolboxActions = ToolboxActions;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var AssetsFolder = (function (_super) {
                __extends(AssetsFolder, _super);
                function AssetsFolder() {
                    _super.apply(this, arguments);
                }
                AssetsFolder.prototype.renderContent1 = function (w) {
                    var css = new Toolbox.CssFolder("assets/css", "css");
                    css.render(w);
                    var images = new Toolbox.ImagesFolder("assets/images", "images");
                    images.render(w);
                };
                return AssetsFolder;
            })(Toolbox.Folder);
            Toolbox.AssetsFolder = AssetsFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var BootstrapFolder = (function (_super) {
                __extends(BootstrapFolder, _super);
                function BootstrapFolder() {
                    _super.apply(this, arguments);
                }
                BootstrapFolder.prototype.renderHeader = function (w) {
                    this.renderTool(w, { text: "+ upload file", type: "upload-asset", name: "bootstrap", dropKind: null, css: "add-button" });
                };
                BootstrapFolder.prototype.renderFile = function (w, file) {
                    this.renderTool(w, { text: file.name, type: "css", name: file.getFullName(), dropKind: "helper", icon: { glyph: "`", color: "3", font: "toolbox" } });
                };
                return BootstrapFolder;
            })(Toolbox.Folder);
            Toolbox.BootstrapFolder = BootstrapFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var CssFolder = (function (_super) {
                __extends(CssFolder, _super);
                function CssFolder() {
                    _super.apply(this, arguments);
                }
                CssFolder.prototype.renderHeader = function (w) {
                    this.renderTool(w, { text: "+ upload file", type: "upload-css", name: "css", dropKind: null, css: "add-button" });
                    this.renderTool(w, { text: "+ create new file", type: "add-css", name: "css", dropKind: null, css: "add-button" });
                };
                CssFolder.prototype.renderFile = function (w, file) {
                    this.renderTool(w, { text: file.name, type: "css", name: file.getFullName(), dropKind: "helper", icon: { glyph: "`", color: "3", font: "toolbox" } });
                };
                return CssFolder;
            })(Toolbox.Folder);
            Toolbox.CssFolder = CssFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var ImagesFolder = (function (_super) {
                __extends(ImagesFolder, _super);
                function ImagesFolder() {
                    _super.apply(this, arguments);
                }
                ImagesFolder.prototype.renderHeader = function (w) {
                    this.renderTool(w, { text: "+ upload image", type: "upload-asset", name: "images", dropKind: null, css: "add-button" });
                };
                ImagesFolder.prototype.renderFile = function (w, file) {
                    this.renderTool(w, { text: file.name, type: "image", name: file.getFullName(), dropKind: "helper", icon: { glyph: "f", color: "4", font: "toolbox" } });
                };
                return ImagesFolder;
            })(Toolbox.Folder);
            Toolbox.ImagesFolder = ImagesFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var LayoutsFolder = (function (_super) {
                __extends(LayoutsFolder, _super);
                function LayoutsFolder() {
                    _super.apply(this, arguments);
                }
                LayoutsFolder.prototype.renderHeader = function (w) {
                    this.renderTool(w, { text: "+ new layout template", type: "add-template", name: "layouts", dropKind: null, css: "add-button" });
                };
                LayoutsFolder.prototype.renderFile = function (w, file) {
                    var name = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(file.name);
                    this.renderTool(w, { text: name, type: "template", name: file.getFullName(), dropKind: "helper", icon: { glyph: ")", color: "0", font: "toolbox" } });
                };
                return LayoutsFolder;
            })(Toolbox.Folder);
            Toolbox.LayoutsFolder = LayoutsFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var ModelFolder = (function (_super) {
                __extends(ModelFolder, _super);
                function ModelFolder(name, text, modelDef) {
                    _super.call(this, name, text);
                    this.modelDef = modelDef;
                    this.dataName = modelDef.name;
                }
                ModelFolder.prototype.init = function () {
                    this.dropKind = "helper";
                    this.type = "model";
                    this.icon = (this.modelDef.exposed) ? IDE.FileIcons.ModelExposed : IDE.FileIcons.Model;
                };
                ModelFolder.prototype.renderContent = function (w) {
                    this.renderFields(w, this.modelDef);
                };
                ModelFolder.prototype.renderFields = function (w, modelDefinition, prefix) {
                    if (!modelDefinition)
                        return;
                    var self = this;
                    var modelRoot = false;
                    if (!prefix) {
                        modelRoot = true;
                        prefix = modelDefinition.name;
                    }
                    if (modelRoot) {
                        this.renderTool(w, { text: "+ add fields", type: "add-fields", name: modelDefinition.name, dropKind: null, css: "add-button" });
                    }
                    for (var key in modelDefinition.fields) {
                        var field = modelDefinition.fields[key];
                        this.renderTool(w, { name: prefix + "." + key, text: key, type: "field", dropKind: "inline", icon: { glyph: "L", color: "1", font: "toolbox" } });
                    }
                    if (modelRoot) {
                        this.renderTool(w, { text: "+ add relationship", type: "add-relationship", name: modelDefinition.name, dropKind: null, css: "add-button" });
                    }
                    for (var key in modelDefinition.relationships) {
                        var relationship = modelDefinition.relationships[key];
                        var icon = { color: "1", font: "toolbox" };
                        var expandable;
                        if (relationship.type == "belongs_to") {
                            icon.glyph = "V";
                            expandable = true;
                        }
                        else if (relationship.type == "detail") {
                            icon.glyph = "X";
                        }
                        else {
                            icon.glyph = "U";
                        }
                        this.renderTool(w, { name: prefix + "." + key, text: key, expandable: expandable, type: "relationship", icon: icon, dropKind: "relationship" });
                    }
                };
                ModelFolder.prototype.renderRelatedFields = function (li) {
                    var w = new Retool.Writer("ds");
                    var name = li.data("rto-name");
                    var segments = name.split('.');
                    var modelName = segments[0];
                    var modelDef = IDE.Ide.sourceApp.models.getDefinition(modelName);
                    for (var i = 1; i < segments.length; i++) {
                        var relationshipId = segments[i];
                        var relationship = modelDef.relationships[relationshipId];
                        modelDef = IDE.Ide.sourceApp.models.getDefinition(relationship.model);
                    }
                    w.writeTag("ul", "toolbox-items");
                    var prefix = name;
                    this.renderFields(w, modelDef, prefix);
                    w.write('</ul>');
                    w.appendToElement(li);
                    this.attachDragEvents(li);
                };
                return ModelFolder;
            })(Toolbox.Folder);
            Toolbox.ModelFolder = ModelFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var ModelsFolder = (function (_super) {
                __extends(ModelsFolder, _super);
                function ModelsFolder() {
                    _super.apply(this, arguments);
                }
                ModelsFolder.prototype.renderHeader = function (w) {
                    this.renderTool(w, { text: "+ new model", type: "add-model", name: "", dropKind: null, css: "add-button" });
                };
                ModelsFolder.prototype.renderFile = function (w, file) {
                    var modelDef = file.getContent();
                    var name = modelDef.name;
                    var modelFolder = new Toolbox.ModelFolder("models/" + name, name, modelDef);
                    this.renderChild(w, modelFolder);
                };
                return ModelsFolder;
            })(Toolbox.Folder);
            Toolbox.ModelsFolder = ModelsFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var TemplatesFolder = (function (_super) {
                __extends(TemplatesFolder, _super);
                function TemplatesFolder(name, text, appName) {
                    _super.call(this, name, text);
                    this.appName = appName;
                    this.dataName = appName;
                }
                TemplatesFolder.prototype.renderHeader = function (w) {
                    this.renderTool(w, { text: "+ new template", type: "add-template", name: this.appName, dropKind: null, css: "add-button" });
                };
                TemplatesFolder.prototype.renderFile1 = function (w, file) {
                    var name = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(file.name);
                    if (file.getIsNative()) {
                        this.renderTool(w, { text: name, type: "template", name: file.getFullName(), dropKind: "helper", icon: IDE.FileIcons.Template });
                    }
                    else {
                        this.renderTool(w, { text: file.name, type: "file", name: file.getFullName(), dropKind: "helper", icon: IDE.FileIcons.File });
                    }
                };
                return TemplatesFolder;
            })(Toolbox.Folder);
            Toolbox.TemplatesFolder = TemplatesFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var RootFolder = (function (_super) {
                __extends(RootFolder, _super);
                function RootFolder(name, text) {
                    _super.call(this, name, text);
                }
                RootFolder.prototype.render = function (w) {
                    var attrib = { "id": "tboxfld-" + this.id };
                    w.writeTag("div", null, attrib);
                    this.renderContent(w);
                    w.write("</div>");
                };
                return RootFolder;
            })(Toolbox.Folder);
            Toolbox.RootFolder = RootFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var ControllersFolder = (function (_super) {
                __extends(ControllersFolder, _super);
                function ControllersFolder() {
                    _super.apply(this, arguments);
                }
                ControllersFolder.prototype.renderHeader = function (w) {
                    this.renderTool(w, { text: "+ new api", type: "add-controller", name: "", dropKind: null, css: "add-button" });
                };
                ControllersFolder.prototype.renderFile = function (w, file) {
                    var controllerDef = file.getContent();
                    var name = controllerDef.name;
                    var icon = IDE.FileIcons.Api;
                    this.renderTool(w, { id: "controller-" + name, text: name, dropKind: null, type: "controller", name: name, icon: icon });
                };
                return ControllersFolder;
            })(Toolbox.Folder);
            Toolbox.ControllersFolder = ControllersFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var ComponentsFolder = (function (_super) {
                __extends(ComponentsFolder, _super);
                function ComponentsFolder() {
                    _super.apply(this, arguments);
                }
                ComponentsFolder.prototype.renderHeader = function (w) {
                    this.renderTool(w, { text: "+ new component", type: "add-component", name: "components", dropKind: null, css: "add-button" });
                };
                ComponentsFolder.prototype.renderFile = function (w, file) {
                    var name = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(file.name);
                    this.renderTool(w, { text: name, type: "component", name: name, dropKind: "helper", icon: IDE.FileIcons.Component });
                };
                return ComponentsFolder;
            })(Toolbox.Folder);
            Toolbox.ComponentsFolder = ComponentsFolder;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var Section = (function (_super) {
                __extends(Section, _super);
                function Section(id) {
                    _super.call(this);
                    this.id = id;
                }
                Section.prototype.getElem = function (selector) {
                    if (selector) {
                        return $('#rto-' + this.getElemId() + " " + selector);
                    }
                    return $('#rto-' + this.getElemId());
                };
                Section.prototype.getElemId = function () {
                    return "toolbox-" + this.id;
                };
                Section.prototype.render = function (w) {
                };
                Section.prototype.refresh = function () {
                };
                Section.prototype.attachEvents = function () {
                };
                return Section;
            })(Toolbox.ToolRenderer);
            Toolbox.Section = Section;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var AppsSection = (function (_super) {
                __extends(AppsSection, _super);
                function AppsSection() {
                    _super.apply(this, arguments);
                }
                AppsSection.prototype.render = function (w) {
                    w.writeTag("section", null, { id: this.getElemId(), style: "display:none" });
                    w.writeTag("div", "section-content");
                    w.writeTag("ul", "designer-toolbox data-source");
                    var self = this;
                    this.rootFolder = new Toolbox.RootFolder("", "");
                    this.rootFolder.render(w);
                    /*
                    var templateFolderName = FileSystem.FilePath.forType(FileSystem.FileType.Template);
        
                    this.renderFolder(w,new TemplatesFolder(App.ADMIN_APP_NAME,App.ADMIN_APP_NAME,App.ADMIN_APP_NAME));
                    this.renderFolder(w,new AssetsFolder("assets","assets"));
                    this.renderFolder(w,new ControllersFolder(FileSystem.FilePath.forType(FileSystem.FileType.Controller),"api","api"));
                    // this.renderFolder(w,new BootstrapFolder(FileSystem.FilePath.forType(FileSystem.FileType.Bootstrap),"bootstrap"));
                    this.renderFolder(w,new ComponentsFolder(FileSystem.FilePath.forType(FileSystem.FileType.Component),"components"));
                    
            
                  
                   
        
                    // w.writeTag("div","sec-title").write("RESOURCES</div>");
                
                    // this.renderFolder(w,new ImagesFolder(FileSystem.FilePath.forType(FileSystem.FileType.Image),"images"));
                    this.renderFolder(w,new ModelsFolder(FileSystem.FilePath.forType(FileSystem.FileType.Model),"models","models"));
                     this.renderFolder(w,new TemplatesFolder(App.FRONTEND_DOMAIN,App.FRONTEND_DOMAIN,App.FRONTEND_DOMAIN));
                    
                    */
                    w.write('</ul>');
                    w.write("</div>");
                    w.write("</section>");
                };
                AppsSection.prototype.refresh = function () {
                    this.rootFolder.refresh();
                };
                AppsSection.prototype.refreshFile = function (file, action) {
                    var name = file.getFullName();
                    var root = "";
                    var i = name.indexOf('/');
                    if (i != -1) {
                        root = name.substr(0, i);
                    }
                    if (!root) {
                        return this.rootFolder.refresh();
                    }
                    for (var i = 0; i < this.rootFolder.children.length; i++) {
                        var folder = this.rootFolder.children[i];
                        if (folder.name == root) {
                            folder.refresh();
                        }
                    }
                    var fileType = Retool.FileSystem.FilePath.getType(file.getFullName());
                    if (fileType == 8 /* Component */) {
                        this.refreshComponents();
                    }
                };
                AppsSection.prototype.segmentsMatch = function (segments, match) {
                    for (var i = 0; i < match.length; i++) {
                        if (!(i < segments.length && segments[i] == match[i])) {
                            return false;
                        }
                    }
                    return true;
                };
                AppsSection.prototype.attachEvents = function () {
                    this.attachDragEvents(this.getElem());
                };
                AppsSection.prototype.refreshComponents = function () {
                };
                return AppsSection;
            })(Toolbox.Section);
            Toolbox.AppsSection = AppsSection;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var ComponentsSection = (function (_super) {
                __extends(ComponentsSection, _super);
                function ComponentsSection() {
                    _super.apply(this, arguments);
                }
                ComponentsSection.prototype.render = function (w) {
                    this.components = this.sortComponents();
                    w.writeTag("section", null, { id: "toolbox-components" });
                    var categories = {
                        "general": { text: "form" },
                        "grid": { text: "grid" },
                        "html": { text: "html" },
                        "misc": { text: "misc" },
                        "nav": { text: "navigation" },
                        "table": { text: "table" },
                        "widget": { text: "widgets" }
                    };
                    w.writeTag("div", "filter-box empty");
                    w.writeTag("input", null, { id: "component-filter", placeholder: "filter" });
                    w.writeTag("a", null, { href: "#" }).write("&times;").write('</a>');
                    w.write('</div>');
                    w.writeTag("div", "section-content components");
                    this.writeComponentList(w);
                    w.write('</div>');
                    w.write("</section>");
                };
                ComponentsSection.prototype.writeComponentList = function (w) {
                    w.writeTag("ul", "designer-toolbox components");
                    this.renderAllComponents(w);
                    w.write("</ul>");
                };
                ComponentsSection.prototype.renderAllComponents = function (w) {
                    var components = this.components;
                    var fLen = 0;
                    var filter;
                    if (this.filterValue) {
                        fLen = this.filterValue.length;
                        filter = this.filterValue.toLowerCase();
                    }
                    for (var i = 0; i < components.length; i++) {
                        var helper = components[i];
                        /*
                        if (helper.settings.category == "helpers"){
                            continue;
                        }
                        */
                        var color = (helper.settings.category == "helpers") ? "0" : "8";
                        if (helper.settings.isSnippet) {
                            color = "3";
                        }
                        var label = helper.settings.label || helper.settings.kind;
                        var sort = helper.settings.sort;
                        if (fLen) {
                            if (fLen > sort.length || sort.substr(0, fLen) != filter) {
                                continue;
                            }
                        }
                        var dropKind = helper.settings.dropKind || helper.settings.kind;
                        var glyph = helper.settings.glyph || "i";
                        var kind = helper.settings.dropAsKind || helper.settings.kind;
                        this.renderTool(w, { text: label, name: kind, type: "element", dropKind: dropKind, icon: { glyph: glyph, color: color, font: "toolbox" } });
                    }
                };
                ComponentsSection.prototype.filterComponents = function () {
                    this.redraw();
                };
                ComponentsSection.prototype.redraw = function () {
                    var w = new Retool.Writer('ds');
                    this.renderAllComponents(w);
                    w.writeToElement("#rto-" + this.getElemId() + " ul.rto-components");
                    this.attachDragEvents(this.getElem());
                };
                ComponentsSection.prototype.refresh = function () {
                    this.components = this.sortComponents();
                    this.redraw();
                };
                ComponentsSection.prototype.attachEvents = function () {
                    var self = this;
                    var elem = this.getElem();
                    this.attachDragEvents(elem);
                    elem.on('input', function (e) {
                        self.filterValue = e.target.value;
                        if (e.target.value) {
                            $(e.target).closest('.rto-filter-box').removeClass("rto-empty");
                        }
                        else {
                            $(e.target).closest('.rto-filter-box').addClass("rto-empty");
                        }
                        self.filterComponents();
                    });
                    elem.on('click', '.rto-filter-box a', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $('#rto-component-filter').val("");
                        self.filterValue = "";
                        $('#rto-component-filter').closest('.rto-filter-box').addClass('rto-empty');
                        self.filterComponents();
                    });
                };
                ComponentsSection.prototype.sortComponents = function () {
                    var helpers = IDE.Ide.sourceApp.helpers.getAll();
                    var toolboxComponents = [];
                    for (var i = 0; i < helpers.length; i++) {
                        var helper = helpers[i];
                        if (helper.settings && helper.settings.toolbox) {
                            var sort = helper.settings.label;
                            if (sort[0] == "#") {
                                sort = sort.substr(1);
                            }
                            helper.settings.sort = sort;
                            toolboxComponents.push(helper);
                        }
                    }
                    var snippets = IDE.Ide.elementSnippets.getAll();
                    for (var i = 0; i < snippets.length; i++) {
                        var snippet = snippets[i];
                        snippet.settings.sort = snippet.settings.label;
                        toolboxComponents.push(snippet);
                    }
                    toolboxComponents.sort(function (a, b) {
                        if (a.settings.sort > b.settings.sort) {
                            return 1;
                        }
                        else if (a.settings.sort < b.settings.sort) {
                            return -1;
                        }
                        ;
                        return 0;
                    });
                    return toolboxComponents;
                };
                return ComponentsSection;
            })(Toolbox.Section);
            Toolbox.ComponentsSection = ComponentsSection;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var DataPropertiesSection = (function (_super) {
                __extends(DataPropertiesSection, _super);
                function DataPropertiesSection() {
                    _super.apply(this, arguments);
                }
                DataPropertiesSection.prototype.render = function (w) {
                    w.writeTag("section", null, { id: this.getElemId(), style: "display:none" });
                    w.writeTag("div", "section-content");
                    this.renderContent(w);
                    w.write('</div>');
                    w.write("</section>");
                };
                DataPropertiesSection.prototype.refresh = function () {
                    var w = new Retool.Writer("ds");
                    this.renderContent(w);
                    w.writeToElement(this.getElem(".rto-section-content"));
                    this.attachEvents();
                };
                DataPropertiesSection.prototype.renderContent = function (w) {
                    var self = this;
                    var canvas = IDE.Ide.getAppCanvas();
                    if (!canvas)
                        return;
                    var viewModel = canvas.viewModel;
                    if (viewModel) {
                        w.writeTag("ul", "designer-toolbox components");
                        this.renderObjectProperties(w, viewModel, "");
                        w.write("</ul>");
                    }
                };
                DataPropertiesSection.prototype.renderObjectChildProperties = function (li) {
                    var w = new Retool.Writer("ds");
                    var name = li.data("rto-name");
                    var viewModel = IDE.Ide.getAppCanvas().viewModel;
                    var source = viewModel.get(name);
                    var prefix = name;
                    if (Retool.App.isArrayModel(source)) {
                        if (source.getLength()) {
                            source = source.getRow(0);
                            prefix += ".0";
                        }
                    }
                    else if (Array.isArray(source)) {
                        if (source.length) {
                            source = source[0];
                            prefix = ".0";
                        }
                    }
                    w.writeTag("ul", "toolbox-items");
                    this.renderObjectProperties(w, source, prefix);
                    w.write('</ul>');
                    w.appendToElement(li);
                    this.attachDragEvents(li);
                };
                DataPropertiesSection.prototype.renderObjectProperties = function (w, source, prefix) {
                    if (!source)
                        return;
                    var self = this;
                    var attributes;
                    if (Retool.App.isModel(source)) {
                        attributes = source.getAttributes();
                    }
                    else if (source.__isVMObject) {
                        attributes = source.propertyValues;
                    }
                    else {
                        attributes = source;
                    }
                    for (var key in attributes) {
                        var value = attributes[key];
                        var icon = { color: "1", font: "toolbox" };
                        var expandable = false;
                        var text = key;
                        var type = "";
                        var subText = "";
                        if (Retool.App.isObjectModel(value)) {
                            icon.glyph = "R";
                            expandable = true;
                            type = "objectmodel";
                        }
                        else if (Retool.App.isArrayModel(value)) {
                            icon.glyph = "X";
                            expandable = true;
                            subText = "[" + value.getLength() + "]";
                            type = "arraymodel";
                        }
                        else if (Array.isArray(value)) {
                            icon.glyph = "X";
                            expandable = true;
                            subText = "[" + value.length + "]";
                            type = "array";
                        }
                        else if (Retool.VM.Global.isObject(value)) {
                            icon.glyph = "R";
                            expandable = true;
                            type = "object";
                        }
                        else {
                            icon.glyph = "u";
                            subText = " " + value;
                            type = "value";
                        }
                        var name = (prefix) ? prefix + "." + key : key;
                        this.renderTool(w, { name: name, text: text, expandable: expandable, type: type, icon: icon, dropKind: "inline", subText: subText });
                    }
                };
                DataPropertiesSection.prototype.attachEvents = function () {
                    this.attachDragEvents(this.getElem());
                };
                return DataPropertiesSection;
            })(Toolbox.Section);
            Toolbox.DataPropertiesSection = DataPropertiesSection;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Toolbox;
        (function (Toolbox) {
            var ClipboardSection = (function (_super) {
                __extends(ClipboardSection, _super);
                function ClipboardSection() {
                    _super.apply(this, arguments);
                }
                ClipboardSection.prototype.render = function (w) {
                    w.writeTag("section", null, { id: this.getElemId(), style: "display:none" });
                    w.writeTag("div", "filter-box empty");
                    w.writeTag("input", null, { id: "quick-inject", placeholder: "emmet/html" });
                    w.writeTag("a", null, { href: "#" }).write("&times;").write('</a>');
                    w.write('</div>');
                    w.writeTag("div", "section-content clipboard-section");
                    this.renderContent(w);
                    w.write('</div>');
                    w.write('</section>');
                };
                ClipboardSection.prototype.renderContent = function (w) {
                    var clipboard = IDE.activeDesigner.viewInspector.clipboard;
                    if (clipboard.elements.length) {
                        w.writeTag("ul", "designer-toolbox components clipboard");
                        for (var i = 0; i < clipboard.elements.length; i++) {
                            if (i == 1) {
                                w.write('<hr>');
                            }
                            var element = clipboard.elements[i];
                            if (Array.isArray(element)) {
                                element = element[0];
                            }
                            var helper = IDE.Ide.sourceApp.helpers.get(element.kind);
                            if (helper) {
                                var dropKind = helper.settings.dropKind || helper.settings.kind;
                                var label = helper.settings.label || helper.settings.kind;
                                var glyph = helper.settings.glyph || "i";
                                var itemCls = (helper.settings.command) ? " command" : "";
                                this.renderTool(w, { name: i.toString(), type: "clipboard", css: "clipboard element-syntax " + itemCls, dropKind: dropKind, renderContent: function (w) {
                                    IDE.activeDesigner.viewInspector.renderElement(w, element);
                                } });
                            }
                        }
                        w.write("</ul>");
                    }
                };
                ClipboardSection.prototype.injectContent = function () {
                    var value = this._inject;
                    if (!value) {
                        return;
                    }
                    var match = value.match(/\S/);
                    if (match) {
                        var firstChar = match[0];
                        if (firstChar == "<") {
                            this.injectHTML(value);
                        }
                        else {
                            this.injectEmmet(value);
                        }
                    }
                };
                ClipboardSection.prototype.injectHTML = function (html) {
                    var elements = IDE.HTMLParser.parse(html);
                    // var parsed = JavascriptCompiler.compileProgram(html,{allowHTML:true});
                    if (elements) {
                        var clipboard = IDE.activeDesigner.viewInspector.clipboard;
                        if (elements && elements.length) {
                            if (elements.length > 1) {
                                clipboard.add(elements);
                            }
                            else {
                                clipboard.add(elements[0]);
                            }
                            IDE.activeDesigner.toolbox.refreshClipboard();
                        }
                    }
                };
                ClipboardSection.prototype.injectEmmet = function (value) {
                    var html = Emmet.expand(value);
                    if (html) {
                        var parsed = IDE.JavascriptCompiler.compileProgram(html, { allowHTML: true });
                        if (parsed) {
                            var clipboard = IDE.activeDesigner.viewInspector.clipboard;
                            var elements = parsed.getHTML();
                            if (elements && elements.length) {
                                if (elements.length > 1) {
                                    clipboard.add(elements);
                                }
                                else {
                                    clipboard.add(elements[0]);
                                }
                                IDE.activeDesigner.toolbox.refreshClipboard();
                            }
                        }
                    }
                };
                ClipboardSection.prototype.refresh = function () {
                    var w = new Retool.Writer("ds");
                    this.renderContent(w);
                    var clipboardSection = this.getElem(".rto-section-content");
                    w.writeToElement(clipboardSection);
                    if (IDE.activeDesigner.viewInspector.clipboard) {
                        clipboardSection.show();
                    }
                    else {
                        clipboardSection.hide();
                    }
                    this.attachDragEvents(this.getElem());
                    IDE.activeDesigner.toolbox.showClipboard();
                };
                ClipboardSection.prototype.attachEvents = function () {
                    this.attachDragEvents(this.getElem());
                    var self = this;
                    var elem = this.getElem();
                    elem.on('keypress', function (e) {
                        if (e.which == 13) {
                            e.preventDefault();
                            self._inject = e.target.value;
                            if (e.target.value) {
                                $(e.target).closest('.rto-filter-box').removeClass("rto-empty");
                            }
                            else {
                                $(e.target).closest('.rto-filter-box').addClass("rto-empty");
                            }
                            self.injectContent();
                            $('#rto-quick-inject').val("");
                            self._inject = "";
                            $('#rto-quick-inject').closest('.rto-filter-box').addClass('rto-empty');
                        }
                    });
                    elem.on('click', '.rto-filter-box a', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $('#rto-quick-inject').val("");
                        self._inject = "";
                        $('#rto-quick-inject').closest('.rto-filter-box').addClass('rto-empty');
                    });
                };
                return ClipboardSection;
            })(Toolbox.Section);
            Toolbox.ClipboardSection = ClipboardSection;
        })(Toolbox = IDE.Toolbox || (IDE.Toolbox = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ElementAttribute = (function () {
            function ElementAttribute(name) {
                this.name = name;
            }
            return ElementAttribute;
        })();
        IDE.ElementAttribute = ElementAttribute;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ElementAttributeList = (function () {
            function ElementAttributeList() {
                this.list = [];
            }
            ElementAttributeList.prototype.add = function (attr) {
                this.list.push(attr);
            };
            ElementAttributeList.prototype.addTextProp = function (name, text, options) {
                var a = new IDE.ElementAttribute(name);
                a.text = text;
                a.type = "text";
                if (options) {
                    a.allowNonDrop = options.allowNonDrop;
                    a.droptype = options.droptype;
                    a.dropItems = options.dropItems;
                }
                this.list.push(a);
            };
            ElementAttributeList.prototype.addCheckbox = function (name, text) {
                var a = new IDE.ElementAttribute(name);
                a.type = "checkbox";
                a.text = text;
                this.list.push(a);
            };
            ElementAttributeList.prototype.addNote = function (name, text, options) {
                var a = new IDE.ElementAttribute(name);
                a.type = "note";
                a.text = text;
                if (options) {
                    a.cssclass = options.cssclass;
                }
                this.list.push(a);
            };
            ElementAttributeList.prototype.addRichText = function (name, text, options) {
                var a = new IDE.ElementAttribute(name);
                a.type = "richtext";
                a.text = text;
                if (options) {
                    a.cssclass = options.cssclass;
                }
                this.list.push(a);
            };
            ElementAttributeList.prototype.addMarkdown = function (name, text, options) {
                var a = new IDE.ElementAttribute(name);
                a.type = "markdown";
                a.text = text;
                if (options) {
                    a.cssclass = options.cssclass;
                }
                this.list.push(a);
            };
            ElementAttributeList.prototype.addKindProp = function (type, name, text) {
                var a = new IDE.ElementAttribute(name);
                a.type = type;
                a.text = text;
                this.list.push(a);
            };
            ElementAttributeList.prototype.concat = function (list) {
                if (!list)
                    return;
                var items = list.list;
                for (var i = 0; i < items.length; i++) {
                    this.list.push(items[i]);
                }
            };
            return ElementAttributeList;
        })();
        IDE.ElementAttributeList = ElementAttributeList;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ElementAttributeFormBuilder = (function () {
            function ElementAttributeFormBuilder(attributes) {
                this.nameCssMap = {
                    "cssclass": "cssclass",
                    "role": "role",
                    "text": "literal",
                    "markdown": "literal",
                    "label": "literal",
                    "href": "href",
                    "src": "href",
                    "path": "href",
                    "value": "field",
                    "scope": "field",
                    "scopeName": "field",
                    "expression": "field",
                    "template": "filelink",
                    "name": "name",
                    "outlet": "name"
                };
                this.attributes = attributes;
            }
            ElementAttributeFormBuilder.prototype.build = function () {
                var children = [];
                var viewDef = { "kind": "r-with", obj: "this.model", var: "m", children: [
                    { "kind": "ds-attributeform", toolbar: this.toolbar, children: [
                        { "kind": "ds-attriblist", labelsontop: true, "children": children }
                    ] }
                ] };
                var list = this.attributes.list;
                for (var i = 0; i < list.length; i++) {
                    var attr = list[i];
                    var item = this.buildAttribute(attr);
                    if (item) {
                        children.push(item);
                    }
                }
                return viewDef;
            };
            ElementAttributeFormBuilder.prototype.createElementToolbar = function () {
                return [
                    { kind: "ds-tool", text: "Convert To partial", name: "btnCreatePartial" }
                ];
            };
            ElementAttributeFormBuilder.prototype.buildAttribute = function (attr) {
                switch (attr.type) {
                    case "text": return this.buildText(attr);
                    case "checkbox": return this.buildCheckbox(attr);
                    case "note": return this.buildNote(attr);
                    case "headingSize": return this.buildHeadingSize(attr);
                    case "markdown": return this.buildMarkdown(attr);
                    case "richtext": return this.buildRichText(attr);
                }
                return null;
            };
            ElementAttributeFormBuilder.prototype.buildText = function (attr) {
                var item = { kind: "ds-attrib_text" };
                item.value = this.valueExpression(attr.name);
                item.label = attr.text;
                var droptype = attr.droptype;
                var allowNonDrop = attr.allowNonDrop;
                if (!droptype) {
                    if (attr.name == "icon") {
                        droptype = "icons";
                    }
                    else if (attr.name == "cssclass") {
                        droptype = "css";
                        allowNonDrop = true;
                    }
                }
                if (droptype) {
                    item.isDrop = true;
                    item.droptype = droptype;
                    item.allowNonDrop = allowNonDrop;
                    item.dropItems = attr.dropItems;
                }
                item.cssclass = this.getCssClass(attr);
                item.bubbleEnterKey = true;
                item.attrName = attr.name;
                return item;
            };
            ElementAttributeFormBuilder.prototype.buildCheckbox = function (attr) {
                var item = { kind: "ds-attrib_checkbox", value: this.valueExpression(attr.name), label: attr.text };
                item.cssclass = this.getCssClass(attr);
                return item;
            };
            ElementAttributeFormBuilder.prototype.buildNote = function (attr) {
                var item = { kind: "ds-attrib_textarea", value: this.valueExpression(attr.name), label: attr.text, singleLine: true };
                item.cssclass = this.getCssClass(attr) || "";
                if (attr.cssclass) {
                    item.cssclass += " " + attr.cssclass;
                }
                item.isNote = true;
                return item;
            };
            ElementAttributeFormBuilder.prototype.buildMarkdown = function (attr) {
                var item = { kind: "ds-attrib_textarea", value: this.valueExpression(attr.name), label: attr.text, singleLine: false };
                item.cssclass = this.getCssClass(attr) || "";
                if (attr.cssclass) {
                    item.cssclass += " " + attr.cssclass;
                }
                item.isNote = true;
                return item;
            };
            ElementAttributeFormBuilder.prototype.buildRichText = function (attr) {
                var item = { kind: "ds-attrib_richtext", value: this.valueExpression(attr.name), label: attr.text, singleLine: true, attrName: attr.name };
                item.cssclass = this.getCssClass(attr) || "";
                if (attr.cssclass) {
                    item.cssclass += " " + attr.cssclass;
                }
                return item;
            };
            ElementAttributeFormBuilder.prototype.buildHeadingSize = function (attr) {
                var item = { kind: "ds-attrib_titlesize", value: this.valueExpression(attr.name), label: attr.text };
                return item;
            };
            ElementAttributeFormBuilder.prototype.valueExpression = function (name) {
                if (this.usePrefix) {
                    return "m." + IDE.ElementAttributeModel.PROPERTY_PREFIX + name;
                }
                return "m." + name;
            };
            ElementAttributeFormBuilder.prototype.getCssClass = function (attr) {
                if (attr.cssclass) {
                    return attr.cssclass;
                }
                return this.nameCssMap[attr.name];
            };
            return ElementAttributeFormBuilder;
        })();
        IDE.ElementAttributeFormBuilder = ElementAttributeFormBuilder;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ElementAttributeModel = (function (_super) {
            __extends(ElementAttributeModel, _super);
            function ElementAttributeModel() {
                _super.call(this, null, { modelDef: null });
            }
            ElementAttributeModel.prototype.loadValues = function (attrList, elem) {
                var list = attrList.list;
                for (var i = 0; i < list.length; i++) {
                    var item = list[i];
                    this.set(ElementAttributeModel.PROPERTY_PREFIX + item.name, elem[item.name] || "");
                }
                var hTags = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
                if (hTags.indexOf(elem.kind) != -1) {
                    this.set(ElementAttributeModel.PROPERTY_PREFIX + "size", elem.kind[1]);
                }
            };
            ElementAttributeModel.prototype.getValues = function (attrList) {
                var values = {};
                var list = attrList.list;
                for (var i = 0; i < list.length; i++) {
                    var item = list[i];
                    values[item.name] = this.get(ElementAttributeModel.PROPERTY_PREFIX + item.name);
                }
                return values;
            };
            ElementAttributeModel.PROPERTY_PREFIX = "attr_";
            return ElementAttributeModel;
        })(Retool.ModelWithPrevious);
        IDE.ElementAttributeModel = ElementAttributeModel;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ElementEventCodeGenerator = (function () {
            function ElementEventCodeGenerator() {
            }
            ElementEventCodeGenerator.addEventCode = function (eventName) {
                IDE.activeDesigner.autoApplyAttributesDialog();
                var elementName = IDE.activeDesigner.attributeView.model.get(IDE.ElementAttributeModel.PROPERTY_PREFIX + "name");
                if (!elementName) {
                    return;
                }
                var section = IDE.activeDesigner.footer.getTemplateSection(IDE.activeDesigner.sourceTemplate.file.getFullName());
                if (!section) {
                    return;
                }
                IDE.activeDesigner.footer.select(section.id);
                if (IDE.activeDesigner.attributeView.context) {
                    var editor = section.editor;
                    if (editor) {
                        var methodDeclaration = elementName + '_' + eventName + '(';
                        if (editor.findCodeLine(methodDeclaration) < 0) {
                            var insertText = methodDeclaration + '){\n    // todo: add event code here\n  }';
                            var currentText = editor.getValue();
                            var i = currentText.lastIndexOf("}");
                            if (i == -1) {
                                currentText += '\n\n' + insertText;
                            }
                            else {
                                currentText = currentText.substr(0, i) + "\n  " + insertText + "\n" + currentText.substr(i);
                            }
                            editor.setValue(currentText);
                            // select controller code section
                            editor.scrollToLineContaining(methodDeclaration, { select: { start: 1, ch: 2, count: 1 } });
                        }
                        else {
                            editor.scrollToLineContaining(methodDeclaration);
                        }
                    }
                }
            };
            return ElementEventCodeGenerator;
        })();
        IDE.ElementEventCodeGenerator = ElementEventCodeGenerator;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ElementAttributeViewModel = (function () {
            function ElementAttributeViewModel() {
            }
            ElementAttributeViewModel.show = function (options) {
                var des = IDE.activeDesigner;
                var item = options.item;
                if (!des.isInspectorContent(des.sourceTemplate, item)) {
                    var validationError = des.autoApplyAttributesDialog();
                    if (validationError) {
                        return;
                    }
                    ;
                }
                $('#rto-viewInspectorContent li.rto-selected').removeClass('rto-selected');
                $('#rto-view-' + item["id"]).addClass('rto-selected');
                var viewModel;
                var model = new IDE.ElementAttributeModel();
                var attributeList = new IDE.ElementAttributeList();
                var getTemplate = function () {
                    if (model.get("is_component")) {
                        return IDE.Ide.sourceApp.components.getByFilename(model.get("view_name"));
                    }
                    else {
                        return IDE.Ide.sourceApp.templates.get(Retool.Url.filename(model.get("view_name")));
                    }
                };
                var actions = {
                    btnCancel_onclick: function (event) {
                        var titlebar = event.component.closest('titlebar');
                    },
                    btnCreatePartial_onclick: function (event) {
                        var id = model.get("id");
                        var url = Retool.Url.filename(model.get("view_name"));
                        var template = IDE.Ide.sourceApp.templates.get(url);
                        var location = IDE.activeDesigner.getComponentLocation(template.wrapper, id);
                        var pointer = IDE.activeDesigner.getElementPointer(template, id);
                        var done = function (partialName) {
                            var deleteCommand = new IDE.DeleteCommand(location, pointer.element);
                            deleteCommand.do(template);
                            IDE.activeDesigner.commandStack.add(deleteCommand);
                            var dropCommand = new IDE.ToolDropCommand(location, { kind: "r-outlet", href: partialName });
                            dropCommand.do(template);
                            IDE.activeDesigner.commandStack.add(dropCommand);
                            IDE.activeDesigner.saveFile(template.file);
                            IDE.activeDesigner.closeAttributesPanel();
                            IDE.activeDesigner.refreshViewInspector(true);
                            IDE.activeDesigner.refreshView();
                        };
                        IDE.Ide.render("template/create-partial", null, { element: pointer.element, done: done });
                    },
                    btnUpdate_onclick: function (event) {
                        var context = IDE.activeDesigner.attributeView.context;
                        var template = getTemplate();
                        var pointer = IDE.activeDesigner.getElementPointer(template, model.get("id"));
                        var newValues;
                        if (attributeList) {
                            newValues = model.getValues(attributeList);
                        }
                        else {
                            newValues = {};
                        }
                        var elem = pointer.element;
                        var hTags = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
                        if (hTags.indexOf(elem.kind) != -1) {
                            // is heading
                            elem.kind = "h" + newValues["size"];
                            newValues["size"] = null;
                        }
                        var command = new IDE.SetAttributesCommand(pointer.element, newValues);
                        command.do(template);
                        IDE.activeDesigner.commandStack.add(command);
                        IDE.activeDesigner.saveFile(template.file);
                        if (model.get("is_component")) {
                            var componentName = model.get("view_name");
                            IDE.Ide.sourceApp.components.wasModified(componentName);
                        }
                        model.copyToPreviousValues();
                        IDE.activeDesigner.refreshViewInspector(true);
                        IDE.activeDesigner.attributeView.showElementTitle(pointer.element);
                        IDE.activeDesigner.refreshView();
                        IDE.activeDesigner.attributeView.model.dirty = false;
                        IDE.activeDesigner.attributeView.updateDirty();
                    },
                    btnDelete_onclick: function (event) {
                        var template = getTemplate();
                        var id = model.get("id");
                        IDE.activeDesigner.viewInspector.deleteItem(id, template);
                        IDE.activeDesigner.closeAttributesPanel();
                        IDE.activeDesigner.refreshViewInspector(true);
                        IDE.activeDesigner.refreshView();
                    }
                };
                var kind = item["kind"];
                var helper = IDE.Ide.sourceApp.helpers.get(kind);
                if (kind != "text") {
                    attributeList.addTextProp("name", "Name");
                }
                helper.buildEditor(attributeList);
                if (kind != "text") {
                    attributeList.addTextProp("tabindex", "Tab Index");
                    attributeList.addRichText("data", "Data");
                    if (helper.settings.tourstop) {
                        attributeList.addTextProp("tourtext", "Tour Text");
                    }
                }
                var builder = new IDE.ElementAttributeFormBuilder(attributeList);
                builder.usePrefix = true;
                builder.toolbar = builder.createElementToolbar();
                var viewDef = builder.build();
                var viewDefinition = { elements: [viewDef], name: "attributes" };
                var viewFile = new Retool.FileSystem.File("attribute-editor", viewDefinition);
                var errorLog = new IDE.CompilerErrorLog();
                var template = IDE.TemplateCompiler.compile(IDE.Ide.ideApp, viewFile, IDE.Ide.ideApp.helpers, errorLog);
                viewModel = new IDE.ViewModels.ElementViewModel(null, template);
                viewModel.actions = actions;
                model.set("title", "Attributes");
                model.set("id", item["id"]);
                model.set("view_name", des.sourceTemplate.file.getFullName());
                model.set("is_component", des.sourceTemplate.isComponent);
                model.set("builder", builder);
                model.loadValues(attributeList, item);
                viewModel.model = model;
                var writer = new Retool.Writer("ds");
                model.dirty = false;
                var context = Retool.RenderingContext.createRoot(des.attributeView, template, viewModel);
                des.attributeView.context = context;
                des.attributeView.mode = "element.edit";
                des.attributeView.render(null);
                des.attributeView.showElementTitle(item);
                if (des.footer) {
                    var codeLineDisplayed = false;
                    if (kind == "r-content") {
                        var filename = item.src;
                        var file = IDE.Ide.sourceApp.getFile(filename);
                        if (file) {
                            IDE.activeDesigner.toolbox.actions.showGenericFile(filename, { contentOnly: true });
                        }
                    }
                    if (item.name) {
                        var code = item.name + "_";
                        var templateSection = des.footer.getTemplateSection(des.sourceTemplate.file.getFullName());
                        var templateCodeEditor = templateSection.editor;
                        if (options.shiftClick) {
                            var lineIndex = templateCodeEditor.findCodeLine(code);
                            if (lineIndex > -1) {
                                des.footer.select(templateSection.id);
                                templateCodeEditor.scrollToLineContaining(code, { flash: true });
                                codeLineDisplayed = true;
                            }
                        }
                        else if (des.footer.activeSection && des.footer.activeSection == templateSection) {
                            templateCodeEditor.scrollToLineContaining(code, { flash: true });
                            codeLineDisplayed = true;
                        }
                    }
                    if (item["model"] && !codeLineDisplayed) {
                        var itemModel = item["model"];
                        var dataMethod = "find"; // ??
                        var modelFile = IDE.Ide.sourceApp.models.getFile(itemModel);
                        if (modelFile) {
                            var modelCodeSection = des.getModelCodeSection();
                            if (modelCodeSection.sourceFile != modelFile) {
                                modelCodeSection.loadFile(modelFile);
                            }
                            var editor = modelCodeSection.editor;
                            var parenthesis = dataMethod.indexOf("(");
                            if (parenthesis != -1) {
                                dataMethod = dataMethod.substr(0, parenthesis);
                            }
                            var code = "function " + dataMethod + "(";
                            if (options.shiftClick) {
                                var lineIndex = editor.findCodeLine(code, true);
                                if (lineIndex > -1) {
                                    des.footer.select("model-code");
                                    editor.scrollToLineContaining(code, { caseInsensitive: true, flash: true });
                                    codeLineDisplayed = true;
                                }
                            }
                            else if (des.footer.visible) {
                                des.footer.select("model-code");
                                editor.scrollToLineContaining(code, { caseInsensitive: true });
                                codeLineDisplayed = true;
                            }
                        }
                    }
                }
                des.viewInspector.refreshToolbar();
            };
            return ElementAttributeViewModel;
        })();
        IDE.ElementAttributeViewModel = ElementAttributeViewModel;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var StaticDropdown = (function (_super) {
            __extends(StaticDropdown, _super);
            function StaticDropdown() {
                _super.apply(this, arguments);
                this.minCharsToTriggerDrop = 1;
            }
            StaticDropdown.prototype.toDisplay = function (value) {
                for (var i = 0; i < this.rows.length; i++) {
                    var row = this.rows[i];
                    if (row == value) {
                        return value;
                    }
                    if (row.id && row.id == value) {
                        return row.text;
                    }
                }
                return "";
            };
            StaticDropdown.prototype.hasFiltering = function () {
                return false;
            };
            StaticDropdown.prototype.getRowInfo = function (index) {
                var row = this.rows[index];
                return { id: row.id, text: row.text };
            };
            StaticDropdown.prototype.filterMatch = function (context, filter, index) {
                var row = this.rows[index];
                if (row.filter) {
                    return filter.matches(row.filter);
                }
                return filter.matches(row.text);
            };
            return StaticDropdown;
        })(Retool.DropdownRenderer);
        IDE.StaticDropdown = StaticDropdown;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var IconAutoComplete = (function (_super) {
            __extends(IconAutoComplete, _super);
            function IconAutoComplete() {
                _super.apply(this, arguments);
            }
            IconAutoComplete.prototype.toDisplay = function (value) {
                var icon = Retool.Icons[value];
                if (icon) {
                    return icon.text;
                }
                return "";
            };
            IconAutoComplete.prototype.renderRow = function (w, row) {
                var icon = row.icon;
                w.writeTag("a", null, { href: "#" });
                if (icon.font == "bootstrap") {
                    w.write('<span class="glyphicon glyphicon-' + icon.className + '""></span> &nbsp;');
                }
                w.text(icon.text);
                w.write('</a>');
            };
            IconAutoComplete.prototype.fetch = function (filter, done) {
                done(IconAutoComplete.rows);
            };
            IconAutoComplete.createRows = function () {
                var rows = [];
                for (var iconName in Retool.Icons) {
                    var icon = Retool.Icons[iconName];
                    rows.push({ id: iconName, text: icon.text, icon: icon });
                }
                return rows;
            };
            return IconAutoComplete;
        })(IDE.StaticDropdown);
        IDE.IconAutoComplete = IconAutoComplete;
        IconAutoComplete.rows = IconAutoComplete.createRows();
        Retool.addStaticAutoComplete("icons", IconAutoComplete);
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ModelListAutoComplete = (function (_super) {
            __extends(ModelListAutoComplete, _super);
            function ModelListAutoComplete() {
                _super.apply(this, arguments);
            }
            ModelListAutoComplete.prototype.toDisplay = function (value) {
                var model = IDE.Ide.sourceApp.models.getDefinition(value);
                if (model) {
                    return model.name;
                }
                else {
                    return value;
                }
            };
            ModelListAutoComplete.prototype.fetch = function (filter, done) {
                var rows = [];
                var models = ModelListAutoComplete.buildModelList();
                for (var i = 0; i < models.length; i++) {
                    var model = models[i];
                    rows.push({ id: model.id, text: model.id, filter: model.filter });
                }
                done(rows);
            };
            ModelListAutoComplete.prototype.filterMatch = function (context, filter, index) {
                var row = this.rows[index];
                return filter.matches(row.filter);
            };
            ModelListAutoComplete.prototype.renderRow = function (w, row) {
                w.writeTag("a", null, { href: "#" });
                w.writeTag("span", "glyph toolbox color1").write("O </span>");
                w.text(row.text);
                w.write('</a>');
            };
            ModelListAutoComplete.buildModelList = function () {
                var list = [];
                var folder = IDE.Ide.sourceApp.getFolder("models");
                if (folder) {
                    folder.forEachFolder(function (folder) {
                        folder.forEachFile(function (file) {
                            var fileType = Retool.FileSystem.FilePath.getType(file.getFullName());
                            if (fileType == 1 /* Model */) {
                                list.push(file.getFullName());
                            }
                        });
                    });
                    list.sort();
                }
                var models = [];
                for (var i = 0; i < list.length; i++) {
                    var filename = list[i];
                    var file = IDE.Ide.sourceApp.getFile(filename);
                    var modelDef = file.getContent();
                    var id = modelDef.name;
                    var text = modelDef.name;
                    models.push({ id: id, text: text, filter: modelDef.name });
                }
                return models;
            };
            return ModelListAutoComplete;
        })(Retool.DropdownRenderer);
        IDE.ModelListAutoComplete = ModelListAutoComplete;
        Retool.addStaticAutoComplete("models", ModelListAutoComplete);
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var FieldListAutoComplete = (function (_super) {
            __extends(FieldListAutoComplete, _super);
            function FieldListAutoComplete() {
                _super.apply(this, arguments);
            }
            FieldListAutoComplete.prototype.toDisplay = function (value) {
                return value;
            };
            FieldListAutoComplete.prototype.fetch = function (filter, done) {
                var rows = [];
                var modelDef;
                if (modelDef) {
                    for (var fieldId in modelDef.fields) {
                        rows.push({ id: fieldId, text: fieldId });
                    }
                }
                done(rows);
            };
            FieldListAutoComplete.prototype.renderRow = function (w, row) {
                w.writeTag("a", null, { href: "#" });
                w.writeTag("span", "glyph toolbox color2").write("L </span>");
                w.text(row.text);
                w.write('</a>');
            };
            return FieldListAutoComplete;
        })(IDE.StaticDropdown);
        IDE.FieldListAutoComplete = FieldListAutoComplete;
        Retool.addStaticAutoComplete("fields", FieldListAutoComplete);
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var VariableListAutoComplete = (function (_super) {
            __extends(VariableListAutoComplete, _super);
            function VariableListAutoComplete() {
                _super.apply(this, arguments);
            }
            VariableListAutoComplete.prototype.toDisplay = function (value) {
                return value;
            };
            VariableListAutoComplete.prototype.fetch = function (filter, done) {
                var rows = this.fetchViewModel();
                rows.sort();
                var out = [];
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    out.push({ id: row, text: row });
                }
                done(out);
            };
            VariableListAutoComplete.prototype.fetchViewModel = function () {
                var viewModel = IDE.Ide.getAppCanvas().viewModel;
                var rows = [];
                this.addProperties("this.", viewModel, rows);
                this.fetchLocalScope(rows);
                return rows;
            };
            VariableListAutoComplete.prototype.fetchLocalScope = function (rows) {
                var elementId = IDE.activeDesigner.attributeView.model.get("id");
                var pointer = IDE.activeDesigner.getElementPointer(IDE.activeDesigner.sourceTemplate, elementId);
                var elem = pointer.element;
                var scopeExpression = "";
                if (elem) {
                    var p = IDE.activeDesigner.getParentElement(elem);
                    var segments = [];
                    while (p) {
                        if (p.var) {
                            segments.push(p);
                        }
                        p = IDE.activeDesigner.getParentElement(p);
                    }
                    var value;
                    var rc = new Retool.RenderingContext(null, IDE.Ide.getAppCanvas().viewModel, null, null);
                    try {
                        while (segments.length) {
                            var p = segments.pop();
                            var scopeValue = rc.evaluateMethod(p._compiled["scope"]);
                            var source = this.addProperties(p.var + ".", scopeValue, rows);
                            rc = new Retool.RenderingContext(p.var, rc.viewModel, source, rc);
                        }
                    }
                    catch (e) {
                    }
                }
            };
            VariableListAutoComplete.prototype.addProperties = function (prefix, source, rows) {
                if (!source)
                    return;
                var attributes;
                if (Retool.App.isArrayModel(source)) {
                    if (source.getLength()) {
                        source = source.getRow(0);
                    }
                }
                else if (Array.isArray(source)) {
                    if (source.length) {
                        source = source[0];
                    }
                }
                if (Retool.App.isModel(source)) {
                    attributes = source.getAttributes();
                }
                else {
                    attributes = source.propertyValues;
                }
                for (var key in attributes) {
                    rows.push(prefix + key);
                }
                return source;
            };
            VariableListAutoComplete.prototype.renderRow = function (w, row) {
                w.writeTag("a", null, { href: "#" });
                if (row.isModelField) {
                    w.writeTag("span", "glyph toolbox color2").write("L </span>");
                    w.writeTag("span", "code-font").text(row.text).write('</span>');
                }
                else {
                    w.writeTag("span", "glyph toolbox color0").write("R </span>");
                    w.writeTag("span", "code-font").text(row.text).write('</span>');
                }
                w.write('</a>');
            };
            return VariableListAutoComplete;
        })(Retool.DropdownRenderer);
        IDE.VariableListAutoComplete = VariableListAutoComplete;
        Retool.addStaticAutoComplete("variables", VariableListAutoComplete);
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ControllerMethodAutoComplete = (function (_super) {
            __extends(ControllerMethodAutoComplete, _super);
            function ControllerMethodAutoComplete() {
                _super.apply(this, arguments);
            }
            ControllerMethodAutoComplete.prototype.toDisplay = function (value) {
                return value;
            };
            ControllerMethodAutoComplete.prototype.render = function (w) {
                var controllerFile;
                if (!controllerFile) {
                    return;
                }
                var fileSegments = controllerFile.path.split('/');
                var appName = fileSegments[1];
                var proto = Retool.ViewModel.tryCompile(controllerFile);
                if (proto) {
                    var methodList = [];
                    for (var methodName in proto.methods) {
                        methodList.push(methodName);
                    }
                    if (appName != "web") {
                        methodList.push("find");
                        methodList.push("query");
                    }
                    methodList.sort();
                    for (var i = 0; i < methodList.length; i++) {
                        var methodName = methodList[i];
                        this.renderOption(w, { value: methodName }, function () {
                            w.writeTag("span", "glyph toolbox color0").write("R </span>");
                            w.writeTag("span", "code-font").text(methodName + "()").write('</span>');
                        });
                    }
                }
            };
            return ControllerMethodAutoComplete;
        })(Retool.DropdownRenderer);
        IDE.ControllerMethodAutoComplete = ControllerMethodAutoComplete;
        Retool.addStaticAutoComplete("controllerMethod", ControllerMethodAutoComplete);
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var FieldTypeAutoComplete = (function (_super) {
            __extends(FieldTypeAutoComplete, _super);
            function FieldTypeAutoComplete() {
                _super.apply(this, arguments);
                this.minCharsToTriggerDrop = 1;
            }
            FieldTypeAutoComplete.prototype.toDisplay = function (value) {
                return value;
            };
            FieldTypeAutoComplete.prototype.fetch = function (filter, done) {
                var rows = [];
                for (var typeName in IDE.fieldTypes) {
                    var fieldType = IDE.fieldTypes[typeName];
                    rows.push({ id: typeName, text: fieldType.text });
                }
                var models = IDE.ModelListAutoComplete.buildModelList();
                for (var i = 0; i < models.length; i++) {
                    var model = models[i];
                    rows.push({ id: model.id, text: model.id, isModel: true, filter: model.filter });
                }
                done(rows);
            };
            FieldTypeAutoComplete.prototype.renderRow = function (w, row) {
                w.writeTag("a", null, { href: "#" });
                if (row.isModel) {
                    w.writeTag("span", "glyph toolbox color1").write("O </span>");
                    w.text(row.text);
                }
                else {
                    w.text(row.text);
                }
                w.write('</a>');
            };
            return FieldTypeAutoComplete;
        })(IDE.StaticDropdown);
        IDE.FieldTypeAutoComplete = FieldTypeAutoComplete;
        Retool.addStaticAutoComplete("fieldtypes", FieldTypeAutoComplete);
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        IDE.fieldTypes = {
            "string": { hasSize: true, defaultSize: 50, text: "string" },
            "boolean": { text: "boolean" },
            "date": { text: "date" },
            "datetime": { text: "datetime" },
            "email": { hasSize: true, defaultSize: 60, text: "email" },
            "integer": { text: "integer" },
            "money": { text: "money" },
            "number": { hasSize: true, defaultSize: 10, text: "number" },
            "objectid": { text: "objectid" },
            "phone": { hasSize: true, defaultSize: 30, text: "phone" },
            "picklist": { hasSize: true, defaultSize: 5, text: "picklist" },
            "text": { text: "text" },
            "url": { text: "url", hasSize: true, defaultSize: 80 }
        };
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var GenericAutoComplete = (function (_super) {
            __extends(GenericAutoComplete, _super);
            function GenericAutoComplete() {
                _super.apply(this, arguments);
            }
            GenericAutoComplete.prototype.toDisplay = function (value) {
                return value;
            };
            GenericAutoComplete.prototype.fetch = function (filter, done) {
                var rows = [];
                if (this.dropItems) {
                    for (var i = 0; i < this.dropItems.length; i++) {
                        var item = this.dropItems[i];
                        rows.push({ id: item, text: item });
                    }
                }
                done(rows);
            };
            return GenericAutoComplete;
        })(IDE.StaticDropdown);
        IDE.GenericAutoComplete = GenericAutoComplete;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        IDE.bootstrapClasses = [
            'active',
            'affix',
            'alert',
            'alert-danger',
            'alert-dismissable',
            'alert-info',
            'alert-link',
            'alert-success',
            'alert-warning',
            'arrow',
            'badge',
            'bottom',
            'breadcrumb',
            'btn',
            'btn-block',
            'btn-danger',
            'btn-default',
            'btn-group',
            'btn-group-justified',
            'btn-group-vertical',
            'btn-info',
            'btn-lg',
            'btn-link',
            'btn-primary',
            'btn-success',
            'btn-warning',
            'btn-xs',
            'caption',
            'caret',
            'carousel',
            'carousel-caption',
            'carousel-control',
            'carousel-indicators',
            'carousel-inner',
            'checkbox',
            'checkbox-inline',
            'close',
            'col',
            'col-lg-1',
            'col-lg-10',
            'col-lg-11',
            'col-lg-12',
            'col-lg-2',
            'col-lg-3',
            'col-lg-4',
            'col-lg-5',
            'col-lg-6',
            'col-lg-7',
            'col-lg-8',
            'col-lg-9',
            'col-lg-offset-0',
            'col-lg-offset-1',
            'col-lg-offset-10',
            'col-lg-offset-11',
            'col-lg-offset-2',
            'col-lg-offset-3',
            'col-lg-offset-4',
            'col-lg-offset-5',
            'col-lg-offset-6',
            'col-lg-offset-7',
            'col-lg-offset-8',
            'col-lg-offset-9',
            'col-lg-pull-0',
            'col-lg-pull-1',
            'col-lg-pull-10',
            'col-lg-pull-11',
            'col-lg-pull-2',
            'col-lg-pull-3',
            'col-lg-pull-4',
            'col-lg-pull-5',
            'col-lg-pull-6',
            'col-lg-pull-7',
            'col-lg-pull-8',
            'col-lg-pull-9',
            'col-lg-push-0',
            'col-lg-push-1',
            'col-lg-push-10',
            'col-lg-push-11',
            'col-lg-push-2',
            'col-lg-push-3',
            'col-lg-push-4',
            'col-lg-push-5',
            'col-lg-push-6',
            'col-lg-push-7',
            'col-lg-push-8',
            'col-lg-push-9',
            'col-md-1',
            'col-md-10',
            'col-md-11',
            'col-md-12',
            'col-md-2',
            'col-md-3',
            'col-md-4',
            'col-md-5',
            'col-md-6',
            'col-md-7',
            'col-md-8',
            'col-md-9',
            'col-md-offset-0',
            'col-md-offset-1',
            'col-md-offset-10',
            'col-md-offset-11',
            'col-md-offset-2',
            'col-md-offset-3',
            'col-md-offset-4',
            'col-md-offset-5',
            'col-md-offset-6',
            'col-md-offset-7',
            'col-md-offset-8',
            'col-md-offset-9',
            'col-md-pull-0',
            'col-md-pull-1',
            'col-md-pull-10',
            'col-md-pull-11',
            'col-md-pull-2',
            'col-md-pull-3',
            'col-md-pull-4',
            'col-md-pull-5',
            'col-md-pull-6',
            'col-md-pull-7',
            'col-md-pull-8',
            'col-md-pull-9',
            'col-md-push-0',
            'col-md-push-1',
            'col-md-push-10',
            'col-md-push-11',
            'col-md-push-2',
            'col-md-push-3',
            'col-md-push-4',
            'col-md-push-5',
            'col-md-push-6',
            'col-md-push-7',
            'col-md-push-8',
            'col-md-push-9',
            'col-sm-1',
            'col-sm-10',
            'col-sm-11',
            'col-sm-12',
            'col-sm-2',
            'col-sm-3',
            'col-sm-4',
            'col-sm-5',
            'col-sm-6',
            'col-sm-7',
            'col-sm-8',
            'col-sm-9',
            'col-sm-offset-1',
            'col-sm-offset-10',
            'col-sm-offset-11',
            'col-sm-offset-2',
            'col-sm-offset-3',
            'col-sm-offset-4',
            'col-sm-offset-5',
            'col-sm-offset-6',
            'col-sm-offset-7',
            'col-sm-offset-8',
            'col-sm-offset-9',
            'col-sm-pull-1',
            'col-sm-pull-10',
            'col-sm-pull-11',
            'col-sm-pull-2',
            'col-sm-pull-3',
            'col-sm-pull-4',
            'col-sm-pull-5',
            'col-sm-pull-6',
            'col-sm-pull-7',
            'col-sm-pull-8',
            'col-sm-pull-9',
            'col-sm-push-1',
            'col-sm-push-10',
            'col-sm-push-11',
            'col-sm-push-2',
            'col-sm-push-3',
            'col-sm-push-4',
            'col-sm-push-5',
            'col-sm-push-6',
            'col-sm-push-7',
            'col-sm-push-8',
            'col-sm-push-9',
            'col-xs-1',
            'col-xs-10',
            'col-xs-11',
            'col-xs-12',
            'col-xs-2',
            'col-xs-3',
            'col-xs-4',
            'col-xs-5',
            'col-xs-6',
            'col-xs-7',
            'col-xs-8',
            'col-xs-9',
            'collapse',
            'collapsing',
            'container',
            'control-label',
            'divider',
            'dropdown',
            'dropdown-backdrop',
            'dropdown-header',
            'dropdown-menu',
            'dropdown-toggle',
            'fade',
            'form-control',
            'form-control-static',
            'form-group',
            'glyphicon',
            'glyphicon-chevron-right',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'help-block',
            'hidden',
            'hidden-lg',
            'hidden-md',
            'hidden-print',
            'hidden-sm',
            'hidden-xs',
            'hide',
            'icon-bar',
            'icon-next',
            'img-circle',
            'img-responsive',
            'img-rounded',
            'img-thumbnail',
            'in',
            'initialism',
            'input-group',
            'input-group-addon',
            'input-group-btn',
            'input-lg',
            'input-sm',
            'invisible',
            'item',
            'jumbotron',
            'label',
            'label-danger',
            'label-default',
            'label-info',
            'label-primary',
            'label-success',
            'label-warning',
            'lead',
            'left',
            'list-group',
            'list-group-item',
            'list-group-item-heading',
            'list-group-item-text',
            'list-inline',
            'list-unstyled',
            'media',
            'media-body',
            'media-heading',
            'media-list',
            'media-object',
            'modal',
            'modal-backdrop',
            'modal-body',
            'modal-content',
            'modal-dialog',
            'modal-footer',
            'modal-header',
            'modal-open',
            'modal-title',
            'nav',
            'nav-divider',
            'nav-justified',
            'nav-tabs',
            'nav-tabs-justified',
            'navbar',
            'navbar-brand',
            'navbar-btn',
            'navbar-collapse',
            'navbar-default',
            'navbar-fixed-bottom',
            'navbar-fixed-top',
            'navbar-form',
            'navbar-header',
            'navbar-inverse',
            'navbar-left',
            'navbar-link',
            'navbar-nav',
            'navbar-right',
            'navbar-static-top',
            'navbar-text',
            'navbar-toggle',
            'next',
            'page-header',
            'pager',
            'pagination',
            'panel',
            'panel-body',
            'panel-danger',
            'panel-default',
            'panel-footer',
            'panel-heading',
            'panel-info',
            'panel-primary',
            'panel-success',
            'panel-title',
            'panel-warning',
            'pill-pane',
            'popover',
            'popover-content',
            'popover-title',
            'pre-scrollable',
            'prettyprint',
            'prev',
            'progress',
            'progress-bar',
            'progress-bar-danger',
            'progress-bar-info',
            'progress-bar-success',
            'progress-bar-warning',
            'pull-left',
            'pull-right',
            'right',
            'row',
            'show',
            'sr-only',
            'table',
            'table-bordered',
            'table-responsive',
            'text-center',
            'text-danger',
            'text-hide',
            'text-info',
            'text-left',
            'text-muted',
            'text-primary',
            'text-right',
            'text-success',
            'text-warning',
            'thumbnail',
            'tooltip',
            'tooltip-arrow',
            'tooltip-inner',
            'top',
            'visible-lg',
            'visible-md',
            'visible-print',
            'visible-sm',
            'visible-xs',
            'well',
            'well-lg',
            'well-sm'
        ];
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CssClassAutoComplete = (function (_super) {
            __extends(CssClassAutoComplete, _super);
            function CssClassAutoComplete() {
                _super.apply(this, arguments);
                this.minCharsToTriggerDrop = 1;
                this.closeOnSpaceBar = true;
            }
            CssClassAutoComplete.prototype.toDisplay = function (value) {
                return value;
            };
            CssClassAutoComplete.prototype.fetch = function (filter, done) {
                var rows = [];
                for (var i = 0; i < IDE.bootstrapClasses.length; i++) {
                    var value = IDE.bootstrapClasses[i];
                    rows.push({ id: value, text: value });
                }
                done(rows);
            };
            CssClassAutoComplete.prototype.renderRow = function (w, row) {
                w.writeTag("a", null, { href: "#" });
                w.writeTag("span", "glyph toolbox color3").write("` </span>");
                w.writeTag("span", "code-font").text(row.text).write('</span>');
                w.write('</a>');
            };
            CssClassAutoComplete.prototype.filterMatch = function (context, filter, index) {
                var row = this.rows[index];
                if (row.filter) {
                    return filter.matches(row.filter);
                }
                return filter.matches(row.text);
            };
            CssClassAutoComplete.prototype.getFilter = function (value) {
                if (value) {
                    var i = value.lastIndexOf(' ');
                    if (i != -1) {
                        value = value.substr(i + 1);
                    }
                }
                return new Retool.DropdownFilter(value);
            };
            CssClassAutoComplete.prototype.getRowInfo = function (index) {
                var value = IDE.bootstrapClasses[index];
                var inputElem = this.component.getElement("input");
                var currentValue = inputElem.val();
                if (currentValue) {
                    var i = currentValue.lastIndexOf(' ');
                    if (i != -1) {
                        value = currentValue.substr(0, i) + ' ' + value;
                    }
                }
                return { id: value, text: value };
            };
            return CssClassAutoComplete;
        })(IDE.StaticDropdown);
        IDE.CssClassAutoComplete = CssClassAutoComplete;
        Retool.addStaticAutoComplete("css", CssClassAutoComplete);
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Footer = (function () {
            function Footer() {
                this.jsConsoleHeight = 150;
            }
            Footer.prototype.init = function () {
                this.sections = [];
                this.sections.push(new IDE.TemplateCodeEditor(Footer.APP_MAIN_SECTION));
                this.sections.push(new IDE.ModelCodeEditor("model-code"));
                this.sections.push(new IDE.ControllerCodeEditor("controller-code"));
                this.sections.push(new IDE.CssFileEditor("css-code"));
                this.sections.push(new IDE.GenericFileEditor("generic-file"));
                var log = new IDE.LogSection("log");
                IDE.activeDesigner.executionLog = log;
                this.sections.push(log);
                //	this.sections.push(new ProjectSourceEditor("project-source"));
                this.jsConsole = new IDE.JSConsole("js-console");
                this.height = $(window).height() / 2;
                this.restoreHeight = this.height;
                this.visible = true;
            };
            Footer.prototype.render = function (w) {
                this.init();
                // var w = new Writer("ds");
                w.writeTag("div", "ide-panel", { id: "footer" });
                w.writeTag("div", "panel-sizer").write("</div>");
                //	w.writeTag("div",null,{id:"footer-splitter",style:"display:none"}).writeTag("div","vertical-handle").write('<div></div></div></div>');
                //	w.writeTag("div","designer-toggle",{id:"toggle"}).write('<span class="rto-glyph rto-toolbox"></span>');
                //	w.write('</div>');
                w.writeTag("div", "inner");
                this.renderNavBar(w);
                w.writeTag("div", "sections");
                for (var i = 0; i < this.sections.length; i++) {
                    var section = this.sections[i];
                    section.render(w);
                }
                w.write("</div>");
                w.write("</div>");
                this.jsConsole.render(w);
                w.write('</div>');
                // $('#rto-designer-bar').remove('#rto-footer');
                // w.appendToElement('#rto-designer-bar');
            };
            Footer.prototype.initializeSections = function () {
                for (var i = 0; i < this.sections.length; i++) {
                    var section = this.sections[i];
                    if (section.attachEvents) {
                        section.attachEvents();
                    }
                    section.initialize();
                }
                if (this.jsConsole.attachEvents) {
                    this.jsConsole.attachEvents();
                }
                this.jsConsole.initialize();
                if (this.jsConsoleVisible) {
                    $('#rto-js-console.rto-container').show().css('height', this.jsConsoleHeight);
                    this.jsConsole.activate();
                }
                this.setActiveSection(0);
            };
            Footer.prototype.getTemplateSection = function (templateName) {
                var id = Footer.APP_MAIN_SECTION;
                return this.getSection(id);
            };
            Footer.prototype.renderNavBar = function (w) {
                w.writeTag("div", "nav-buttons");
                for (var i = 0; i < this.sections.length; i++) {
                    var section = this.sections[i];
                    var css = "";
                    if (section.addSeparator) {
                        css = "sep";
                    }
                    w.writeTag("a", css, { href: "#" });
                    section.renderButton(w);
                    w.write("</a>");
                }
                /*
                w.writeTag("div","nav-buttons-right");
                
                
                
                
                
                
                w.writeTag("a","toggle-js-console",{href:"#"}).text(">").write('</a>');
                w.writeTag("a","debug-resume",{href:"#"}).text("Resume").write('</a>');
                w.writeTag("a","debug-singlestep",{href:"#"}).text("Step").write('</a>');
                w.writeTag("a","show-opcodes",{href:"#"}).text("Opcode").write('</a>');
                w.writeTag("a","hide-footer",{href:"#"}).text("Hide").write('</a>');
    
                
                w.write('</div>');
                */
                w.write('<div style="clear:both"></div>');
                w.write("</div>");
            };
            Footer.prototype.onNavButtonClick = function (e) {
                var target = $(e.target).closest('a');
                /*
                if (target.hasClass('rto-hide-footer') || (target.hasClass('active') && this.visible)){
                    this.hide();
                    return;
                }
                */
                if (target.hasClass('rto-toggle-js-console')) {
                    this.toggleJSConsole();
                    return;
                }
                if (target.hasClass('rto-debug-singlestep')) {
                    this.singleStep();
                    return;
                }
                if (target.hasClass('rto-debug-resume')) {
                    this.debugResume();
                    return;
                }
                var index = target.index();
                this.setActiveSection(index);
            };
            Footer.prototype.singleStep = function () {
                var controller = this.getSection("controller-code");
                if (controller) {
                    var proc = controller.editor.debugInfo.proc;
                    controller.editor.clearCurrentDebugLine();
                    proc.debugStepInto();
                }
            };
            Footer.prototype.debugResume = function () {
                var controller = this.getSection("controller-code");
                if (controller) {
                    var proc = controller.editor.debugInfo.proc;
                    controller.editor.clearCurrentDebugLine();
                    proc.debugResume();
                }
            };
            Footer.prototype.toggleJSConsole = function () {
                this.jsConsoleVisible = !this.jsConsoleVisible;
                if (this.jsConsoleVisible) {
                    $('#rto-js-console').show();
                    this.jsConsole.activate();
                    $('#rto-console-splitter').css('bottom', (this.jsConsoleHeight) + "px").show();
                }
                else {
                    $('#rto-js-console').hide();
                    $('#rto-console-splitter').hide();
                }
                this.resize();
            };
            Footer.prototype.select = function (sectionId, options) {
                for (var i = 0; i < this.sections.length; i++) {
                    var section = this.sections[i];
                    if (section.id == sectionId) {
                        this.setActiveSection(i, options);
                        return section;
                    }
                }
                return null;
            };
            Footer.prototype.setActiveSection = function (index, options) {
                $('#rto-footer-splitter').show();
                if (this.jsConsoleVisible) {
                    $('#rto-console-splitter').show();
                }
                var buttons = $('#rto-footer .rto-nav-buttons').children();
                buttons.removeClass('active').eq(index).addClass('active');
                var sections = $('#rto-footer .rto-sections').children();
                sections.hide();
                sections.eq(index).show();
                var section = this.sections[index];
                section.activate({});
                this.activeSection = section;
                this.show(options);
            };
            Footer.prototype.show = function (options) {
                return;
                if (!this.visible) {
                    this.height = this.restoreHeight;
                }
                if (options) {
                    if (options.fullHeight) {
                        this.height = $(window).height();
                    }
                }
                this.visible = true;
                $('#rto-footer').removeClass('rto-hidden');
                $('body').addClass('ide-footer-open');
                IDE.activeDesigner.resize();
            };
            Footer.prototype.resize = function () {
                var self = this;
                if (self.visible && self.activeSection) {
                    self.activeSection.resize();
                }
                return;
                var windowHeight = $(window).height();
                if (this.height > windowHeight) {
                    this.height = windowHeight;
                }
                if (this.height < 36) {
                    this.height = 36;
                }
                var consoleHeight = (this.jsConsoleVisible) ? this.jsConsoleHeight : 0;
                $('#rto-footer .rto-inner').css('height', (this.height - consoleHeight) + "px");
                if (this.visible) {
                    $('#rto-footer').css('height', this.height + "px");
                    // $('#rto-footer .rto-container').get(0).scrollTop = 99999;
                    $('#rto-bottom-pad').css('height', this.height + "px"); // set padding so scroll works
                }
                else {
                    $('#rto-footer').css('height', '');
                    $('#rto-bottom-pad').css('height', 40); // set padding so scroll works
                }
                var self = this;
                if (self.visible && self.activeSection) {
                    self.activeSection.resize();
                }
                $('#rto-js-console').css('height', consoleHeight + "px");
                this.jsConsole.resize();
            };
            Footer.prototype.getSection = function (id) {
                for (var i = 0; i < this.sections.length; i++) {
                    var section = this.sections[i];
                    if (section.id == id) {
                        return section;
                    }
                }
                return null;
            };
            Footer.prototype.hide = function () {
                return;
                if (this.visible) {
                    if (this.height < $(window).height() - 10) {
                        this.restoreHeight = this.height;
                    }
                }
                this.visible = false;
                var buttons = $('#rto-footer .rto-nav-buttons').children();
                buttons.removeClass('active');
                $('#rto-footer').addClass('rto-hidden');
                if (this.activeSection) {
                    this.activeSection.deactivate();
                }
                $('#rto-footer-splitter').hide();
                $('#rto-console-splitter').hide();
                $('body').removeClass('ide-footer-open');
                IDE.activeDesigner.resize();
            };
            Footer.prototype.getConsoleContainer = function (mode) {
                if (mode == "interactve") {
                    return $('#rto-interactive');
                }
                else {
                    return $('#rto-console');
                }
            };
            Footer.prototype.attachEvents = function () {
                var self = this;
                $(document).on('click', '#rto-footer .rto-nav-buttons a', function (e) {
                    e.preventDefault();
                    self.onNavButtonClick(e);
                });
                $(document).on('click', '.rto-toggle-ide', function (event) {
                    event.preventDefault();
                    IDE.activeDesigner.toggle();
                });
                $('#rto-footer').on('mouseenter', "[tooltip]", function (event) {
                    IDE.activeDesigner.showTooltip({ elem: this, text: $(this).attr('tooltip') });
                });
                $('#rto-footer').on('mouseleave', "[tooltip]", function (event) {
                    IDE.activeDesigner.hideTooltip();
                });
                $('#rto-footer').on('mousedown', "[tooltip]", function (event) {
                    IDE.activeDesigner.hideTooltip();
                });
            };
            Footer.prototype.showConsole = function (options) {
            };
            Footer.prototype.codeSnippetDragStart = function (e) {
                e.originalEvent.dataTransfer.effectAllowed = 'move';
                var target = $(e.target).closest('div');
                e.originalEvent.dataTransfer.setData('text', target.data("snippet"));
            };
            Footer.prototype.codeSnippetDragEnd = function (e) {
                // this.codeEditor.hideDropPlaceHolder();
            };
            Footer.prototype.onViewChange = function () {
                for (var i = 0; i < this.sections.length; i++) {
                    var section = this.sections[i];
                    if (section.onViewChange) {
                        section.onViewChange.apply(section);
                    }
                }
            };
            Footer.prototype.clearConsole = function () {
                var section = this.activeSection;
                if (section && section.clearConsole) {
                    section.clearConsole();
                }
            };
            Footer.APP_SECTION = "app";
            Footer.APP_MAIN_SECTION = "app-main";
            return Footer;
        })();
        IDE.Footer = Footer;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ConsoleSection = (function () {
            function ConsoleSection() {
            }
            ConsoleSection.prototype.render = function (w) {
                w.writeTag("div", "container hide-for-small", { id: this.id, style: "display:none" });
                this.renderSplitter(w);
                w.writeTag("div", "output").write('</div>');
                w.writeTag("div", "command-line").writeTag("div", "command-prompt");
                w.text(this.promptChar).write('</div>');
                w.writeTag("div", "line-editor", { id: this.id + "-editor" }).write("</div>");
                w.write('</div>');
                w.write('</div>');
                // w.write('</footer>');
            };
            ConsoleSection.prototype.renderSplitter = function (w) {
            };
            ConsoleSection.prototype.renderButton = function (w) {
                w.text(this.promptChar);
            };
            ConsoleSection.prototype.resize = function () {
            };
            ConsoleSection.prototype.activate = function (options) {
                var editor = this.editor;
                if (editor) {
                    editor.activate();
                    if (options && options.text) {
                        editor.setValue(options.text);
                    }
                    editor.focusToEnd();
                }
                /*
                if (options && options.help){
                    var w = new Writer("ds");
                    w.writeTag("div","command-help").text("hint: " + options.help).write('</div>');
                    w.appendToElement(container.find('.rto-output'));
                }
                */
            };
            ConsoleSection.prototype.initialize = function () {
            };
            ConsoleSection.prototype.deactivate = function () {
                this.editor.deactivate();
            };
            return ConsoleSection;
        })();
        IDE.ConsoleSection = ConsoleSection;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CodeEditorSection = (function () {
            function CodeEditorSection() {
            }
            CodeEditorSection.prototype.render = function (w) {
                this.renderCodeEditor(w, this.id + "-editor");
            };
            CodeEditorSection.prototype.renderButton = function (w) {
                w.writeTag("span", null, { id: this.id + "-btn" }).text(this.label).write("</span>");
            };
            CodeEditorSection.prototype.renderCodeEditor = function (w, id, visible) {
                w.writeTag("div", "container code-editor", { style: (!visible) ? "display:none" : "" });
                //this.renderCodeEditorTools(w);
                w.writeTag("div", "code-content", { id: id });
                //w.writeTag("div","c-scriptedit-snippets",{id:"code-content_snippets",style:"display:none"});
                //w.writeTag("div","c-designtoolboxitem",{draggable:"true","data-rto-snippet":"sendemail"}).write('Send Email</div>');
                //w.write('</div>'); // snippeted
                w.write('</div>'); // code-content
                w.write('</div>'); //code-editor
            };
            CodeEditorSection.prototype.codeHasChanges = function (currentValue, newValue) {
                var v1 = currentValue || null;
                var v2 = newValue || null;
                return v1 != v2;
            };
            CodeEditorSection.prototype.renderCodeEditorTools = function (w) {
                w.writeTag("div", "c-debugcontrol");
                w.writeTag("div", "c-debugcontrol-snippets").write('</div>');
                w.writeTag("div", "c-debugcontrol-right");
                w.writeTag("div", "c-debugcontrol-continue").write('</div>');
                w.writeTag("div", "c-debugcontrol-stepover").write('</div>');
                w.writeTag("div", "c-debugcontrol-stepinto").write('</div>');
                w.writeTag("div", "c-debugcontrol-stepout").write('</div>');
                w.writeTag("div", "c-debugcontrol-clearbreak").write('</div>');
                w.write('</div>'); // right
                w.write('</div>');
            };
            CodeEditorSection.prototype.resize = function () {
                if (this.editor.widgetContainer) {
                    var codeContent = this.editor.widgetContainer.closest('.rto-code-content');
                    var container = codeContent.closest('.rto-container');
                    // codeContent.css('height',container.height());
                    this.editor.setSize(codeContent.width(), codeContent.height());
                }
            };
            CodeEditorSection.prototype.activate = function (options) {
                this.resize();
                var initialized = this.editor.isInitialized();
                this.editor.activate();
                var self = this;
            };
            CodeEditorSection.prototype.loadFile = function (file) {
            };
            CodeEditorSection.prototype.initialize = function () {
                this.editor.activate();
                this.onInitialize();
            };
            CodeEditorSection.prototype.deactivate = function () {
                this.editor.deactivate();
            };
            CodeEditorSection.prototype.onInitialize = function () {
            };
            return CodeEditorSection;
        })();
        IDE.CodeEditorSection = CodeEditorSection;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ControllerCodeEditor = (function (_super) {
            __extends(ControllerCodeEditor, _super);
            function ControllerCodeEditor(id) {
                _super.call(this);
                this.id = id;
                var self = this;
                var codeEditor = new IDE.CodeEditor({
                    id: "rto-" + this.id + "-editor",
                    mode: "javascript",
                    onChange: function (value) {
                        if (self.sourceFile) {
                            var controllerDef = self.sourceFile.getContent();
                            if (self.codeHasChanges(controllerDef.source_code, value)) {
                                controllerDef.source_code = value;
                                self.sourceFile.requiresCompile = true;
                                IDE.activeDesigner.saveFile(self.sourceFile, false);
                            }
                        }
                    },
                    onGetSuggestions: function (prefix) {
                        var segments = prefix.split('.');
                        if (prefix && prefix[0] >= 'A' && prefix[0] <= 'Z') {
                            return IDE.CodeCompletePopup.forStatic(prefix);
                        }
                        if (segments.length == 1 && self.sourceFile) {
                            var controllerDef = self.sourceFile.getContent();
                            var modelPrototype = Retool.ViewModel.tryCompile(self.sourceFile);
                            if (modelPrototype) {
                                return IDE.CodeCompletePopup.forController(controllerDef, modelPrototype);
                            }
                        }
                        return null;
                    }
                });
                this.editor = codeEditor;
                this.label = "";
            }
            ControllerCodeEditor.prototype.loadFile = function (file) {
                if (file != this.sourceFile) {
                    this.sourceFile = file;
                    this.loadContent();
                }
            };
            ControllerCodeEditor.prototype.loadContent = function () {
                var sourceCode = "";
                var label = "";
                var file = this.sourceFile;
                var icon = {};
                if (file) {
                    var controllerDef = file.getContent();
                    label = "api/" + controllerDef.name + ".js";
                    label = label.toLowerCase();
                    icon = IDE.FileIcons.Api;
                    sourceCode = controllerDef.source_code;
                }
                this.editor.setValue(sourceCode || "");
                // label += " { }";
                var w = new Retool.Writer();
                w.write('<span class="rto-glyph rto-toolbox rto-color' + icon.color + '">' + icon.glyph + '</span> <span>').text(label).write('</span>');
                if (file) {
                    $('#rto-' + this.id + '-btn').html(w.getStream()).closest('a').show();
                }
                else {
                    $('#rto-' + this.id + '-btn').closest('a').hide();
                }
            };
            ControllerCodeEditor.prototype.onInitialize = function () {
                this.sourceFile = null;
                $('#rto-' + this.id + '-btn').closest('a').hide();
                //this.loadContent();
            };
            ControllerCodeEditor.prototype.onViewChange = function () {
                return;
                var view = IDE.activeDesigner.sourceTemplate;
                if (view) {
                    var file = null; // model file
                    if (file) {
                        this.loadFile(file);
                        return;
                    }
                }
                this.sourceFile = null;
                this.loadContent();
            };
            return ControllerCodeEditor;
        })(IDE.CodeEditorSection);
        IDE.ControllerCodeEditor = ControllerCodeEditor;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ModelCodeEditor = (function (_super) {
            __extends(ModelCodeEditor, _super);
            function ModelCodeEditor(id) {
                _super.call(this);
                this.id = id;
                var self = this;
                var codeEditor = new IDE.CodeEditor({
                    id: "rto-" + this.id + "-editor",
                    mode: "javascript",
                    onChange: function (value) {
                        if (self.sourceFile) {
                            var modelDef = self.sourceFile.getContent();
                            if (self.codeHasChanges(modelDef.source_code, value)) {
                                modelDef.source_code = value;
                                self.sourceFile.requiresCompile = true;
                                IDE.activeDesigner.saveFile(self.sourceFile, false);
                            }
                        }
                    },
                    onGetSuggestions: function (prefix) {
                        var segments = prefix.split('.');
                        if (prefix && prefix[0] >= 'A' && prefix[0] <= 'Z') {
                            return IDE.CodeCompletePopup.forStatic(prefix);
                        }
                        if (segments.length == 1 && self.sourceFile) {
                            var modelDef = self.sourceFile.getContent();
                            var modelPrototype = Retool.ViewModel.tryCompile(self.sourceFile);
                            if (modelPrototype) {
                                return IDE.CodeCompletePopup.forModel(modelDef, modelPrototype);
                            }
                        }
                        return null;
                    }
                });
                this.editor = codeEditor;
                this.label = "";
            }
            ModelCodeEditor.prototype.loadFile = function (file) {
                if (file != this.sourceFile) {
                    this.sourceFile = file;
                    this.loadContent();
                }
            };
            ModelCodeEditor.prototype.loadContent = function () {
                var sourceCode = "";
                var label = "";
                var file = this.sourceFile;
                var icon = {};
                if (file) {
                    var modelDef = file.getContent();
                    label = "models/" + modelDef.name + ".js";
                    label = label.toLowerCase();
                    icon = (modelDef.exposed) ? IDE.FileIcons.ModelExposed : IDE.FileIcons.Model;
                    sourceCode = modelDef.source_code;
                }
                this.editor.setValue(sourceCode || "");
                // label += " { }";
                var w = new Retool.Writer();
                w.write('<span class="rto-glyph rto-toolbox rto-color' + icon.color + '">' + icon.glyph + '</span> <span>').text(label).write('</span>');
                if (file) {
                    $('#rto-' + this.id + '-btn').html(w.getStream()).closest('a').show();
                }
                else {
                    $('#rto-' + this.id + '-btn').closest('a').hide();
                }
            };
            ModelCodeEditor.prototype.onInitialize = function () {
                this.sourceFile = null;
                $('#rto-' + this.id + '-btn').closest('a').hide();
                //this.loadContent();
            };
            ModelCodeEditor.prototype.onViewChange = function () {
                return;
                var view = IDE.activeDesigner.sourceTemplate;
                if (view) {
                    var file = null; // model file
                    if (file) {
                        this.loadFile(file);
                        return;
                    }
                }
                this.sourceFile = null;
                this.loadContent();
            };
            return ModelCodeEditor;
        })(IDE.CodeEditorSection);
        IDE.ModelCodeEditor = ModelCodeEditor;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var JSConsole = (function (_super) {
            __extends(JSConsole, _super);
            function JSConsole(id) {
                _super.call(this);
                this.id = id;
                var self = this;
                var editor = new IDE.CodeEditor({
                    id: "rto-" + this.id + "-editor",
                    boundingBoxId: 'rto-footer',
                    mode: "javascript",
                    singleLine: true,
                    onEnterKey: function (commandValue) {
                        self.lastCommand = commandValue;
                        self.execute(commandValue);
                    },
                    onReplay: function () {
                        return self.lastCommand;
                    },
                    onGetSuggestions: function (prefix) {
                        var popup = new IDE.CodeCompletePopup(prefix);
                        return popup.getPropertyList();
                    }
                });
                this.editor = editor;
                this.promptChar = ">";
                IDE.activeDesigner.jsConsole = this;
            }
            JSConsole.prototype.renderSplitter = function (w) {
                w.writeTag("div", null, { id: "console-splitter", style: "display:none" }).writeTag("div", "vertical-handle").write('<div></div></div></div>');
            };
            JSConsole.prototype.execute = function (text) {
                var w = new Retool.Writer("ds");
                if (text == "") {
                    return;
                }
                if (text[0] == '@') {
                    this.executeSystemCommand(text);
                    return;
                }
                var prompt = ">";
                var container = $('#rto-' + this.id);
                w.write('<div class="rto-prompt"><span>').text(prompt).write('</span>').text(text).write('</div>');
                var templateCodeEditor = IDE.activeDesigner.footer.getSection(IDE.Footer.APP_MAIN_SECTION);
                var localProperties;
                if (templateCodeEditor.editor && templateCodeEditor.editor.debugInfo) {
                    localProperties = templateCodeEditor.editor.debugInfo.proc.currentCall.localProperties;
                }
                try {
                    var viewModel = IDE.Ide.getAppCanvas().viewModel;
                    this.executeVMMethod({ w: w, expression: text, viewModel: viewModel, localProperties: localProperties });
                }
                catch (e) {
                    w.write('<div class="rto-error">').text(e + "").write('</div>');
                }
                w.appendToElement(container.find('.rto-output'));
                this.writePrompt();
            };
            JSConsole.prototype.executeVMMethod = function (options) {
                var canvas = IDE.Ide.getAppCanvas();
                var target = options.viewModel;
                target.myPrototype = Retool.ViewModel.getCompiledPrototype(target.file);
                var exprClass = IDE.JavascriptCompiler.compileClass("", "function e(){return " + options.expression + ";}");
                var methodInfo = exprClass.methods["e"];
                var viewModel = options.viewModel;
                var proc = Retool.VM.createProcess(canvas);
                proc.viewModel = viewModel;
                var w = options.w;
                proc.onException = function (err) {
                    w.write('<div class="rto-error">').text(err + "").write('</div>');
                };
                var startOptions = { target: target, methodInfo: methodInfo, localProperties: options.localProperties };
                proc.onComplete = function (result) {
                    if (canvas) {
                        canvas.refreshRenderedComponents({});
                    }
                    w.write('<div>').text(result + "").write('</div>');
                };
                proc.start(startOptions);
            };
            JSConsole.prototype.clear = function () {
                var container = $('#rto-' + this.id);
                container.find('.rto-output').html('');
            };
            JSConsole.prototype.writePrompt = function () {
                var prompt = ">";
                var container = $('#rto-' + this.id);
                container.get(0).scrollTop = 99999;
                container.find('.rto-command-prompt').text(prompt);
                var promptWidth = container.find('.rto-command-prompt').width();
                container.find('.rto-command-line').css('padding-left', (promptWidth) + 'px');
                container.get(0).scrollTop = 99999;
            };
            JSConsole.prototype.writeOutput = function (w) {
                var container = $('#rto-' + this.id);
                w.appendToElement(container.find('.rto-output'));
            };
            JSConsole.prototype.executeSystemCommand = function (text) {
                if (text == "@clear") {
                    this.clear();
                }
                else {
                    var w = new Retool.Writer("ds");
                    w.write('<div>').text("Unknown system command: " + text).write('</div>');
                    this.writeOutput(w);
                }
                this.writePrompt();
            };
            JSConsole.prototype.log = function (text) {
                var container = $('#rto-' + this.id);
                var w = new Retool.Writer("ds");
                w.writeTag("div", null).text(text + "").write('</div>');
                w.appendToElement(container.find('.rto-output'));
            };
            return JSConsole;
        })(IDE.ConsoleSection);
        IDE.JSConsole = JSConsole;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CssFileEditor = (function (_super) {
            __extends(CssFileEditor, _super);
            function CssFileEditor(id) {
                _super.call(this);
                this.id = id;
                var self = this;
                var editor = new IDE.CodeEditor({
                    id: "rto-" + id + "-editor",
                    mode: "css",
                    onChange: function (value) {
                        var file = self.sourceFile;
                        if (file) {
                            var fileContent = file.getContent();
                            var currentCss = (fileContent) ? fileContent : null;
                            if (!currentCss && !value) {
                                return; // both are empty
                            }
                            if (currentCss != value) {
                                file.setContent(value);
                                IDE.activeDesigner.saveFile(file, false);
                                var name = "/" + file.getFullName();
                                var styles = $(Retool.App.document).find('head style');
                                for (var i = 0; i < styles.length; i++) {
                                    var style = $(styles[i]);
                                    if (style.data("file") == name) {
                                        style.html(value);
                                    }
                                }
                            }
                        }
                    },
                    onGetSuggestions: function (prefix) {
                        return null;
                    }
                });
                this.editor = editor;
                this.label = "";
            }
            CssFileEditor.prototype.loadFile = function (file) {
                if (file != this.sourceFile) {
                    this.sourceFile = file;
                    this.loadContent();
                }
            };
            CssFileEditor.prototype.loadContent = function () {
                var sourceCode = "";
                var label = "";
                var file = this.sourceFile;
                if (file) {
                    label = file.name;
                    sourceCode = file.getContent();
                }
                this.editor.setValue(sourceCode || "");
                // label += " { }";
                var w = new Retool.Writer();
                w.write('<span class="rto-glyph rto-toolbox rto-color3">`</span> <span>').text(label).write('</span>');
                if (file) {
                    $('#rto-' + this.id + '-btn').html(w.getStream()).closest('a').show();
                }
                else {
                    $('#rto-' + this.id + '-btn').closest('a').hide();
                }
            };
            CssFileEditor.prototype.onInitialize = function () {
                this.sourceFile = null;
                $('#rto-' + this.id + '-btn').closest('a').hide();
            };
            return CssFileEditor;
        })(IDE.CodeEditorSection);
        IDE.CssFileEditor = CssFileEditor;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var UtilitiesSection = (function () {
            function UtilitiesSection(id) {
                this.id = id;
            }
            UtilitiesSection.prototype.render = function (w) {
                w.writeTag("div", "container", { id: "footer-" + this.id });
                w.write('<h1>Utilities</h1>');
                w.write('<h3>Deploy</h3>');
                w.writeTag("div", "util-section");
                var loc = window.location;
                w.text("Url ").writeTag("input", null, { type: "text", id: "deploy-url", style: "border:solid 1px #999;width:400px;margin-left:20px;margin-right:20px", value: loc.protocol + "//" + loc.host });
                w.writeTag("a", "button", { href: "#", "data-action": "deploy" }).text("Deploy Site").write('</a> ');
                w.writeTag("a", null, { href: "#", "data-action": "migrate" }).text("Migrate Database").write("</a> ");
                w.writeTag("div", "action-result").write('</div>');
                w.write('</div>');
                w.write('<h3>Import</h3>');
                w.writeTag("div", "util-section");
                w.write('<input id="rto-import-app-file" type="file" size="10">');
                w.writeTag("a", "button", { href: "#", "data-action": "import-app" }).text("Import Application").write('</a>');
                w.write('<br><br>');
                w.write('<input id="rto-import-site-file" type="file" size="10">');
                w.writeTag("a", "button", { href: "#", "data-action": "import-site" }).text("Import Site").write('</a>');
                w.writeTag("div", "action-result").write('</div>');
                w.write('</div>');
                w.write('<h3>Export</h3>');
                w.writeTag("div", "util-section");
                w.text("App Folder");
                w.writeTag("input", null, { type: "text", id: "export-app", style: "border:solid 1px #999;width:400px;margin-left:20px;margin-right:20px" });
                w.writeTag("a", "button", { href: "#", "data-action": "export-app" }).text("Export Application").write('</a>');
                w.writeTag("div", "action-result").write('</div>');
                w.write("<br><br>");
                w.writeTag("a", null, { href: "#", "data-action": "export-site" }).text("Export Site").write("</a>");
                w.write("<br><br>");
                w.writeTag("a", null, { href: "#", "data-action": "export-dashboard-app" }).text("Export Dashboard App").write("</a>");
                w.write("<br>");
                w.writeTag("a", null, { href: "#", "data-action": "export-admin-app" }).text("Export Admin App").write("</a>");
                w.write("<br>");
                w.writeTag("a", null, { href: "#", "data-action": "export-shared" }).text("Export Shared Folder").write("</a>");
                w.write('</div>');
                w.write('</div>');
            };
            UtilitiesSection.prototype.activate = function (options) {
            };
            UtilitiesSection.prototype.initialize = function () {
            };
            UtilitiesSection.prototype.deactivate = function () {
            };
            UtilitiesSection.prototype.renderButton = function (w) {
                w.text("Utilities");
            };
            UtilitiesSection.prototype.resize = function () {
            };
            UtilitiesSection.prototype.doAction = function (action) {
                if (action == "export-dashboard-app") {
                    var packageBuilder = new IDE.Util.DeployPackageBuilder({});
                    var dashboardSource = null; // packageBuilder.exportDashboard();
                    $('#rto-footer-' + this.id + " textarea").val(dashboardSource).show();
                    this.downloadEcho({
                        filename: "system_dashboard.js",
                        content: dashboardSource
                    });
                }
                else if (action == "export-admin-app") {
                    var packageBuilder = new IDE.Util.DeployPackageBuilder({});
                    var dashboardSource = null; // packageBuilder.exportAdminApps();
                    $('#rto-footer-' + this.id + " textarea").val(dashboardSource).show();
                    this.downloadEcho({
                        filename: "system_admin.js",
                        content: dashboardSource
                    });
                }
                else if (action == "deploy") {
                    var input = $('#rto-deploy-url');
                    var url = input.val();
                    var packageBuilder = new IDE.Util.DeployPackageBuilder({ siteMapUrl: url });
                    var pkg = packageBuilder.build();
                    var self = this;
                    packageBuilder.send({
                        url: url,
                        body: pkg,
                        success: function (response) {
                            self.showSuccess(input, "**" + url + "** upgraded to version: **" + response.result.version + "**");
                        },
                        error: function (response) {
                            self.showErrorResponse(input, response);
                        }
                    });
                }
                else if (action == "migrate") {
                }
                else if (action == "export-app") {
                }
                else if (action == "export-site") {
                    this.exportSite();
                }
                else if (action == "export-shared") {
                    this.exportShared();
                }
                else if (action == "import-app") {
                    this.importApplication();
                }
                else if (action == "import-site") {
                    this.importSite();
                }
            };
            UtilitiesSection.prototype.showSuccess = function (selector, text) {
                var w = new Retool.Writer("ds");
                w.writeTag("div", "action-success").prettyText(text).write("</div>");
                $(selector).closest('.rto-util-section').find('.rto-action-result').html(w.getStream());
            };
            UtilitiesSection.prototype.showErrorResponse = function (selector, response) {
                if (response.exception) {
                    this.showError(selector, response.exception.message);
                }
                else if (response.error) {
                    var w = new Retool.Writer("ds");
                    w.writeTag("div", "action-error");
                    for (var i = 0; i < response.error.general.length; i++) {
                        if (i > 0) {
                            w.write('<br>');
                        }
                        w.text(response.error.general[i]);
                    }
                    w.write('</div>');
                    $(selector).closest('.rto-util-section').find('.rto-action-result').html(w.getStream());
                }
            };
            UtilitiesSection.prototype.showError = function (selector, error) {
                var w = new Retool.Writer("ds");
                w.writeTag("div", "action-error").prettyText(error).write("</div>");
                $(selector).closest('.rto-util-section').find('.rto-action-result').html(w.getStream());
            };
            UtilitiesSection.prototype.attachEvents = function () {
                var self = this;
                $('#rto-footer-' + this.id).on('click', 'a', function (e) {
                    self.doAction($(this).data("action"));
                    e.preventDefault();
                });
            };
            UtilitiesSection.prototype.sendData = function (params) {
                var self = this;
                var settings = {
                    "type": params.type,
                    "url": params.url,
                    "dataType": 'json',
                    "contentType": "application/json",
                    "headers": params.headers,
                    crossDomain: true,
                    processData: false,
                    cache: false,
                    success: function (data, a, xhr) {
                        params.success(data);
                    },
                    error: function (xhr, b, c) {
                        params.error(xhr.responseText);
                    }
                };
                if (params.data) {
                    settings["data"] = JSON.stringify(params.data);
                }
                $.ajax(settings);
            };
            UtilitiesSection.prototype.importApplication = function () {
                var input = $('#rto-import-app-file');
                var inputFile = input.get(0);
                var file = inputFile.files[0];
                var reader = new FileReader();
                var self = this;
                reader.onload = function (evt) {
                    var content;
                    var target = evt.target;
                    try {
                        content = JSON.parse(target.result);
                    }
                    catch (e) {
                        self.showError(input, "Unable to import, file does not contain valid json.");
                        return;
                    }
                    IDE.ImportUtils.importFilePkg({ content: content, success: function (fileList) {
                        self.showSuccess(input, "Imported folder: **" + content.root + "**, " + fileList.length.toString() + " files imported.");
                    }, error: function (err) {
                        self.showError(input, err);
                        return;
                    } });
                };
                reader.onerror = function (evt) {
                    self.showError(input, 'Error reading file');
                };
                reader.readAsText(file, "UTF-8");
            };
            UtilitiesSection.prototype.exportShared = function () {
                var input = $('#rto-export-app');
                var packageBuilder = new IDE.Util.DeployPackageBuilder({});
                var content;
                try {
                    var list = [];
                    var sharedFolder = IDE.Ide.sourceApp.getFolder("/shared");
                    Retool.App.exportFolder(sharedFolder, list);
                    content = { app_folder: "$shared", files: list };
                }
                catch (e) {
                    this.showError(null, e);
                    return;
                }
                this.downloadEcho({
                    filename: "shared.js",
                    content: JSON.stringify(content),
                    successMessage: "Exported shared folder",
                    input: input
                });
            };
            UtilitiesSection.prototype.downloadEcho = function (options) {
                var self = this;
                var request = new Retool.Request({ type: "data" });
                request.add({ className: "echoFile", method: "getToken", args: { "content": btoa(options.content), "content_disposition": "attachment" }, success: function (data) {
                    var href = Retool.Url.domain("admin").href("/!echofile/" + options.filename + "?token=" + encodeURIComponent(data.result.token));
                    var w = new Retool.Writer();
                    w.write('<a').writeAttr("id", "get-file").writeAttr("href", href.toDisplay()).write('>Get File</a>');
                    $('body').append(w.getStream());
                    $('#get-file').get(0).click();
                    $('#get-file').remove();
                    if (options.input) {
                        self.showSuccess(options.input, options.successMessage);
                    }
                    if (options.success) {
                        options.success();
                    }
                }, error: function (data) {
                    if (options.error) {
                        options.error(data);
                    }
                } });
                request.execute();
            };
            UtilitiesSection.prototype.exportSite = function () {
                var input = $('#rto-export-app');
                var appFolder = input.val();
                var packageBuilder = new IDE.Util.DeployPackageBuilder({});
                var content;
                try {
                    content = packageBuilder.exportSite();
                }
                catch (e) {
                    this.showError(input, e);
                    return;
                }
                this.downloadEcho({
                    filename: location.hostname + "-site.js",
                    content: JSON.stringify(content),
                    successMessage: "Exported site **" + location.hostname + "-site.js" + "**",
                    input: input
                });
            };
            UtilitiesSection.prototype.importSite = function () {
                var input = $('#rto-import-site-file');
                var inputFile = input.get(0);
                var file = inputFile.files[0];
                var reader = new FileReader();
                var self = this;
                reader.onload = function (evt) {
                    var content;
                    var target = evt.target;
                    try {
                        content = JSON.parse(target.result);
                    }
                    catch (e) {
                        self.showError(input, "Unable to import, file does not contain valid json.");
                        return;
                    }
                    if (!content || !content.length) {
                        alert('Not a site file.');
                        return;
                    }
                    var appsFolder = IDE.Ide.sourceApp.getFolder("apps");
                    if (!appsFolder.isEmpty()) {
                        self.showError(input, 'Cannot import, this site already contains applications');
                        return;
                    }
                    var filesToSave = [];
                    for (var i = 0; i < content.length; i++) {
                        var pkgFile = content[i];
                        var file = new Retool.FileSystem.File(pkgFile.id, pkgFile.value);
                        filesToSave.push(file);
                    }
                    IDE.activeDesigner.saveFileBatch(filesToSave);
                    for (var i = 0; i < filesToSave.length; i++) {
                        var newFile = filesToSave[i];
                        IDE.Ide.sourceApp.addFile(newFile);
                        console.log("Creating " + newFile.path + "/" + newFile.name + " ...");
                    }
                    self.showSuccess(input, "Imported site: " + filesToSave.length.toString() + " files imported.");
                };
                reader.onerror = function (evt) {
                    self.showError(input, 'Error reading file');
                };
                reader.readAsText(file, "UTF-8");
            };
            return UtilitiesSection;
        })();
        IDE.UtilitiesSection = UtilitiesSection;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var LogSection = (function () {
            function LogSection(id) {
                this.id = id;
                this.logEntries = [];
            }
            LogSection.prototype.render = function (w) {
                w.writeTag("div", "container execution-log", { id: "footer-" + this.id, style: "display:none" });
                w.writeTag("div", "toolbar");
                w.writeTag("a", "", { href: "#", "data-action": "Clear" }).text("Clear").write("</a>");
                w.write("</div>");
                w.writeTag("ul", null);
                w.write("</ul>");
                w.write('</div>');
            };
            LogSection.prototype.activate = function (options) {
            };
            LogSection.prototype.initialize = function () {
            };
            LogSection.prototype.deactivate = function () {
            };
            LogSection.prototype.renderButton = function (w) {
                w.writeTag("span", null);
                w.text("Log");
                w.write("</span>");
            };
            LogSection.prototype.resize = function () {
            };
            LogSection.prototype.add = function (items) {
                this.logEntries.push(item);
                var w = new Retool.Writer("ds");
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    this.renderRequestEntry(w, item);
                }
                w.appendToElement($('#rto-footer-' + this.id + " > ul"));
            };
            LogSection.prototype.renderRequestEntry = function (w, item) {
                var css = (item.request.method == "CALL") ? "client" : "server";
                w.writeTag("li", "log-request " + css);
                w.writeTag("div", "req-url").writeTag("strong", null).text(item.request.method).write("</strong> ").text(item.request.url).write("</div>");
                if (item.response) {
                    w.writeTag("div", null).writeTag("strong", null).text("Status:").write("</strong> ");
                    if (item.response.statusCode >= 200 && item.response.statusCode <= 299) {
                        w.writeTag("span", "status-ok").write("</span>");
                    }
                    else {
                        w.writeTag("span", "status-fail").write("</span>");
                    }
                    w.text(item.response.statusCode);
                    w.writeTag("strong", null).write(" Time:</strong> ").text(item.time + "ms").write("</div>");
                }
                w.writeTag("div", "toggle-section collapsed");
                w.writeTag("a", "toggle-show", { href: "#", "data-action": "Show" }).text("Show Details").write('</a>');
                w.writeTag("div", "toggle-content").writeTag("a", "toggle-hide", { href: "#", "data-action": "Hide" }).text("Hide Details").write('</a>');
                if (item.request.headers) {
                    w.write("<h4>Request Headers</h4>");
                    w.writeTag("div", "req-headers");
                    for (var key in item.request.headers) {
                        w.writeTag("strong", null).text(key + ":").write("</strong> ").text(item.request.headers[key]).write("<br>");
                    }
                    w.write("</div>");
                }
                if (item.request.body) {
                    w.write("<h4>Request Body</h4>");
                    w.text(item.request.body);
                    w.write("</div>");
                }
                if (item.response) {
                    if (item.response.headers) {
                        w.write("<h4>Response Headers</h4>");
                        w.writeTag("div", "res-headers");
                        for (var key in item.response.headers) {
                            w.writeTag("strong", null).text(key + ":").write("</strong> ").text(item.response.headers[key]).write("<br>");
                        }
                        w.write("</div>");
                    }
                    w.writeTag("div", "res-body");
                    w.write("<h4>Response Body</h4>");
                    w.text(item.response.body);
                    w.write("</div>");
                }
                w.write("</div>");
                w.write("</li>");
            };
            LogSection.prototype.actionShow = function ($this) {
                $this.closest('.rto-toggle-section').removeClass('rto-collapsed');
            };
            LogSection.prototype.actionHide = function ($this) {
                $this.closest('.rto-toggle-section').addClass('rto-collapsed');
            };
            LogSection.prototype.actionClear = function ($this) {
                $('#rto-footer-' + this.id + " > ul").html("");
                return;
            };
            LogSection.prototype.attachEvents = function () {
                var self = this;
                $('#rto-footer-' + this.id).on('click', 'a', function (e) {
                    var $this = $(this);
                    var method = "action" + $this.data("action");
                    self[method].apply(self, [$this]);
                    e.preventDefault();
                });
            };
            return LogSection;
        })();
        IDE.LogSection = LogSection;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var TemplateCodeEditor = (function (_super) {
            __extends(TemplateCodeEditor, _super);
            function TemplateCodeEditor(id) {
                _super.call(this);
                this.id = id;
                var self = this;
                var codeEditor = new IDE.CodeEditor({
                    id: "rto-" + this.id + "-editor",
                    mode: "javascript",
                    save: function (value) {
                        // execute save
                    },
                    onChange: function (value) {
                        if (self.sourceFile) {
                            var viewDef = self.sourceFile.getContent();
                            if (self.codeHasChanges(viewDef.source_code, value)) {
                                viewDef.source_code = value;
                                self.sourceFile.requiresCompile = true;
                                if (self.isCustomComponent) {
                                }
                                else {
                                    IDE.Ide.sourceApp.templateChanged(self.sourceFile.getFullName());
                                }
                                IDE.activeDesigner.saveFile(self.sourceFile, false);
                            }
                        }
                    },
                    onGetSuggestions: function (prefix) {
                        var list;
                        Retool.App.ignoreErrors();
                        var filename = self.sourceFile.getFullName();
                        var template = IDE.Ide.sourceApp.templates.getByFilename(filename);
                        var currentLine = self.editor.editor.getCursor().line;
                        var code = self.editor.editor.getValue();
                        var lines = code.split('\n');
                        lines[currentLine] = "";
                        code = lines.join('\n');
                        var hints = self.codeComplete.getHints(template, prefix, code);
                        Retool.App.popErrors();
                        return hints;
                    }
                });
                this.editor = codeEditor;
                this.label = "{ } Api";
            }
            TemplateCodeEditor.prototype.loadFile = function (file) {
                if (file != this.sourceFile) {
                    var info = file.getInfo();
                    if (info.name && info.name[0] == "_") {
                        // isPartial so no code
                        file = null;
                    }
                    this.sourceFile = file;
                    this.loadContent();
                }
            };
            TemplateCodeEditor.prototype.loadContent = function () {
                var sourceCode = "";
                var label = "";
                var file = this.sourceFile;
                if (file) {
                    var info = file.getInfo();
                    if (info.extension == "com") {
                        this.isCustomComponent = true;
                    }
                    else {
                        this.isCustomComponent = false;
                    }
                    var label = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(file.getFullName());
                    var viewDef = file.getContent();
                    sourceCode = viewDef.source_code;
                }
                this.editor.setValue(sourceCode || "");
                //label += " { }";
                var w = new Retool.Writer();
                var icon = this.getIcon();
                w.write('<span class="rto-glyph rto-toolbox rto-color' + icon.color + '">' + icon.glyph + '</span> <span>').text(label).write('</span>');
                if (file) {
                    $('#rto-' + this.id + '-btn').html(w.getStream()).closest('a').show();
                }
                else {
                    $('#rto-' + this.id + '-btn').closest('a').hide();
                }
                this.codeComplete = new IDE.TemplateCodeComplete();
            };
            TemplateCodeEditor.prototype.getIcon = function () {
                if (this.isCustomComponent) {
                    return IDE.FileIcons.Component;
                }
                return { glyph: ")", color: "0" };
            };
            TemplateCodeEditor.prototype.onInitialize = function () {
                this.onViewChange();
            };
            TemplateCodeEditor.prototype.onViewChange = function () {
                if (IDE.activeDesigner.sourceTemplate) {
                    var view = IDE.activeDesigner.sourceTemplate;
                    if (view) {
                        var file = view.file;
                        if (file) {
                            this.loadFile(file);
                            return;
                        }
                    }
                }
                this.sourceFile = null;
                this.loadContent();
            };
            return TemplateCodeEditor;
        })(IDE.CodeEditorSection);
        IDE.TemplateCodeEditor = TemplateCodeEditor;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ProjectSourceEditor = (function (_super) {
            __extends(ProjectSourceEditor, _super);
            function ProjectSourceEditor(id) {
                _super.call(this);
                this.id = id;
                var self = this;
                var editor = new IDE.CodeEditor({
                    id: "rto-" + id + "-editor",
                    mode: "css",
                    onChange: function (value) {
                    },
                    onGetSuggestions: function (prefix) {
                        return null;
                    }
                });
                this.editor = editor;
                this.label = "";
            }
            ProjectSourceEditor.prototype.load = function () {
                var s = this.getContent();
                this.loadContent(s);
            };
            ProjectSourceEditor.prototype.getContent = function () {
                var files = IDE.Ide.sourceApp.volume.fileData;
                var templateSerializer = new Retool.Transformers.TemplateSerializer();
                var s = "";
                for (var key in files) {
                    var data = files[key];
                    s += '<script type="text/retool" name="' + key + '">\n';
                    var fileType = Retool.FileSystem.FilePath.getType(key);
                    if (fileType == 0 /* Template */) {
                        var url = Retool.Url.filename(key);
                        var template = IDE.Ide.sourceApp.templates.get(url);
                        s += templateSerializer.serialize(template.definition);
                    }
                    s += '\n</script>\n\n';
                }
                return s;
            };
            ProjectSourceEditor.prototype.loadContent = function (sourceCode) {
                var label = "source.html";
                this.editor.setValue(sourceCode || "");
                // label += " { }";
                var w = new Retool.Writer();
                w.write('<span class="rto-glyph rto-toolbox rto-color3">`</span> <span>').text(label).write('</span>');
                $('#rto-' + this.id + '-btn').html(w.getStream()).closest('a').show();
            };
            ProjectSourceEditor.prototype.activate = function (options) {
                this.editor.setValue(this.getContent());
                _super.prototype.activate.call(this, options);
            };
            ProjectSourceEditor.prototype.onInitialize = function () {
                this.load();
            };
            return ProjectSourceEditor;
        })(IDE.CodeEditorSection);
        IDE.ProjectSourceEditor = ProjectSourceEditor;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var GenericFileEditor = (function (_super) {
            __extends(GenericFileEditor, _super);
            function GenericFileEditor(id) {
                _super.call(this);
                this.refreshDelay = 100;
                this.id = id;
                var self = this;
                var editor = new IDE.CodeEditor({
                    id: "rto-" + id + "-editor",
                    mode: "css",
                    onChange: function (value) {
                        var file = self.sourceFile;
                        if (file) {
                            var currentContent = file.getContent();
                            if (!currentContent && !value) {
                                return; // both are empty
                            }
                            if (currentContent !== value) {
                                file.setContent(value);
                                file.requiresCompile = true;
                                file.version++;
                                if (self.autoRefreshView && !self.timer) {
                                    self.timer = setTimeout(function () {
                                        self.timer = null;
                                        IDE.activeDesigner.saveFile(file, false);
                                        var canvas = IDE.Ide.getAppCanvas();
                                        canvas.refreshRenderedComponents({});
                                        //activeDesigner.refreshView();
                                    }, self.refreshDelay);
                                }
                            }
                        }
                    },
                    onGetSuggestions: function (prefix) {
                        return null;
                    }
                });
                this.editor = editor;
                this.label = "";
            }
            GenericFileEditor.prototype.loadFile = function (file) {
                if (file != this.sourceFile) {
                    this.sourceFile = file;
                    this.loadContent();
                }
            };
            GenericFileEditor.prototype.loadContent = function () {
                var sourceCode = "";
                var file = this.sourceFile;
                if (file) {
                    sourceCode = file.getContent();
                }
                this.editor.setValue(sourceCode || "");
                this.autoRefreshView = false;
                // label += " { }";
                if (file) {
                    var filename = file.getFullName();
                    var label = filename;
                    var w = new Retool.Writer();
                    var ext = Retool.FileSystem.PathInfo.getExtension(filename);
                    if (ext == "txt" || ext == "md") {
                        this.autoRefreshView = true;
                    }
                    if (ext == "md") {
                        this.editor.setMode("gfm");
                    }
                    else if (ext == "json" || ext == "js") {
                        this.editor.setMode("javascript");
                    }
                    else {
                        this.editor.setMode("");
                    }
                    var icon = IDE.FileIcons.forExtension(ext);
                    w.write('<span class="rto-glyph rto-toolbox rto-color' + icon.color + '">' + icon.glyph + '</span> <span>').text(label).write('</span>');
                    $('#rto-' + this.id + '-btn').html(w.getStream()).closest('a').show();
                }
                else {
                    $('#rto-' + this.id + '-btn').closest('a').hide();
                }
            };
            GenericFileEditor.prototype.onInitialize = function () {
                this.sourceFile = null;
                $('#rto-' + this.id + '-btn').closest('a').hide();
            };
            return GenericFileEditor;
        })(IDE.CodeEditorSection);
        IDE.GenericFileEditor = GenericFileEditor;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CodeMirrorMixedMode = (function () {
            function CodeMirrorMixedMode() {
            }
            CodeMirrorMixedMode.initialize = function () {
                CodeMirror.multiplexingMode = function (outer /*, others */) {
                    // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects
                    var others = Array.prototype.slice.call(arguments, 1);
                    var n_others = others.length;
                    function indexOf(string, pattern, from) {
                        if (typeof pattern == "string")
                            return string.indexOf(pattern, from);
                        var m = pattern.exec(from ? string.slice(from) : string);
                        return m ? m.index + from : -1;
                    }
                    return {
                        startState: function () {
                            return {
                                outer: CodeMirror.startState(outer),
                                innerActive: null,
                                inner: null
                            };
                        },
                        copyState: function (state) {
                            return {
                                outer: CodeMirror.copyState(outer, state.outer),
                                innerActive: state.innerActive,
                                inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)
                            };
                        },
                        findScript: function (src, pos) {
                            while (pos < src.length) {
                                var ch = src[pos++];
                                if (ch == "{" && pos <= src.length && src[pos] == "{") {
                                    return pos - 1;
                                }
                                else {
                                    if (ch == "\\" && pos <= src.length && src[pos] == "{") {
                                        pos++;
                                    }
                                }
                            }
                            return -1;
                        },
                        scanScript: function (src, pos) {
                            var curly = 0;
                            var expr = "";
                            while (pos < src.length) {
                                var ch = src[pos++];
                                if (ch == "{") {
                                    curly++;
                                }
                                else if (ch == "}") {
                                    curly--;
                                    if (curly < 0) {
                                        return pos - 1;
                                    }
                                }
                                if (ch == "\'" || ch == "\"") {
                                    pos = this.scanLiteral(ch, src, pos);
                                }
                            }
                            return -1;
                        },
                        scanLiteral: function (q, src, pos) {
                            while (pos < src.length) {
                                var ch = src[pos++];
                                if (ch == "\\") {
                                    pos++;
                                }
                                else if (ch == q) {
                                    return pos;
                                }
                            }
                            return pos;
                        },
                        token: function (stream, state) {
                            if (!state.innerActive) {
                                var cutOff = Infinity, oldContent = stream.string;
                                for (var i = 0; i < n_others; ++i) {
                                    var other = others[i];
                                    //var found = indexOf(oldContent, other.open, stream.pos);
                                    var found = this.findScript(oldContent, stream.pos);
                                    if (found == stream.pos) {
                                        stream.match(other.open);
                                        state.innerActive = other;
                                        state.inner = CodeMirror.startState(other.mode, outer.indent ? outer.indent(state.outer, "") : 0);
                                        return other.delimStyle;
                                    }
                                    else if (found != -1 && found < cutOff) {
                                        cutOff = found;
                                    }
                                }
                                if (cutOff != Infinity)
                                    stream.string = oldContent.slice(0, cutOff);
                                var outerToken = outer.token(stream, state.outer);
                                if (cutOff != Infinity)
                                    stream.string = oldContent;
                                return outerToken;
                            }
                            else {
                                var curInner = state.innerActive, oldContent = stream.string;
                                if (!curInner.close && stream.sol()) {
                                    state.innerActive = state.inner = null;
                                    return this.token(stream, state);
                                }
                                if (typeof stream.found === "undefined") {
                                    stream.found = curInner.close ? this.scanScript(oldContent, stream.pos) : -1;
                                }
                                var found = stream.found;
                                //var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos) : -1;
                                if (found != -1) {
                                    stream.found = found;
                                }
                                if (found == stream.pos) {
                                    stream.match(curInner.close);
                                    state.innerActive = state.inner = null;
                                    delete stream.found;
                                    return curInner.delimStyle;
                                }
                                if (found > -1)
                                    stream.string = oldContent.slice(0, found);
                                var innerToken = curInner.mode.token(stream, state.inner);
                                if (found > -1)
                                    stream.string = oldContent;
                                if (curInner.innerStyle) {
                                    if (innerToken)
                                        innerToken = innerToken + ' ' + curInner.innerStyle;
                                    else
                                        innerToken = curInner.innerStyle;
                                }
                                return innerToken;
                            }
                        },
                        indent: function (state, textAfter) {
                            var mode = state.innerActive ? state.innerActive.mode : outer;
                            if (!mode.indent)
                                return CodeMirror.Pass;
                            return mode.indent(state.innerActive ? state.inner : state.outer, textAfter);
                        },
                        blankLine: function (state) {
                            var mode = state.innerActive ? state.innerActive.mode : outer;
                            if (mode.blankLine) {
                                mode.blankLine(state.innerActive ? state.inner : state.outer);
                            }
                            if (!state.innerActive) {
                                for (var i = 0; i < n_others; ++i) {
                                    var other = others[i];
                                    if (other.open === "\n") {
                                        state.innerActive = other;
                                        state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, "") : 0);
                                    }
                                }
                            }
                            else if (state.innerActive.close === "\n") {
                                state.innerActive = state.inner = null;
                            }
                        },
                        electricChars: outer.electricChars,
                        innerMode: function (state) {
                            return state.inner ? { state: state.inner, mode: state.innerActive.mode } : { state: state.outer, mode: outer };
                        }
                    };
                };
                CodeMirror.defineMode("mixedmode", function () {
                    var inner = CodeMirror.getMode({}, "text/typescript");
                    var outer = CodeMirror.getMode({}, "");
                    var innerOptions = {
                        open: '{{',
                        close: '}}',
                        mode: inner,
                        delimStyle: 'delim',
                        innerStyle: 'inner'
                    };
                    return CodeMirror.multiplexingMode(outer, innerOptions);
                });
            };
            return CodeMirrorMixedMode;
        })();
        IDE.CodeMirrorMixedMode = CodeMirrorMixedMode;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Generators;
        (function (Generators) {
            var TemplateGenerator = (function () {
                function TemplateGenerator(name, modelDef) {
                    this.modelDef = modelDef;
                    this.name = name;
                }
                TemplateGenerator.prototype.generate = function () {
                    return null;
                };
                return TemplateGenerator;
            })();
            Generators.TemplateGenerator = TemplateGenerator;
        })(Generators = IDE.Generators || (IDE.Generators = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Generators;
        (function (Generators) {
            var Home = (function (_super) {
                __extends(Home, _super);
                function Home() {
                    _super.apply(this, arguments);
                }
                Home.prototype.generate = function () {
                    var vb = new IDE.ViewBuilder("");
                    vb.add({ kind: "h2", text: "Home Page" });
                    return vb.definition;
                };
                return Home;
            })(Generators.TemplateGenerator);
            Generators.Home = Home;
        })(Generators = IDE.Generators || (IDE.Generators = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Generators;
        (function (Generators) {
            var Blank = (function (_super) {
                __extends(Blank, _super);
                function Blank() {
                    _super.apply(this, arguments);
                }
                Blank.prototype.generate = function () {
                    var vb = new IDE.ViewBuilder("");
                    var text = Retool.Inflection.titleize(this.name);
                    vb.add({ kind: "h1", text: text });
                    return vb.definition;
                };
                return Blank;
            })(Generators.TemplateGenerator);
            Generators.Blank = Blank;
        })(Generators = IDE.Generators || (IDE.Generators = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var IDERoute = (function () {
            function IDERoute(path, viewModelConstructor, view) {
                this.path = path;
                this.viewModelConstructor = viewModelConstructor;
                this.view = view;
            }
            return IDERoute;
        })();
        IDE.IDERoute = IDERoute;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ElementAttributeView = (function (_super) {
            __extends(ElementAttributeView, _super);
            function ElementAttributeView() {
                _super.call(this, "iea");
                this.app = IDE.Ide.ideApp;
            }
            ElementAttributeView.prototype.isElementEdit = function () {
                return this.mode == "element.edit";
            };
            ElementAttributeView.prototype.render = function (w) {
                var context = this.context;
                var viewModel = context.viewModel;
                this.model = viewModel.model;
                this.context = context;
                $('#rto-attributes-apply').addClass('rto-inactive');
                var w = new Retool.Writer("ds");
                this.updateDirty();
                this.model.copyToPreviousValues();
                this.renderContent(w);
                w.writeToElement('#rto-attributes-content');
                $('#rto-attributes').show();
            };
            ElementAttributeView.prototype.updateDirty = function () {
                if (this.model && this.model.dirty) {
                    $('#rto-attributes-apply').removeClass('rto-inactive');
                }
                else {
                    $('#rto-attributes-apply').addClass('rto-inactive');
                }
            };
            ElementAttributeView.prototype.show = function (template, viewModel) {
                this.context = Retool.RenderingContext.createRoot(this, template, viewModel);
                this.mode = "";
                this.render(null);
                var title = viewModel.get_title(viewModel.model);
                this.renderTitle(title);
                IDE.activeDesigner.viewInspector.refreshToolbar();
            };
            ElementAttributeView.prototype.renderTitle = function (options) {
                var w = new Retool.Writer("ds");
                if (options.icon) {
                    var font = options.icon.font || "toolbox";
                    w.writeTag("span", "glyph " + font + " color" + options.icon.color).write(options.icon.glyph).write(' </span>');
                }
                if (options.text) {
                    var text = options.text;
                    w.writeTag("span", "m-label");
                    this.writeElementKind(w, options.label, options.helper);
                    w.write(' </span> ');
                    var path = "";
                    var item = "";
                    var i = text.lastIndexOf('.');
                    if (i == -1) {
                        i = text.lastIndexOf('/');
                    }
                    if (i != -1) {
                        path = text.substr(0, i + 1);
                        item = text.substr(i + 1);
                    }
                    else {
                        item = text;
                    }
                    if (path.length >= 2 && (path.substr(0, 2) == "g/" || path.substr(0, 2) == "g.")) {
                        path = path.substr(2);
                    }
                    w.writeTag("span", "path").text(path).write('</span>');
                    w.text(item);
                }
                else {
                    w.writeTag("span", "m-label notext");
                    this.writeElementKind(w, options.label, options.helper);
                    w.write(' </span>');
                }
                if (options.eventList && options.eventList.length) {
                    this.writeCodeDropMenu(w, options.eventList);
                }
                w.writeToElement('#' + Retool.makeDomId('attributes-title'));
                var css = (options.css) ? w.makeClassList(options.css) : "";
                $('#' + Retool.makeDomId('attributes-title')).attr('class', css);
            };
            ElementAttributeView.prototype.writeCodeDropMenu = function (w, eventList) {
                w.writeTag("div", "!dropdown add-code-drop").writeTag("a", null, { href: "#", "data-drop-toggle": "true", tooltip: "Add event code" }).writeTag("span", "glyph toolbox").text("P").write('</span></a>');
                w.writeTag("ul", "!dropdown-menu !pull-right");
                for (var i = 0; i < eventList.length; i++) {
                    var item = eventList[i];
                    w.writeTag('li', null).writeTag("a", null, { href: "#", "data-item": item, "data-action": "addevent" }).text(item).write('</a></li>');
                }
                w.write('</ul>');
                w.write('</div>');
            };
            ElementAttributeView.prototype.writeElementKind = function (w, label, helper) {
                if (helper && helper.settings.isCustom) {
                    w.writeTag("a", null, { href: "#", "data-comp": helper.settings.kind }).text(label).write('</a>');
                }
                else {
                    w.text(label);
                }
            };
            ElementAttributeView.prototype.showElementTitle = function (item) {
                var helper = IDE.Ide.sourceApp.helpers.get(item["kind"]);
                var color = (helper.settings.command) ? "0" : "8";
                var icon = { glyph: helper.settings.glyph || "r", color: color, font: "toolbox" };
                var elementInfo = helper.getInspectorInfo(item);
                var kindLabel = helper.settings.label || item.kind;
                var contentText = (elementInfo.text || item.name || "");
                if (contentText.length > 30) {
                    contentText = contentText.substr(0, 30) + "...";
                    if (contentText[0] == '"') {
                        contentText += '"';
                    }
                }
                var eventList = [];
                helper.getSupportedEvents(eventList);
                this.renderTitle({ label: kindLabel, text: contentText, icon: icon, eventList: eventList, helper: helper });
            };
            ElementAttributeView.prototype.createWriter = function () {
                return new Retool.Writer("ds");
            };
            return ElementAttributeView;
        })(Retool.Canvas);
        IDE.ElementAttributeView = ElementAttributeView;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var IDEDialog = (function (_super) {
            __extends(IDEDialog, _super);
            function IDEDialog() {
                _super.call(this, "idl");
                this.app = IDE.Ide.ideApp;
            }
            IDEDialog.prototype.render = function (w) {
                var dialog = $('#rto-ide-dialog');
                if (!dialog.length) {
                    this.renderContainer();
                }
                var context = this.context;
                var viewModel = context.viewModel;
                var template = context.template;
                var model = viewModel.model;
                this.initViewModel(viewModel);
                if (model) {
                    model.copyToPreviousValues();
                }
                this.writeViewElements(template, viewModel, model);
                $('#rto-ide-dialog-cover').show();
                var css = "rto-ide-dialog";
                if (template.definition.cssclass) {
                    css += " " + template.definition.cssclass;
                }
                $('#rto-ide-dialog').attr('class', css).show();
            };
            IDEDialog.prototype.initViewModel = function (viewModel) {
                if (viewModel.actions && viewModel.actions["init"]) {
                    viewModel.executeAction({ methodName: "init", viewModel: this });
                }
            };
            IDEDialog.prototype.hide = function () {
                $('#rto-ide-dialog').hide();
                $('#rto-ide-dialog-cover').hide();
                Retool.hideDropLists();
            };
            IDEDialog.prototype.renderContainer = function () {
                var w = new Retool.Writer("ds");
                w.writeTag("div", "ide-dialog", { id: "ide-dialog", style: "display:none" });
                w.write('</div>');
                w.appendToElement($('body'));
                var self = this;
                $('#rto-ide-dialog').on("click", ".close", function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    self.hide();
                });
                w = new Retool.Writer("ds");
                w.writeTag("div", null, { id: "ide-dialog-cover", style: "display:none" }).write('<div>');
                w.appendToElement($('body'));
            };
            IDEDialog.prototype.writeViewElements = function (template, viewModel, model) {
                var w = this.createWriter();
                w.writeTag("button", "close").write("&times;").write('</button>');
                w.writeTag("div", "ide-dialog-inner");
                w.writeTag("div", "content-pane");
                if (template && template.definition) {
                    this.renderContent(w);
                }
                w.write('</div>');
                w.write('</div>');
                w.writeToElement('#rto-ide-dialog');
                $("#rto-dialog input:visible:enabled:first").focus();
            };
            IDEDialog.prototype.createWriter = function () {
                return new Retool.Writer();
            };
            IDEDialog.prototype.refresh = function () {
                var viewModel = this.context.viewModel;
                this.writeViewElements(this.context.template, viewModel, this.model);
            };
            return IDEDialog;
        })(Retool.Canvas);
        IDE.IDEDialog = IDEDialog;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var IDEModel = (function (_super) {
            __extends(IDEModel, _super);
            function IDEModel() {
                _super.apply(this, arguments);
            }
            IDEModel.prototype.validate = function (errors) {
            };
            IDEModel.prototype.save = function () {
                return null;
            };
            IDEModel.prototype.destroy = function () {
                return null;
            };
            return IDEModel;
        })(Retool.ModelWithPrevious);
        IDE.IDEModel = IDEModel;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Models;
        (function (Models) {
            var TemplateModel = (function (_super) {
                __extends(TemplateModel, _super);
                function TemplateModel() {
                    _super.apply(this, arguments);
                }
                TemplateModel.prototype.define = function () {
                    return {
                        name: "Template",
                        fields: {
                            name: { type: "string", label: "Name" },
                            title: { type: "string", label: "Title" },
                            model: { type: "string", label: "Data model" },
                            copyfrom: { type: "string", label: "Copy From" },
                            namespace: { type: "string", label: "Namespace" },
                            cssclass: { type: "string", label: "CSS Class" },
                            baseLayout: { type: "string", label: "Base Template (default)" }
                        }
                    };
                };
                TemplateModel.createFor = function (name, params) {
                    if (name) {
                        var file = IDE.Ide.sourceApp.getFile(name); // App.templates.get(id); -> file
                        var def = file.getContent();
                        return new TemplateModel({ file: file, name: name, title: def.title, cssclass: def.cssclass, baseLayout: def.baseLayout }, { modelDef: null, isNew: false });
                    }
                    params = params || {};
                    var folder = (params.folder) ? params.folder + "/" : "";
                    var m = new TemplateModel({ file: null, name: folder, title: "", model: "", baseLayout: "" }, { modelDef: TemplateModel.prototype.modelDef, isNew: true });
                    var choices = [
                        { id: "blank", name: "Blank Template" },
                        { id: "list", name: "List" },
                        { id: "show", name: "Show Form" },
                        { id: "edit", name: "Edit Form" },
                        { id: "home", name: "Home Page" },
                        { id: "create", name: "Create Form" },
                    ];
                    m.set("choices", new Retool.ArrayModel(choices, { modelDef: null }));
                    if (params) {
                        if (params.copyfrom) {
                            m.set("copyfrom", params.copyfrom);
                        }
                        m.set("done", params.done);
                        m.set("element", params.element);
                    }
                    return m;
                };
                TemplateModel.prototype.validateTemplate = function (errors, name) {
                    var isNew = this.getIsNew();
                    if (isNew) {
                        if (errors.required("name", name, "Template name is required")) {
                            if (IDE.Folders.isRestricted(name)) {
                                return errors.addFieldError("name", "The specified folder is restricted.");
                            }
                            if (!IDE.DesignerTools.isValidFilename(name)) {
                                return errors.addFieldError("name", "Invalid file name");
                            }
                            var rootFolder = IDE.Folders.getRoot(name);
                            if (rootFolder != "" && rootFolder != "admin" && rootFolder != "frontend") {
                                return errors.addFieldError("name", "Templates must reside in the root folder, admin folder or frontend folder");
                            }
                            var filename = this.makeFilename(name);
                            var existingFile = IDE.Ide.sourceApp.getFile(name);
                            if (existingFile) {
                                errors.addFieldError("name", "A file with this name already exists");
                            }
                        }
                    }
                };
                TemplateModel.prototype.makeFilename = function (name) {
                    var filename = name;
                    var i = filename.indexOf(".");
                    if (i == -1) {
                        filename += Retool.FileSystem.FilePath.DEFAULT_FILE_EXTENSION;
                    }
                    return filename;
                };
                TemplateModel.prototype.save = function () {
                    var errors = new Retool.ValidationError();
                    if (this.getIsNew()) {
                        var name = this.get("name").toLowerCase();
                        this.validateTemplate(errors, name);
                        errors.throwIfAny();
                        var files = [];
                        var filename = this.makeFilename(name);
                        var elements = [];
                        if (this.get("elements")) {
                            elements = this.get("elements").getArray();
                        }
                        var j = name.lastIndexOf("/");
                        var className = (j == -1) ? name : name.substr(j + 1);
                        className = className.replace(/\-/g, '');
                        className = Retool.Inflection.classify(className);
                        var source = "class " + className + " extends Template {\n";
                        source += "  constructor(){\n";
                        source += "  }\n";
                        source += "}\n";
                        var template = { "name": name, elements: elements, title: "", source_code: source, cssclass: "", baseLayout: "" };
                        var file = new Retool.FileSystem.File(filename, template);
                        files.push(file);
                        IDE.activeDesigner.saveFileBatch(files);
                        for (var i = 0; i < files.length; i++) {
                            var file = files[i];
                            IDE.Ide.sourceApp.addFile(file);
                        }
                    }
                    else {
                        var name = this.get("name").toLowerCase();
                        this.validateTemplate(errors, name);
                        errors.throwIfAny();
                        var file = this.get("file");
                        var template = file.getContent();
                        template.title = this.get("title");
                        template.baseLayout = this.get("baseLayout");
                        template.cssclass = this.get("cssclass");
                        IDE.activeDesigner.saveFile(file, true);
                    }
                    return file;
                };
                TemplateModel.prototype.copy = function () {
                    var errors = new Retool.ValidationError();
                    var name = this.get("name").toLowerCase();
                    this.validateTemplate(errors, name);
                    errors.throwIfAny();
                    var filename = Retool.Url.filename(name).getFilename();
                    var sourceFile = IDE.Ide.sourceApp.templates.getFile(this.get("copyfrom"));
                    var sourceDef = sourceFile.getContent();
                    // create a clone
                    sourceDef = JSON.parse(JSON.stringify(sourceDef));
                    var template = { "name": name, elements: sourceDef.elements, title: sourceDef.title, source_code: sourceDef.source_code, cssclass: sourceDef.cssclass, baseLayout: sourceDef.baseLayout };
                    var file = new Retool.FileSystem.File(filename, template);
                    IDE.activeDesigner.saveFileBatch([file]);
                    IDE.Ide.sourceApp.addFile(file);
                    return file;
                };
                TemplateModel.prototype.createPartial = function () {
                    var errors = new Retool.ValidationError();
                    var name = this.get("name").toLowerCase();
                    this.validateTemplate(errors, name);
                    errors.throwIfAny();
                    var currentDomain = Retool.Url.file(IDE.activeDesigner.sourceTemplate.file).domainName;
                    var url = Retool.Url.domain(currentDomain).name(name);
                    var filename = url.getFilename();
                    // create a clone
                    var element = JSON.parse(JSON.stringify(this.get("element")));
                    var template = { "name": name, elements: [element], title: "", source_code: "", baseLayout: "" };
                    var file = new Retool.FileSystem.File(filename, template);
                    IDE.activeDesigner.saveFileBatch([file]);
                    IDE.Ide.sourceApp.addFile(file);
                    return file;
                };
                return TemplateModel;
            })(IDE.IDEModel);
            Models.TemplateModel = TemplateModel;
            IDE.Ide.models.add(TemplateModel);
        })(Models = IDE.Models || (IDE.Models = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Models;
        (function (Models) {
            var ModelModel = (function (_super) {
                __extends(ModelModel, _super);
                function ModelModel() {
                    _super.apply(this, arguments);
                }
                ModelModel.prototype.define = function () {
                    return {
                        name: "Model",
                        fields: {
                            name: { type: "string", label: "Name" },
                            label: { type: "string", label: "Label" },
                            key: { type: "string", label: "Key field" },
                            record_name: { type: "string", label: "Record name field" },
                            db_table: { type: "string", label: "Table name" },
                            exposed: { type: "boolean", label: "Endpoint" }
                        }
                    };
                };
                ModelModel.createFor = function (id, params) {
                    if (id) {
                        var file = IDE.Ide.sourceApp.models.getFile(id);
                        var def = file.getContent();
                        var fields = new Retool.ArrayModel([{ name: "", type: "string", size: "50" }], { modelDef: Models.FieldModel.prototype.modelDef });
                        return new ModelModel({ file: file, name: id, label: def.label, fields: fields, db_table: def.db_table, exposed: def.exposed }, { isNew: false, modelDef: ModelModel.prototype.modelDef });
                    }
                    else {
                        var defaultFields = new Retool.ArrayModel([{ name: "id", type: "objectid", size: "default" }, { name: "name", type: "string", size: "50" }], { modelDef: Models.FieldModel.prototype.modelDef });
                        var m = new ModelModel({ file: null, name: "", label: "", fields: defaultFields, exposed: true, type: "model" }, { isNew: true, modelDef: ModelModel.prototype.modelDef });
                        /*
                        if (params && params.userApp){
                            m.set("name",params.userApp + ".");
                        }
                        */
                        return m;
                    }
                };
                ModelModel.prototype.validate = function (errors) {
                    var name = this.get("name");
                    if (errors.required("name", name, "Model name is required")) {
                        /*
                        var segments = name.split('.');
                        if (segments.length != 2){
                            errors.addFieldError("name","Model name must be in format [App].[Name]");
                        }
                        else {
                            var userApp = App.userApps.getDefinition(segments[0]);
                            if (!userApp){
                                errors.addFieldError("name","Unknown application: " + segments[0]);
                            }
                            if (!DesignerTools.isValidId(segments[1])){
                                errors.addFieldError("name", "Model name "+ DesignerTools.invalidIdMessage());
                            }
                        }
                        */
                        if (!IDE.DesignerTools.isValidId(name)) {
                            errors.addFieldError("name", "Model name " + IDE.DesignerTools.invalidIdMessage());
                        }
                    }
                };
                ModelModel.prototype.save = function () {
                    if (this.getIsNew()) {
                        return this.create();
                    }
                    else {
                        return this.update();
                    }
                };
                ModelModel.prototype.addFields = function () {
                    var fieldDefs = [];
                    var relationshipDefs = [];
                    var file = this.get("file");
                    var modelDef = file.getContent();
                    var errors = new Retool.ValidationError();
                    var fields = this.get("fields");
                    var fieldArray = fields.getArray();
                    this.validateFields(errors, modelDef, fieldArray);
                    errors.throwIfAny();
                    this.createFields(modelDef, fieldDefs, relationshipDefs, fieldArray);
                    for (var i = 0; i < fieldDefs.length; i++) {
                        var fieldDef = fieldDefs[i];
                        modelDef.fields[fieldDef.name] = fieldDef;
                    }
                    for (var i = 0; i < relationshipDefs.length; i++) {
                        var relationshipDef = relationshipDefs[i];
                        modelDef.relationships[relationshipDef.name] = relationshipDef;
                    }
                    IDE.activeDesigner.saveFile(file, true);
                    return file;
                };
                ModelModel.prototype.destroy = function () {
                    var file = this.get("file");
                    IDE.activeDesigner.deleteFile(file);
                    return file;
                };
                ModelModel.createEmptyDefinition = function () {
                    var modelDef = {
                        name: null,
                        db_table: null,
                        fields: {},
                        relationships: {},
                        indexes: {},
                        key: "",
                        recordname: null,
                        label: "",
                        route: null,
                        trackRevisions: false,
                        access: "all",
                        source_code: "",
                        type: "model"
                    };
                    return modelDef;
                };
                ModelModel.prototype.update = function () {
                    var errors = new Retool.ValidationError();
                    this.validate(errors);
                    errors.throwIfAny();
                    var file = this.get("file");
                    var modelDef = file.getContent();
                    modelDef.db_table = this.get("db_table");
                    modelDef.recordname = this.get("recordname");
                    modelDef.label = this.get("label");
                    modelDef.access = this.get("access");
                    modelDef.trackRevisions = this.get("track_revisions");
                    modelDef.key = this.get("key");
                    modelDef.exposed = this.get("exposed");
                    IDE.activeDesigner.saveFile(file, true);
                    return file;
                };
                ModelModel.prototype.create = function () {
                    var name = this.get("name");
                    var fieldDefs = [];
                    var relationshipDefs = [];
                    var modelDef = {
                        name: null,
                        db_table: null,
                        fields: {},
                        relationships: {},
                        indexes: {},
                        key: "",
                        recordname: null,
                        label: "",
                        route: null,
                        trackRevisions: false,
                        access: "all",
                        source_code: "",
                        type: "model"
                    };
                    modelDef.name = name;
                    modelDef.label = this.get("label");
                    modelDef.exposed = this.get("exposed");
                    modelDef.db_table = Retool.Inflection.pluralize(name.toLowerCase());
                    var filename = IDE.Ide.sourceApp.models.getFilename(name);
                    var errors = new Retool.ValidationError();
                    this.validate(errors);
                    var fields = this.get("fields");
                    var fieldArray;
                    if (fields) {
                        fieldArray = fields.getArray();
                        this.validateFields(errors, modelDef, fieldArray);
                    }
                    var existing = IDE.Ide.sourceApp.getFile(filename);
                    if (existing) {
                        errors.addFieldError("name", "A model with this name already exists");
                    }
                    errors.throwIfAny();
                    if (fieldArray) {
                        this.createFields(modelDef, fieldDefs, relationshipDefs, fieldArray);
                    }
                    if (fieldDefs.length > 0) {
                        modelDef.key = fieldDefs[0].name;
                    }
                    if (fieldDefs.length > 1) {
                        modelDef.recordname = fieldDefs[1].name;
                    }
                    for (var i = 0; i < fieldDefs.length; i++) {
                        var fieldDef = fieldDefs[i];
                        modelDef.fields[fieldDef.name] = fieldDef;
                    }
                    for (var i = 0; i < relationshipDefs.length; i++) {
                        var relationshipDef = relationshipDefs[i];
                        modelDef.relationships[relationshipDef.name] = relationshipDef;
                    }
                    var segments = name.split('.');
                    modelDef.source_code = "class " + name + " extends Model {\n\n}\n";
                    var file = new Retool.FileSystem.File(filename, modelDef);
                    IDE.activeDesigner.saveFile(file, true);
                    IDE.Ide.sourceApp.addFile(file);
                    return file;
                };
                ModelModel.prototype.createFields = function (modelDef, fieldDefs, relationshipDefs, fields) {
                    var fieldDef;
                    var fieldsNeedingColumnNames = [];
                    for (var i = 0; i < fields.length; i++) {
                        var field = fields[i];
                        var name = $.trim(field.get("name"));
                        if (name) {
                            fieldDef = IDE.ModelBuilder.newField();
                            fieldDef.required = (name.indexOf('*') != -1);
                            name = name.replace(/\*$/g, '');
                            fieldDef.name = name;
                            fieldDef.label = $.trim(Retool.Inflection.titleize(name));
                            var type = field.get("type");
                            if (!type) {
                                fieldDef.type = "string";
                            }
                            else {
                                var dot = type.indexOf('.');
                                if (dot == -1) {
                                    fieldDef.type = type;
                                }
                                else {
                                    fieldDef.type = "objectid";
                                    fieldDef.belongs_to = type;
                                    var autoRelationshipName = ModelModel.getRelationshipNameFromFieldName(name);
                                    if (autoRelationshipName) {
                                        fieldDef.label = $.trim(Retool.Inflection.titleize(autoRelationshipName));
                                        var relationship = { name: autoRelationshipName, type: "belongs_to", foreignKey: name, model: fieldDef.belongs_to, label: fieldDef.label };
                                        relationshipDefs.push(relationship);
                                    }
                                }
                            }
                            var fieldType = IDE.fieldTypes[fieldDef.type];
                            if (fieldType && fieldType.hasSize) {
                                var size;
                                try {
                                    size = parseInt(field.get("size"), 10);
                                }
                                catch (e) {
                                    size = fieldType.defaultSize;
                                }
                                fieldDef.size = size;
                            }
                            fieldDefs.push(fieldDef);
                            if (!field.get("db_column")) {
                                if (name == "_id") {
                                    fieldDef.db_column = "id";
                                }
                                else {
                                    fieldsNeedingColumnNames.push(fieldDef);
                                }
                            }
                        }
                    }
                    var pool = new IDE.Util.AvailableDbColumnPool(modelDef);
                    for (var i = 0; i < fieldsNeedingColumnNames.length; i++) {
                        fieldDef = fieldsNeedingColumnNames[i];
                        var columnName = pool.nextAvailable(fieldDef);
                        fieldDef.db_column = columnName;
                    }
                };
                ModelModel.validateField = function (errors, modelDef, field) {
                    if (field.belongs_to) {
                        var belongsToModelDef = IDE.Ide.sourceApp.models.getDefinition(field.belongs_to);
                        if (!belongsToModelDef) {
                            errors.addFieldError("belongs_to", "Invalid collection id");
                        }
                    }
                };
                ModelModel.prototype.validateFields = function (errors, modelDef, fields) {
                    var namesLower = {};
                    for (var fieldName in modelDef.fields) {
                        namesLower[fieldName.toLowerCase()] = 1;
                    }
                    for (var relationshipName in modelDef.relationships) {
                        namesLower[relationshipName.toLowerCase()] = 1;
                    }
                    var dupCheck = {};
                    for (var i = 0; i < fields.length; i++) {
                        var field = fields[i];
                        var name = $.trim(field.get("name")).replace(/\*$/g, '');
                        if (name) {
                            if (!IDE.DesignerTools.isValidId(name)) {
                                errors.add("Field name '" + name + "' " + IDE.DesignerTools.invalidIdMessage());
                            }
                            var fieldType = field.get("type");
                            if (!fieldType) {
                                errors.add("Type Error: Invalid field type on field: " + name);
                            }
                            else {
                                var dot = fieldType.indexOf('.');
                                if (dot == -1) {
                                    if (!IDE.fieldTypes[fieldType]) {
                                        errors.add("Type Error: Invalid field type on field: " + name);
                                    }
                                }
                                else {
                                    var relatedModelDef = IDE.Ide.sourceApp.models.getDefinition(fieldType);
                                    if (!relatedModelDef) {
                                        errors.add("Type Error: Invalid field type on field: " + name);
                                    }
                                    var autoRelationshipName = IDE.ModelBuilder.getRelationshipNameFromFieldName(name);
                                    if (!autoRelationshipName) {
                                        errors.add("Expected " + name + " to be " + name + "_id for a relationship");
                                    }
                                    else {
                                        if (namesLower[autoRelationshipName.toLowerCase()]) {
                                            errors.add("Duplicate Error: A field named " + autoRelationshipName + " already exists in this collection");
                                        }
                                        else if (dupCheck[autoRelationshipName.toLowerCase()]) {
                                            errors.add("Duplicate Error: Field " + autoRelationshipName + " has been declared more than once.");
                                        }
                                        else {
                                            dupCheck[autoRelationshipName.toLowerCase()] = 1;
                                        }
                                    }
                                }
                            }
                            if (namesLower[name.toLowerCase()]) {
                                errors.add("Duplicate Error: A field named " + name + " already exists in this collection");
                            }
                            else if (dupCheck[name.toLowerCase()]) {
                                errors.add("Duplicate Error: Field " + name + " has been declared more than once.");
                            }
                            else {
                                dupCheck[name.toLowerCase()] = 1;
                            }
                        }
                    }
                };
                ModelModel.getAvailDbColumnNames = function (model, count) {
                    var prefix = "f";
                    var index = 1;
                    var maxIndex = 200;
                    var map = ModelModel.buildDbColumnMap(model);
                    var result = [];
                    while (index <= maxIndex) {
                        var fieldName;
                        if (index < 10) {
                            fieldName = prefix + "00" + index.toString();
                        }
                        else if (index < 100) {
                            fieldName = prefix + "0" + index.toString();
                        }
                        else {
                            fieldName = prefix + index.toString();
                        }
                        if (!map[fieldName]) {
                            result.push(fieldName);
                            count--;
                            if (count == 0) {
                                return result;
                            }
                        }
                        index++;
                    }
                    // too many fields;
                    return null;
                };
                ModelModel.buildDbColumnMap = function (model) {
                    // build a hash of all the db column names in the model def
                    var map = {};
                    for (var id in model.fields) {
                        var field = model.fields[id];
                        map[field.db_column] = 1;
                    }
                    return map;
                };
                ModelModel.getName = function (model) {
                    return model.name;
                };
                ModelModel.getRelationshipNameFromFieldName = function (fieldName) {
                    if (fieldName.length > 3 && fieldName.substr(fieldName.length - 3) == "_id") {
                        return fieldName.substr(0, fieldName.length - 3);
                    }
                    return null;
                };
                ModelModel.APP_NAME = "Models";
                return ModelModel;
            })(IDE.IDEModel);
            Models.ModelModel = ModelModel;
            IDE.Ide.models.add(ModelModel);
        })(Models = IDE.Models || (IDE.Models = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Models;
        (function (Models) {
            var FieldModel = (function (_super) {
                __extends(FieldModel, _super);
                function FieldModel() {
                    _super.apply(this, arguments);
                }
                FieldModel.prototype.define = function () {
                    return {
                        "name": "Field",
                        "fields": {
                            "name": { "name": "name", "type": "string", "label": "Name" },
                            "type": { "name": "type", "type": "string", "label": "Type", "default_value": "string" },
                            "size": { "name": "size", "type": "string", "label": "Size", "default_value": "50" },
                            "label": { "name": "label", "type": "string", label: "Label" },
                            "hidden": { "name": "hidden", "type": "boolean", label: "Hidden" },
                            "db_column": { "name": "db_column", "type": "string", label: "DB Column" }
                        }
                    };
                };
                FieldModel.createFor = function (id) {
                    var fieldPointer = IDE.Ide.sourceApp.getModelAndField(id);
                    var modelName = fieldPointer.modelDef.name;
                    var file = IDE.Ide.sourceApp.models.getFile(modelName);
                    var modelDef = file.getContent();
                    var fieldDef = fieldPointer.fieldDef;
                    return new FieldModel({ file: file, name: fieldDef.name, modelDef: modelDef, modelName: modelName, type: fieldDef.type, size: fieldDef.size, label: fieldDef.label, hidden: fieldDef.hidden, db_column: fieldDef.db_column }, { modelDef: FieldModel.prototype.modelDef });
                };
                FieldModel.prototype.validate = function (errors) {
                    var file = this.get("file");
                    var modelDef = file.getContent();
                };
                FieldModel.prototype.save = function () {
                    var errors = new Retool.ValidationError();
                    this.validate(errors);
                    errors.throwIfAny();
                    var file = this.get("file");
                    var modelDef = file.getContent();
                    var name = this.get("name");
                    var field = modelDef.fields[name];
                    if (field) {
                        field.label = this.get("label");
                        field.type = this.get("type");
                        field.size = this.get("size");
                        field.hidden = this.get("hidden");
                        field.db_column = this.get("db_column");
                    }
                    IDE.activeDesigner.saveFile(file, true);
                    return file;
                };
                FieldModel.prototype.destroy = function () {
                    var file = this.get("file");
                    var modelDef = file.getContent();
                    var fieldName = this.get("name");
                    var fieldDef = modelDef.fields[fieldName];
                    if (fieldDef) {
                        delete modelDef.fields[fieldName];
                    }
                    IDE.activeDesigner.saveFile(file, true);
                    return file;
                };
                return FieldModel;
            })(IDE.IDEModel);
            Models.FieldModel = FieldModel;
            IDE.Ide.models.add(FieldModel);
        })(Models = IDE.Models || (IDE.Models = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Models;
        (function (Models) {
            var RelationshipModel = (function (_super) {
                __extends(RelationshipModel, _super);
                function RelationshipModel() {
                    _super.apply(this, arguments);
                }
                RelationshipModel.prototype.define = function () {
                    return {
                        "name": "Relationship",
                        "fields": {
                            "name": { "name": "name", "type": "string", "label": "Name" },
                            "type": { "name": "type", "type": "picklist", "label": "Type", "listvalues": "belongs_to=Belongs To,has_many=Has Many,master=Master,detail=Details" },
                            "related_model": { "name": "model", "type": "string", "label": "Related Model" },
                            "foreign_key": { "name": "foreign_key", "type": "string", label: "Foreign Key" }
                        }
                    };
                };
                RelationshipModel.createFor = function (id) {
                    var segments = id.split('.');
                    var file;
                    if (segments.length > 1) {
                        var pointer = IDE.Ide.sourceApp.getModelAndRelationship(id);
                        var def = pointer.relationshipDef;
                        file = IDE.Ide.sourceApp.models.getFile(pointer.modelDef.name);
                        var modelDef = file.getContent();
                        var modelName = pointer.modelDef.name;
                        return new RelationshipModel({ file: file, name: def.name, modelDef: modelDef, modelName: modelName, type: def.type, foreign_key: def.foreignKey, related_model: def.model }, { isNew: false, modelDef: RelationshipModel.prototype.modelDef });
                    }
                    else {
                        file = IDE.Ide.sourceApp.models.getFile(id);
                        var modelDef = file.getContent();
                        return new RelationshipModel({ file: file, name: "", modelDef: modelDef, modelName: segments[0], type: "belongs_to", related_model: "", foreign_key: "" }, { isNew: true, modelDef: RelationshipModel.prototype.modelDef });
                    }
                };
                RelationshipModel.prototype.validate = function (errors) {
                    var file = this.get("file");
                    var modelDef = file.getContent();
                };
                RelationshipModel.prototype.save = function () {
                    var errors = new Retool.ValidationError();
                    this.validate(errors);
                    errors.throwIfAny();
                    var file = this.get("file");
                    var modelDef = file.getContent();
                    var name = this.get("name");
                    if (this.getIsNew()) {
                        var r = {
                            name: name,
                            foreignKey: this.get("foreign_key"),
                            model: this.get("related_model"),
                            type: this.get("type")
                        };
                        modelDef.relationships[name] = r;
                    }
                    else {
                        var relationship = modelDef.relationships[name];
                        if (relationship) {
                            relationship.foreignKey = this.get("foreign_key");
                            relationship.model = this.get("related_model");
                            relationship.type = this.get("type");
                        }
                    }
                    IDE.activeDesigner.saveFile(file, true);
                    return file;
                };
                RelationshipModel.prototype.destroy = function () {
                    var file = this.get("file");
                    var modelDef = file.getContent();
                    var name = this.get("name");
                    var relationship = modelDef.relationships[name];
                    if (relationship) {
                        delete modelDef.relationships[name];
                    }
                    IDE.activeDesigner.saveFile(file, true);
                    return file;
                };
                return RelationshipModel;
            })(IDE.IDEModel);
            Models.RelationshipModel = RelationshipModel;
            IDE.Ide.models.add(RelationshipModel);
        })(Models = IDE.Models || (IDE.Models = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Models;
        (function (Models) {
            var CssModel = (function (_super) {
                __extends(CssModel, _super);
                function CssModel() {
                    _super.apply(this, arguments);
                }
                CssModel.prototype.define = function () {
                    return {
                        name: "Css",
                        fields: {
                            name: { name: "name", type: "string", label: "Name" }
                        }
                    };
                };
                CssModel.createFor = function (id, params) {
                    if (id) {
                        var file = IDE.Ide.sourceApp.getFile(id);
                        var name = "";
                        if (file) {
                            name = file.name;
                        }
                        return new CssModel({ file: file, name: name }, { modelDef: null, isNew: false });
                    }
                    var m = new CssModel({ file: null, name: "" }, { modelDef: CssModel.prototype.modelDef, isNew: true });
                    return m;
                };
                CssModel.prototype.validate = function (errors) {
                    var name = this.get("name");
                    if (errors.required("name", name, "File name is required")) {
                        var name = this.get("name").toLowerCase();
                        /*
                        if (!DesignerTools.isValidId(name)){
                            errors.addFieldError("name", "File name "+ DesignerTools.invalidIdMessage());
                        }
                        */
                        var path = Retool.FileSystem.FilePath.forType(3 /* Css */);
                        if (this.getIsNew()) {
                            var existingFile = IDE.Ide.sourceApp.getFile(path + "/" + name);
                            if (existingFile) {
                                errors.addFieldError("name", "A file with this name already exists");
                            }
                        }
                    }
                };
                CssModel.prototype.save = function () {
                    var errors = new Retool.ValidationError();
                    var file;
                    if (this.getIsNew()) {
                        this.validate(errors);
                        errors.throwIfAny();
                        var files = [];
                        var name = this.get("name");
                        var path = Retool.FileSystem.FilePath.forType(3 /* Css */);
                        var fullName = path + "/" + name;
                        file = new Retool.FileSystem.File(fullName, "");
                        this.set("file", file);
                        files.push(file);
                        IDE.activeDesigner.saveFileBatch(files);
                        for (var i = 0; i < files.length; i++) {
                            var file = files[i];
                            IDE.Ide.sourceApp.addFile(file);
                        }
                    }
                    else {
                        this.validate(errors);
                        errors.throwIfAny();
                        file = this.get("file");
                        IDE.activeDesigner.saveFile(file, true);
                    }
                    return file;
                };
                CssModel.prototype.destroy = function () {
                    var file = this.get("file");
                    IDE.activeDesigner.deleteFile(file);
                    return file;
                };
                return CssModel;
            })(IDE.IDEModel);
            Models.CssModel = CssModel;
            IDE.Ide.models.add(CssModel);
        })(Models = IDE.Models || (IDE.Models = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Models;
        (function (Models) {
            var ImageModel = (function (_super) {
                __extends(ImageModel, _super);
                function ImageModel() {
                    _super.apply(this, arguments);
                }
                ImageModel.prototype.define = function () {
                    return {
                        name: "Image",
                        fields: {
                            name: { name: "name", type: "string", label: "Name" }
                        }
                    };
                };
                ImageModel.createFor = function (name, params) {
                    if (name) {
                        var file = IDE.Ide.sourceApp.getFile("images/" + name);
                        return new ImageModel({ file: file, name: name }, { modelDef: null, isNew: false });
                    }
                    var m = new ImageModel({ file: null, name: "" }, { modelDef: ImageModel.prototype.modelDef, isNew: true });
                    return m;
                };
                ImageModel.prototype.validate = function (errors) {
                    var name = this.get("name");
                    if (errors.required("name", name, "File name is required")) {
                        var name = this.get("name").toLowerCase();
                        /*
                        if (!DesignerTools.isValidId(name)){
                            errors.addFieldError("name", "File name "+ DesignerTools.invalidIdMessage());
                        }
                        */
                        var path = Retool.FileSystem.FilePath.forType(6 /* Image */);
                        if (this.getIsNew()) {
                            var existingFile = IDE.Ide.sourceApp.getFile(path + "/" + name);
                            if (existingFile) {
                                errors.addFieldError("name", "A file with this name already exists");
                            }
                        }
                    }
                };
                ImageModel.prototype.save = function () {
                    var errors = new Retool.ValidationError();
                    var file;
                    if (this.getIsNew()) {
                        this.validate(errors);
                        errors.throwIfAny();
                        var files = [];
                        var name = this.get("name");
                        var path = Retool.FileSystem.FilePath.forType(6 /* Image */);
                        var fullName = path + "/" + name;
                        file = new Retool.FileSystem.File(fullName, "");
                        files.push(file);
                        IDE.activeDesigner.saveFileBatch(files);
                        for (var i = 0; i < files.length; i++) {
                            var file = files[i];
                            IDE.Ide.sourceApp.addFile(file);
                        }
                    }
                    else {
                        this.validate(errors);
                        errors.throwIfAny();
                        file = this.get("file");
                        IDE.activeDesigner.saveFile(file, true);
                    }
                    return file;
                };
                ImageModel.prototype.destroy = function () {
                    var file = this.get("file");
                    IDE.activeDesigner.deleteFile(file);
                    return file;
                };
                return ImageModel;
            })(IDE.IDEModel);
            Models.ImageModel = ImageModel;
            IDE.Ide.models.add(ImageModel);
        })(Models = IDE.Models || (IDE.Models = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Models;
        (function (Models) {
            var LoginModel = (function (_super) {
                __extends(LoginModel, _super);
                function LoginModel() {
                    _super.apply(this, arguments);
                }
                LoginModel.prototype.define = function () {
                    return {
                        name: "Login",
                        fields: {
                            email: { name: "email", type: "string", label: "Email" },
                            password: { name: "password", type: "password", label: "Password" }
                        }
                    };
                };
                LoginModel.createFor = function (name, params) {
                    var m = new LoginModel({ file: null, email: "", password: "" }, { modelDef: LoginModel.prototype.modelDef, isNew: true });
                    return m;
                };
                LoginModel.prototype.validate = function (errors) {
                    var email = this.get("email");
                    if (errors.required("email", email, "Email is required")) {
                    }
                    var password = this.get("password");
                    if (errors.required("password", password, "Password is required")) {
                    }
                };
                return LoginModel;
            })(IDE.IDEModel);
            Models.LoginModel = LoginModel;
            IDE.Ide.models.add(LoginModel);
        })(Models = IDE.Models || (IDE.Models = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Models;
        (function (Models) {
            var ComponentModel = (function (_super) {
                __extends(ComponentModel, _super);
                function ComponentModel() {
                    _super.apply(this, arguments);
                }
                ComponentModel.prototype.define = function () {
                    return {
                        name: "Component",
                        fields: {
                            name: { type: "string", label: "Name" }
                        }
                    };
                };
                ComponentModel.createFor = function (name, params) {
                    if (name) {
                        var file = file = IDE.Ide.sourceApp.getFile(name);
                        var def = file.getContent();
                        return new ComponentModel({ file: file, name: name }, { modelDef: null, isNew: false });
                    }
                    var m = new ComponentModel({ file: null, name: "" }, { modelDef: ComponentModel.prototype.modelDef, isNew: true });
                    if (params) {
                        if (params.copyfrom) {
                            m.set("copyfrom", params.copyfrom);
                        }
                        m.set("done", params.done);
                        m.set("element", params.element);
                    }
                    return m;
                };
                ComponentModel.prototype.validateComponent = function (errors, name) {
                    if (errors.required("name", name, "Component name is required")) {
                        if (!IDE.DesignerTools.isValidTemplateName(name)) {
                            errors.addFieldError("name", "Component name " + IDE.DesignerTools.invalidIdMessage());
                        }
                        //var name = this.get("name").toLowerCase();
                        var path = Retool.FileSystem.FilePath.forType(8 /* Component */);
                        var filename = path + "/" + name.toLowerCase() + Retool.FileSystem.FilePath.DEFAULT_FILE_EXTENSION;
                        var existingFile = IDE.Ide.sourceApp.getFile(filename);
                        if (existingFile) {
                            errors.addFieldError("name", "A component with this name already exists");
                        }
                    }
                };
                ComponentModel.prototype.save = function () {
                    var errors = new Retool.ValidationError();
                    if (this.getIsNew()) {
                        var name = this.get("name").toLowerCase();
                        this.validateComponent(errors, name);
                        errors.throwIfAny();
                        var files = [];
                        var path = Retool.FileSystem.FilePath.forType(8 /* Component */);
                        var fullName = path + "/" + name + Retool.FileSystem.FilePath.DEFAULT_FILE_EXTENSION;
                        var elements = [];
                        if (this.get("elements")) {
                            elements = this.get("elements").getArray();
                        }
                        var j = name.lastIndexOf("/");
                        var className = (j == -1) ? name : name.substr(j + 1);
                        className = className.replace(/\-/g, '');
                        className = Retool.Inflection.classify(className);
                        var source = "class " + className + " extends Component {\n";
                        source += "  constructor(){\n";
                        source += "  }\n";
                        source += "}\n";
                        var component = { "name": name, elements: elements, source_code: source };
                        var file = new Retool.FileSystem.File(fullName, component);
                        files.push(file);
                        IDE.activeDesigner.saveFileBatch(files);
                        for (var i = 0; i < files.length; i++) {
                            var file = files[i];
                            IDE.Ide.sourceApp.addFile(file);
                        }
                    }
                    else {
                        var name = this.get("name").toLowerCase();
                        this.validateComponent(errors, name);
                        errors.throwIfAny();
                        var file = this.get("file");
                        var component = file.getContent();
                        // set fields here
                        IDE.activeDesigner.saveFile(file, true);
                    }
                    return file;
                };
                ComponentModel.prototype.copy = function () {
                    var errors = new Retool.ValidationError();
                    var name = this.get("name").toLowerCase();
                    this.validateComponent(errors, name);
                    errors.throwIfAny();
                    var path = Retool.FileSystem.FilePath.forType(8 /* Component */);
                    var fullName = path + "/" + name + Retool.FileSystem.FilePath.DEFAULT_FILE_EXTENSION;
                    var sourceFile = IDE.Ide.sourceApp.templates.getFile(this.get("copyfrom"));
                    var sourceDef = sourceFile.getContent();
                    // create a clone
                    sourceDef = JSON.parse(JSON.stringify(sourceDef));
                    var component = { "name": name, elements: sourceDef.elements, source_code: sourceDef.source_code };
                    var file = new Retool.FileSystem.File(fullName, component);
                    IDE.activeDesigner.saveFileBatch([file]);
                    IDE.Ide.sourceApp.addFile(file);
                    return file;
                };
                ComponentModel.prototype.destroy = function () {
                    var file = this.get("file");
                    IDE.activeDesigner.deleteFile(file);
                    return file;
                };
                return ComponentModel;
            })(IDE.IDEModel);
            Models.ComponentModel = ComponentModel;
            IDE.Ide.models.add(ComponentModel);
        })(Models = IDE.Models || (IDE.Models = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var IDEViewModel = (function (_super) {
            __extends(IDEViewModel, _super);
            function IDEViewModel(idParam, params) {
                _super.call(this, null);
                this.model = this.get_model(idParam, params);
            }
            IDEViewModel.prototype.confirmDelete = function (settings) {
                var options = {};
                options.title = settings.text;
                options.cssclass = settings.cssClass || "panel-confirm-delete";
                var continueText = "Confirm Delete";
                options.buttons = [
                    { name: "btnContinue", text: continueText, cssclass: "btn-danger" },
                    { name: "btnCancel", text: "Cancel", cssclass: "btn-secondary" }
                ];
                options.onconfirm = function (event) {
                    settings.onconfirm();
                };
                var dialog = new Retool.VM.Dialog(null);
                dialog.showDialog(settings.component, options);
            };
            IDEViewModel.prototype.closePanel = function () {
                IDE.activeDesigner.footer.hide();
            };
            IDEViewModel.prototype.vm_get_model = function (params) {
                return this.model;
            };
            IDEViewModel.prototype.clearDirty = function () {
                this.model.dirty = false;
            };
            IDEViewModel.prototype.closeAfterDelete = function () {
                IDE.activeDesigner.closeAttributesPanel();
            };
            IDEViewModel.prototype.closeAfterCreate = function (options) {
                var dialog = IDE.Ide.dialogCanvas;
                if (dialog) {
                    dialog.hide();
                }
            };
            IDEViewModel.prototype.closeAfterUpdate = function () {
                IDE.activeDesigner.footer.hide();
            };
            IDEViewModel.prototype.getModel = function () {
                return IDE.activeDesigner.attributeView.model;
            };
            IDEViewModel.prototype.get_title = function (model) {
                return { label: "" };
            };
            IDEViewModel.prototype.get_properties = function (list) {
            };
            IDEViewModel.prototype.get_toolbar = function () {
                return null;
            };
            IDEViewModel.prototype.get_model = function (id, params) {
                return null;
            };
            IDEViewModel.prototype.build_property_template = function () {
                var toolbarItems = this.get_toolbar();
                var toolbar;
                if (toolbarItems) {
                    toolbar = [];
                    for (var i = 0; i < toolbarItems.length; i++) {
                        var tool = toolbarItems[i];
                        toolbar.push({ kind: "ds-tool", text: tool.text, name: tool.name });
                    }
                }
                var attributes = new IDE.ElementAttributeList();
                this.get_properties(attributes);
                var builder = new IDE.ElementAttributeFormBuilder(attributes);
                builder.toolbar = toolbar;
                var viewDef = builder.build();
                var viewDefinition = { actions: this, elements: [viewDef], name: "attributes" };
                var viewFile = new Retool.FileSystem.File("attribute-editor", viewDefinition);
                var errorLog = new IDE.CompilerErrorLog();
                var template = IDE.TemplateCompiler.compile(null, viewFile, IDE.Ide.ideApp.helpers, errorLog);
                // var template = {id:"designer.attributes",name:"attributes",sourceFile:viewFile,definition:viewDefinition,appName:"_designer"};
                this.setSourceFile(template);
                return template;
            };
            return IDEViewModel;
        })(Retool.ViewModel);
        IDE.IDEViewModel = IDEViewModel;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var ElementViewModel = (function (_super) {
                __extends(ElementViewModel, _super);
                function ElementViewModel() {
                    _super.apply(this, arguments);
                }
                return ElementViewModel;
            })(IDE.IDEViewModel);
            ViewModels.ElementViewModel = ElementViewModel;
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var TemplateViewModel = (function (_super) {
                __extends(TemplateViewModel, _super);
                function TemplateViewModel() {
                    _super.apply(this, arguments);
                }
                TemplateViewModel.prototype.get_properties = function (list) {
                    list.addTextProp("title", "Title");
                    list.addTextProp("baseLayout", "Base Template");
                    list.addTextProp("cssclass", "Css Class");
                };
                TemplateViewModel.prototype.get_toolbar = function () {
                    return [
                        { name: "btnCopy", text: "Copy" }
                    ];
                };
                TemplateViewModel.prototype.get_model = function (id, params) {
                    return IDE.Models.TemplateModel.createFor(id, params);
                };
                TemplateViewModel.prototype.get_title = function (model) {
                    var name = model.get("name");
                    name = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(name);
                    return { label: "Template", icon: { color: "0", glyph: ")" }, text: name };
                };
                TemplateViewModel.prototype.btnItem_onclick = function (event) {
                    var autoCreateType = event.getContext().get("id");
                    var m = this.model;
                    var modelId = m.get("model");
                    var elements = this.autoCreate(autoCreateType, modelId);
                    m.set("elements", elements);
                    var file = m.save();
                    var name = this.model.get("name");
                    this.closeAfterCreate();
                    IDE.activeDesigner.toolbox.fileAdded(file);
                    var url = Retool.Url.filename(name);
                    IDE.activeDesigner.navigateApp(url);
                };
                TemplateViewModel.prototype.autoCreate = function (type, modelId) {
                    var modelDef = IDE.Ide.sourceApp.models.get(modelId);
                    var generator;
                    var name = this.model.get("name");
                    var rawName = Retool.FileSystem.PathInfo.getFilenameWithoutExtension(Retool.FileSystem.PathInfo.parseFilename(name).filename);
                    if (type == "home") {
                        generator = new IDE.Generators.Home(rawName, modelDef);
                    }
                    else {
                        generator = new IDE.Generators.Blank(rawName, modelDef);
                    }
                    if (generator) {
                        var def = generator.generate();
                        if (def) {
                            return def.elements;
                        }
                    }
                    return [];
                };
                TemplateViewModel.prototype.btnUpdate_onclick = function () {
                    var m = this.model;
                    var file = m.save();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    m.copyToPreviousValues();
                    this.clearDirty();
                    IDE.activeDesigner.refreshView();
                    m.clearError();
                };
                TemplateViewModel.prototype.btnDelete_onclick = function (event) {
                    var m = this.model;
                    var self = this;
                    var file = m.get("file");
                    this.confirmDelete({ component: event.component, text: "This action cannot be un-done.", onconfirm: function () {
                        IDE.ViewBuilder.destroy(file);
                        IDE.activeDesigner.toolbox.fileDeleted(file);
                        IDE.activeDesigner.closeAttributesPanel();
                        self.closeAfterDelete();
                        var url = Retool.Url.filename("admin/error");
                        IDE.activeDesigner.navigateApp(url);
                    } });
                };
                TemplateViewModel.prototype.btnCopy_onclick = function () {
                    IDE.Ide.render("template/copy", null, { copyfrom: this.model.get("name") });
                };
                TemplateViewModel.prototype.btnCreateFromCopy_onclick = function () {
                    var m = this.model;
                    var file = m.copy();
                    this.closeAfterCreate();
                    IDE.activeDesigner.toolbox.fileAdded(file);
                };
                TemplateViewModel.prototype.btnCreatePartial_onclick = function () {
                    var m = this.model;
                    var name = m.get("name");
                    var file = m.createPartial();
                    this.closeAfterCreate();
                    IDE.activeDesigner.toolbox.fileAdded(file);
                    var done = m.get("done");
                    done(name);
                };
                return TemplateViewModel;
            })(IDE.IDEViewModel);
            ViewModels.TemplateViewModel = TemplateViewModel;
            IDE.Ide.routes.add("template/edit", TemplateViewModel, "inspector");
            IDE.Ide.routes.add("template/create", TemplateViewModel, "dialog");
            IDE.Ide.routes.add("template/copy", TemplateViewModel, "dialog");
            IDE.Ide.routes.add("template/create-partial", TemplateViewModel, "dialog");
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var ModelViewModel = (function (_super) {
                __extends(ModelViewModel, _super);
                function ModelViewModel() {
                    _super.apply(this, arguments);
                }
                ModelViewModel.prototype.get_properties = function (list) {
                    list.addTextProp("name", "Name");
                    list.addTextProp("label", "Label");
                    list.addTextProp("db_table", "Table Name");
                    list.addCheckbox("exposed", "Exposed as Endpoint");
                };
                ModelViewModel.prototype.get_model = function (id, params) {
                    if (params && params.addfields) {
                        this.set("addfields", true);
                    }
                    return IDE.Models.ModelModel.createFor(id, params);
                };
                ModelViewModel.prototype.get_title = function (model) {
                    var icon = (model.get("exposed")) ? IDE.FileIcons.ModelExposed : IDE.FileIcons.Model;
                    return { label: "Model", icon: icon, text: model.get("name") };
                };
                ModelViewModel.prototype.btnCreate_onclick = function () {
                    var m = this.model;
                    var file;
                    if (this.get("addfields")) {
                        file = m.addFields();
                        IDE.activeDesigner.toolbox.fileUpdated(file);
                    }
                    else {
                        file = m.save();
                        IDE.activeDesigner.toolbox.fileAdded(file);
                    }
                    //activeDesigner.closeAttributesPanel();
                    IDE.activeDesigner.toolbox.actions.showModel(m.get("name"));
                    this.closeAfterCreate();
                };
                ModelViewModel.prototype.btnUpdate_onclick = function (event) {
                    var m = this.model;
                    var file = m.save();
                    m.copyToPreviousValues();
                    this.clearDirty();
                    IDE.activeDesigner.refreshView();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    this.closeAfterUpdate();
                };
                ModelViewModel.prototype.btnDelete_onclick = function (event) {
                    var m = this.model;
                    var self = this;
                    this.confirmDelete({ component: event.component, text: "This action cannot be un-done.", onconfirm: function () {
                        var file = m.destroy();
                        IDE.activeDesigner.toolbox.fileDeleted(file);
                        var editor = IDE.activeDesigner.getModelCodeSection();
                        editor.loadFile(null);
                        IDE.activeDesigner.footer.select(IDE.Footer.APP_MAIN_SECTION);
                        self.closeAfterDelete();
                    } });
                };
                ModelViewModel.prototype.btnDeleteRow_onclick = function (e) {
                    var fields = this.model.get("fields");
                    var context = e.getContext();
                    fields.remove(context.model);
                };
                ModelViewModel.prototype.btnAddRow_onclick = function (e) {
                    var newItem = new IDE.Models.FieldModel({ name: "", type: "string", size: "50" }, { modelDef: null });
                    var fields = this.model.get("fields");
                    var index = fields.push(newItem) - 1;
                    e.setFocus("fieldRow", index);
                };
                ModelViewModel.prototype.txtKey_getdrop = function (event) {
                    return { model: event.component.context.get("id") };
                };
                ModelViewModel.prototype.txtRecordName_getdrop = function (event) {
                    return { model: event.component.context.get("id") };
                };
                ModelViewModel.prototype.txtFieldName_onchange = function (event) {
                    var component = event.component;
                    var value = component.getFieldValue();
                    var ds = event.component.context;
                    var m = this.getModel();
                    var autoRelationshipName = IDE.ModelBuilder.getRelationshipNameFromFieldName(value);
                    if (autoRelationshipName) {
                        var modelName = autoRelationshipName.toLowerCase();
                        var modelDef = IDE.Ide.sourceApp.models.getDefinition(modelName);
                        if (modelDef) {
                            component.context.set("type", modelName);
                        }
                    }
                };
                ModelViewModel.prototype.txtFieldType_onchange = function (event) {
                    var component = event.component;
                    var value = component.getFieldValue();
                    var fieldType = IDE.fieldTypes[value];
                    if (fieldType && fieldType.hasSize) {
                        component.context.set("size", fieldType.defaultSize.toString());
                    }
                    else {
                        component.context.set("size", "default");
                    }
                };
                ModelViewModel.prototype.txtName_onchange = function (event) {
                    var component = event.component;
                    var value = component.getFieldValue();
                    if (!value) {
                        return;
                    }
                    component.context.set("label", Retool.Inflection.titleize(value));
                };
                return ModelViewModel;
            })(IDE.IDEViewModel);
            ViewModels.ModelViewModel = ModelViewModel;
            IDE.Ide.routes.add("model/edit", ModelViewModel, "inspector");
            IDE.Ide.routes.add("model/create", ModelViewModel, "dialog");
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var FieldViewModel = (function (_super) {
                __extends(FieldViewModel, _super);
                function FieldViewModel() {
                    _super.apply(this, arguments);
                }
                FieldViewModel.prototype.get_properties = function (list) {
                    list.addTextProp("name", "Name");
                    list.addTextProp("label", "Label");
                    list.addTextProp("type", "Type", { droptype: "fieldtypes" });
                    list.addTextProp("size", "Size");
                    list.addCheckbox("hidden", "Hidden");
                    list.addTextProp("db_column", "DB Column");
                };
                FieldViewModel.prototype.get_model = function (id, params) {
                    return IDE.Models.FieldModel.createFor(id);
                };
                FieldViewModel.prototype.get_title = function (model) {
                    var modelName = model.get("modelName");
                    return { label: "Field", icon: { color: "1", glyph: "L" }, text: modelName + "." + model.get("name") };
                };
                FieldViewModel.prototype.btnUpdate_onclick = function (event) {
                    var m = this.model;
                    var file = m.save();
                    m.copyToPreviousValues();
                    IDE.activeDesigner.refreshView();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    this.closeAfterUpdate();
                    this.clearDirty();
                };
                FieldViewModel.prototype.btnDelete_onclick = function (event) {
                    var m = this.model;
                    var self = this;
                    this.confirmDelete({ component: event.component, text: "This action cannot be un-done.", onconfirm: function () {
                        var file = m.destroy();
                        IDE.activeDesigner.toolbox.fileUpdated(file);
                        self.closeAfterDelete();
                    } });
                };
                return FieldViewModel;
            })(IDE.IDEViewModel);
            ViewModels.FieldViewModel = FieldViewModel;
            IDE.Ide.routes.add("field/edit", FieldViewModel, "inspector");
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var RelationshipViewModel = (function (_super) {
                __extends(RelationshipViewModel, _super);
                function RelationshipViewModel() {
                    _super.apply(this, arguments);
                }
                RelationshipViewModel.prototype.get_properties = function (list) {
                    list.addTextProp("name", "Name");
                    list.addTextProp("type", "Type", { droptype: "generic", dropItems: ["belongs_to", "detail", "master"] });
                    list.addTextProp("related_model", "Model", { droptype: "models" });
                    list.addTextProp("foreign_key", "Foreign Key");
                };
                RelationshipViewModel.prototype.get_model = function (id, params) {
                    return IDE.Models.RelationshipModel.createFor(id);
                };
                RelationshipViewModel.prototype.get_title = function (model) {
                    var modelName = model.get("modelName");
                    return { label: "Relationship", icon: { color: "1", glyph: "V" }, text: modelName + "." + model.get("name") };
                };
                RelationshipViewModel.prototype.btnCreate_onclick = function () {
                    var m = this.model;
                    var file = m.save();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    this.closeAfterCreate();
                };
                RelationshipViewModel.prototype.btnUpdate_onclick = function () {
                    var m = this.model;
                    var file = m.save();
                    m.copyToPreviousValues();
                    this.clearDirty();
                    m.clearError();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    this.closeAfterUpdate();
                };
                RelationshipViewModel.prototype.btnDelete_onclick = function (event) {
                    var m = this.model;
                    var self = this;
                    this.confirmDelete({ component: event.component, text: "This action cannot be un-done.", onconfirm: function () {
                        var file = m.destroy();
                        IDE.activeDesigner.toolbox.fileUpdated(file);
                        IDE.activeDesigner.closeAttributesPanel();
                        self.closeAfterDelete();
                    } });
                };
                return RelationshipViewModel;
            })(IDE.IDEViewModel);
            ViewModels.RelationshipViewModel = RelationshipViewModel;
            IDE.Ide.routes.add("relationship/edit", RelationshipViewModel, "inspector");
            IDE.Ide.routes.add("relationship/create", RelationshipViewModel, "dialog");
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var DropAsViewModel = (function (_super) {
                __extends(DropAsViewModel, _super);
                function DropAsViewModel() {
                    _super.apply(this, arguments);
                }
                DropAsViewModel.prototype.get_model = function (id, params) {
                    this.callback = params.callback;
                    return new Retool.ObjectModel(params, { modelDef: null });
                };
                DropAsViewModel.prototype.btnItem_onclick = function (data) {
                    if (this.callback) {
                        this.callback(data.get("id"));
                    }
                    this.closeAfterCreate();
                };
                return DropAsViewModel;
            })(IDE.IDEViewModel);
            ViewModels.DropAsViewModel = DropAsViewModel;
            IDE.Ide.routes.add("drop-as/ask", DropAsViewModel, "dialog");
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var CssViewModel = (function (_super) {
                __extends(CssViewModel, _super);
                function CssViewModel() {
                    _super.apply(this, arguments);
                }
                CssViewModel.prototype.get_properties = function (list) {
                    list.addTextProp("name", "Name");
                };
                CssViewModel.prototype.get_model = function (id, params) {
                    return IDE.Models.CssModel.createFor(id);
                };
                CssViewModel.prototype.get_title = function (model) {
                    return { label: "CSS File", icon: { color: "3", glyph: "`" }, text: model.get("name") };
                };
                CssViewModel.prototype.btnCreate_onclick = function () {
                    var m = this.model;
                    var file = m.save();
                    IDE.activeDesigner.closeAttributesPanel();
                    IDE.activeDesigner.toolbox.fileAdded(file);
                    var cssEditor = IDE.activeDesigner.getCssEditor();
                    if (cssEditor) {
                        cssEditor.loadFile(m.get("file"));
                        IDE.activeDesigner.footer.select(cssEditor.id);
                    }
                    this.closeAfterCreate();
                };
                CssViewModel.prototype.btnUpdate_onclick = function (event) {
                    var m = this.model;
                    var file = m.save();
                    m.copyToPreviousValues();
                    IDE.activeDesigner.refreshView();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    this.closeAfterUpdate();
                    this.clearDirty();
                };
                CssViewModel.prototype.btnDelete_onclick = function (event) {
                    var m = this.model;
                    var self = this;
                    this.confirmDelete({ component: event.component, text: "This action cannot be un-done.", onconfirm: function () {
                        var file = m.destroy();
                        IDE.activeDesigner.toolbox.fileDeleted(file);
                        var editor = IDE.activeDesigner.getCssEditor();
                        editor.loadFile(null);
                        self.closeAfterDelete();
                    } });
                };
                return CssViewModel;
            })(IDE.IDEViewModel);
            ViewModels.CssViewModel = CssViewModel;
            IDE.Ide.routes.add("css/edit", CssViewModel, "inspector");
            IDE.Ide.routes.add("css/create", CssViewModel, "dialog");
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var ImageViewModel = (function (_super) {
                __extends(ImageViewModel, _super);
                function ImageViewModel() {
                    _super.apply(this, arguments);
                }
                ImageViewModel.prototype.get_properties = function (list) {
                    list.addTextProp("name", "Name");
                };
                ImageViewModel.prototype.get_model = function (id, params) {
                    return IDE.Models.ImageModel.createFor(id);
                };
                ImageViewModel.prototype.get_title = function (model) {
                    return { label: "Image File", icon: { color: "4", glyph: "f" }, text: model.get("name") };
                };
                ImageViewModel.prototype.btnCreate_onclick = function () {
                    var m = this.model;
                    var file = m.save();
                    IDE.activeDesigner.closeAttributesPanel();
                    IDE.activeDesigner.toolbox.fileAdded(file);
                    this.closeAfterCreate();
                };
                ImageViewModel.prototype.btnUpdate_onclick = function (event) {
                    var m = this.model;
                    var file = m.save();
                    m.copyToPreviousValues();
                    IDE.activeDesigner.refreshView();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    this.closeAfterUpdate();
                    this.clearDirty();
                };
                ImageViewModel.prototype.btnDelete_onclick = function (event) {
                    var m = this.model;
                    var self = this;
                    this.confirmDelete({ component: event.component, text: "This action cannot be un-done.", onconfirm: function () {
                        var file = m.destroy();
                        IDE.activeDesigner.toolbox.fileDeleted(file);
                        self.closeAfterDelete();
                    } });
                };
                return ImageViewModel;
            })(IDE.IDEViewModel);
            ViewModels.ImageViewModel = ImageViewModel;
            IDE.Ide.routes.add("image/edit", ImageViewModel, "inspector");
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var LoginViewModel = (function (_super) {
                __extends(LoginViewModel, _super);
                function LoginViewModel() {
                    _super.apply(this, arguments);
                }
                LoginViewModel.prototype.get_model = function (id, params) {
                    return IDE.Models.LoginModel.createFor(id);
                };
                LoginViewModel.prototype.btnSignin_onclick = function (e) {
                    var clientId = "3e034d4781124b9a67f0";
                    var devId = "7ffee70db6a91f55c9f1";
                    var state = "";
                    var loc = window.location;
                    if (loc.href.indexOf(":3474") != -1) {
                        clientId = devId;
                    }
                    var redirect = loc.protocol + "//" + loc.host + "/@github-auth" + loc.pathname + loc.search;
                    window.location.href = "https://github.com/login/oauth/authorize?client_id=" + clientId + "&redirect_uri=" + encodeURIComponent(redirect);
                    return;
                    var m = this.model;
                    var error = new Retool.ValidationError();
                    m.validate(error);
                    error.throwIfAny();
                    var email = m.get("email");
                    var password = m.get("password");
                    e.pause();
                    var self = this;
                };
                LoginViewModel.prototype.auth = function () {
                    var loc = window.location;
                    var search = loc.search;
                    var query = {};
                    var display = loc.pathname.substr(13);
                    var keep = [];
                    var code;
                    if (search) {
                        var parameters = search.substr(1).split('&');
                        var keep = [];
                        for (var i = 0; i < parameters.length; i++) {
                            if (parameters[i].substr(0, 5) != "code=") {
                                keep.push(parameters[i]);
                            }
                            var parameter = parameters[i].split('=');
                            query[parameter[0]] = decodeURIComponent(parameter[1]);
                        }
                        var code = query["code"];
                    }
                    if (keep.length) {
                        display += "?" + keep.join("&");
                    }
                    window.history.replaceState(null, null, display);
                    if (code) {
                    }
                    else {
                        this.showError("Expected authorization code");
                    }
                };
                LoginViewModel.prototype.showError = function (err) {
                    var dialog = IDE.Ide.dialogCanvas;
                    dialog.showFormError(Retool.VM.VMError.cast(err));
                    IDE.Ide.render("login/index", null);
                };
                LoginViewModel.prototype.btnForgot_onclick = function () {
                    this.closeAfterCreate();
                    IDE.Ide.render("forgotpwd/index", null);
                };
                return LoginViewModel;
            })(IDE.IDEViewModel);
            ViewModels.LoginViewModel = LoginViewModel;
            IDE.Ide.routes.add("login/index", LoginViewModel, "dialog");
            IDE.Ide.routes.add("login/auth", LoginViewModel, "dialog");
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var SignupViewModel = (function (_super) {
                __extends(SignupViewModel, _super);
                function SignupViewModel() {
                    _super.apply(this, arguments);
                }
                SignupViewModel.prototype.get_model = function (id, params) {
                    return SignupModel.createFor(id);
                };
                SignupViewModel.prototype.btnSignup_onclick = function (e) {
                    var m = this.model;
                    var firstName = m.get("firstName");
                    var lastName = m.get("lastName");
                    var email = m.get("email");
                    var domain = m.get("domain");
                    var password = m.get("password");
                    e.pause();
                    var self = this;
                };
                return SignupViewModel;
            })(IDE.IDEViewModel);
            ViewModels.SignupViewModel = SignupViewModel;
            IDE.Ide.routes.add("signup/index", SignupViewModel, "dialog");
            var SignupModel = (function (_super) {
                __extends(SignupModel, _super);
                function SignupModel() {
                    _super.apply(this, arguments);
                }
                SignupModel.prototype.define = function () {
                    return {
                        id: "_designer.signup",
                        fields: {
                            firstName: { name: "firstName", type: "string", label: "First Name" },
                            lastName: { name: "lastName", type: "string", label: "Last Name" },
                            email: { name: "email", type: "string", label: "Email" },
                            password: { name: "password", type: "password", label: "Password" },
                            domain: { name: "domain", type: "string", label: "Domain" }
                        }
                    };
                };
                SignupModel.createFor = function (name, params) {
                    var m = new SignupModel({ file: null, email: "", firstName: "", lastName: "", password: "", domain: "" }, { modelDef: SignupModel.prototype.modelDef, isNew: true });
                    return m;
                };
                SignupModel.prototype.validate = function (errors) {
                    var email = this.get("email");
                    if (errors.required("email", name, "Email is required")) {
                    }
                };
                return SignupModel;
            })(IDE.IDEModel);
            ViewModels.SignupModel = SignupModel;
            IDE.Ide.models.add(SignupModel);
            IDE.Ide.templateDefinitions.add("signup/index", {
                name: "signup/index",
                title: "Signup",
                cssclass: "rto-small-dialog",
                hasForm: true,
                elements: [
                    { kind: "r-with", obj: "this.model", var: "m", children: [
                        { kind: "div", cssclass: "caption-bar", children: [
                            { kind: "h2", cssclass: "text-normal", children: [
                                { kind: "span", text: "`", cssclass: "glyph toolbox color0" },
                                { kind: "text", text: "Sign up" }
                            ] }
                        ] },
                        { kind: "ds-dialog-form", children: [
                            { kind: "formgroup", type: "basic", children: [
                                { "kind": "input_text", "value": "m.firstName", label: "First Name", "placeholder": "First", "cssclass": "", "name": "" },
                                { "kind": "input_text", "value": "m.lastName", label: "Last Name", "placeholder": "Last", "cssclass": "", "name": "" },
                                { "kind": "input_text", "value": "m.email", label: "Email", "placeholder": "email", "cssclass": "", "name": "txtEmail" },
                                { "kind": "input_password", "value": "m.password", label: "Password", "cssclass": "", "name": "txtPassword" },
                                { "kind": "input_text", "value": "m.domain", label: "Sub-Domain", "placeholder": "subdomain", "cssclass": "", "name": "", addonrighttext: "-app.retool.io" },
                            ] },
                            { kind: "div", cssclass: "button-list", children: [
                                { kind: "button", text: "Sign up", cssclass: "btn-primary", defaultButton: true, name: "btnSignup" }
                            ] },
                        ] }
                    ] }
                ],
                "events": {}
            });
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var ForgotPasswordViewModel = (function (_super) {
                __extends(ForgotPasswordViewModel, _super);
                function ForgotPasswordViewModel() {
                    _super.call(this);
                    this.set("sent", false);
                }
                ForgotPasswordViewModel.prototype.get_model = function (id, params) {
                    return ForgotPasswordModel.createFor(id);
                };
                ForgotPasswordViewModel.prototype.btnSend_onclick = function () {
                    var m = this.model;
                    var error = new Retool.ValidationError();
                    m.validate(error);
                    error.throwIfAny();
                    this.set("sent", true);
                    //this.closeAfterCreate();
                };
                return ForgotPasswordViewModel;
            })(IDE.IDEViewModel);
            ViewModels.ForgotPasswordViewModel = ForgotPasswordViewModel;
            IDE.Ide.routes.add("forgotpwd/index", ForgotPasswordViewModel, "dialog");
            var ForgotPasswordModel = (function (_super) {
                __extends(ForgotPasswordModel, _super);
                function ForgotPasswordModel() {
                    _super.apply(this, arguments);
                }
                ForgotPasswordModel.prototype.define = function () {
                    return {
                        id: "_designer.signup",
                        fields: {
                            email: { name: "email", type: "string", label: "Email" }
                        }
                    };
                };
                ForgotPasswordModel.createFor = function (name, params) {
                    var m = new ForgotPasswordModel({ file: null, email: "" }, { modelDef: ForgotPasswordModel.prototype.modelDef, isNew: true });
                    return m;
                };
                ForgotPasswordModel.prototype.validate = function (errors) {
                    var email = this.get("email");
                    if (errors.required("email", email, "Email is required")) {
                    }
                };
                return ForgotPasswordModel;
            })(IDE.IDEModel);
            ViewModels.ForgotPasswordModel = ForgotPasswordModel;
            IDE.Ide.models.add(ForgotPasswordModel);
            IDE.Ide.templateDefinitions.add("forgotpwd/index", {
                name: "forgotpwd/index",
                title: "Forgot Password",
                cssclass: "rto-small-dialog",
                hasForm: true,
                elements: [
                    { kind: "r-with", obj: "this.model", var: "m", children: [
                        { kind: "div", cssclass: "caption-bar", children: [
                            { kind: "h2", cssclass: "text-normal", children: [
                                { kind: "span", text: "", cssclass: "glyph glyphicon glyphicon-lock color1" },
                                { kind: "text", text: "Password help" }
                            ] }
                        ] },
                        { kind: "r-if", condition: "!controller.sent", children: [
                            { kind: "p", "text": "Enter your email address and we will send you instructions to reset your password." },
                            { kind: "ds-dialog-form", children: [
                                { kind: "formgroup", type: "basic", children: [
                                    { "kind": "input_text", "m.value": "email", "placeholder": "email", "cssclass": "", "name": "txtEmail" },
                                ] },
                                { kind: "div", cssclass: "button-list", children: [
                                    { kind: "button", text: "Send Reset Instructions", cssclass: "btn-primary", defaultButton: true, name: "btnSend" }
                                ] },
                            ] },
                            { kind: "else" },
                            { kind: "p", text: "Check your email for password reset instructions." }
                        ] }
                    ] }
                ],
                "events": {}
            });
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var PasswordResetViewModel = (function (_super) {
                __extends(PasswordResetViewModel, _super);
                function PasswordResetViewModel() {
                    _super.apply(this, arguments);
                }
                PasswordResetViewModel.prototype.get_model = function (id, params) {
                    return PasswordResetModel.createFor(id, params);
                };
                PasswordResetViewModel.prototype.btnReset_onclick = function () {
                    var m = this.model;
                    var error = new Retool.ValidationError();
                    m.validate(error);
                    error.throwIfAny();
                    this.closeAfterCreate();
                };
                return PasswordResetViewModel;
            })(IDE.IDEViewModel);
            ViewModels.PasswordResetViewModel = PasswordResetViewModel;
            IDE.Ide.routes.add("resetpwd/index", PasswordResetViewModel, "dialog");
            var PasswordResetModel = (function (_super) {
                __extends(PasswordResetModel, _super);
                function PasswordResetModel() {
                    _super.apply(this, arguments);
                }
                PasswordResetModel.prototype.define = function () {
                    return {
                        id: "_designer.signup",
                        fields: {
                            email: { name: "email", type: "string", label: "Email" },
                            password: { name: "password", type: "password", label: "Password" },
                            token: { name: "token", type: "string", label: "Token" }
                        }
                    };
                };
                PasswordResetModel.createFor = function (name, params) {
                    var m = new PasswordResetModel({ file: null, email: "", password: "" }, { modelDef: PasswordResetModel.prototype.modelDef, isNew: true });
                    if (params) {
                        m.set("email", params.email || "");
                        m.set("token", params.token);
                    }
                    return m;
                };
                PasswordResetModel.prototype.validate = function (errors) {
                    var email = this.get("password");
                    if (errors.required("password", email, "Password is required")) {
                    }
                };
                return PasswordResetModel;
            })(IDE.IDEModel);
            ViewModels.PasswordResetModel = PasswordResetModel;
            IDE.Ide.models.add(PasswordResetModel);
            IDE.Ide.templateDefinitions.add("resetpwd/index", {
                name: "resetpwd/index",
                title: "Reset Password",
                cssclass: "rto-small-dialog",
                hasForm: true,
                elements: [
                    { kind: "r-with", obj: "this.model", var: "m", children: [
                        { kind: "div", cssclass: "caption-bar", children: [
                            { kind: "h2", cssclass: "text-normal", children: [
                                { kind: "span", text: "", cssclass: "glyph glyphicon glyphicon-lock color1" },
                                { kind: "text", text: "Reset password" }
                            ] }
                        ] },
                        { kind: "ds-dialog-form", children: [
                            { kind: "formgroup", type: "basic", children: [
                                { "kind": "input_text", "value": "m.email", label: "Email", "placeholder": "email", "cssclass": "", "name": "txtEmail" },
                                { "kind": "input_password", "value": "m.password", label: "Password", "placeholder": "password", "cssclass": "", "name": "txtPassword" },
                            ] },
                            { kind: "div", cssclass: "button-list", children: [
                                { kind: "button", text: "Reset my password", cssclass: "btn-primary", defaultButton: true, name: "btnReset" }
                            ] },
                        ] }
                    ] }
                ],
                "events": {}
            });
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var ControllerViewModel = (function (_super) {
                __extends(ControllerViewModel, _super);
                function ControllerViewModel() {
                    _super.apply(this, arguments);
                }
                ControllerViewModel.prototype.get_properties = function (list) {
                    list.addTextProp("name", "Name");
                };
                ControllerViewModel.prototype.get_model = function (id, params) {
                    return ControllerModel.createFor(id, params);
                };
                ControllerViewModel.prototype.get_title = function (model) {
                    return { label: "Api", icon: IDE.FileIcons.Api, text: model.get("name") };
                };
                ControllerViewModel.prototype.btnCreate_onclick = function () {
                    var m = this.model;
                    var file = m.save();
                    IDE.activeDesigner.closeAttributesPanel();
                    IDE.activeDesigner.toolbox.fileAdded(file);
                    this.closeAfterCreate();
                    IDE.activeDesigner.toolbox.actions.showController(m.get("name"));
                };
                ControllerViewModel.prototype.btnUpdate_onclick = function (event) {
                    var m = this.model;
                    var file = m.save();
                    m.copyToPreviousValues();
                    this.clearDirty();
                    IDE.activeDesigner.refreshView();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    this.closeAfterUpdate();
                };
                ControllerViewModel.prototype.btnDelete_onclick = function (event) {
                    var m = this.model;
                    var self = this;
                    this.confirmDelete({ component: event.component, text: "This action cannot be un-done.", onconfirm: function () {
                        var file = m.destroy();
                        IDE.activeDesigner.toolbox.fileDeleted(file);
                        var editor = IDE.activeDesigner.getControllerCodeSection();
                        editor.loadFile(null);
                        IDE.activeDesigner.footer.select(IDE.Footer.APP_MAIN_SECTION);
                        self.closeAfterDelete();
                    } });
                };
                return ControllerViewModel;
            })(IDE.IDEViewModel);
            ViewModels.ControllerViewModel = ControllerViewModel;
            IDE.Ide.routes.add("controller/edit", ControllerViewModel, "inspector");
            IDE.Ide.routes.add("controller/create", ControllerViewModel, "dialog");
            var ControllerModel = (function (_super) {
                __extends(ControllerModel, _super);
                function ControllerModel() {
                    _super.apply(this, arguments);
                }
                ControllerModel.prototype.define = function () {
                    return {
                        name: "Api",
                        fields: {
                            name: { type: "string", label: "Name" }
                        }
                    };
                };
                ControllerModel.createFor = function (id, params) {
                    if (id) {
                        var file = IDE.Ide.sourceApp.controllers.getFile(id);
                        var def = file.getContent();
                        return new ControllerModel({ file: file, name: def.name }, { isNew: false, modelDef: ControllerModel.prototype.modelDef });
                    }
                    else {
                        var m = new ControllerModel({ file: null, name: "" }, { isNew: true, modelDef: ControllerModel.prototype.modelDef });
                        return m;
                    }
                };
                ControllerModel.prototype.validate = function (errors) {
                    var name = this.get("name");
                    if (errors.required("name", name, "Api name is required")) {
                        if (!IDE.DesignerTools.isValidId(name)) {
                            errors.addFieldError("name", "Api name " + IDE.DesignerTools.invalidIdMessage());
                        }
                    }
                };
                ControllerModel.prototype.save = function () {
                    if (this.getIsNew()) {
                        return this.create();
                    }
                    else {
                        return this.update();
                    }
                };
                ControllerModel.prototype.destroy = function () {
                    var file = this.get("file");
                    IDE.activeDesigner.deleteFile(file);
                    return file;
                };
                ControllerModel.createEmptyDefinition = function () {
                    var controllerDef = {
                        name: null,
                        source_code: ""
                    };
                    return controllerDef;
                };
                ControllerModel.prototype.update = function () {
                    var errors = new Retool.ValidationError();
                    this.validate(errors);
                    errors.throwIfAny();
                    var file = this.get("file");
                    var controllerDef = file.getContent();
                    IDE.activeDesigner.saveFile(file, true);
                    return file;
                };
                ControllerModel.prototype.create = function () {
                    var name = this.get("name");
                    var fieldDefs = [];
                    var relationshipDefs = [];
                    var controllerDef = {
                        name: null,
                        source_code: ""
                    };
                    controllerDef.name = name;
                    var filename = IDE.Ide.sourceApp.controllers.getFilename(name);
                    var errors = new Retool.ValidationError();
                    this.validate(errors);
                    var existing = IDE.Ide.sourceApp.getFile(filename);
                    if (existing) {
                        errors.addFieldError("name", "An api with this name already exists");
                    }
                    errors.throwIfAny();
                    controllerDef.source_code = "class " + name + " extends ApiController {\n\n}\n";
                    var file = new Retool.FileSystem.File(filename, controllerDef);
                    IDE.activeDesigner.saveFile(file, true);
                    IDE.Ide.sourceApp.addFile(file);
                    return file;
                };
                return ControllerModel;
            })(IDE.IDEModel);
            ViewModels.ControllerModel = ControllerModel;
            IDE.Ide.models.add(ControllerModel);
            IDE.Ide.templateDefinitions.add("controller/create", {
                "name": "create",
                "title": "Create api",
                "hasForm": true,
                cssclass: "rto-small-dialog",
                "elements": [
                    { kind: "r-with", obj: "this.model", var: "m", children: [
                        { kind: "div", cssclass: "caption-bar", children: [
                            { "kind": "h2", "children": [
                                { "kind": "span", "text": "'", "cssclass": "glyph toolbox color4" },
                                { "kind": "span", "text": "New Api", "cssclass": "text-normal" }
                            ] }
                        ] },
                        { "kind": "ds-dialog-form", "children": [
                            { kind: "formgroup", type: "basic", children: [
                                { "kind": "input_text", "value": "m.name", label: "Name", "placeholder": "ApiName", "cssclass": "", "name": "txtName" },
                            ] },
                            { "kind": "div", "cssclass": "button-list", "children": [
                                { "kind": "button", "text": "Create api", "cssclass": "btn-primary", "defaultButton": true, "name": "btnCreate" }
                            ] }
                        ] }
                    ] }
                ],
                "events": {},
                "model": "_designer.controller"
            });
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var ComponentViewModel = (function (_super) {
                __extends(ComponentViewModel, _super);
                function ComponentViewModel() {
                    _super.apply(this, arguments);
                }
                ComponentViewModel.prototype.get_properties = function (list) {
                    list.addTextProp("name", "Name");
                };
                ComponentViewModel.prototype.get_toolbar = function () {
                    return [
                        { name: "btnCopy", text: "Copy" }
                    ];
                };
                ComponentViewModel.prototype.get_model = function (id, params) {
                    return IDE.Models.ComponentModel.createFor(id, params);
                };
                ComponentViewModel.prototype.get_title = function (model) {
                    return { label: "Component", icon: IDE.FileIcons.Component, text: model.get("name") };
                };
                ComponentViewModel.prototype.btnCreate_onclick = function () {
                    var m = this.model;
                    var file = m.save();
                    var canvas = IDE.Ide.getAppCanvas();
                    canvas.componentChanged(file);
                    IDE.activeDesigner.toolbox.refreshComponents();
                    this.closeAfterCreate();
                    IDE.activeDesigner.toolbox.fileAdded(file);
                };
                ComponentViewModel.prototype.btnUpdate_onclick = function () {
                    var m = this.model;
                    var file = m.save();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    m.copyToPreviousValues();
                    this.clearDirty();
                    IDE.activeDesigner.refreshView();
                    m.clearError();
                };
                ComponentViewModel.prototype.btnDelete_onclick = function (event) {
                    var m = this.model;
                    var self = this;
                    this.confirmDelete({ component: event.component, text: "This action cannot be un-done.", onconfirm: function () {
                        var file = m.destroy();
                        var canvas = IDE.Ide.getAppCanvas();
                        canvas.componentDeleted(file);
                        IDE.activeDesigner.toolbox.refreshComponents();
                        IDE.activeDesigner.toolbox.fileDeleted(file);
                        IDE.activeDesigner.closeAttributesPanel();
                        self.closeAfterDelete();
                    } });
                };
                ComponentViewModel.prototype.btnCopy_onclick = function () {
                    IDE.Ide.render("component/copy", null, { copyfrom: this.model.get("name") });
                };
                ComponentViewModel.prototype.btnCreateFromCopy_onclick = function () {
                    var m = this.model;
                    var file = m.copy();
                    this.closeAfterCreate();
                    IDE.activeDesigner.toolbox.fileAdded(file);
                };
                return ComponentViewModel;
            })(IDE.IDEViewModel);
            ViewModels.ComponentViewModel = ComponentViewModel;
            IDE.Ide.routes.add("component/edit", ComponentViewModel, "inspector");
            IDE.Ide.routes.add("component/create", ComponentViewModel, "dialog");
            IDE.Ide.routes.add("component/copy", ComponentViewModel, "dialog");
            IDE.Ide.templateDefinitions.add("component/create", {
                name: "component/create",
                title: "New component",
                cssclass: "rto-small-dialog",
                hasForm: true,
                elements: [
                    { kind: "r-with", obj: "this.model", var: "m", children: [
                        { kind: "div", cssclass: "caption-bar", children: [
                            { kind: "h2", cssclass: "text-normal", children: [
                                { kind: "span", text: "]", cssclass: "glyph toolbox color8" },
                                { kind: "text", text: "New component" }
                            ] },
                        ] },
                        { kind: "ds-dialog-form", children: [
                            { kind: "formgroup", type: "basic", children: [
                                { kind: "input_text", value: "m.name", placeholder: "component-name", label: "Name", cssclass: "text-lower" }
                            ] },
                            { kind: "div", cssclass: "button-list", children: [
                                { kind: "button", text: "Create", cssclass: "btn-primary", defaultButton: true, name: "btnCreate" }
                            ] }
                        ] }
                    ] }
                ]
            });
            IDE.Ide.templateDefinitions.add("component/copy", {
                name: "component/copy",
                title: "Copy component",
                cssclass: "rto-small-dialog",
                hasForm: true,
                elements: [
                    { kind: "r-with", obj: "this.model", var: "m", children: [
                        { kind: "div", cssclass: "caption-bar", children: [
                            { kind: "h2", cssclass: "text-normal", children: [
                                { kind: "span", text: "]", cssclass: "glyph toolbox color8" },
                                { kind: "text", text: "Copy component" }
                            ] },
                        ] },
                        { kind: "ds-dialog-form", children: [
                            { kind: "formgroup", type: "basic", children: [
                                { kind: "input_text", value: "m.copyfrom", placeholder: "copy-from-component", label: "Copy", cssclass: "text-lower", locked: true },
                                { kind: "input_text", value: "m.name", placeholder: "new-component-name", label: "To Name", cssclass: "text-lower" }
                            ] },
                            { "kind": "div", "cssclass": "button-list", "children": [
                                { "kind": "button", "text": "Create Copy", "cssclass": "btn-primary", "defaultButton": true, "name": "btnCreateFromCopy" }
                            ] }
                        ] }
                    ] }
                ]
            });
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ViewModels;
        (function (ViewModels) {
            var GenericFileViewModel = (function (_super) {
                __extends(GenericFileViewModel, _super);
                function GenericFileViewModel() {
                    _super.apply(this, arguments);
                }
                GenericFileViewModel.prototype.get_properties = function (list) {
                    // list.addTextProp("name","Name");
                };
                GenericFileViewModel.prototype.get_model = function (id, params) {
                    return GenericFileModel.createFor(id, params);
                };
                GenericFileViewModel.prototype.get_title = function (model) {
                    var name = model.get("name");
                    var ext = Retool.FileSystem.PathInfo.getExtension(name);
                    var icon = IDE.FileIcons.forExtension(ext);
                    return { label: "File", icon: icon, text: model.get("name") };
                };
                GenericFileViewModel.prototype.btnCreate_onclick = function () {
                    var m = this.model;
                    var file = m.save();
                    IDE.activeDesigner.closeAttributesPanel();
                    IDE.activeDesigner.toolbox.fileAdded(file);
                    IDE.activeDesigner.toolbox.actions.showGenericFile(m.get("name"));
                    this.closeAfterCreate();
                };
                GenericFileViewModel.prototype.btnUpdate_onclick = function (event) {
                    var m = this.model;
                    var file = m.save();
                    m.copyToPreviousValues();
                    IDE.activeDesigner.refreshView();
                    IDE.activeDesigner.toolbox.fileUpdated(file);
                    this.closeAfterUpdate();
                    this.clearDirty();
                };
                GenericFileViewModel.prototype.btnDelete_onclick = function (event) {
                    var m = this.model;
                    var self = this;
                    this.confirmDelete({ component: event.component, text: "This action cannot be un-done.", onconfirm: function () {
                        var file = m.destroy();
                        IDE.activeDesigner.toolbox.fileDeleted(file);
                        var editor = IDE.activeDesigner.getGenericEditor();
                        editor.loadFile(null);
                        self.closeAfterDelete();
                    } });
                };
                return GenericFileViewModel;
            })(IDE.IDEViewModel);
            ViewModels.GenericFileViewModel = GenericFileViewModel;
            IDE.Ide.routes.add("generic-file/edit", GenericFileViewModel, "inspector");
            IDE.Ide.routes.add("generic-file/create", GenericFileViewModel, "dialog");
            var GenericFileModel = (function (_super) {
                __extends(GenericFileModel, _super);
                function GenericFileModel() {
                    _super.apply(this, arguments);
                }
                GenericFileModel.prototype.define = function () {
                    return {
                        name: "File",
                        fields: {
                            name: { name: "name", type: "string", label: "Name" }
                        }
                    };
                };
                GenericFileModel.createFor = function (id, params) {
                    if (id) {
                        var file = IDE.Ide.sourceApp.getFile(id);
                        var name = "";
                        if (file) {
                            name = file.name;
                        }
                        return new GenericFileModel({ file: file, name: name }, { modelDef: null, isNew: false });
                    }
                    params = params || {};
                    var folder = (params.folder) ? params.folder + "/" : "";
                    var m = new GenericFileModel({ file: null, name: folder }, { modelDef: GenericFileModel.prototype.modelDef, isNew: true });
                    return m;
                };
                GenericFileModel.prototype.validate = function (errors) {
                    var name = this.get("name");
                    if (errors.required("name", name, "File name is required")) {
                        var name = this.get("name").toLowerCase();
                        if (this.getIsNew()) {
                            if (IDE.Folders.isRestricted(name)) {
                                return errors.addFieldError("name", "The specified folder is restricted.");
                            }
                            if (!IDE.DesignerTools.isValidFilename(name)) {
                                return errors.addFieldError("name", "Invalid file name");
                            }
                            var filename = this.makeFilename(name);
                            var existingFile = IDE.Ide.sourceApp.getFile(filename);
                            if (existingFile) {
                                errors.addFieldError("name", "A file with this name already exists");
                            }
                        }
                    }
                };
                GenericFileModel.prototype.makeFilename = function (name) {
                    return name;
                };
                GenericFileModel.prototype.save = function () {
                    var errors = new Retool.ValidationError();
                    var file;
                    if (this.getIsNew()) {
                        this.validate(errors);
                        errors.throwIfAny();
                        var files = [];
                        var name = this.get("name");
                        var filename = this.makeFilename(name);
                        file = new Retool.FileSystem.File(name, "");
                        this.set("file", file);
                        files.push(file);
                        IDE.activeDesigner.saveFileBatch(files);
                        for (var i = 0; i < files.length; i++) {
                            var file = files[i];
                            IDE.Ide.sourceApp.addFile(file);
                        }
                    }
                    else {
                        this.validate(errors);
                        errors.throwIfAny();
                        file = this.get("file");
                        IDE.activeDesigner.saveFile(file, true);
                    }
                    return file;
                };
                GenericFileModel.prototype.destroy = function () {
                    var file = this.get("file");
                    IDE.activeDesigner.deleteFile(file);
                    return file;
                };
                return GenericFileModel;
            })(IDE.IDEModel);
            ViewModels.GenericFileModel = GenericFileModel;
            IDE.Ide.models.add(GenericFileModel);
            IDE.Ide.templateDefinitions.add("generic-file/create", {
                name: "generic-file/create",
                title: "New file",
                cssclass: "rto-small-dialog",
                hasForm: true,
                elements: [
                    { kind: "r-with", obj: "this.model", var: "m", children: [
                        { kind: "div", cssclass: "caption-bar", children: [
                            { kind: "h2", cssclass: "text-normal", children: [
                                { kind: "span", text: IDE.FileIcons.File.glyph, cssclass: "glyph toolbox color" + IDE.FileIcons.File.color },
                                { kind: "text", text: "New file" }
                            ] }
                        ] },
                        { kind: "ds-dialog-form", children: [
                            { kind: "formgroup", type: "basic", children: [
                                { "kind": "input_text", "value": "m.name", label: "Name", "placeholder": "Filename", "cssclass": "", "name": "txtName" },
                            ] },
                            { kind: "div", cssclass: "button-list", children: [
                                { kind: "button", text: "Create", cssclass: "btn-primary", defaultButton: true, name: "btnCreate" }
                            ] },
                        ] }
                    ] }
                ],
                "events": {},
                "model": "_designer.css"
            });
        })(ViewModels = IDE.ViewModels || (IDE.ViewModels = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        IDE.Ide.templateDefinitions.add("template/create", {
            name: "template/create",
            title: "New template",
            cssclass: "rto-small-dialog",
            hasForm: true,
            elements: [
                { kind: "r-with", obj: "this.model", var: "m", children: [
                    { kind: "div", cssclass: "caption-bar", children: [
                        { kind: "h2", cssclass: "text-normal", children: [
                            { kind: "span", text: ")", cssclass: "glyph toolbox color0" },
                            { kind: "text", text: "New template" }
                        ] },
                    ] },
                    { kind: "ds-dialog-form", children: [
                        { kind: "formgroup", type: "basic", children: [
                            { kind: "input_text", value: "m.name", placeholder: "template-name", label: "Name", cssclass: "text-lower" },
                            { kind: "br" },
                            { kind: "input_text", value: "m.model", isDrop: true, droptype: "models", label: "Data model" }
                        ] },
                        { kind: "h5", text: "CREATE AS:" },
                        { kind: "r-foreach", obj: "m.choices", var: "c", children: [
                            { kind: "div", cssclass: "drop-as-choice", children: [
                                { kind: "a", name: "btnItem", children: [
                                    { kind: "strong", text: "{{c.name}}" }
                                ] }
                            ] }
                        ] },
                    ] }
                ] }
            ]
        });
        IDE.Ide.templateDefinitions.add("template/copy", {
            name: "template/copy",
            title: "Copy template",
            cssclass: "rto-small-dialog",
            hasForm: true,
            elements: [
                { kind: "r-with", obj: "this.model", var: "m", children: [
                    { kind: "div", cssclass: "caption-bar", children: [
                        { kind: "h2", cssclass: "text-normal", children: [
                            { kind: "span", text: ")", cssclass: "glyph toolbox color0" },
                            { kind: "text", text: "Copy template" }
                        ] },
                    ] },
                    { kind: "ds-dialog-form", children: [
                        { kind: "formgroup", type: "basic", children: [
                            { kind: "input_text", value: "m.copyfrom", placeholder: "copy from template", label: "Copy", cssclass: "text-lower", locked: true },
                            { kind: "input_text", value: "m.name", placeholder: "template-name", label: "To Name", cssclass: "text-lower" }
                        ] },
                        { "kind": "div", "cssclass": "button-list", "children": [
                            { "kind": "button", "text": "Create Copy", "cssclass": "btn-primary", "defaultButton": true, "name": "btnCreateFromCopy" }
                        ] }
                    ] }
                ] }
            ]
        });
        IDE.Ide.templateDefinitions.add("template/create-partial", {
            name: "template/from-element",
            title: "Create partial",
            cssclass: "rto-small-dialog",
            hasForm: true,
            elements: [
                { kind: "r-with", obj: "this.model", var: "m", children: [
                    { kind: "div", cssclass: "caption-bar", children: [
                        { kind: "h2", cssclass: "text-normal", children: [
                            { kind: "span", text: ")", cssclass: "glyph toolbox color0" },
                            { kind: "text", text: "Create partial" }
                        ] },
                    ] },
                    { kind: "ds-dialog-form", children: [
                        { kind: "formgroup", type: "basic", children: [
                            { kind: "input_text", value: "m.name", placeholder: "partial-name", label: "Name", cssclass: "text-lower" }
                        ] },
                        { "kind": "div", "cssclass": "button-list", "children": [
                            { "kind": "button", "text": "Create", "cssclass": "btn-primary", "defaultButton": true, "name": "btnCreatePartial" }
                        ] }
                    ] }
                ] }
            ]
        });
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
/*
{kind:"div",cssclass:"button-list",children:[
            {kind:"button",text:"Create",cssclass:"default",defaultButton:true,name:"btnCreate"}
          ]},
          */
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        IDE.Ide.templateDefinitions.add("model/create", {
            "name": "create",
            "title": "Create model",
            "hasForm": true,
            cssclass: "rto-large-dialog",
            "elements": [
                { kind: "r-with", obj: "this.model", var: "m", children: [
                    { kind: "div", cssclass: "caption-bar", children: [
                        { kind: "r-if", condition: "!this.addfields", children: [
                            { "kind": "h2", "children": [
                                { "kind": "span", "text": "O", "cssclass": "glyph toolbox color1" },
                                { "kind": "span", "text": "New model", "cssclass": "text-normal" }
                            ] }
                        ] },
                        { kind: "r-if", condition: "this.addfields", children: [
                            { "kind": "h2", "children": [
                                { "kind": "span", "text": "L", "cssclass": "glyph toolbox color1" },
                                { "kind": "span", text: "{{m.name}}" },
                                { "kind": "span", "text": " - add fields", "cssclass": "text-normal" }
                            ] }
                        ] }
                    ] },
                    { "kind": "ds-dialog-form", "children": [
                        { kind: "r-if", condition: "!this.addfields", children: [
                            { kind: "formgroup", type: "basic", children: [
                                { "kind": "input_text", "value": "m.name", label: "Name", "placeholder": "ModelName", "cssclass": "", "name": "txtName" },
                                { "kind": "input_text", "value": "m.label", label: "Label", "placeholder": "My Model" },
                                { "kind": "input_checkbox", "value": "m.exposed", label: "Expose As Endpoint" },
                            ] },
                            { "kind": "hr" },
                            { "kind": "h4", "text": "Fields" }
                        ] },
                        { "kind": "table", "children": [
                            { "kind": "thead", "children": [
                                { "kind": "th", "text": "Name", cssclass: "text-center" },
                                { "kind": "th", "text": "Type", cssclass: "text-center" },
                                { "kind": "th", "text": "Size", "cssclass": "text-center" }
                            ] },
                            { kind: "r-foreach", obj: "m.fields", var: "f", children: [
                                { "kind": "tr", name: "fieldRow", "children": [
                                    { "kind": "td", "width": "250", "children": [
                                        { "kind": "input_text", "value": "f.name" }
                                    ] },
                                    { "kind": "td", "name": "txtType", "children": [
                                        { "kind": "input", "type": "text", "value": "f.type", "droptype": "fieldtypes", "name": "txtFieldType", "isDrop": true }
                                    ] },
                                    { "kind": "td", "width": "120", "cssclass": "text-right", "children": [
                                        { "kind": "input_text", "value": "f.size", "cssclass": "text-right" }
                                    ] },
                                    { "kind": "td", "width": "120", "cssclass": "text-right", "children": [
                                        { "kind": "a", cssclass: "delete-row", name: "btnDeleteRow", tabindex: "-1" }
                                    ] }
                                ] }
                            ] }
                        ] },
                        { kind: "div", cssclass: "table-tools", children: [
                            { kind: "a", name: "btnAddRow", cssclass: "click-on-focus", icon: "plus-sign", text: "Add field" }
                        ] },
                        { "kind": "div", "cssclass": "button-list", "children": [
                            { kind: "r-if", condition: "this.addfields", children: [
                                { "kind": "button", "text": "Update model", "cssclass": "btn-primary", "defaultButton": true, "name": "btnCreate" }
                            ] },
                            { kind: "r-if", condition: "!this.addfields", children: [
                                { "kind": "button", "text": "Create model", "cssclass": "btn-primary", "defaultButton": true, "name": "btnCreate" }
                            ] }
                        ] }
                    ] }
                ] }
            ],
            "events": {},
            "model": "_designer.model"
        });
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        IDE.Ide.templateDefinitions.add("relationship/create", {
            "name": "relationship/create",
            "title": "Add relationship",
            "hasForm": true,
            cssclass: "rto-large-dialog",
            "elements": [
                { kind: "r-with", obj: "this.model", var: "m", children: [
                    { kind: "div", cssclass: "caption-bar", children: [
                        { "kind": "h2", "children": [
                            { "kind": "span", "text": "V", "cssclass": "glyph toolbox color1" },
                            { "kind": "text", "text": "{{m.modelName}}" },
                            { "kind": "span", "text": ": add relationship", "cssclass": "text-normal" }
                        ] },
                    ] },
                    { "kind": "ds-dialog-form", "children": [
                        { kind: "formgroup", type: "basic", children: [
                            { "kind": "input_text", "value": "m.type", label: "Type", droptype: "generic", dropItems: ["belongs_to", "detail", "master"] },
                            { "kind": "input_text", "value": "m.related_model", "droptype": "models", "isDrop": true, label: "Related Model" },
                            { "kind": "input_text", "value": "m.name", "label": "Relationship name" },
                            { "kind": "input_text", "value": "m.foreign_key", "droptype": "fields", "isDrop": true, allowNonDrop: true, label: "Foreign Key" }
                        ] },
                        { "kind": "div", "cssclass": "button-list", "children": [
                            { "kind": "button", "text": "Add relationship", "cssclass": "btn-primary", "defaultButton": true, "name": "btnCreate" }
                        ] }
                    ] }
                ] }
            ],
            "events": {},
            "model": "_designer.relationship"
        });
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        IDE.Ide.templateDefinitions.add("drop-as/ask", {
            name: "drop-as/ask",
            title: "Drop as",
            cssclass: "rto-small-dialog",
            hasForm: true,
            elements: [
                { kind: "r-with", obj: "this.model", var: "m", children: [
                    { kind: "h4", cssclass: "text-normal", children: [
                        { kind: "span", text: "]", cssclass: "glyph toolbox color0" },
                        { kind: "text", text: "Drop " },
                        { kind: "strong", text: "{{m.propname}}" },
                        { kind: "text", text: " as ..." }
                    ] },
                    { kind: "ds-dialog-form", children: [
                        { kind: "r-foreach", obj: "m.items", var: "d", children: [
                            { kind: "div", cssclass: "drop-as-choice", children: [
                                { kind: "a", name: "btnItem", children: [
                                    { kind: "strong", text: "{{d.name}}" },
                                    { kind: "text", text: " {{d.tag}}" }
                                ] }
                            ] }
                        ] }
                    ] }
                ] }
            ]
        });
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        IDE.Ide.templateDefinitions.add("css/create", {
            name: "css/create",
            title: "New css file",
            cssclass: "rto-small-dialog",
            hasForm: true,
            elements: [
                { kind: "r-with", obj: "this.model", var: "m", children: [
                    { kind: "div", cssclass: "caption-bar", children: [
                        { kind: "h2", cssclass: "text-normal", children: [
                            { kind: "span", text: "`", cssclass: "glyph toolbox color3" },
                            { kind: "text", text: "New css file" }
                        ] }
                    ] },
                    { kind: "ds-dialog-form", children: [
                        { kind: "formgroup", type: "basic", children: [
                            { "kind": "input_text", "value": "m.name", label: "Name", "placeholder": "Filename", "cssclass": "", "name": "txtName" },
                        ] },
                        { kind: "div", cssclass: "button-list", children: [
                            { kind: "button", text: "Create", cssclass: "btn-primary", defaultButton: true, name: "btnCreate" }
                        ] },
                    ] }
                ] }
            ],
            "events": {},
            "model": "_designer.css"
        });
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        IDE.Ide.templateDefinitions.add("login/index", {
            name: "login/index",
            title: "Login",
            cssclass: "rto-small-dialog",
            hasForm: true,
            elements: [
                { kind: "r-with", obj: "this.model", var: "m", children: [
                    { kind: "div", cssclass: "caption-bar", children: [
                        { kind: "h2", cssclass: "text-normal", children: [
                            { kind: "span", text: "", cssclass: "glyph glyphicon glyphicon-log-in color1" },
                            { kind: "text", text: "Sign in" }
                        ] }
                    ] },
                    { kind: "ds-dialog-form", children: [
                        { kind: "div", cssclass: "button-list text-center", children: [
                            { kind: "button", text: "Sign in with Github", cssclass: "btn-primary", defaultButton: true, name: "btnSignin" }
                        ] },
                    ] }
                ] }
            ],
            "events": {}
        });
        IDE.Ide.templateDefinitions.add("login/auth", {
            name: "login/auth",
            title: "Login",
            cssclass: "rto-small-dialog",
            hasForm: true,
            elements: [
                { kind: "r-with", obj: "this.model", children: [
                    { kind: "div", cssclass: "caption-bar", children: [
                        { kind: "h2", cssclass: "text-normal", children: [
                            { kind: "span", text: "", cssclass: "glyph glyphicon glyphicon-log-in color1" },
                            { kind: "text", text: "Authorizing..." }
                        ] }
                    ] },
                    { kind: "ds-dialog-form", children: [
                        { kind: "div", cssclass: "button-list text-center", children: [
                            { kind: "button", text: "Sign in with Github", cssclass: "btn-primary", defaultButton: true, name: "btnSignin" }
                        ] },
                    ] }
                ] }
            ],
            "events": {}
        });
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
/*
 {kind:"formgroup",type:"basic",children:[
                {"kind":"input_text","value":"email",label:"Email","placeholder":"email","cssclass":"","name":"txtEmail"},
                {"kind":"input_password","value":"password",label:"Password","cssclass":"","name":"txtPassword"},
              ]},


               {kind:"br"},
              {kind:"a",cssclass:"small",text:"Forgot your password?",name:"btnForgot"}
*/
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var SiteManager = (function (_super) {
            __extends(SiteManager, _super);
            function SiteManager(myPrototype) {
                _super.call(this, myPrototype);
            }
            SiteManager.prototype.vm_deploy = function (params) {
                var proc = params.proc;
                var args = params.args[0];
                var url = args.url;
                var packageBuilder = new IDE.Util.DeployPackageBuilder({ siteMapUrl: url });
                var pkg = packageBuilder.build();
                var self = this;
                var async = proc.pause();
                packageBuilder.send({
                    url: url,
                    body: pkg,
                    success: function (response) {
                        async.resume({ success: "**" + url + "** upgraded to version: **" + response.result.version + "**" });
                    },
                    error: function (response) {
                        async.resume({ error: response.error.general });
                    }
                });
            };
            SiteManager.prototype.vm_exportFolder = function (params) {
                var proc = params.proc;
                var args = params.args[0];
                var folderName = args.name;
                var async = proc.pause();
                var folder = IDE.Ide.sourceApp.getFolder(folderName);
                if (!folder) {
                    async.resume({ error: "Unknow folder: **" + folderName + "**" });
                }
                var packageBuilder = new IDE.Util.DeployPackageBuilder({});
                var content;
                try {
                    var list = [];
                    Retool.App.exportFolder(folder, list);
                    content = { root: folderName, files: list };
                }
                catch (e) {
                    async.exception(e.toString());
                    return;
                }
                var filename = folderName.replace(/\//g, "-") + ".js";
                var contentBlock;
                if (args.asCode) {
                    contentBlock = "Retool.defineApplication(" + JSON.stringify(content) + ");";
                }
                else {
                    contentBlock = JSON.stringify(content);
                }
                IDE.DesignerTools.downloadEcho({
                    filename: filename,
                    content: contentBlock,
                    success: function () {
                        async.resume({ success: "Exported folder **" + folderName + "**" });
                    },
                    error: function (data) {
                        async.exception(data.error.general);
                    }
                });
            };
            SiteManager.prototype.vm_exportSite = function (params) {
                var proc = params.proc;
                var args = params.args[0];
                var async = proc.pause();
                var packageBuilder = new IDE.Util.DeployPackageBuilder({});
                var content;
                try {
                    content = packageBuilder.exportSite();
                }
                catch (e) {
                    async.resume({ error: e.toString() });
                    return;
                }
                var filename = location.hostname + "-site.js";
                IDE.DesignerTools.downloadEcho({
                    filename: filename,
                    content: JSON.stringify(content),
                    success: function () {
                        async.resume({ success: "Exported site **" + filename + "**" });
                    },
                    error: function (data) {
                        async.exception(data.error.general);
                    }
                });
            };
            SiteManager.prototype.vm_importFilePkg = function (params) {
                var proc = params.proc;
                var args = params.args[0];
                var files = args.files;
                var file = files[0];
                var reader = new FileReader();
                var async = proc.pause();
                reader.onload = function (evt) {
                    var content;
                    var target = evt.target;
                    try {
                        content = JSON.parse(target.result);
                    }
                    catch (e) {
                        async.resume({ error: "Unable to import, file does not contain valid json." });
                        return;
                    }
                    IDE.ImportUtils.importFilePkg({ content: content, success: function (fileList) {
                        async.resume({ success: "Imported folder: **" + content.root + "**, " + fileList.length.toString() + " files imported." });
                    }, error: function (err) {
                        async.resume({ error: err });
                    } });
                };
                reader.onerror = function (evt) {
                    async.resume({ error: 'Error reading file' });
                };
                reader.readAsText(file, "UTF-8");
            };
            SiteManager.prototype.vm_importSite = function (params) {
                var proc = params.proc;
                var args = params.args[0];
                var files = args.files;
                var file = files[0];
                var reader = new FileReader();
                var async = proc.pause();
                reader.onload = function (evt) {
                    var content;
                    var target = evt.target;
                    try {
                        content = JSON.parse(target.result);
                    }
                    catch (e) {
                        async.resume({ error: "Unable to import, file does not contain valid json." });
                        return;
                    }
                    if (!content || !content.length) {
                        async.resume({ error: 'Not a site file.' });
                        return;
                    }
                    var appsFolder = IDE.Ide.sourceApp.getFolder("apps");
                    if (!appsFolder.isEmpty() && false) {
                        async.resume({ error: 'Cannot import, this site already contains applications' });
                        return;
                    }
                    var filesToSave = [];
                    for (var i = 0; i < content.length; i++) {
                        var pkgFile = content[i];
                        var file = new Retool.FileSystem.File(pkgFile.id, pkgFile.value);
                        filesToSave.push(file);
                    }
                    IDE.activeDesigner.saveFileBatch(filesToSave);
                    for (var i = 0; i < filesToSave.length; i++) {
                        var newFile = filesToSave[i];
                        IDE.Ide.sourceApp.addFile(newFile);
                        console.log("Creating " + newFile.path + "/" + newFile.name + " ...");
                    }
                    async.resume({ success: "Imported site: " + filesToSave.length.toString() + " files imported." });
                };
                reader.onerror = function (evt) {
                    async.resume({ error: 'Error reading file' });
                };
                reader.readAsText(file, "UTF-8");
            };
            return SiteManager;
        })(Retool.VM.ObjectBase);
        IDE.SiteManager = SiteManager;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var VM;
    (function (VM) {
        var Dialog = (function (_super) {
            __extends(Dialog, _super);
            function Dialog(myPrototype) {
                _super.call(this, myPrototype);
            }
            Dialog.prototype.vm_success = function (params) {
                this.showConfirm(params, "success");
            };
            Dialog.prototype.vm_danger = function (params) {
                this.showConfirm(params, "danger");
            };
            Dialog.prototype.vm_warning = function (params) {
                this.showConfirm(params, "warning");
            };
            Dialog.prototype.vm_info = function (params) {
                this.showConfirm(params, "info");
            };
            Dialog.prototype.showConfirm = function (params, css) {
                var proc = params.proc;
                var arg = params.args[0];
                var options = {};
                var settings;
                if (typeof arg == "string") {
                    settings = {};
                    if (params.args.length > 1) {
                        settings = params.args[1];
                    }
                    settings.text = arg;
                }
                else if (arg) {
                    settings = arg;
                }
                else {
                    settings = { text: "Continue?" };
                }
                options.title = settings.text || "Do you wish to continue?";
                if (css) {
                    options.cssclass = "panel-" + css;
                    options.buttonClass = "btn-" + css;
                }
                else {
                    options.cssclass = "panel-warning";
                    options.buttonClass = "btn-warning";
                }
                options.buttonText = settings.button || "Continue";
                options.buttons = [
                    { name: "btnContinue", text: options.buttonText, cssclass: (options.buttonClass || "btn-primary") },
                    { name: "btnCancel", text: "Cancel", cssclass: "btn-link" }
                ];
                var async = proc.pause();
                options.onconfirm = function (event) {
                    async.resume(true);
                };
                options.oncancel = function (event) {
                    async.resume(false);
                };
                if (proc.component) {
                    var view = proc.component.getView();
                    view.refreshRenderedComponents({});
                }
                this.showDialog(params.proc.component, options);
            };
            Dialog.prototype.showDialog = function (component, options) {
                var viewModel;
                var viewDef;
                if (options.viewDef) {
                    viewDef = options.viewDef;
                }
                else {
                    var children = [];
                    var formKind = (options.formKind || "dialog");
                    viewDef = { "kind": formKind, "title": options.title, children: children, cssclass: options.cssclass };
                    if (options.buttons) {
                        for (var i = 0; i < options.buttons.length; i++) {
                            var button = options.buttons[i];
                            children.push({ "kind": "button", text: button.text, cssclass: (button.cssclass || ""), name: button.name });
                        }
                    }
                }
                var actions = {
                    btnCancel_onclick: function (event) {
                        event.component.closeDialog();
                        if (options.oncancel) {
                            options.oncancel();
                        }
                    },
                    btnContinue_onclick: function (event) {
                        event.component.closeDialog();
                        if (options.onconfirm) {
                            options.onconfirm();
                        }
                    }
                };
                viewDef.actions = actions;
                var viewFile = new Retool.FileSystem.File("dialog", null);
                var url = new Retool.Url();
                var template = { url: url, file: viewFile, definition: viewDef };
                viewModel = this.createDialogViewModel(component.context.canvas, template);
                var model = new Retool.ObjectModel({}, { modelDef: null });
                var context = new Retool.RenderingContext(null, viewModel, model, component.context);
                var container = this.findClosestDialogContainer(component);
                var writer = container.createWriter();
                if (container) {
                    var dialog = writer.createRootComponent({ element: viewDef, viewModel: viewModel, context: context });
                    var h = container.helper;
                    h.renderDialog(container, writer, dialog);
                }
            };
            Dialog.prototype.createDialogViewModel = function (canvas, template) {
                var viewModel = Retool.ViewModel.create(canvas, template);
                var uniqueId = new Date().getTime().toString();
                return viewModel;
            };
            Dialog.prototype.findClosestDialogContainer = function (c) {
                while (c) {
                    if (c.helper["renderDialog"]) {
                        return c;
                    }
                    c = c.parent;
                }
                return null;
            };
            return Dialog;
        })(VM.ObjectBase);
        VM.Dialog = Dialog;
        VM.addType("Dialog", Dialog, new Dialog(null));
    })(VM = Retool.VM || (Retool.VM = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var VMClasses;
        (function (VMClasses) {
            var Controllers = (function (_super) {
                __extends(Controllers, _super);
                function Controllers() {
                    _super.call(this, null);
                }
                Controllers.prototype._getHints = function () {
                    var list = [];
                    list.push({ include: "api" });
                    return list;
                };
                return Controllers;
            })(Retool.VM.ObjectBase);
            VMClasses.Controllers = Controllers;
            Retool.VM.addType("Api", null, new Controllers());
            var Models = (function (_super) {
                __extends(Models, _super);
                function Models() {
                    _super.call(this, null);
                }
                Models.prototype._getHints = function () {
                    var list = [];
                    list.push({ include: "models" });
                    return list;
                };
                return Models;
            })(Retool.VM.ObjectBase);
            VMClasses.Models = Models;
            Retool.VM.addType("Models", null, new Models());
        })(VMClasses = IDE.VMClasses || (IDE.VMClasses = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var MixedExpressionTokenizer = (function () {
            function MixedExpressionTokenizer(src, options) {
                this.src = src;
                this.index = 0;
                if (options) {
                    this.includePartial = options.includePartial;
                }
                this.state = "text";
                this.tokens = [];
            }
            MixedExpressionTokenizer.prototype.peek = function () {
                var p = this.index + 1;
                if (p < this.src.length) {
                    return this.src[p];
                }
                return null;
            };
            MixedExpressionTokenizer.prototype.eof = function () {
                return this.index >= this.src.length;
            };
            MixedExpressionTokenizer.prototype.tokenize = function () {
                var text = "";
                var textStart = 0;
                while (this.index < this.src.length) {
                    var ch = this.src[this.index++];
                    if (ch == "{" && this.index <= this.src.length && this.src[this.index] == "{") {
                        this.index++;
                        this.pushText(text, textStart, this.index - 3);
                        text = "";
                        this.scanScript(this.index - 2);
                        textStart = this.index;
                    }
                    else {
                        if (ch == "\\" && this.index <= this.src.length && this.src[this.index] == "{") {
                            text += "{";
                            this.index++;
                        }
                        else {
                            text += ch;
                        }
                    }
                }
                this.pushText(text, textStart, this.src.length - 1);
                return this.tokens;
            };
            MixedExpressionTokenizer.prototype.pushText = function (text, start, end) {
                if (text) {
                    this.tokens.push({ type: "text", value: text, start: start, end: end });
                }
            };
            MixedExpressionTokenizer.prototype.pushExpression = function (expr, start, end) {
                if (expr) {
                    this.tokens.push({ type: "expr", value: expr, start: start, end: end });
                }
            };
            MixedExpressionTokenizer.prototype.scanScript = function (startIndex) {
                var curly = 0;
                var expr = "";
                while (this.index < this.src.length) {
                    var ch = this.src[this.index++];
                    if (ch == "{") {
                        curly++;
                    }
                    else if (ch == "}") {
                        curly--;
                        if (curly < 0) {
                            this.index++; // remove next }
                            this.pushExpression(expr, startIndex, this.index - 1);
                            return;
                        }
                    }
                    if (ch == "\'" || ch == "\"") {
                        expr += this.scanLiteral(ch);
                    }
                    else {
                        expr += ch;
                    }
                }
                if (this.includePartial) {
                    this.pushExpression(expr, startIndex, this.src.length - 1);
                }
            };
            MixedExpressionTokenizer.prototype.scanLiteral = function (q) {
                var literal = q;
                while (this.index < this.src.length) {
                    var ch = this.src[this.index++];
                    literal += ch;
                    if (ch == "\\") {
                        if (this.index < this.src.length) {
                            literal += this.src[this.index++];
                        }
                    }
                    else if (ch == q) {
                        return literal;
                    }
                }
                return literal;
            };
            return MixedExpressionTokenizer;
        })();
        IDE.MixedExpressionTokenizer = MixedExpressionTokenizer;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var TemplateCompiler = (function () {
            function TemplateCompiler() {
                this.currentFieldList = {};
                this.fieldListStack = [];
                this.prefix = "";
                this.errors = [];
            }
            TemplateCompiler.compile = function (app, sourceFile, helperLocator, logger) {
                var compiler = new TemplateCompiler();
                var fileContent = sourceFile.getContent();
                compiler.definition = fileContent;
                compiler.helperLocator = helperLocator;
                var template = { file: sourceFile, definition: compiler.definition };
                compiler.template = template;
                compiler.sourceFile = sourceFile;
                compiler.logger = logger;
                if (fileContent.source_code) {
                    try {
                        var options = { sourceFile: sourceFile, tracking: true, appName: "" };
                        var program = IDE.JavascriptCompiler.compileProgram(fileContent.source_code, options);
                        var proto = program.getPrototype();
                        if (proto) {
                            sourceFile.compiledPrototype = proto;
                        }
                        else {
                            sourceFile.compiledPrototype = new Retool.VM.Prototype(sourceFile.name);
                        }
                        sourceFile.requiresCompile = false;
                        sourceFile.compileError = null;
                    }
                    catch (e) {
                        var compiledCode = new Retool.VM.Prototype(sourceFile.name);
                        sourceFile.compiledPrototype = compiledCode;
                        sourceFile.requiresCompile = false;
                        var error = Retool.VM.VMError.cast(e);
                        //error.title = "Compile Error";
                        template.hasErrors = true;
                        logger.addError(error);
                    }
                }
                try {
                    compiler.doCompile();
                }
                catch (e) {
                    var error = Retool.VM.VMError.cast(e);
                    error.title = "Template Compile Error:" + name;
                    template.hasErrors = true;
                    logger.addError(error);
                }
                return template;
            };
            TemplateCompiler.prototype.addChildTemplate = function (element, path) {
                var fullId = (this.prefix) ? this.prefix + "." + element.id : element.id;
                var child = { id: fullId, element: element, templateName: path };
                var template = this.template;
                template.childTemplateElements = template.childTemplateElements || [];
                template.childTemplateElements.push(child);
            };
            TemplateCompiler.prototype.pushFieldList = function () {
                this.fieldListStack.push(this.currentFieldList);
                this.currentFieldList = {};
            };
            TemplateCompiler.prototype.popFieldList = function () {
                this.currentFieldList = this.fieldListStack.pop();
            };
            TemplateCompiler.prototype.addReferencedField = function (field) {
                this.currentFieldList[field.toLowerCase()] = 1;
            };
            TemplateCompiler.prototype.doCompile = function () {
                if (!this.definition.elements) {
                    this.definition.elements = [];
                }
                var template = this.template;
                template.wrapper = { kind: "viewcontainer", children: this.definition.elements };
                var children = this.definition.elements;
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    this.compileElement(child);
                }
            };
            TemplateCompiler.prototype.compileElement = function (element) {
                var handler = this.helperLocator.get(element.kind);
                if (!handler) {
                    handler = this.helperLocator.get("div");
                }
                if (element.kind == "r-body") {
                    this.template.hasBodyTag = true;
                }
                var result = IDE.ElementCompiler.compile(handler, element, this.sourceFile);
                element._compiled = result.methods;
                if (element._compiled) {
                    element._compiled._src = this.sourceFile.getFullName();
                }
                if (result.errors) {
                    for (var i = 0; i < result.errors.length; i++) {
                        var e = result.errors[i];
                        var error = e.error;
                        error.title = "Invalid " + e.prop + " expression";
                        error.source = { type: "element", id: element.id, codeText: e.expression, codeLink: element.kind + " " + e.prop, filename: this.template.file.getFullName() };
                        this.logger.addError(error);
                        this.template.hasErrors = true;
                    }
                }
                handler.map(element, this);
            };
            TemplateCompiler.prototype.compileChildren = function (element) {
                if (element.children) {
                    for (var i = 0; i < element.children.length; i++) {
                        var child = element.children[i];
                        this.compileElement(child);
                    }
                }
            };
            TemplateCompiler.prototype.pushPrefix = function (prefix) {
                if (this.prefix) {
                    this.prefix += "." + prefix;
                }
                else {
                    this.prefix = prefix;
                }
            };
            TemplateCompiler.prototype.popPrefix = function () {
                var i = this.prefix.lastIndexOf('.');
                if (i > -1) {
                    this.prefix = this.prefix.substr(0, i);
                }
                else {
                    this.prefix = "";
                }
            };
            return TemplateCompiler;
        })();
        IDE.TemplateCompiler = TemplateCompiler;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ElementCompiler = (function () {
            function ElementCompiler() {
                this._count = 0;
            }
            ElementCompiler.compile = function (handler, element, sourceFile) {
                var compiler = new ElementCompiler();
                compiler.sourceFile = sourceFile;
                compiler.element = element;
                return compiler.doCompile(handler);
            };
            ElementCompiler.prototype.doCompile = function (handler) {
                var element = this.element;
                this._compiled = {};
                if (handler.properties) {
                    // custom component properties
                    var attribs = handler.properties.list;
                    for (var i = 0; i < attribs.length; i++) {
                        var a = attribs[i];
                        this.compileExpression(a.name, "text");
                    }
                }
                else {
                    this.compileExpression("text", "text");
                    this.compileExpression("cssclass", "text");
                    this.compileExpression("expression", "expr");
                    this.compileExpression("condition", "expr");
                    this.compileExpression("params", "expr");
                    this.compileExpression("obj", "expr");
                    this.compileExpression("href", "href");
                    this.compileExpression("value", "expr");
                    this.compileExpression("markdown", "markdown");
                    this.compileExpression("src", "text");
                    if (element.value) {
                        this.compileExpression("value_setter", "expr", { src: element.value + "=$$_value", ignoreError: true });
                    }
                    this.compileExpression("template", element.template);
                    if (handler.attributes) {
                        for (var key in handler.attributes) {
                            var settings = handler.attributes[key];
                            if (settings.implicitExpression) {
                                this.compileExpression(key, "expr");
                            }
                            else if (settings.expression) {
                                this.compileExpression(key, "text");
                            }
                        }
                    }
                }
                if (this._count) {
                    return { methods: this._compiled, errors: this.errors };
                }
                else {
                    return { methods: undefined, errors: this.errors };
                }
            };
            ElementCompiler.prototype.compileExpression = function (name, type, options) {
                var src;
                if (options && options.src) {
                    src = options.src;
                }
                else {
                    src = this.element[name];
                }
                if (!src)
                    return;
                try {
                    var method;
                    switch (type) {
                        case "text":
                            method = IDE.TextAttributeCompiler.compileTextExpression(src);
                            break;
                        case "href":
                            method = IDE.TextAttributeCompiler.compileHref(src);
                            break;
                        case "expr":
                            method = IDE.TextAttributeCompiler.compileExpression(src);
                            break;
                        case "markdown":
                            method = IDE.TextAttributeCompiler.compileMarkdown(src);
                            break;
                        case "multiline":
                            method = IDE.TextAttributeCompiler.compileMultilineText(src);
                            break;
                    }
                    if (method) {
                        method.sourceCode = src;
                        method.name = "@" + name;
                        method.file = this.sourceFile;
                        method.elementId = this.element.id;
                        this._compiled[name] = method;
                        this._count++;
                    }
                }
                catch (e) {
                    if (options && options.ignoreError) {
                        return;
                    }
                    this.errors = this.errors || [];
                    var error = Retool.VM.VMError.cast(e);
                    error.jsStack = null;
                    this.errors.push({ prop: name, error: error, expression: src });
                }
            };
            return ElementCompiler;
        })();
        IDE.ElementCompiler = ElementCompiler;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var TextAttributeCompiler = (function () {
            function TextAttributeCompiler() {
            }
            TextAttributeCompiler.compile1 = function (src, options) {
                if (!src) {
                    return null;
                }
                var implicitCurlyBrace;
                var autoUrlEncode;
                var markdown;
                var asHtml;
                if (options) {
                    implicitCurlyBrace = options.implicitCurlyBrace;
                    autoUrlEncode = options.autoUrlEncode;
                }
                if (markdown) {
                    return TextAttributeCompiler.compileMarkdown(src);
                }
                var output = [];
                if (implicitCurlyBrace && src.indexOf("{{") != 0) {
                    output.push(src);
                }
                else {
                    var i = src.indexOf("{{");
                    if (i == -1) {
                        return null;
                    }
                    var segments = src.split('{{');
                    for (var j = 0; j < segments.length; j++) {
                        var segment = segments[j];
                        if (segment) {
                            var i = segment.indexOf("}}");
                            if (i != -1) {
                                var varName = segment.substr(0, i);
                                if (autoUrlEncode) {
                                    output.push("encodeURIComponent(" + varName + ")");
                                }
                                else if (markdown || asHtml) {
                                    output.push("escape(" + varName + ")");
                                }
                                else {
                                    output.push("(" + varName + ")");
                                }
                                var trailer = segment.substr(i + 2);
                                if (trailer) {
                                    if (markdown) {
                                        trailer = marked(trailer, { sanitize: true });
                                    }
                                    else if (asHtml) {
                                        trailer = Retool.Html.fromText(trailer);
                                    }
                                    output.push(TextAttributeCompiler.singleQuote(trailer));
                                }
                            }
                            else {
                                if (markdown) {
                                    segment = marked(segment, { sanitize: true });
                                }
                                else if (asHtml) {
                                    segment = Retool.Html.fromText(segment);
                                }
                                output.push(TextAttributeCompiler.singleQuote(segment));
                            }
                        }
                    }
                }
                var expression = output.join('+');
                var methodInfo;
                var exprClass = IDE.JavascriptCompiler.compileClass("", "function e(){return " + expression + ";}");
                methodInfo = exprClass.methods["e"];
                return methodInfo;
            };
            TextAttributeCompiler.compileExpression = function (src) {
                var tokens = TextAttributeCompiler.tokenize(src, true);
                ;
                if (!tokens)
                    return null;
                return TextAttributeCompiler.buildMethod(tokens);
            };
            TextAttributeCompiler.compileTextExpression = function (src) {
                var tokens = TextAttributeCompiler.tokenize(src, false);
                ;
                if (!tokens)
                    return null;
                return TextAttributeCompiler.buildMethod(tokens);
            };
            TextAttributeCompiler.compileHref = function (src) {
                var tokens = TextAttributeCompiler.tokenize(src, false);
                if (!tokens) {
                    return null;
                }
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token.type == "text") {
                        token.value = Retool.Html.fromText(token.value);
                    }
                    else if (token.type == "expr") {
                        token.value = "encodeURIComponent(" + token.value + ")";
                    }
                }
                return TextAttributeCompiler.buildMethod(tokens);
            };
            TextAttributeCompiler.compileMarkdown = function (src) {
                var tokens = TextAttributeCompiler.tokenize(src, false);
                if (!tokens) {
                    return null;
                }
                var markdown = "";
                var sep = String.fromCharCode(2);
                for (var i = 0; i < tokens.length; i++) {
                    if (i) {
                        markdown += sep;
                    }
                    var token = tokens[i];
                    if (token.type == "text") {
                        markdown += token.value;
                    }
                }
                var html = marked(markdown, { sanitize: true });
                var segments = html.split(sep);
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token.type == "text") {
                        token.value = segments[i];
                    }
                    else if (token.type == "expr") {
                        token.value = "escape(" + token.value + ")";
                    }
                }
                return TextAttributeCompiler.buildMethod(tokens);
            };
            TextAttributeCompiler.compileMultilineText = function (src) {
                var tokens = TextAttributeCompiler.tokenize(src, false);
                if (!tokens) {
                    return null;
                }
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token.type == "text") {
                        token.value = Retool.Html.fromText(token.value);
                    }
                    else if (token.type == "expr") {
                        token.value = "escape(" + token.value + ")";
                    }
                }
                return TextAttributeCompiler.buildMethod(tokens);
            };
            TextAttributeCompiler.tokenize = function (src, implicitCurlyBrace) {
                if (implicitCurlyBrace && src.indexOf("{{") != 0) {
                    return [{ type: "expr", value: src }]; // entire src is an expression
                }
                else {
                    var tokenizer = new IDE.MixedExpressionTokenizer(src);
                    var tokens = tokenizer.tokenize();
                    if (!tokens.length || (tokens.length == 1 && tokens[0].type == "text")) {
                        // if only text then a method is not required;
                        return null;
                    }
                    return tokens;
                }
            };
            TextAttributeCompiler.buildMethod = function (tokens) {
                var expr = "";
                for (var i = 0; i < tokens.length; i++) {
                    if (i) {
                        expr += "+";
                    }
                    var token = tokens[i];
                    if (token.type == "text") {
                        expr += TextAttributeCompiler.singleQuote(token.value);
                    }
                    else if (token.type == "expr") {
                        expr += "(" + token.value + ")";
                    }
                }
                var methodInfo;
                var exprClass = IDE.JavascriptCompiler.compileClass("", "function e(){return " + expr + ";}");
                methodInfo = exprClass.methods["e"];
                return methodInfo;
            };
            TextAttributeCompiler.singleQuote = function (v) {
                return "'" + v.replace(/\'/g, "\'\'").replace(/\\/g, "\\").replace(/\n/g, "\\n") + "'";
            };
            return TextAttributeCompiler;
        })();
        IDE.TextAttributeCompiler = TextAttributeCompiler;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var ComponentCompiler = (function () {
            function ComponentCompiler() {
            }
            ComponentCompiler.compile = function (name, file, helperLocator, logger) {
                var component = IDE.TemplateCompiler.compile(null, file, helperLocator, logger);
                component.name = name;
                component.isComponent = true;
                if (component.definition.elements && component.definition.elements.length) {
                    var elements = component.definition.elements;
                    var attributes = new IDE.ElementAttributeList();
                    var content;
                    for (var i = 0; i < elements.length; i++) {
                        var element = elements[i];
                        if (element.kind == "r-property") {
                            var attrib = new IDE.ElementAttribute(element.name);
                            attrib.text = element.text;
                            attrib.type = element.type || "text";
                            attributes.add(attrib);
                        }
                        else if (!content) {
                            content = element;
                        }
                    }
                    if (content) {
                        var contentHandler = helperLocator.get(content.kind);
                        if (contentHandler) {
                            component.dropKind = contentHandler.settings.dropKind;
                        }
                    }
                    if (!component.dropKind) {
                        component.dropKind = "inline";
                    }
                    // handler.element = content;
                    var cssAttrib = new IDE.ElementAttribute("cssclass");
                    cssAttrib.text = "Css Class";
                    cssAttrib.type = "text";
                    attributes.add(cssAttrib);
                    component.customAttributes = attributes;
                    if (!content) {
                        content = { kind: "div" };
                    }
                    component.contentElement = content;
                    /*
                    handler.settings.label = name;
                    handler.settings.toolbox = true;
                    handler.settings.isCustom = true;
                    */
                    if (elements && ComponentCompiler.findYield(elements)) {
                        component.isContainer = true;
                    }
                }
                return component;
            };
            ComponentCompiler.findYield = function (elements) {
                for (var i = 0; i < elements.length; i++) {
                    var elem = elements[i];
                    if (elem.kind == "r-yield") {
                        return true;
                    }
                    if (elem.children) {
                        var found = ComponentCompiler.findYield(elem.children);
                        if (found) {
                            return true;
                        }
                    }
                }
                return false;
            };
            return ComponentCompiler;
        })();
        IDE.ComponentCompiler = ComponentCompiler;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
/*
    source from parse5.js
*/
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var HTMLParser = (function () {
            function HTMLParser() {
            }
            HTMLParser.parse = function (code) {
                var htmlParser = new HTMLParser();
                var parser = new HTMLParser.parse5.Parser(HTMLParser.parse5.TreeAdapters.htmlparser2);
                var tree = parser.parseFragment(code);
                return htmlParser.translate(tree);
            };
            HTMLParser.prototype.translate = function (tree) {
                var root = {};
                if (tree && tree.children && tree.children.length) {
                    for (var i = 0, m = tree.children.length; i < m; i++) {
                        var node = tree.children[i];
                        this.parseNode(node, root);
                    }
                }
                return root.children || [];
            };
            HTMLParser.prototype.parseNode = function (node, root) {
                if (node.type === "tag") {
                    this.buildHTMLElement(node, root);
                }
                else if (node.type === "text") {
                    this.buildHTMLLiteral(node, root);
                }
            };
            HTMLParser.prototype.buildHTMLElement = function (node, parent) {
                var element = {
                    kind: node.name
                };
                parent.children = parent.children || [];
                parent.children.push(element);
                var attributes = node.attribs;
                if (attributes) {
                    for (var name in attributes) {
                        var value = attributes[name];
                        if (name === 'class') {
                            name = 'cssclass';
                        }
                        if (name !== 'kind' && name !== 'children') {
                            element[name] = value;
                        }
                    }
                }
                if (node.children && node.children.length) {
                    for (var i = 0, m = node.children.length; i < m; i++) {
                        var child = node.children[i];
                        this.parseNode(child, element);
                    }
                }
            };
            HTMLParser.prototype.buildHTMLLiteral = function (node, parent) {
                var value = node.data;
                if (typeof value === "string") {
                    value = value.replace(/\n/g, "").replace(/\t/g, "").replace(/\s+/g, " ");
                }
                var last;
                if (parent.children && parent.children.length) {
                    last = parent.children[parent.children.length - 1];
                }
                if (value && value !== " ") {
                    if (!parent.text && !parent.children) {
                        parent.text = value;
                    }
                    else if (!last) {
                        parent.text += value;
                    }
                    else if (last.kind === "text") {
                        last.text += value;
                    }
                    else {
                        parent.children = parent.children || [];
                        parent.children.push({
                            kind: 'text',
                            text: value
                        });
                    }
                }
            };
            HTMLParser.isSelfClosing = function (tag) {
                tag = tag.toUpperCase();
                return (tag === "AREA" || tag === "BASE" || tag === "BASEFONT" || tag === "BGSOUND" || tag === "BR" || tag === "COL" || tag === "EMBED" || tag === "FRAME" || tag === "HR" || tag === "IMG" || tag === "INPUT" || tag === "KEYGEN" || tag === "LINK" || tag === "MENUITEM" || tag === "META" || tag === "PARAM" || tag === "SOURCE" || tag === "TRACK" || tag === "WBR");
            };
            return HTMLParser;
        })();
        IDE.HTMLParser = HTMLParser;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
/*
    source from esprima.js
*/
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var JavascriptParser = (function () {
            function JavascriptParser() {
            }
            JavascriptParser.parse = function (code, options) {
                if (!options) {
                    options = { tracking: true };
                }
                var parserOptions = {};
                if (options.tracking) {
                    parserOptions["loc"] = true;
                }
                var syntaxTree = JavascriptParser.esprima.parse(code, parserOptions);
                return syntaxTree;
            };
            JavascriptParser.tokenize = function (code) {
                return JavascriptParser.esprima.tokenize(code);
            };
            return JavascriptParser;
        })();
        IDE.JavascriptParser = JavascriptParser;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var JavascriptCompiler = (function () {
            function JavascriptCompiler(options) {
                this.loop_level_flags = [];
                if (options) {
                    this.sourceFile = options.sourceFile;
                    this.appName = options.appName;
                    this.allowHTML = options.allowHTML;
                }
            }
            JavascriptCompiler.compileClass = function (className, code, options) {
                if (!options) {
                    options = { tracking: true };
                }
                var compiler = new JavascriptCompiler(options);
                compiler.sourceCode = code;
                var tree;
                try {
                    tree = IDE.JavascriptParser.parse(code, options);
                }
                catch (e) {
                    var error = JavascriptCompiler.castParseError(e, code);
                    if (options.sourceFile) {
                        error.source.filename = options.sourceFile.getFullName();
                    }
                    throw error;
                }
                if (!tree)
                    compiler.throwError("Invalid Option: syntax tree required.");
                compiler.init();
                compiler.initClass();
                compiler.buildClassStatements(tree.body);
                return compiler.classDefinition;
            };
            JavascriptCompiler.getSourceFromFunction = function (func) {
                var src = func.toString();
                var i = src.indexOf("{");
                src = src.substr(i + 1);
                i = src.lastIndexOf("}");
                src = src.substr(0, i);
                src = src.replace(/RetoolVMCode\./g, '');
                return src;
            };
            JavascriptCompiler.compileFunctionClass = function (func) {
                var src = JavascriptCompiler.getSourceFromFunction(func);
                return JavascriptCompiler.compileClass("", src, { tracking: true });
            };
            JavascriptCompiler.castParseError = function (e, code) {
                // because the syntax parser throws an exception with the format:
                // Line 1: Unexpected token >
                // we should format it's error into a json parseable object then rethrow
                var error = new Retool.VM.VMError();
                error.source = {};
                if (e.description) {
                    error.messages = [e.description];
                    error.source = {
                        type: "code",
                        line: e.lineNumber,
                        column: e.column,
                        codeLink: "Line: " + e.lineNumber,
                        id: e.lineNumber
                    };
                    var lines = code.split('\n');
                    if (e.lineNumber && e.lineNumber <= lines.length) {
                        error.source.codeText = lines[e.lineNumber - 1];
                    }
                }
                else {
                    error.messages = [e.toString()];
                }
                return error;
            };
            JavascriptCompiler.compileProject = function (code, options) {
                if (!options) {
                    options = { tracking: true };
                }
                var compiler = new JavascriptCompiler(options);
                compiler.sourceCode = code;
                var tree;
                try {
                    tree = IDE.JavascriptParser.parse(code, options);
                }
                catch (e) {
                    var error = JavascriptCompiler.castParseError(e, code);
                    if (options.sourceFile) {
                        error.source.filename = options.sourceFile.getFullName();
                    }
                    throw error;
                }
                return compiler.compileProject(tree);
            };
            JavascriptCompiler.compileProgram = function (code, options) {
                if (!options) {
                    options = { tracking: true };
                }
                var compiler = new JavascriptCompiler(options);
                compiler.sourceCode = code;
                var tree;
                try {
                    tree = IDE.JavascriptParser.parse(code, options);
                }
                catch (e) {
                    var error = JavascriptCompiler.castParseError(e, code);
                    if (options.sourceFile) {
                        error.source.filename = options.sourceFile.getFullName();
                    }
                    throw error;
                }
                return compiler.compileProgram(tree);
            };
            JavascriptCompiler.formatError = function (message, startLine, startColumn) {
                return '{"error": "' + message + '", "line": ' + startLine + ', "column": ' + startColumn + '}';
            };
            JavascriptCompiler.prototype.compileProgram = function (tree) {
                if (!tree)
                    this.throwError("Invalid Option: syntax tree required.");
                this.init();
                this.program = new IDE.Program();
                this.buildProgram(tree);
                return this.program;
            };
            JavascriptCompiler.prototype.compileProject = function (tree) {
                if (!tree)
                    this.throwError("Invalid Option: syntax tree required.");
                this.init();
                this.project = new IDE.Project();
                this.buildProject(tree);
                return this.project;
            };
            JavascriptCompiler.prototype.init = function () {
                this.start_line = 0;
                this.start_column = 0;
            };
            JavascriptCompiler.prototype.initClass = function () {
                this.classDefinition = new Retool.VM.Prototype("");
                this.classDefinition.properties = {};
                this.classDefinition.methods = {};
            };
            JavascriptCompiler.prototype.createLdValue = function (value) {
                return { "opcode": "ldvalue", "value": value, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createCrLoc = function (name, numArgs) {
                return { "opcode": "crloc", "name": name, "argCount": numArgs, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createCrProp = function (name, numArgs) {
                return { "opcode": "crprop", "name": name, "argCount": numArgs, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createLdLoc = function (name) {
                var namespace;
                if (name >= 'A' && name <= 'Z') {
                    var segments = name.split('.');
                    var n = segments.length;
                    name = segments.pop();
                    namespace = segments.join('.');
                }
                else if (name === "undefined") {
                    return { "opcode": "ldvalue", "value": undefined, "line": this.start_line, "column": this.start_column };
                }
                return { "opcode": "ldloc", "name": name, "line": this.start_line, "column": this.start_column, "namespace": namespace };
            };
            JavascriptCompiler.prototype.createLdProp = function (name) {
                return { "opcode": "ldprop", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createLdPropC = function () {
                return { "opcode": "ldpropc", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createLdThisProp = function (name) {
                return { "opcode": "ldthisprop", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createLdThisPropC = function () {
                return { "opcode": "ldthispropc", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createInc = function () {
                return { "opcode": "inc", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createIncLoc = function (name) {
                return { "opcode": "incloc", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createDec = function () {
                return { "opcode": "dec", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createIncProp = function (name) {
                return { "opcode": "incprop", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createDecLoc = function (name) {
                return { "opcode": "decloc", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createDecProp = function (name) {
                return { "opcode": "decprop", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createCallLoc = function (name, numArgs) {
                return { "opcode": "callloc", "name": name, "argCount": numArgs, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createCallProp = function (name, numArgs) {
                return { "opcode": "callprop", "name": name, "argCount": numArgs, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createCallPropC = function (numArgs) {
                return { "opcode": "callpropc", "argCount": numArgs, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createCallThisProp = function (name, numArgs) {
                return { "opcode": "callthisprop", "name": name, "argCount": numArgs, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createCallSuperProp = function (name, numArgs) {
                return { "opcode": "callsuper", "name": name, "argCount": numArgs, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createCallThisPropC = function (numArgs) {
                return { "opcode": "callthispropc", "argCount": numArgs, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createNewObj = function (name, numArgs) {
                return { "opcode": "newobj", "name": name, "argCount": numArgs, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createRetVal = function () {
                return { "opcode": "retval", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createRet = function () {
                return { "opcode": "ret", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createPop = function () {
                return { "opcode": "pop", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createNot = function () {
                return { "opcode": "not", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createNeg = function () {
                return { "opcode": "neg", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createThrowValue = function () {
                return { "opcode": "throwvalue", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createDebug = function () {
                return { "opcode": "debug", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createDup = function () {
                return { "opcode": "dup", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.pushBrFalse = function (instructions, steps) {
                var last = (instructions.length) ? instructions[instructions.length - 1] : null;
                var br = { "opcode": "brfalse", "offset": steps };
                if (last) {
                    br.line = last.line;
                    br.column = last.column;
                }
                else {
                    br.line = 1;
                    br.column = 1;
                }
                instructions.push(br);
            };
            JavascriptCompiler.prototype.pushBrTrue = function (instructions, steps) {
                var last = (instructions.length) ? instructions[instructions.length - 1] : null;
                var br = { "opcode": "brtrue", "offset": steps };
                if (last) {
                    br.line = last.line;
                    br.column = last.column;
                }
                else {
                    br.line = 1;
                    br.column = 1;
                }
                instructions.push(br);
            };
            JavascriptCompiler.prototype.pushBr = function (instructions, steps) {
                var last = (instructions.length) ? instructions[instructions.length - 1] : null;
                var br = { "opcode": "br", "offset": steps };
                if (last) {
                    br.line = last.line;
                    br.column = last.column;
                }
                else {
                    br.line = 1;
                    br.column = 1;
                }
                instructions.push(br);
            };
            JavascriptCompiler.prototype.createBr = function (steps) {
                return { "opcode": "br", "offset": steps, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createStLoc = function (name) {
                return { "opcode": "stloc", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createStProp = function (name) {
                return { "opcode": "stprop", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createStPropC = function () {
                return { "opcode": "stpropc", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createStThisProp = function (name) {
                return { "opcode": "stthisprop", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createStThisPropC = function () {
                return { "opcode": "stthispropc", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createLdValueThis = function () {
                return { "opcode": "ldvaluethis", "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createStPropLv = function (name) {
                return { "opcode": "stproplv", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createGetEnum = function (name) {
                return { "opcode": "getenum", "name": name, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createNextEnum = function (name, offset, iteratorId) {
                return { "opcode": "nextenum", "name": name, "offset": offset, "enumprop": iteratorId, "line": this.start_line, "column": this.start_column };
            };
            JavascriptCompiler.prototype.createBinaryOperator = function (operator) {
                switch (operator) {
                    case "+":
                        return { "opcode": "add", "line": this.start_line, "column": this.start_column };
                    case "-":
                        return { "opcode": "sub", "line": this.start_line, "column": this.start_column };
                    case "*":
                        return { "opcode": "mult", "line": this.start_line, "column": this.start_column };
                    case "/":
                        return { "opcode": "div", "line": this.start_line, "column": this.start_column };
                    case "%":
                        return { "opcode": "rem", "line": this.start_line, "column": this.start_column };
                    case "!=":
                        return { "opcode": "cmpnoteq", "line": this.start_line, "column": this.start_column };
                    case "!==":
                        return { "opcode": "cmpstnoteq", "line": this.start_line, "column": this.start_column };
                    case "==":
                        return { "opcode": "cmpeq", "line": this.start_line, "column": this.start_column };
                    case "===":
                        return { "opcode": "cmpsteq", "line": this.start_line, "column": this.start_column };
                    case ">":
                        return { "opcode": "cmpgreater", "line": this.start_line, "column": this.start_column };
                    case "<":
                        return { "opcode": "cmpless", "line": this.start_line, "column": this.start_column };
                    case ">=":
                        return { "opcode": "cmpgreatereq", "line": this.start_line, "column": this.start_column };
                    case "<=":
                        return { "opcode": "cmplesseq", "line": this.start_line, "column": this.start_column };
                    default:
                        this.throwError(operator + ' is not a supported operator');
                }
            };
            JavascriptCompiler.prototype.createAssignmentOperator = function (operator) {
                var instructions = [];
                switch (operator) {
                    case "=":
                        break;
                    case "+=":
                        instructions.push(this.createBinaryOperator("+"));
                        break;
                    case "-=":
                        instructions.push(this.createBinaryOperator("-"));
                        break;
                    case "/=":
                        instructions.push(this.createBinaryOperator("/"));
                        break;
                    case "*=":
                        instructions.push(this.createBinaryOperator("*"));
                        break;
                    default:
                        this.throwError("unknown assigment operator");
                }
                return instructions;
            };
            JavascriptCompiler.prototype.track = function (statement) {
                if (statement.loc) {
                    this.start_line = statement.loc.start.line;
                    this.start_column = statement.loc.start.column;
                }
            };
            JavascriptCompiler.prototype.buildHTMLExpression = function (expression, element) {
                switch (expression.type) {
                    case "XJSElement":
                        this.track(expression);
                        return this.buildHTMLElement(expression, element);
                    case "Literal":
                        this.track(expression);
                        return this.buildHTMLLiteral(expression, element);
                }
            };
            JavascriptCompiler.prototype.buildHTMLElement = function (expression, parent) {
                var element = {
                    kind: expression.openingElement.name.name
                };
                parent.children = parent.children || [];
                parent.children.push(element);
                var attributes = expression.openingElement.attributes;
                if (attributes && attributes.length) {
                    for (var i = 0, m = attributes.length; i < m; i++) {
                        var attribute = attributes[i], name = attribute.name.name;
                        if (name === 'class') {
                            name = 'cssclass';
                        }
                        if (name !== 'kind' && name !== 'children') {
                            element[name] = attribute.value.value;
                        }
                    }
                }
                if (expression.children && expression.children.length) {
                    for (var i = 0, m = expression.children.length; i < m; i++) {
                        var child = expression.children[i];
                        this.buildHTMLExpression(child, element);
                    }
                }
            };
            JavascriptCompiler.prototype.buildHTMLLiteral = function (expression, parent) {
                var value = expression.value;
                if (typeof value === "string") {
                    value = value.replace(/\n/g, "").replace(/\t/g, "").replace(/\s+/g, " ");
                }
                var last;
                if (parent.children && parent.children.length) {
                    last = parent.children[parent.children.length - 1];
                }
                if (value && value !== " ") {
                    if (!parent.text) {
                        parent.text = value;
                    }
                    else if (!last) {
                        parent.text += value;
                    }
                    else if (last.kind === "text") {
                        last.text += value;
                    }
                    else {
                        parent.children = parent.children || [];
                        parent.children.push({
                            kind: 'text',
                            text: value
                        });
                    }
                }
            };
            JavascriptCompiler.prototype.buildStatement = function (statement) {
                switch (statement.type) {
                    case "FunctionDeclaration":
                        this.track(statement);
                        this.throwError("function declaration not supported");
                    case "VariableDeclaration":
                        this.track(statement);
                        return this.buildVariableDeclaration(statement);
                    case "ArrayExpression":
                        return this.buildArrayExpression(statement);
                    case "BinaryExpression":
                        return this.buildBinaryExpression(statement);
                    case "UpdateExpression":
                        return this.buildUpdateExpression(statement);
                    case "NewExpression":
                        return this.buildNewExpression(statement);
                    case "ObjectExpression":
                        return this.buildObjectExpression(statement);
                    case "ThisExpression":
                        return this.buildThisExpression(statement);
                    case "UnaryExpression":
                        return this.buildUnaryExpression(statement);
                    case "MemberExpression":
                        return this.buildMemberExpression(statement);
                    case "AssignmentExpression":
                        return this.buildAssignmentExpression(statement);
                    case "LogicalExpression":
                        return this.buildLogicalExpression(statement);
                    case "ConditionalExpression":
                        return this.buildConditionalExpression(statement);
                    case "CallExpression":
                        return this.buildCallExpression(statement);
                    case "Literal":
                        return this.buildLiteral(statement);
                    case "Identifier":
                        return this.buildIdentifier(statement);
                    case "BlockStatement":
                        return this.buildBlockStatement(statement);
                    case "ExpressionStatement":
                        this.track(statement);
                        return this.buildExpressionStatement(statement);
                    case "ForStatement":
                        this.track(statement);
                        return this.buildForStatement(statement);
                    case "ForInStatement":
                        this.track(statement);
                        return this.buildForInStatement(statement);
                    case "WhileStatement":
                        this.track(statement);
                        return this.buildWhileStatement(statement);
                    case "DoWhileStatement":
                        this.track(statement);
                        return this.buildDoWhileStatement(statement);
                    case "ReturnStatement":
                        this.track(statement);
                        return this.buildReturnStatement(statement);
                    case "IfStatement":
                        this.track(statement);
                        return this.buildIfStatement(statement);
                    case "BreakStatement":
                        this.track(statement);
                        return this.buildBreakStatement(statement);
                    case "ContinueStatement":
                        this.track(statement);
                        return this.buildContinueStatement(statement);
                    case "SwitchStatement":
                        this.track(statement);
                        return this.buildSwitchStatement(statement);
                    case "TryStatement":
                        this.track(statement);
                        return this.buildTryStatement(statement);
                    case "ThrowStatement":
                        this.track(statement);
                        return this.buildThrowStatement(statement);
                    case "DebuggerStatement":
                        this.track(statement);
                        return this.buildDebuggerStatement(statement);
                    case "EmptyStatement":
                        return [];
                    case "HTMLExpressionStatement":
                        this.throwError("Unexpected token <");
                    default:
                        this.track(statement);
                        this.throwError(statement.type + " is not yet supported");
                }
            };
            JavascriptCompiler.prototype.buildProgram = function (tree) {
                this.track(tree);
                if (tree.type !== "Program") {
                    this.throwError("invalid source tree");
                }
                var statement;
                for (var i = 0; i < tree.body.length; i++) {
                    statement = tree.body[i];
                    switch (statement.type) {
                        case "ClassDeclaration":
                            this.buildClass(statement);
                            break;
                        case "ObjectExpression":
                            var instructions = this.buildObjectExpression(statement);
                            var methodInfo = new Retool.VM.MethodInfo("");
                            methodInfo.instructions = instructions;
                            this.program.sections.push({
                                type: "json",
                                content: methodInfo
                            });
                            break;
                        case "HTMLExpressionStatement":
                            if (!this.allowHTML) {
                                this.throwError("only classes can be declared at the program level");
                                return;
                            }
                            var element = {};
                            this.buildHTMLExpression(statement.expression, element);
                            if (element.children && element.children.length) {
                                var child = element.children[0], last;
                                var sections = this.program.sections;
                                if (sections.length) {
                                    last = sections[sections.length - 1];
                                }
                                if (last && last.type === "html") {
                                    last.content.push(child);
                                }
                                else {
                                    sections.push({
                                        type: "html",
                                        content: [child]
                                    });
                                }
                            }
                            break;
                        default:
                            this.throwError("only classes can be declared at the program level");
                            break;
                    }
                }
                return this.program;
            };
            JavascriptCompiler.prototype.buildProject = function (tree) {
                this.track(tree);
                console.log(JSON.stringify(tree, null, 2));
                if (tree.type !== "Program") {
                    this.throwError("invalid project tree");
                }
                var statement;
                for (var i = 0; i < tree.body.length; i++) {
                    statement = tree.body[i];
                    if (statement.type === "HTMLExpressionStatement") {
                        var script = statement.expression.openingElement;
                        if (script.name.name === 'script') {
                            if (statement.expression.children && statement.expression.children.length) {
                                this.program = new IDE.Program();
                                this.program.attributes = {};
                                var program = this.buildProgram(statement.expression.children[0]);
                                statement.expression.children[0];
                                if (script.attributes && script.attributes.length) {
                                    for (var i = 0, m = script.attributes.length; i < m; i++) {
                                        var attribute = script.attributes[i];
                                        program.attributes[attribute.name.name] = attribute.value.value;
                                    }
                                    //console.log(program);
                                    this.project.programs.push(program);
                                }
                            }
                        }
                        else {
                            this.throwError("script tag expected");
                        }
                    }
                    else {
                        this.throwError("only templates allowed at the project level");
                    }
                }
                return this.project;
            };
            JavascriptCompiler.prototype.buildClass = function (classDeclaration) {
                this.initClass();
                this.classDefinition.name = classDeclaration.id.name;
                this.program.sections.push({
                    type: "class",
                    content: this.classDefinition,
                    loc: classDeclaration.loc
                });
                if (classDeclaration.baseId) {
                    this.classDefinition.baseName = classDeclaration.baseId.name;
                }
                var statements = classDeclaration.body.body;
                this.buildClassStatements(statements);
            };
            JavascriptCompiler.prototype.buildClassStatements = function (statements) {
                var statement;
                for (var i = 0; i < statements.length; i++) {
                    statement = statements[i];
                    switch (statement.type) {
                        case "FunctionDeclaration":
                            this.buildFunction(statement);
                            break;
                        case "VariableDeclaration":
                            this.buildGlobalVariableDeclaration(statement);
                            break;
                        default:
                            this.throwError("only functions and properties can be declared globally in the class");
                            break;
                    }
                }
            };
            JavascriptCompiler.prototype.buildFunction = function (functionDeclaration) {
                var i;
                var numStatements;
                var name = functionDeclaration.id.name;
                var method = new Retool.VM.MethodInfo(name);
                method.file = this.sourceFile;
                method.params = [];
                method.instructions = [];
                method.sourceLine = this.start_line;
                //iterators should be reset at the function level;
                this.iterator_stack = [];
                this.iterator_key = 0;
                numStatements = functionDeclaration.params.length;
                for (i = 0; i < numStatements; i++) {
                    var param = this.buildParameter(functionDeclaration.params[i]);
                    method.params.push(param);
                }
                numStatements = functionDeclaration.body.body.length;
                for (i = 0; i < numStatements; i++) {
                    var statement = functionDeclaration.body.body[i];
                    var instructions = this.buildStatement(statement);
                    method.instructions = method.instructions.concat(instructions);
                }
                if (name == "constructor") {
                    if (this.classDefinition.constructorMethod) {
                        this.throwError("duplicate constructor declaration");
                    }
                    this.classDefinition.constructorMethod = method;
                }
                else {
                    if (this.classDefinition.methods[method.name]) {
                        this.throwError("duplicate method declaration for " + method.name);
                    }
                    this.classDefinition.methods[method.name] = method;
                }
            };
            JavascriptCompiler.prototype.buildGlobalVariableDeclaration = function (variableDeclaration) {
                var initMethod = this.classDefinition.methods["__initClass"];
                if (!initMethod) {
                    initMethod = new Retool.VM.MethodInfo("__initClass");
                    initMethod.file = this.sourceFile;
                    initMethod.instructions = [];
                    this.classDefinition.methods["__initClass"] = initMethod;
                }
                initMethod.instructions = initMethod.instructions.concat(this.buildVariableDeclaration(variableDeclaration, { isProperty: true }));
            };
            JavascriptCompiler.prototype.buildVariableDeclaration = function (variableDeclaration, params) {
                if (params === void 0) { params = { isProperty: false }; }
                if (variableDeclaration.kind == "let") {
                    this.throwError("let keyword is not supported");
                }
                else if (variableDeclaration.kind == "const") {
                    this.throwError("const keyword is not supported");
                }
                var instructions = [];
                for (var i = 0; i < variableDeclaration.declarations.length; i++) {
                    var declaration = variableDeclaration.declarations[i];
                    this.track(declaration);
                    // inline assignment
                    var numArgs = 0;
                    if (declaration.init) {
                        var initInstructions = this.buildStatement(declaration.init);
                        instructions = instructions.concat(initInstructions);
                        numArgs = 1;
                    }
                    if (params && params.isProperty) {
                        var property = new Retool.VM.ClassProperty;
                        property.name = declaration.id.name;
                        this.classDefinition.properties[property.name] = property;
                        instructions.push(this.createCrProp(declaration.id.name, numArgs));
                    }
                    else {
                        instructions.push(this.createCrLoc(declaration.id.name, numArgs));
                    }
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildParameter = function (parameter) {
                return { name: parameter.name };
            };
            JavascriptCompiler.prototype.buildLiteral = function (literal) {
                if (literal.value instanceof RegExp) {
                }
                return [this.createLdValue(literal.value)];
            };
            JavascriptCompiler.prototype.buildIdentifier = function (identifier) {
                return [this.createLdLoc(identifier.name)];
            };
            JavascriptCompiler.prototype.getFullMemberName = function (expression) {
                if (expression.type == "Identifier") {
                    return expression.name;
                }
                else if (expression.type == "MemberExpression") {
                    return this.getFullMemberName(expression.object) + "." + expression.property.name;
                }
                else {
                    this.throwError(expression.callee.type + " member name callee type not supported");
                }
            };
            JavascriptCompiler.prototype.buildNewExpression = function (newExpression) {
                var typeName;
                if (newExpression.callee.type == "MemberExpression" || newExpression.callee.type == "Identifier") {
                    typeName = this.qualifyTypeName(this.getFullMemberName(newExpression.callee));
                }
                else {
                    this.throwError(newExpression.callee.type + " new expression callee type not supported");
                }
                var numArgs = newExpression.arguments.length;
                var instructions = this.parseArguments(newExpression.arguments);
                instructions.push(this.createNewObj(typeName, numArgs));
                return instructions;
            };
            JavascriptCompiler.prototype.qualifyTypeName = function (name) {
                var segments = name.split('.');
                /*
                if (segments.length == 2){
                    return "Models." + name;
                }
                */
                return name;
            };
            JavascriptCompiler.prototype.buildObjectExpression = function (objectExpression) {
                var instructions = [];
                var numProperties = objectExpression.properties.length;
                var property;
                var propertyName;
                instructions.push(this.createNewObj("Object", 0));
                for (var i = 0; i < numProperties; i++) {
                    property = objectExpression.properties[i];
                    if (property.kind !== "init") {
                        this.track(property);
                        this.throwError(property.kind + ' kind of property is not supported');
                    }
                    switch (property.key.type) {
                        case "Identifier":
                            propertyName = property.key.name;
                            break;
                        case "Literal":
                            propertyName = property.key.value;
                            break;
                        default:
                            this.throwError(objectExpression.key.type + " property key type not supported");
                    }
                    instructions = instructions.concat(this.buildStatement(property.value));
                    instructions.push(this.createStPropLv(propertyName));
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildThisExpression = function (thisExpressionStatement) {
                var instructions = [];
                instructions.push(this.createLdValueThis());
                return instructions;
            };
            JavascriptCompiler.prototype.buildArrayExpression = function (arrayExpression) {
                var instructions = [];
                var numElements = arrayExpression.elements.length;
                for (var i = 0; i < numElements; i++) {
                    instructions = instructions.concat(this.buildStatement(arrayExpression.elements[i]));
                }
                instructions.push(this.createNewObj("Array", numElements));
                return instructions;
            };
            JavascriptCompiler.prototype.buildExpressionStatement = function (expression) {
                var instructions = this.buildStatement(expression.expression);
                instructions.push(this.createPop()); // throw away the remaining value on the stack
                return instructions;
            };
            JavascriptCompiler.prototype.buildBlockStatement = function (blockStatement) {
                var instructions = [];
                var statement;
                for (var i = 0; i < blockStatement.body.length; i++) {
                    statement = blockStatement.body[i];
                    instructions = instructions.concat(this.buildStatement(statement));
                }
                return instructions;
            };
            JavascriptCompiler.prototype.parseArguments = function (args) {
                var instructions = [];
                var argument;
                for (var i = 0; i < args.length; i++) {
                    argument = args[i];
                    instructions = instructions.concat(this.buildStatement(argument));
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildMemberExpression = function (memberExpression) {
                var instructions = [];
                if (memberExpression.object.type === "ThisExpression") {
                    if (memberExpression.computed === true) {
                        instructions = instructions.concat(this.buildStatement(memberExpression.property));
                        instructions.push(this.createLdThisPropC());
                    }
                    else {
                        instructions.push(this.createLdThisProp(memberExpression.property.name));
                    }
                }
                else {
                    instructions = instructions.concat(this.buildStatement(memberExpression.object));
                    if (memberExpression.computed === true) {
                        instructions = instructions.concat(this.buildStatement(memberExpression.property));
                        instructions.push(this.createLdPropC());
                    }
                    else {
                        var name = memberExpression.property.name;
                        instructions.push(this.createLdProp(name));
                    }
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildCallExpression = function (callExpression) {
                var instructions = [];
                switch (callExpression.callee.type) {
                    case "Identifier":
                        instructions = this.parseArguments(callExpression.arguments);
                        instructions.push(this.createCallLoc(callExpression.callee.name, callExpression.arguments.length));
                        break;
                    case "MemberExpression":
                        instructions = this.buildCallExpressionForMember(callExpression);
                        break;
                    default:
                        this.throwError(callExpression.callee.type + " call expression callee type not supported");
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildCallExpressionForMember = function (callExpression) {
                var instructions = [];
                var createCallInstructionFunction;
                var numArgs = callExpression.arguments.length;
                // since we have a callthisprop instruction we don't need to ldvaluethis
                if (callExpression.callee.object.name == "super") {
                    createCallInstructionFunction = this.createCallSuperProp;
                }
                else if (callExpression.callee.object.type !== "ThisExpression") {
                    instructions = instructions.concat(this.buildStatement(callExpression.callee.object));
                    createCallInstructionFunction = this.createCallProp;
                }
                else {
                    createCallInstructionFunction = this.createCallThisProp;
                }
                instructions = instructions.concat(this.parseArguments(callExpression.arguments));
                if (callExpression.callee.computed) {
                    instructions = instructions.concat(this.buildStatement(callExpression.callee.property));
                    if (callExpression.callee.object.type === "ThisExpression") {
                        instructions.push(this.createCallThisPropC(numArgs));
                    }
                    else {
                        instructions.push(this.createLdPropC());
                        instructions.push(this.createCallPropC(numArgs));
                    }
                }
                else {
                    instructions.push(createCallInstructionFunction.apply(this, [callExpression.callee.property.name, numArgs]));
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildUpdateExpressionForMemberCalculatedProperty = function (updateExpression) {
                var instructions = [];
                var updateInstructionFunction;
                switch (updateExpression.operator) {
                    case "++":
                        updateInstructionFunction = this.createInc;
                        break;
                    case "--":
                        updateInstructionFunction = this.createDec;
                        break;
                    default:
                        this.throwError(updateExpression.operator + "  not supported on object properties");
                }
                if (updateExpression.argument.object.type !== "ThisExpression") {
                    instructions = instructions.concat(this.buildStatement(updateExpression.argument.object));
                    instructions = instructions.concat(this.buildStatement(updateExpression.argument.property));
                    instructions.push(this.createLdPropC());
                    instructions.push(updateInstructionFunction.apply(this));
                    instructions.push(this.createStPropC());
                }
                else {
                    instructions = instructions.concat(this.buildStatement(updateExpression.argument.property));
                    instructions.push(this.createLdThisPropC());
                    instructions.push(updateInstructionFunction.apply(this));
                    instructions.push(this.createStThisPropC());
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildUpdateExpressionForMember = function (updateExpression) {
                var instructions = [];
                var updateInstructionFunction;
                // we don't have an incpropc function so we must expand the instructions to do
                // a regular inc and stpropc on calculated properties ie: foo["bar"]++
                if (updateExpression.argument.computed) {
                    return this.buildUpdateExpressionForMemberCalculatedProperty(updateExpression);
                }
                if (updateExpression.argument.property.type !== "Identifier") {
                    this.throwError(updateExpression.argument.property.type + " was an unexpected property type.  expecting identifier.");
                }
                var prefix = updateExpression.prefix;
                switch (updateExpression.operator) {
                    case "++":
                        updateInstructionFunction = (prefix) ? this.createInc : this.createIncProp;
                        break;
                    case "--":
                        updateInstructionFunction = prefix ? this.createDec : this.createDecProp;
                        break;
                    default:
                        this.throwError(updateExpression.operator + "  not supported on object properties");
                }
                instructions = instructions.concat(this.buildStatement(updateExpression.argument.object));
                if (updateExpression.prefix) {
                    instructions.push(this.createLdProp(updateExpression.argument.property.name));
                    instructions.push(updateInstructionFunction.apply(this));
                    instructions.push(this.createStProp(updateExpression.argument.property.name));
                }
                else {
                    instructions.push(updateInstructionFunction.apply(this, [updateExpression.argument.property.name]));
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildUpdateExpressionForIdentifier = function (updateExpression) {
                var instructions = [];
                var loc = updateExpression.argument.name;
                var updateInstructionFunction;
                switch (updateExpression.operator) {
                    case "++":
                        updateInstructionFunction = updateExpression.prefix ? this.createInc : this.createIncLoc;
                        break;
                    case "--":
                        updateInstructionFunction = updateExpression.prefix ? this.createDec : this.createDecLoc;
                        break;
                    default:
                        this.throwError(updateExpression.operator + "  not supported");
                }
                if (updateExpression.argument.type == "Identifier") {
                    if (updateExpression.prefix) {
                        instructions.push(this.createLdLoc(loc));
                        instructions.push(updateInstructionFunction.apply(this));
                        instructions.push(this.createStLoc(loc));
                    }
                    else {
                        instructions.push(updateInstructionFunction.apply(this, [loc]));
                    }
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildUpdateExpression = function (updateExpression) {
                var instructions;
                switch (updateExpression.argument.type) {
                    case "Identifier":
                        instructions = this.buildUpdateExpressionForIdentifier(updateExpression);
                        break;
                    case "MemberExpression":
                        instructions = this.buildUpdateExpressionForMember(updateExpression);
                        break;
                    default:
                        this.throwError(updateExpression.argument.type + " not supported yet for update expression");
                }
                return instructions;
            };
            JavascriptCompiler.prototype.isSelfAssignmentOperator = function (operator) {
                return ["+=", "-=", "/=", "*="].indexOf(operator) !== -1;
            };
            JavascriptCompiler.prototype.buildAssignmentExpression = function (assignmentExpression) {
                switch (assignmentExpression.left.type) {
                    case "Identifier":
                        return this.buildAssignmentExpressionForIdentifier(assignmentExpression);
                    case "MemberExpression":
                        if (assignmentExpression.left.object.type === "ThisExpression") {
                            return this.buildAssignmentExpressionForThis(assignmentExpression);
                        }
                        else {
                            return this.buildAssignmentExpressionForMember(assignmentExpression);
                        }
                    default:
                        this.track(assignmentExpression.left);
                        this.throwError(assignmentExpression.left.type + " not supported on left side of assigment");
                }
            };
            JavascriptCompiler.prototype.buildAssignmentExpressionForIdentifier = function (assignmentExpression) {
                var instructions = [];
                var operatorInstructions = [];
                var rightInstructions = this.buildStatement(assignmentExpression.right);
                if (this.isSelfAssignmentOperator(assignmentExpression.operator)) {
                    instructions = this.buildStatement(assignmentExpression.left);
                }
                operatorInstructions = this.createAssignmentOperator(assignmentExpression.operator);
                operatorInstructions.push(this.createStLoc(assignmentExpression.left.name));
                instructions = instructions.concat(rightInstructions, operatorInstructions);
                return instructions;
            };
            JavascriptCompiler.prototype.buildAssignmentExpressionForMember = function (assignmentExpression) {
                var instructions = [];
                var operatorInstructions = [];
                var rightInstructions = this.buildStatement(assignmentExpression.right);
                var isSelfAssignmentExpression = this.isSelfAssignmentOperator(assignmentExpression.operator);
                instructions = this.buildStatement(assignmentExpression.left.object);
                if (assignmentExpression.left.computed) {
                    instructions = instructions.concat(this.buildStatement(assignmentExpression.left.property));
                    if (isSelfAssignmentExpression) {
                        instructions = instructions.concat(instructions);
                        instructions.push(this.createLdPropC());
                    }
                    operatorInstructions = this.createAssignmentOperator(assignmentExpression.operator);
                    operatorInstructions.push(this.createStPropC());
                }
                else {
                    if (assignmentExpression.left.property.type !== 'Identifier') {
                        this.throwError(assignmentExpression.left.property.type + " property type not supported on left hand side of assignment");
                    }
                    if (isSelfAssignmentExpression) {
                        instructions.push(this.createDup());
                        instructions.push(this.createLdProp(assignmentExpression.left.property.name));
                    }
                    operatorInstructions = this.createAssignmentOperator(assignmentExpression.operator);
                    operatorInstructions.push(this.createStProp(assignmentExpression.left.property.name));
                }
                instructions = instructions.concat(rightInstructions, operatorInstructions);
                return instructions;
            };
            JavascriptCompiler.prototype.buildAssignmentExpressionForThis = function (assignmentExpression) {
                var instructions = [];
                var operatorInstructions = [];
                var rightInstructions = this.buildStatement(assignmentExpression.right);
                var isSelfAssignmentExpression = this.isSelfAssignmentOperator(assignmentExpression.operator);
                if (assignmentExpression.left.computed) {
                    instructions = instructions.concat(this.buildStatement(assignmentExpression.left.property));
                    if (isSelfAssignmentExpression) {
                        instructions = instructions.concat(instructions);
                        instructions.push(this.createLdThisPropC());
                    }
                    operatorInstructions = this.createAssignmentOperator(assignmentExpression.operator);
                    operatorInstructions.push(this.createStThisPropC());
                }
                else {
                    if (assignmentExpression.left.property.type !== 'Identifier') {
                        this.throwError(assignmentExpression.left.property.type + " property type not supported on left hand side of assignment");
                    }
                    if (isSelfAssignmentExpression) {
                        instructions.push(this.createDup());
                        instructions.push(this.createLdThisProp(assignmentExpression.left.property.name));
                    }
                    operatorInstructions = this.createAssignmentOperator(assignmentExpression.operator);
                    operatorInstructions.push(this.createStThisProp(assignmentExpression.left.property.name));
                }
                instructions = instructions.concat(rightInstructions, operatorInstructions);
                return instructions;
            };
            JavascriptCompiler.prototype.buildBinaryExpression = function (binaryExpression) {
                var instructions = [];
                var leftInstructions = this.buildStatement(binaryExpression.left);
                var rightInstructions = this.buildStatement(binaryExpression.right);
                var operatorInstruction = this.createBinaryOperator(binaryExpression.operator);
                instructions = instructions.concat(leftInstructions, rightInstructions);
                instructions.push(operatorInstruction);
                return instructions;
            };
            JavascriptCompiler.prototype.buildUnaryExpression = function (unaryExpression) {
                var instructions = this.buildStatement(unaryExpression.argument);
                switch (unaryExpression.operator) {
                    case "!":
                        instructions.push(this.createNot());
                        break;
                    case "-":
                        instructions.push(this.createNeg());
                        break;
                    case "+":
                        break;
                    case "delete":
                        var last = instructions[instructions.length - 1];
                        if (last.opcode == "ldprop") {
                            last.opcode = "delprop";
                        }
                        else if (last.opcode == "ldpropc") {
                            last.opcode = "delpropc";
                        }
                        else {
                            this.throwError("invalid delete statement");
                        }
                        break;
                    default:
                        this.throwError("unary expression operator " + unaryExpression.operator + " not supported");
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildLogicalExpression = function (logicalExpression) {
                var instructions = [];
                var leftInstructions = this.buildStatement(logicalExpression.left);
                var rightInstructions = this.buildStatement(logicalExpression.right);
                instructions = instructions.concat(leftInstructions);
                instructions.push(this.createDup());
                switch (logicalExpression.operator) {
                    case "&&":
                        this.pushBrFalse(instructions, rightInstructions.length + 1);
                        break;
                    case "||":
                        this.pushBrTrue(instructions, rightInstructions.length + 1);
                        break;
                }
                instructions.push(this.createPop());
                instructions = instructions.concat(rightInstructions);
                return instructions;
            };
            JavascriptCompiler.prototype.buildConditionalExpression = function (conditionalExpression) {
                return this.buildIfStatement(conditionalExpression);
            };
            JavascriptCompiler.prototype.buildBranch = function (instructions, consequentInstructions, alternateInstructions) {
                this.pushBrFalse(instructions, consequentInstructions.length);
                instructions = instructions.concat(consequentInstructions, alternateInstructions);
                return instructions;
            };
            JavascriptCompiler.prototype.buildIfStatement = function (ifStatement) {
                var instructions = [];
                var consequentInstructions = [];
                var alternateInstructions = [];
                if (ifStatement.test.type === "AssignmentExpression") {
                    this.throwError('Assignment (=) is not allowed here, possibly you intended to use == for equality comparison');
                }
                instructions = this.buildStatement(ifStatement.test);
                var ifLine = this.start_line;
                if (ifStatement.consequent) {
                    consequentInstructions = this.buildStatement(ifStatement.consequent);
                }
                if (ifStatement.alternate) {
                    alternateInstructions = this.buildStatement(ifStatement.alternate);
                    this.pushBr(consequentInstructions, alternateInstructions.length);
                }
                instructions = this.buildBranch(instructions, consequentInstructions, alternateInstructions);
                return instructions;
            };
            JavascriptCompiler.prototype.buildTryStatement = function (tryStatement) {
                var tryBlock = new Retool.VM.TryCatchFinallyBlock();
                tryBlock.block = this.buildStatement(tryStatement.block);
                if (tryStatement.handlers && tryStatement.handlers.length > 0) {
                    tryBlock.handler = this.buildStatement(tryStatement.handlers[0].body);
                    tryBlock.handlerParameterName = tryStatement.handlers[0].param.name;
                }
                if (tryStatement.finalizer) {
                    tryBlock.finalizer = this.buildStatement(tryStatement.finalizer);
                }
                return [{ opcode: "tryblock", data: tryBlock }];
            };
            JavascriptCompiler.prototype.buildWhileStatement = function (whileStatement) {
                var instructions = [];
                var bodyInstructions = [];
                var testInstructionsLength = 0;
                if (whileStatement.test) {
                    instructions = this.buildStatement(whileStatement.test);
                    testInstructionsLength = instructions.length;
                }
                bodyInstructions = this.buildBreakableStatement(whileStatement.body, testInstructionsLength, 1);
                if (whileStatement.test) {
                    this.pushBrFalse(instructions, bodyInstructions.length + 1);
                }
                instructions = instructions.concat(bodyInstructions);
                this.pushBr(instructions, -(bodyInstructions.length + testInstructionsLength + 2));
                return instructions;
            };
            JavascriptCompiler.prototype.buildDoWhileStatement = function (doWhileStatement) {
                var instructions = [];
                instructions = this.buildBreakableStatement(doWhileStatement.body, instructions.length, 0);
                if (doWhileStatement.test) {
                    instructions = instructions.concat(this.buildStatement(doWhileStatement.test));
                    this.pushBrFalse(instructions, 1);
                }
                this.pushBr(instructions, -(instructions.length + 1));
                return instructions;
            };
            JavascriptCompiler.prototype.buildForStatement = function (forStatement) {
                var instructions = [];
                var testInstructions = [];
                var updateInstructions = [];
                var bodyInstructions = [];
                if (forStatement.init) {
                    instructions = this.buildStatement(forStatement.init);
                }
                if (forStatement.test) {
                    testInstructions = this.buildStatement(forStatement.test);
                    instructions = instructions.concat(testInstructions);
                }
                if (forStatement.update) {
                    updateInstructions = this.buildStatement(forStatement.update);
                }
                bodyInstructions = this.buildBreakableStatement(forStatement.body, testInstructions.length, 2, updateInstructions.length);
                this.pushBrFalse(instructions, bodyInstructions.length + updateInstructions.length + 1);
                instructions = instructions.concat(bodyInstructions, updateInstructions);
                this.pushBr(instructions, -(bodyInstructions.length + updateInstructions.length + testInstructions.length + 2));
                return instructions;
            };
            JavascriptCompiler.prototype.buildForInStatement = function (forInStatement) {
                var iteratorId = this.uniqueIteratorId();
                var instructions = this.buildStatement(forInStatement.right);
                var bodyInstructions = this.buildStatement(forInStatement.body);
                var identifier;
                if (forInStatement.left.type !== 'Identifier' && forInStatement.left.type !== "VariableDeclaration") {
                    this.throwError(forInStatement.left.type + ' is not supported on left hand side of forin statement');
                }
                if (forInStatement.left.type === "VariableDeclaration") {
                    identifier = forInStatement.left.declarations[0].id.name;
                    instructions = instructions.concat(this.buildStatement(forInStatement.left));
                }
                else {
                    identifier = forInStatement.left.name;
                }
                instructions.push(this.createGetEnum(iteratorId));
                instructions.push(this.createNextEnum(identifier, bodyInstructions.length + 1, iteratorId));
                instructions = instructions.concat(bodyInstructions);
                this.pushBr(instructions, -(bodyInstructions.length + 2));
                this.removeUniqueItertatorId(iteratorId);
                return instructions;
            };
            JavascriptCompiler.prototype.uniqueIteratorId = function () {
                var iteratorId = '_enum_' + (this.iterator_key);
                this.iterator_stack.push(iteratorId);
                this.iterator_key += 1;
                return iteratorId;
            };
            JavascriptCompiler.prototype.removeUniqueItertatorId = function (iteratorId) {
                this.iterator_stack.splice(this.iterator_stack.indexOf(iteratorId), 1);
            };
            JavascriptCompiler.prototype.buildBreakStatement = function (breakStatement) {
                this.loop_level_flags[this.loop_level_flags.length - 1].has_break = true;
                return [this.createBr("BRK")];
            };
            JavascriptCompiler.prototype.buildContinueStatement = function (continueStatement) {
                this.loop_level_flags[this.loop_level_flags.length - 1].has_continue = true;
                return [this.createBr("CNT")];
            };
            JavascriptCompiler.prototype.buildSwitchStatement = function (switchStatement) {
                var instructions = [];
                var numCases = switchStatement.cases.length;
                var numInstructions = 0;
                var caseStatement;
                var caseInstructions;
                var testInstructions;
                var valueInstructions = this.buildStatement(switchStatement.discriminant);
                instructions = instructions.concat(valueInstructions);
                var caseBodyInstructions;
                var hasBreak;
                for (var i = 0; i < numCases; i++) {
                    caseStatement = switchStatement.cases[i];
                    this.track(caseStatement);
                    if (caseStatement.type !== 'SwitchCase') {
                        this.throwError(caseStatement.type + ' not supported in switch statement');
                    }
                    if (caseStatement.test) {
                        testInstructions = [];
                        testInstructions.push(this.createDup());
                        testInstructions = testInstructions.concat(this.buildStatement(caseStatement.test));
                        testInstructions.push(this.createBinaryOperator("=="));
                    }
                    else {
                        testInstructions = [];
                    }
                    caseBodyInstructions = [];
                    var caseHasBreak = false;
                    for (var n = 0; n < caseStatement.consequent.length; n++) {
                        if (caseStatement.consequent[n].type === "BreakStatement") {
                            caseBodyInstructions.push(this.createBr("BRK"));
                            caseHasBreak = true;
                            hasBreak = true;
                        }
                        else {
                            caseBodyInstructions = caseBodyInstructions.concat(this.buildStatement(caseStatement.consequent[n]));
                        }
                    }
                    instructions = instructions.concat(testInstructions);
                    if (caseStatement.test) {
                        if (!caseHasBreak) {
                            this.track(caseStatement.consequent[n - 1]);
                            this.throwError("break statement required.");
                        }
                        this.pushBrFalse(instructions, caseBodyInstructions.length);
                    }
                    else {
                        caseBodyInstructions.push(this.createBr("BRK"));
                    }
                    instructions = instructions.concat(caseBodyInstructions);
                }
                instructions.push(this.createPop());
                if (hasBreak) {
                    numInstructions = instructions.length;
                    for (var i = 0; i < numInstructions; i++) {
                        if (instructions[i].opcode === "br" && instructions[i].offset === "BRK") {
                            instructions[i].offset = numInstructions - (i) - 1;
                        }
                    }
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildBreakableStatement = function (breakableStatement, startOffset, endOffset, updateOffset) {
                this.loop_level_flags.push({ has_break: false, has_continue: false });
                var instructions = this.buildStatement(breakableStatement);
                var loop_level_flags = this.loop_level_flags.pop();
                var inst_value;
                if (loop_level_flags.has_break || loop_level_flags.has_continue) {
                    for (var i = 0; i < instructions.length; i++) {
                        if (instructions[i].opcode === "br") {
                            inst_value = instructions[i].offset;
                            if (inst_value === "BRK") {
                                instructions[i].offset = instructions.length - i + endOffset - 1;
                            }
                            else if (inst_value === "CNT") {
                                if (updateOffset) {
                                    instructions[i].offset = instructions.length - updateOffset - i;
                                }
                                else {
                                    instructions[i].offset = -(i + startOffset + 2);
                                }
                            }
                        }
                    }
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildReturnStatement = function (returnStatement) {
                var instructions = [];
                if (returnStatement.argument) {
                    instructions = instructions.concat(this.buildStatement(returnStatement.argument));
                    instructions.push(this.createRetVal());
                }
                else {
                    instructions.push(this.createRet());
                }
                return instructions;
            };
            JavascriptCompiler.prototype.buildThrowStatement = function (throwStatement) {
                var instructions = this.buildStatement(throwStatement.argument);
                instructions.push(this.createThrowValue());
                return instructions;
            };
            JavascriptCompiler.prototype.buildDebuggerStatement = function (debuggerStatement) {
                return [this.createDebug()];
            };
            JavascriptCompiler.prototype.throwError = function (message) {
                var error = new Retool.VM.VMError();
                var lines = this.sourceCode.split('\n');
                var codeLine = "";
                if (this.start_line && this.start_line <= lines.length) {
                    codeLine = lines[this.start_line - 1];
                }
                error.messages = [message];
                error.source = {
                    type: "code",
                    line: this.start_line,
                    column: this.start_column,
                    codeText: codeLine,
                    codeLine: "Line " + this.start_line,
                    id: this.start_line
                };
                if (this.sourceFile) {
                    error.source.filename = this.sourceFile.getFullName();
                }
                throw error;
            };
            return JavascriptCompiler;
        })();
        IDE.JavascriptCompiler = JavascriptCompiler;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var JavascriptByteCodeFormatter = (function () {
            function JavascriptByteCodeFormatter() {
            }
            JavascriptByteCodeFormatter.toHtml = function (instructions) {
                var formatter = new JavascriptByteCodeFormatter();
                formatter.instructions = instructions;
                return formatter.renderHtml();
            };
            JavascriptByteCodeFormatter.prototype.startHtmlOutput = function () {
                this.html = '<table class="formtbl c-jsconsole-punc"><tbody>';
            };
            JavascriptByteCodeFormatter.prototype.endHtmlOutput = function () {
                this.html += '</tbody></table>';
            };
            JavascriptByteCodeFormatter.prototype.renderHtml = function () {
                var i;
                var numInstructions = this.instructions.length;
                this.startHtmlOutput();
                for (i = 0; i < numInstructions; i++) {
                    this.html += (this.renderInstructionAsHtml(i, this.instructions[i]));
                }
                this.endHtmlOutput();
                return this.html;
            };
            JavascriptByteCodeFormatter.prototype.renderInstructionAsHtml = function (offset, instruction) {
                return '<tr>' + '<td class="c-jsconsole-member-name">' + this.padLeadingZeros(offset) + ': </td>' + '<td>' + instruction.opcode + '</td>' + '<td class="c-jsconsole-member-value">' + this.renderInstructionArgsAsHtml(offset, instruction) + '</td></tr>';
            };
            JavascriptByteCodeFormatter.prototype.renderInstructionArgsAsHtml = function (offset, instruction) {
                var htmlArgs = [];
                if (instruction.offset !== undefined) {
                    htmlArgs.push(this.padLeadingZeros(offset + instruction.offset + 1));
                }
                if (instruction.name !== undefined) {
                    htmlArgs.push(instruction.name);
                }
                if (instruction.value !== undefined) {
                    htmlArgs.push(instruction.value);
                }
                if (instruction.args !== undefined) {
                    htmlArgs.push('args=' + instruction.args);
                }
                if (instruction.enumprop !== undefined) {
                    htmlArgs.push('enumprop=' + instruction.enumprop);
                }
                return htmlArgs.join(', ');
            };
            JavascriptByteCodeFormatter.prototype.padLeadingZeros = function (num) {
                var s = num + "";
                var maxLength = 4;
                while (s.length < maxLength)
                    s = "0" + s;
                return s;
            };
            return JavascriptByteCodeFormatter;
        })();
        IDE.JavascriptByteCodeFormatter = JavascriptByteCodeFormatter;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var MethodAnalyzer = (function () {
            function MethodAnalyzer(code) {
                this.IDENTIFIER_TOKEN = "Identifier";
                this.PUNCUATOR_TOKEN = "Punctuator";
                try {
                    this._tokens = IDE.JavascriptParser.tokenize(code);
                }
                catch (e) {
                    this._tokens = [];
                }
            }
            MethodAnalyzer.prototype.getFirstCall = function () {
                var i = 0;
                while (i < this._tokens.length) {
                    var pos = this.findPuncuator(i, "(");
                    if (pos == -1) {
                        return null;
                    }
                    var method = this.getMethodPrecedingParethesis(pos);
                    if (method) {
                        return method;
                    }
                    i = pos + 1;
                }
                return null;
            };
            MethodAnalyzer.prototype.getMethodPrecedingParethesis = function (i) {
                if (i < 1) {
                    return null;
                }
                var token;
                token = this._tokens[i - 1];
                if (!this.isIdentifier(token)) {
                    return null;
                }
                var out = { methodName: token.value };
                i -= 2;
                if (i < 0) {
                    return out;
                }
                token = this._tokens[i];
                if (!this.isPunctuator(token, "."))
                    return out;
                i--;
                token = this._tokens[i];
                if (this.isIdentifier(token)) {
                    out.target = token.value;
                }
                return out;
            };
            MethodAnalyzer.prototype.isIdentifier = function (token) {
                if (token.type == this.IDENTIFIER_TOKEN) {
                    return true;
                }
                return false;
            };
            MethodAnalyzer.prototype.isPunctuator = function (token, value) {
                if (token.type == this.PUNCUATOR_TOKEN) {
                    if (!value)
                        return true;
                    if (token.value == value) {
                        return true;
                    }
                }
                return false;
            };
            MethodAnalyzer.prototype.findPuncuator = function (start, value) {
                for (var i = start; i < this._tokens.length; i++) {
                    var token = this._tokens[i];
                    if (token.type == this.PUNCUATOR_TOKEN && token.value == value) {
                        return i;
                    }
                }
                return -1;
            };
            return MethodAnalyzer;
        })();
        IDE.MethodAnalyzer = MethodAnalyzer;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var CompilerErrorLog = (function () {
            function CompilerErrorLog() {
            }
            CompilerErrorLog.prototype.addError = function (error) {
            };
            return CompilerErrorLog;
        })();
        IDE.CompilerErrorLog = CompilerErrorLog;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Program = (function () {
            function Program() {
                this.sections = [];
            }
            Program.prototype.getPrototype = function () {
                for (var i = 0; i < this.sections.length; i++) {
                    var sec = this.sections[i];
                    if (sec.type == "class") {
                        return sec.content;
                    }
                }
                return null;
            };
            Program.prototype.getPrototypeLocation = function () {
                for (var i = 0; i < this.sections.length; i++) {
                    var sec = this.sections[i];
                    if (sec.type == "class") {
                        return sec.loc;
                    }
                }
                return null;
            };
            Program.prototype.getHTML = function () {
                for (var i = 0; i < this.sections.length; i++) {
                    var sec = this.sections[i];
                    if (sec.type == "html") {
                        return sec.content;
                    }
                }
                return null;
            };
            Program.prototype.getJSON = function () {
                for (var i = 0; i < this.sections.length; i++) {
                    var sec = this.sections[i];
                    if (sec.type == "json") {
                        return sec.content;
                    }
                }
            };
            Program.prototype.getAttributes = function () {
                return this.attributes;
            };
            return Program;
        })();
        IDE.Program = Program;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Project = (function () {
            function Project() {
                this.programs = [];
            }
            return Project;
        })();
        IDE.Project = Project;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var TextFileCompiler = (function () {
            function TextFileCompiler() {
            }
            TextFileCompiler.compile = function (app, sourceFile, logger) {
                var content = sourceFile.getContent();
                if (content) {
                    var method = IDE.TextAttributeCompiler.compileMultilineText(content);
                    if (method) {
                        return { method: method };
                    }
                    else {
                        return { html: Retool.Html.fromText(content) };
                    }
                }
                else {
                    return { html: "" };
                }
            };
            return TextFileCompiler;
        })();
        IDE.TextFileCompiler = TextFileCompiler;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var MarkdownFileCompiler = (function () {
            function MarkdownFileCompiler() {
            }
            MarkdownFileCompiler.compile = function (app, sourceFile, logger) {
                var content = sourceFile.getContent();
                if (content) {
                    var method = IDE.TextAttributeCompiler.compileMarkdown(content);
                    if (method) {
                        return { method: method };
                    }
                    else {
                        var html = marked(content, { sanitize: true });
                        return { html: html };
                    }
                }
                else {
                    return { html: "" };
                }
            };
            return MarkdownFileCompiler;
        })();
        IDE.MarkdownFileCompiler = MarkdownFileCompiler;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var Transformers;
    (function (Transformers) {
        var TemplateSerializer = (function () {
            function TemplateSerializer() {
            }
            TemplateSerializer.prototype.serialize = function (definition) {
                var sourceCode = definition.source_code || "";
                var elements = definition.elements;
                var html = this.serializeElements("", elements);
                //var html = JSON.stringify(elements);
                var s = html;
                if (!html || html[html.length - 1] != "\n") {
                    s += "\n";
                }
                if (sourceCode) {
                    s += "==\n" + sourceCode;
                }
                s += "\n==\n";
                var settings = {};
                if (definition.cssclass) {
                    settings.cssclass = definition.cssclass;
                }
                if (definition.baseLayout) {
                    settings.baseLayout = definition.baseLayout;
                }
                s += JSON.stringify(settings);
                return s;
            };
            TemplateSerializer.prototype.serializeElements = function (tab, elements) {
                if (!elements) {
                    return;
                }
                var out = "";
                for (var i = 0; i < elements.length; i++) {
                    var elem = elements[i];
                    out += this.serializeElement(tab, elem);
                }
                return out;
            };
            TemplateSerializer.prototype.serializeElement = function (tab, elem) {
                var kind = elem.kind;
                if (kind == "text") {
                    return Retool.Html.escape(elem.text);
                }
                var out = tab + "<" + kind;
                if (elem.cssclass) {
                    out += ' class="' + Retool.Html.escapeAttr(elem.cssclass) + '"';
                }
                if (elem.name) {
                    out += ' name="' + Retool.Html.escapeAttr(elem.name) + '"';
                }
                for (var attrib in elem) {
                    if (attrib[0] != "_" && attrib != "text" && attrib != "kind" && attrib != "id" && attrib != "name" && attrib != "cssclass" && attrib != "children") {
                        var value = elem[attrib];
                        if (value) {
                            out += " " + attrib + "=\"" + Retool.Html.escapeAttr(value) + "\"";
                        }
                    }
                }
                var children = elem.children;
                var hasContent = elem.text || (children && children.length);
                if (hasContent) {
                    out += ">";
                    if (elem.text) {
                        out += Retool.Html.escape(elem.text);
                    }
                    if (children) {
                        out += "\n" + this.serializeElements(tab + "  ", children);
                    }
                    if (out[out.length - 1] == "\n") {
                        out += tab;
                    }
                    out += "</" + kind + ">\n";
                }
                else if (Retool.IDE.HTMLParser.isSelfClosing(kind)) {
                    out += "/>\n";
                }
                else {
                    out += "></" + kind + ">\n";
                }
                return out;
            };
            return TemplateSerializer;
        })();
        Transformers.TemplateSerializer = TemplateSerializer;
    })(Transformers = Retool.Transformers || (Retool.Transformers = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var Transformers;
    (function (Transformers) {
        var ComponentSerializer = (function (_super) {
            __extends(ComponentSerializer, _super);
            function ComponentSerializer() {
                _super.apply(this, arguments);
            }
            return ComponentSerializer;
        })(Transformers.TemplateSerializer);
        Transformers.ComponentSerializer = ComponentSerializer;
    })(Transformers = Retool.Transformers || (Retool.Transformers = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var Transformers;
    (function (Transformers) {
        var ControllerParser = (function () {
            function ControllerParser() {
            }
            ControllerParser.prototype.parse = function (name, source) {
                name = Retool.Inflection.classify(name);
                return {
                    name: name,
                    source_code: source
                };
            };
            return ControllerParser;
        })();
        Transformers.ControllerParser = ControllerParser;
    })(Transformers = Retool.Transformers || (Retool.Transformers = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var Transformers;
    (function (Transformers) {
        var ControllerSerializer = (function () {
            function ControllerSerializer() {
            }
            ControllerSerializer.prototype.serialize = function (definition) {
                return definition.source_code;
            };
            return ControllerSerializer;
        })();
        Transformers.ControllerSerializer = ControllerSerializer;
    })(Transformers = Retool.Transformers || (Retool.Transformers = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var Transformers;
    (function (Transformers) {
        var ModelParser = (function () {
            function ModelParser() {
            }
            ModelParser.prototype.parse = function (name, source) {
                name = Retool.Inflection.classify(name);
                var sourceCode;
                var settings;
                var sections = source.split(/\n==\s*\n/); // split on == separator
                for (var i = 0; i < sections.length; i++) {
                    var section = sections[i];
                    var match = section.match(/\S/);
                    if (match.length && match[0] == "{") {
                        settings = JSON.parse(section);
                    }
                    else {
                        match = section.match(/\w+/);
                        if (match && match.length && match[0] == "class") {
                            sourceCode = section;
                        }
                    }
                }
                settings = settings || {};
                return {
                    name: name,
                    fields: settings.fields,
                    indexes: null,
                    relationships: settings.relationships,
                    source_code: sourceCode
                };
            };
            return ModelParser;
        })();
        Transformers.ModelParser = ModelParser;
    })(Transformers = Retool.Transformers || (Retool.Transformers = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var Transformers;
    (function (Transformers) {
        var ModelSerializer = (function () {
            function ModelSerializer() {
            }
            ModelSerializer.prototype.serialize = function (definition) {
                var d = {};
                for (var key in definition) {
                    if (key != "source_code") {
                        d[key] = definition[key];
                    }
                }
                var out = definition.source_code;
                out += "\n==\n";
                out += JSON.stringify(d, null, "\t");
                return out;
            };
            return ModelSerializer;
        })();
        Transformers.ModelSerializer = ModelSerializer;
    })(Transformers = Retool.Transformers || (Retool.Transformers = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Util;
        (function (Util) {
            var FileUploader = (function () {
                function FileUploader(options) {
                    this.type == "binary";
                    if (options) {
                        if (options.type) {
                            this.type = options.type;
                        }
                    }
                }
                FileUploader.prototype.sendData = function (params) {
                    var self = this;
                    // contentType was: "application/octet-stream"
                    var settings = {
                        "type": "POST",
                        "url": params.url,
                        "dataType": 'json',
                        "contentType": params.contentType,
                        "headers": {
                            "Authorization": "Bearer " + Retool.App.getSessionToken()
                        },
                        crossDomain: true,
                        processData: false,
                        cache: false,
                        xhrFields: {
                            withCredentials: true
                        },
                        success: function (data, a, xhr) {
                            Retool.hideLoading();
                            params.success(data);
                        },
                        error: function (xhr, b, c) {
                            Retool.hideLoading();
                            params.error(xhr);
                        },
                        data: params.data
                    };
                    Retool.showLoading();
                    $.ajax(settings);
                };
                FileUploader.prototype.getFile = function (callback) {
                    this.callback = callback;
                    IDE.activeDesigner.fileUploader = this;
                    $('#file-add-asset').click();
                };
                FileUploader.prototype.readFile = function (file) {
                    var reader = new FileReader();
                    var self = this;
                    reader.onload = function (e) {
                        self.callback(file, reader.result);
                    };
                    if (this.type == "text") {
                        reader.readAsText(file);
                    }
                    else {
                        reader.readAsArrayBuffer(file);
                    }
                };
                return FileUploader;
            })();
            Util.FileUploader = FileUploader;
        })(Util = IDE.Util || (IDE.Util = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Util;
        (function (Util) {
            var ProjectImporter = (function () {
                function ProjectImporter() {
                }
                ProjectImporter.prototype.import = function () {
                    var self = this;
                    var uploader = new Util.FileUploader({ type: "text" });
                    var app;
                    uploader.getFile(function (file, content) {
                        var files = JSON.parse(content);
                        var batch = [];
                        for (var i = 0; i < files.length; i++) {
                            var appFile = files[i];
                            var newFile = new Retool.FileSystem.File(appFile.name, appFile.content);
                            batch.push(newFile);
                        }
                        IDE.activeDesigner.saveFileBatch(batch, { success: function () {
                            for (var i = 0; i < batch.length; i++) {
                                app.addFile(batch[i], true); // ? allow overwrite
                            }
                            IDE.activeDesigner.toolbox.refreshAll();
                        } });
                    });
                };
                ProjectImporter.prototype.uploadTheme = function () {
                    var self = this;
                    var uploader = new Util.FileUploader({ type: "binary" });
                    uploader.getFile(function (file, content) {
                        var filename = file.name.toLowerCase().replace(/ /g, '-');
                        var data = new FormData();
                        data.append("0", file);
                        uploader.sendData({
                            url: Retool.App.apiHost + "upload-theme",
                            data: data,
                            contentType: "",
                            success: function (data) {
                                if (data.error) {
                                    IDE.Ide.displayError(data.error);
                                    return;
                                }
                                alert('Theme uploaded');
                            },
                            error: function (err) {
                                IDE.Ide.displayError(err);
                            }
                        });
                    });
                };
                ProjectImporter.prototype.copyBase = function (name, done) {
                    var request = new Retool.Request({ type: "data" });
                    request.add({ className: "ProjectFiles", method: "copy_base", args: { name: name }, success: function (data) {
                        done(null, data);
                    }, error: function (err) {
                        done(err);
                    } });
                    request.execute();
                };
                return ProjectImporter;
            })();
            Util.ProjectImporter = ProjectImporter;
        })(Util = IDE.Util || (IDE.Util = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Util;
        (function (Util) {
            var AvailableDbColumnPool = (function () {
                function AvailableDbColumnPool(model) {
                    var map = {};
                    for (var id in model.fields) {
                        var field = model.fields[id];
                        map[field.db_column] = 1;
                    }
                    this._map = map;
                }
                AvailableDbColumnPool.prototype.nextAvailable = function (field) {
                    var nameBase = "nvarchar";
                    var columnName = this.getNext(nameBase);
                    return columnName;
                };
                AvailableDbColumnPool.prototype.getNext = function (name) {
                    var max = 100;
                    var map = this._map;
                    for (var i = 1; i <= max; i++) {
                        if (!map[name + i]) {
                            var n = name + i;
                            map[n] = 1;
                            return n;
                        }
                    }
                    return null; // none available for type
                };
                return AvailableDbColumnPool;
            })();
            Util.AvailableDbColumnPool = AvailableDbColumnPool;
        })(Util = IDE.Util || (IDE.Util = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Snippets;
        (function (Snippets) {
            var TabSet = (function (_super) {
                __extends(TabSet, _super);
                function TabSet() {
                    _super.apply(this, arguments);
                    this.settings = { label: "tab-set", toolbox: true, dropKind: "block", glyph: "f", tourstop: true, isSnippet: true };
                }
                TabSet.prototype.createFromToolbox = function (item) {
                    return [
                        { kind: "ul", cssclass: "nav nav-tabs", role: "tablist", children: [
                            { kind: "li", href: "#tab1", cssclass: "active", text: "Tab 1", role: "tab" },
                            { kind: "li", href: "#tab2", cssclass: "", text: "Tab 2", role: "tab" }
                        ] },
                        { kind: "div", cssclass: "tab-content", children: [
                            { kind: "div", cssclass: "tab-pane active", name: "tab1", role: "tabpanel", children: [{ kind: "text", text: "Tab 1 Content" }] },
                            { kind: "div", cssclass: "tab-pane", name: "tab2", role: "tabpanel", children: [{ kind: "text", text: "Tab 2 Content" }] }
                        ] }
                    ];
                };
                return TabSet;
            })(Retool.Helpers.HelperBase);
            Snippets.TabSet = TabSet;
            IDE.Ide.elementSnippets.add("_tab-set", new TabSet());
        })(Snippets = IDE.Snippets || (IDE.Snippets = {}));
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var LessonRenderer = (function () {
            function LessonRenderer() {
            }
            LessonRenderer.prototype.render = function (w) {
                w.writeTag("div", "lesson-panel", { id: "lesson-panel" });
                this.renderContent(w);
                w.write('</div>');
            };
            LessonRenderer.prototype.renderContent = function (w) {
                w.write('<div class="banner"></div>');
                w.write('<section><h2>Learn to build apps</h2><p>In this lesson you will create your first application.</p><p>An application contains models and templates.  Models are used for data, templates are for displaying data.</p></section><p class="instructions">1. Click on +add application<br>2. Enter the name of your new application</p><p></p>');
            };
            return LessonRenderer;
        })();
        IDE.LessonRenderer = LessonRenderer;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
var Retool;
(function (Retool) {
    var IDE;
    (function (IDE) {
        var Designer = (function () {
            function Designer() {
                this.toolboxMode = "";
                this.designerBarSelector = '#rto-ds';
                this.designerWidth = 600;
                this.designerTopPercent = 60;
                this.consoleCurrentPath = "";
                this.ideOffset = 0;
                this.panelWidths = [220, 500, 500, 500];
                this.panelNames = ['rto-designerTL', 'rto-designerTR', 'rto-designerBottom', 'rto-footer'];
                this.panelStatus = ['show', 'show', 'show', 'show'];
                this.fileSaveQueue = new IDE.FileSaveQueue();
                this.anchorSide = false;
                this.anchorBottom = true;
            }
            Designer.prototype.toggle = function () {
                this.visible = !this.visible;
                if (this.visible) {
                    //this.anchorSide = !this.anchorSide;
                    //this.anchorBottom = !this.anchorBottom;
                    $('#rto-designerBottom').attr('style', '');
                    $('#rto-panels').attr('style', '');
                    if (this.anchorBottom) {
                        $('#rto-ide').addClass("rto-docked-bottom");
                        $('#rto-ide').css("top", this.designerTopPercent + "%");
                    }
                    else {
                        $('#rto-ide').css("top", 0);
                        $('#rto-ide').removeClass("rto-docked-bottom");
                    }
                }
                this.updatePanelWidths();
                var self = this;
                this.resize();
            };
            Designer.prototype.updatePanelWidths = function () {
                if (this.visible) {
                    //$('#retool-app').css('margin-right',this.designerWidth);
                    if (this.anchorBottom) {
                        $('#rto-app-container').css('left', 0);
                    }
                    else {
                        $('#rto-app-container').css('left', this.designerWidth + this.ideOffset);
                    }
                    $('#rto-ide').show();
                    $('body').removeClass('preview-mode');
                }
                else {
                    $('body').addClass('preview-mode');
                    $('#rto-app-container').css('left', this.ideOffset);
                    $('#rto-ide').hide();
                }
                var left = 0;
                var totalAvail = $('#rto-panels').width();
                for (var i = 0; i < this.panelNames.length; i++) {
                    var panelId = this.panelNames[i];
                    var status = this.panelStatus[i];
                    if (status == "show") {
                        var wid = this.panelWidths[i];
                        if (i == (this.panelNames.length - 1)) {
                            wid = totalAvail - left;
                            if (wid < 1200) {
                                wid = 1200;
                            }
                        }
                    }
                    else {
                        wid = 25;
                    }
                    $('#' + panelId).css('left', left).css('width', wid);
                    left += wid;
                }
                $('#rto-ide').css('left', this.ideOffset);
                $('#rto-designer-bar').css('left', this.ideOffset);
                setTimeout(function () {
                    $('body').get(0).scrollLeft = 9999;
                    $('html').get(0).scrollLeft = 9999;
                }, 25);
                return;
            };
            Designer.prototype.hide = function () {
                /*
                $("#rto-toggle").removeClass("rto-open").addClass("rto-closed");
                $('body').removeClass('retool-designer-visible');
                $('#rto-designer-bar').css('left',-this.designerWidth + "px");
                this.setAppScreenOffset("0px");
                $("#" + makeDomId('designerScreenSplitter')).hide();
                */
                this.visible = false;
                this.updatePanelWidths();
                this.resize();
            };
            Designer.prototype.showDesignerPane = function () {
                if (this.anchorBottom) {
                    $('#rto-app-container').css('left', 0);
                }
                else {
                    $('#rto-app-container').css('left', this.designerWidth + this.ideOffset);
                }
                $('#rto-ide').show();
                this.visible = true;
                this.updatePanelWidths();
                this.resize();
                /*
                $("#rto-toggle").removeClass("rto-closed").addClass("rto-open");
                $('body').addClass('retool-designer-visible');
                $('#rto-designer-bar').css('left',0);
                this.setAppScreenOffset(this.designerWidth + "px");
                $("#" + makeDomId('designerScreenSplitter')).show();
                */
            };
            Designer.registerModel = function (type) {
            };
            Designer.prototype.setAppScreenOffset = function (width) {
                // $("body").css("margin-left", width);
            };
            Designer.prototype.show = function (options) {
                if (!this.visible) {
                    this.toggle();
                }
                var validationError = this.autoApplyAttributesDialog();
                this.attachToViewContainer({ template: options.template, shiftClick: options.shiftClick });
                if (options.id) {
                    var viewInspectorItemId = options.id;
                    this.showAttributesForId({ id: viewInspectorItemId, shiftClick: options.shiftClick });
                    this.viewInspector.showElement(viewInspectorItemId);
                }
            };
            Designer.prototype.resize = function () {
                var ideHeight = 0;
                var panelsBottom = 0;
                if (this.footer) {
                    this.footer.resize();
                    if (this.footer.visible && false) {
                        panelsBottom = this.footer.height;
                        ideHeight = this.footer.height;
                        var windowHeight = $(window).height();
                        if (panelsBottom > windowHeight / 2) {
                            panelsBottom = windowHeight / 2;
                        }
                    }
                }
                if (this.anchorBottom && this.visible) {
                    var ht = $('#rto-panels').height() + 0;
                    if (ht > ideHeight) {
                        ideHeight = ht;
                    }
                }
                $('#rto-app-container').css('bottom', ideHeight);
            };
            Designer.prototype.showConsoleWindow = function (options) {
                this.footer.showConsole(options);
            };
            Designer.prototype.hideConsoleWindow = function () {
                145;
                this.footer.hide();
            };
            Designer.prototype.toggleLessons = function () {
                if (this.ideOffset) {
                    this.ideOffset = 0;
                    $('#rto-lesson-panel').hide();
                }
                else {
                    $('#rto-lesson-panel').show();
                    this.ideOffset = 380;
                }
                this.updatePanelWidths();
            };
            Designer.prototype.attachEvents = function () {
                var self = this;
                $(window).unload(function () {
                    self.fileSaveQueue.flush();
                });
                $('#rto-designerTBHandle').on('mousedown', function (e) {
                    self.dragStart(e, this.parentNode, { updown: true, min: 100, max: $('#rto-ds').height() - 100, mode: "inspector-topbot" });
                });
                $('#rto-designerTopSizer').on('mousedown', function (e) {
                    self.dragStart(e, this.parentNode, { updown: true, min: 0, max: $(window).height() - 100, mode: "top-sizer" });
                });
                $('#rto-footer-splitter .rto-vertical-handle').on('mousedown', function (e) {
                    self.dragStart(e, this.parentNode, { updown: true, anchorBottom: true, min: 40, max: $(window).height() - 100, mode: "footer" });
                });
                $('#rto-console-splitter .rto-vertical-handle').on('mousedown', function (e) {
                    self.dragStart(e, this.parentNode, { updown: true, anchorBottom: true, min: $(window).height() - self.footer.height + 60, max: $(window).height() - 60, mode: "jsconsole" });
                });
                $('#rto-designerTopSplitter').on('mousedown', function (e) {
                    self.dragStart(e, this, { updown: false, min: 100, max: $('#rto-ds').width() - 100, mode: "inspector-leftright" });
                });
                $('#rto-panels').on('mousedown', '.rto-panel-sizer', function (e) {
                    var panel = $(this).closest('.rto-ide-panel').get(0);
                    if (!panel) {
                        return;
                    }
                    var index = self.getPanelIndex(panel.id);
                    self.dragStart(e, this, { updown: false, min: 100, max: $('#rto-ds').width() - 100, mode: "panel-leftright", index: index });
                });
                $('#rto-designerScreenSplitter').on('mousedown', function (e) {
                    self.dragStart(e, this, { updown: false, min: 300, max: $(window).width() - 100, mode: "designer-width" });
                });
                /*
                $('#rto-ide').off('click');
                
                $('#rto-ide').on("click","[id^='rt-']",function(event){
                    if (event.shiftKey){
                        event.preventDefault();
                        Retool.raise(this,"onshiftclick",event);
                    }
                    else {
                        Retool.raise(this,"onclick",event);
                    }
                });
                $('#rto-ide').on("blur","[id^='rt-']",function(event){
                    Retool.raise(this,"onblur",event);
                });
    
                $('#rto-ide').on("focus","[id^='rt-']",function(event){
                    Retool.raise(this,"onfocus",event);
                });
    
                $('#rto-ide').on("keypress","[id^='rt-']",function(event){
                    Retool.raise(this,"onkeypress",event);
                });
                $('#rto-ide').on("keydown","[id^='rt-']",function(event){
                    Retool.raise(this,"onkeydown",event);
                });
                $('#rto-ide').on("keyup","[id^='rt-']",function(event){
                    Retool.raise(this,"onkeyup",event);
                });
                $('#rto-ide').on("change","[id^='rt-']",function(event){
                    Retool.raise(this,"onchange",event);
                });
                $('#rto-ide').on('click',function(event){
                    Retool.hideDropLists();
                });
                 $('#rto-ide').on('focus','[data-clickonfocus]',function(event){
                    this.click();
                });
    */
                $('#rto-ide').on('mouseenter', "[tooltip]", function (event) {
                    IDE.activeDesigner.showTooltip({ elem: this, text: $(this).attr('tooltip') });
                });
                $('#rto-ide').on('mouseleave', "[tooltip]", function (event) {
                    IDE.activeDesigner.hideTooltip();
                });
                $('#rto-ide').on('mousedown', "[tooltip]", function (event) {
                    IDE.activeDesigner.hideTooltip();
                });
                $('#rto-panels').on('click', '#rto-toolbox-heading a', function (e) {
                    e.preventDefault();
                    var li = $(this).closest('li');
                    var index = li.index();
                    self.setActiveExplorerTab(index);
                });
                $('#rto-ide').on('click', '#rto-attributes-title .rto-m-label a', function (e) {
                    var id = $(this).data("comp");
                    e.preventDefault();
                    e.stopPropagation();
                    if (id) {
                        self.toolbox.actions.execute("component", "components/" + id + ".retool.js");
                    }
                });
                $('#rto-ide').on('click', '.rto-attributes-form .rto-pip', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    $(this).closest('tr').toggleClass('rto-expanded');
                });
                this.footer.attachEvents();
                $('#rto-ide').on('click', "[data-drop-toggle]", function (e) {
                    $(this).closest('.dropdown').toggleClass('open');
                    e.preventDefault();
                    e.stopPropagation();
                });
                $('#rto-panels-nav').on('click', "a", function (e) {
                    var $this = $(this);
                    var data = $this.data("item");
                    $this.closest('.dropdown').toggleClass('open');
                    e.preventDefault();
                    e.stopPropagation();
                    if (data == "build") {
                        IDE.DesignerTools.build();
                    }
                    if (data == "tablet") {
                        $('#rto-app-container').attr('class', 'size-tablet');
                    }
                    if (data == "mobile") {
                        $('#rto-app-container').attr('class', 'size-mobile');
                    }
                    if (data == "desktop") {
                        $('#rto-app-container').attr('class', 'size-desktop');
                    }
                    if (data == "lessons") {
                        IDE.activeDesigner.toggleLessons();
                    }
                    if (data == "refresh") {
                        IDE.Ide.refreshCurrentAppPage();
                    }
                    if (data == "import-theme") {
                        var projectImporter = new IDE.Util.ProjectImporter();
                        projectImporter.uploadTheme();
                    }
                    if (data == "copy-base-project") {
                        var projectImporter = new IDE.Util.ProjectImporter();
                        projectImporter.copyBase("basic", function (err) {
                        });
                    }
                    if (data == "myaccount") {
                        var ht = $(window).height();
                        var wid = $(window).width() - 200;
                        var launch = window.open(window.location.href, "retoolide", "height=" + ht.toString() + ",width=" + wid + ",location=0,alwaysRaised=1");
                        IDE.activeDesigner.hide();
                    }
                });
                $('#rto-panels-nav-r').on('click', "a", function (e) {
                    var $this = $(this);
                    var data = $this.data("item");
                    e.preventDefault();
                });
                $('#rto-panels').on('click', '[data-action]', function (e) {
                    var action = $(this).data("action");
                    if (action == "addevent") {
                        IDE.ElementEventCodeGenerator.addEventCode($(this).data('item'));
                        e.preventDefault();
                    }
                });
                $('#rto-ide').on("click", "[data-url]", function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    var url = $(this).data("url");
                    if (url.length > 3 && url.substring(0, 3) == "go:") {
                        IDE.activeDesigner.goAction(url.substring(3));
                    }
                });
                $('#rto-ide').on("click", ".rto-close-dialog", function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.designerView.hide();
                });
                $('#rto-ide').on("click", "#rto-dialog-modal", function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.designerView.hide();
                });
                // $('#rto-ds').bind('dragover',self.elementDragOver);
                $(document).bind('dragover', IDE.activeDesigner.elementDragOverNonDrop);
                $('#rto-theme-chooser').on('click', 'div', function (e) {
                    var id = $(this).data('id');
                    $('#rto-theme-link').attr('href', '/stylesheets/' + id + '?ver=$ver$');
                    e.preventDefault();
                });
                $('#rto-ide').on("change", ".retool-file-upload", function (event) {
                    var target = event.target;
                    var $target = $(target);
                    var file = event.target.files[0];
                    $(target).replaceWith($target.val('').clone(true));
                    if (self.fileUploader) {
                        var uploader = self.fileUploader;
                        self.fileUploader = null;
                        uploader.readFile(file);
                    }
                });
            };
            Designer.prototype.setActiveExplorerTab = function (index) {
                var ul = $('#rto-toolbox-heading ul');
                var li = ul.children().eq(index);
                ul.find('li').removeClass('rto-active');
                li.addClass('rto-active');
                $('#rto-toolbox-content').children().hide();
                $('#rto-toolbox-content').children().eq(index).show();
            };
            Designer.prototype.dragStart = function (e, elem, options) {
                IDE.activeDesigner.dragInfo = { "startx": e.clientX, "starty": e.clientY, active: false, "elem": elem, origin: $(elem).position(), "options": options };
                $(document).on('mousemove', IDE.activeDesigner.dragMove);
                $(document).on('mouseup', IDE.activeDesigner.dragEnd);
                $('body').addClass('rto-dragging');
            };
            Designer.prototype.dragMove = function (e) {
                IDE.activeDesigner.clearSelection();
                var dragInfo = IDE.activeDesigner.dragInfo;
                var elem = dragInfo.elem;
                if (dragInfo.options.updown) {
                    if (dragInfo.options.mode == "footer") {
                        var windowHeight = $(window).height();
                        var newHeight = windowHeight - e.clientY;
                        if (newHeight > windowHeight) {
                            newHeight = windowHeight;
                        }
                        if (newHeight < 200) {
                            newHeight = 200;
                        }
                        IDE.activeDesigner.footer.height = newHeight;
                    }
                    else if (dragInfo.options.mode == "inspector-topbot") {
                        var containerHeight = $('#rto-inspector-container').height();
                        var containerPosition = $('#rto-inspector-container').offset();
                        var splitPoint = Retool.boundCheck(e.clientY - containerPosition.top, 100, containerHeight - 100);
                        var ratio = Math.floor(((containerHeight - splitPoint) * 100) / containerHeight);
                        $('#rto-designerTop').css('bottom', ratio + "%");
                        $('#rto-designerBottom').css('height', ratio + "%");
                    }
                    else if (dragInfo.options.mode == "top-sizer") {
                        IDE.activeDesigner.topSizerMove(e);
                    }
                    else if (dragInfo.options.mode == "jsconsole") {
                        var windowHeight = $(window).height();
                        var newHeight = windowHeight - e.clientY;
                        if (newHeight > IDE.activeDesigner.footer.height - 80) {
                            newHeight = IDE.activeDesigner.footer.height - 80;
                        }
                        if (newHeight < 40) {
                            newHeight = 40;
                        }
                        IDE.activeDesigner.footer.jsConsoleHeight = newHeight;
                    }
                    else {
                        var newTop = (e.clientY - dragInfo.starty) + dragInfo.origin.top;
                        if (newTop < dragInfo.options.min) {
                            newTop = dragInfo.options.min;
                        }
                        else if (newTop > dragInfo.options.max) {
                            newTop = dragInfo.options.max;
                        }
                        if (dragInfo.options.anchorBottom) {
                            $(elem).css('bottom', $(window).height() - newTop);
                        }
                        else {
                            $(elem).css('top', newTop);
                        }
                    }
                }
                else {
                    if (dragInfo.options.mode == "inspector-leftright") {
                        var containerWidth = $('#rto-designerTop').width();
                        var containerPosition = $('#rto-designerTop').offset();
                        var mouseX = e.clientX + IDE.activeDesigner.getBodyScrollLeft();
                        var splitPoint = Retool.boundCheck(mouseX - containerPosition.left, 100, containerWidth - 100);
                        $('#rto-designerTL').css('width', splitPoint);
                        $('#rto-designerTR').css('left', splitPoint);
                    }
                    else if (dragInfo.options.mode == "panel-leftright") {
                        IDE.activeDesigner.panelSplitterMove(e, dragInfo.options.index);
                    }
                    else if (dragInfo.options.mode == "designer-width") {
                        var containerWidth = $('#rto-panels').width();
                        var containerPosition = $('#rto-panels').offset();
                        var mouseX = e.clientX + IDE.activeDesigner.getBodyScrollLeft();
                        var splitPoint = Retool.boundCheck(mouseX - containerPosition.left, 300, $(window).width());
                        $('#rto-panels').css('width', splitPoint);
                        var translateX = splitPoint;
                        IDE.activeDesigner.designerWidth = translateX;
                        $('#rto-app-container').css('left', translateX + IDE.activeDesigner.ideOffset);
                    }
                    else {
                        var newLeft = (e.clientX - dragInfo.startx) + dragInfo.origin.left;
                        if (newLeft < dragInfo.options.min) {
                            newLeft = dragInfo.options.min;
                        }
                        else if (newLeft > dragInfo.options.max) {
                            newLeft = dragInfo.options.max;
                        }
                        if (dragInfo.options.mode == "designer-width") {
                            IDE.activeDesigner.designerWidth = newLeft;
                        }
                        else {
                            $(elem).css('left', newLeft);
                        }
                    }
                }
                $('body').addClass('rto-resizing');
                IDE.activeDesigner.resize();
                $('body').removeClass('rto-resizing');
            };
            Designer.prototype.topSizerMove = function (e) {
                var containerHeight = $(window).height();
                var containerPosition = { top: 0, left: 0 };
                var splitPoint = Retool.boundCheck(e.clientY - containerPosition.top, 0, containerHeight - 100);
                var ratio = Math.floor((splitPoint * 100) / containerHeight);
                $('#rto-ide').css('top', ratio + "%");
                $('#rto-app-container').css('bottom', (100 - ratio) + "%");
                this.designerTopPercent = ratio;
            };
            Designer.prototype.panelSplitterMove = function (e, index) {
                var containerWidth = this.panelWidths[index - 1];
                var containerPosition = $('#' + this.panelNames[index]).offset();
                var mouseX = e.clientX + IDE.activeDesigner.getBodyScrollLeft();
                var newWidth = containerWidth + mouseX - containerPosition.left;
                if (newWidth < 120) {
                    newWidth = 120;
                }
                this.panelWidths[index - 1] = newWidth;
                this.updatePanelWidths();
                var splitPoint = Retool.boundCheck(mouseX - containerPosition.left, 100, containerWidth - 100);
                /*
                $('#rto-designerTop').css('right',containerWidth - splitPoint);
                $('#rto-designerBottom').css('width',containerWidth - splitPoint);
                */
            };
            Designer.prototype.getPanelIndex = function (id) {
                for (var i = 0; i < this.panelNames.length; i++) {
                    if (this.panelNames[i] == id) {
                        return i;
                    }
                }
                return -1;
            };
            Designer.prototype.getBodyScrollLeft = function () {
                return ($('body').get(0).scrollLeft || $('html').get(0).scrollLeft);
            };
            Designer.prototype.dragEnd = function () {
                $(document).off('mouseup', IDE.activeDesigner.dragEnd);
                $(document).off('mousemove', IDE.activeDesigner.dragMove);
                $('body').removeClass('rto-dragging');
            };
            Designer.prototype.elementDragStart = function (e) {
                e.originalEvent.dataTransfer.effectAllowed = 'move';
                var $target = $(e.target);
                var target = $target.closest('li');
                var isClosing = $target.hasClass('rto-closing');
                var dragElement = new IDE.DragElement({ id: target.attr('id'), name: target.data("rto-name"), type: target.data("rto-type"), dropKind: target.data("rto-kind"), isClosing: isClosing });
                if (!dragElement.type) {
                    dragElement.type = "dom-element";
                }
                e.originalEvent.dataTransfer.setData('text', JSON.stringify(dragElement));
                IDE.activeDesigner.dragElement = dragElement;
            };
            Designer.prototype.elementDragEnter = function (e) {
                $('#rto-view-inspector .rto-item.rto-drop-target').removeClass("rto-drop-target");
                var view = IDE.activeDesigner.sourceTemplate;
                var dropPointer = IDE.activeDesigner.getDropTargetPointer(view, e.target);
                if (!dropPointer) {
                    IDE.activeDesigner.viewInspector.hideOutliner();
                    return false; // cannot drop here
                }
                $(e.target).closest('.rto-item').addClass("rto-drop-target");
                if (dropPointer.parent) {
                    IDE.activeDesigner.viewInspector.showOutliner(dropPointer.parent.id);
                }
                else {
                    IDE.activeDesigner.viewInspector.hideOutliner();
                }
                return false;
            };
            Designer.prototype.elementDragLeave = function (e) {
                return false;
            };
            Designer.prototype.elementDragOver = function (e) {
                return false;
            };
            Designer.prototype.elementDragOverNonDrop = function (e) {
                $('#rto-view-inspector .rto-item.rto-drop-target').removeClass("rto-drop-target");
                /*
                if (activeDesigner.codeEditor){
                    activeDesigner.codeEditor.hideDropPlaceHolder();
                }
                */
            };
            Designer.prototype.elementDragEnd = function (e) {
                $('#rto-view-inspector .rto-item.rto-drop-target').removeClass("rto-drop-target");
                IDE.activeDesigner.dragElement = null;
            };
            Designer.prototype.allowDrop = function (sourceKind, targetElem) {
                var helper = IDE.Ide.sourceApp.helpers.get(targetElem.kind);
                if (sourceKind == "helper")
                    return true;
                if (sourceKind == "else") {
                    if (targetElem.children) {
                        var children = targetElem.children;
                        for (var i = 0; i < children.length; i++) {
                            if (children[i].kind == "else") {
                                return false; // only one else allowed in a parent
                            }
                        }
                    }
                }
                if (helper.allowableChildren.indexOf(sourceKind) != -1 || helper.allowableChildren.indexOf('*') != -1) {
                    return true;
                }
                if (sourceKind == "datafield" && helper.allowableChildren.indexOf('inline') != -1) {
                    return true;
                }
                return false;
            };
            Designer.prototype.getDropTargetPointer = function (view, targetElem) {
                var isClosingTag = $(targetElem).closest('.rto-closing').length > 0;
                var target = $(targetElem).closest('li');
                var targetName = target.attr('id').split("-");
                var targetId = targetName[2];
                var dragElem = IDE.activeDesigner.dragElement;
                if (dragElem.id) {
                    if (!dragElem.isClosing && $('#' + dragElem.id).has('#' + target.attr('id')).length) {
                        return null; // target is a child of the source
                    }
                    if (target.attr('id') == dragElem.id) {
                        return null; // cannot drop on self
                    }
                }
                var location;
                var dropTarget;
                if (targetId == "append") {
                    location = new IDE.ComponentTreeLocation(view.wrapper, null);
                }
                else if (isClosingTag) {
                    dropTarget = this.getElementPointer(view, targetId);
                    location = new IDE.ComponentTreeLocation(dropTarget.element, null);
                }
                else {
                    dropTarget = this.getElementPointer(view, targetId);
                    location = new IDE.ComponentTreeLocation(dropTarget.parent, dropTarget.element);
                }
                if (dragElem.isClosing) {
                    // dragging the closing tag of a container;
                    var sourceId = dragElem.id.split("-")[2];
                    var sourcePointer = this.getElementPointer(view, sourceId);
                    if (location.parent == sourcePointer.parent) {
                        if (targetId == "append" || dropTarget.index > sourcePointer.index) {
                            return location;
                        }
                    }
                    if (location.parent == sourcePointer.element) {
                        // is a child of source
                        return location;
                    }
                    if (location.parent == sourcePointer.parent && !location.nextSibling) {
                        return location;
                    }
                    return null;
                }
                else if (this.allowDrop(dragElem.dropKind, location.parent)) {
                    return location;
                }
                else {
                    return null; // cannot drop here
                }
            };
            Designer.prototype.elementDrop = function (e) {
                var dt = e.originalEvent.dataTransfer;
                var sourceInfo = JSON.parse(dt.getData('text'));
                e.preventDefault();
                var view = IDE.activeDesigner.sourceTemplate;
                var dropLocation = IDE.activeDesigner.getDropTargetPointer(view, e.target);
                if (!dropLocation) {
                    return;
                }
                $('#rto-view-inspector .rto-item.rto-drop-target').removeClass("rto-drop-target");
                IDE.DropCommandFactory.create(dropLocation, sourceInfo, function (dropCommand) {
                    IDE.activeDesigner.executeDropCommand(dropCommand, view);
                });
            };
            Designer.prototype.executeDropCommand = function (dropCommand, view) {
                dropCommand.command.do(view);
                IDE.activeDesigner.commandStack.add(dropCommand.command);
                IDE.activeDesigner.refreshViewInspector(true);
                if (dropCommand.elementAdded && dropCommand.affectedElement) {
                    IDE.activeDesigner.showAttributes({ item: dropCommand.affectedElement });
                    var helper = IDE.Ide.sourceApp.helpers.get(dropCommand.affectedElement.kind);
                    if (helper && helper.settings.expandOnCreate) {
                        /* expand all inspector nodes on the item */
                        $('#rto-view-' + dropCommand.affectedElement.id).addClass('rto-expanded'); // .find('.rto-expandable').addClass('rto-expanded');
                    }
                }
                IDE.activeDesigner.saveFile(this.sourceTemplate.file);
                IDE.activeDesigner.refreshView();
            };
            Designer.prototype.getComponentLocation = function (parent, id) {
                if (parent.children) {
                    for (var i = 0; i < parent.children.length; i++) {
                        var child = parent.children[i];
                        if (child.id == id) {
                            if ((i + 1) < parent.children.length) {
                                return new IDE.ComponentTreeLocation(parent, parent.children[i + 1]);
                            }
                            else {
                                return new IDE.ComponentTreeLocation(parent, null);
                            }
                        }
                        if (child.children) {
                            var found = this.getComponentLocation(child, id);
                            if (found) {
                                return found;
                            }
                        }
                    }
                }
                return null;
            };
            Designer.prototype.getElementPointer = function (template, id) {
                return this.doGetElementPointer(template.wrapper, id);
            };
            Designer.prototype.doGetElementPointer = function (parent, id) {
                if (parent.children) {
                    for (var i = 0; i < parent.children.length; i++) {
                        var child = parent.children[i];
                        if (child.id == id) {
                            return { "parent": parent, "element": child, index: i };
                        }
                        if (child.children) {
                            var found = this.doGetElementPointer(child, id);
                            if (found) {
                                return found;
                            }
                        }
                    }
                }
                return null;
            };
            Designer.prototype.getUniqueIdInView = function () {
                var view = this.sourceTemplate;
                for (var i = 0; i < 100; i++) {
                    var id = (Math.floor(Math.random() * 99998) + 1).toString();
                    var pointer = this.getElementPointer(view, id);
                    if (pointer == null) {
                        // item does not currently exist
                        return id;
                    }
                }
                return null;
            };
            Designer.prototype.navigateApp = function (url) {
                var canvas = IDE.Ide.getAppCanvas();
                canvas.redirect(null, { url: url });
            };
            Designer.prototype.refreshView = function () {
                var canvas = IDE.Ide.getAppCanvas();
                if (this.sourceTemplate.isComponent) {
                    canvas.componentChanged(this.sourceTemplate.file);
                }
                else {
                    canvas.templateChanged(this.sourceTemplate.file);
                }
                return;
            };
            Designer.prototype.refreshViewInspector = function (preserveState) {
                if (!this.viewInspector) {
                    return;
                }
                this.viewInspector.refresh(preserveState);
            };
            Designer.prototype.attachToViewContainer = function (options) {
                this.commandStack = new IDE.CommandStack();
                var template = options.template;
                var currentTemplateName = (this.sourceTemplate) ? this.sourceTemplate.file.getFullName() : null;
                var templateName = (template) ? template.file.getFullName() : null;
                if (templateName != currentTemplateName || options.reload) {
                    this.sourceTemplate = template;
                    if (template && template.isComponent) {
                    }
                    else if (template) {
                        IDE.Ide.render("template/edit", template.file.getFullName());
                    }
                    else {
                        this.closeAttributesPanel();
                    }
                    if (this.visible || true) {
                        this.refreshViewInspector(false);
                        this.toolbox.onViewChange();
                    }
                    if (this.footer) {
                        this.footer.onViewChange();
                        this.footer.select(IDE.Footer.APP_MAIN_SECTION);
                    }
                    if (template && Retool.startupShiftClickElementId) {
                        var id = Retool.startupShiftClickElementId;
                        Retool.startupShiftClickElementId = null;
                        this.showAttributesForId({ id: id, shiftClick: true });
                    }
                }
            };
            Designer.prototype.getModelCodeSection = function () {
                if (this.footer) {
                    return this.footer.getSection("model-code");
                }
            };
            Designer.prototype.getControllerCodeSection = function () {
                if (this.footer) {
                    return this.footer.getSection("controller-code");
                }
            };
            Designer.prototype.getCssEditor = function () {
                if (this.footer) {
                    return this.footer.getSection("css-code");
                }
            };
            Designer.prototype.getGenericEditor = function () {
                if (this.footer) {
                    return this.footer.getSection("generic-file");
                }
            };
            Designer.prototype.clearSelection = function () {
                var sel;
                if (document.selection && document.selection.empty) {
                    document.selection.empty();
                }
                else if (window.getSelection) {
                    sel = window.getSelection();
                    if (sel && sel.removeAllRanges)
                        sel.removeAllRanges();
                }
            };
            Designer.prototype.closeAttributesPanel = function () {
                this.attributeView.model = null;
                var w = new Retool.Writer("ds");
                w.write('Click on item to inspect attributes');
                w.writeToElement('#rto-attributes-title');
                $('#rto-attributes-title').attr("class", "rto-empty");
                $('#rto-attributes').hide();
            };
            Designer.prototype.showAttributesForId = function (options) {
                var pointer = this.getElementPointer(this.sourceTemplate, options.id);
                if (pointer) {
                    this.showAttributes({ item: pointer.element, shiftClick: options.shiftClick });
                }
            };
            Designer.prototype.isInspectorContent = function (compiledTemplate, element) {
                if (this.attributeView && this.attributeView.isElementEdit()) {
                    var context = IDE.activeDesigner.attributeView.context;
                    var inspectorTemplate = IDE.Ide.sourceApp.templates.get(Retool.Url.filename(context.get("view_name")));
                    if (compiledTemplate && inspectorTemplate && inspectorTemplate.file == compiledTemplate.file && context.get("id") == element.id) {
                        return true;
                    }
                }
                return false;
            };
            Designer.prototype.setBoundToProperty = function (value, newValues) {
                newValues["value"] = value;
            };
            Designer.prototype.showAttributes = function (options) {
                IDE.ElementAttributeViewModel.show(options);
            };
            Designer.prototype.gotoCodeLine = function (params) {
                if (!this.visible) {
                    this.toggle();
                }
                var file = params.file;
                if (!file) {
                    file = IDE.Ide.sourceApp.getFile(params.filename);
                    if (!file) {
                        return;
                    }
                }
                var info = file.getInfo();
                var fileType = Retool.FileSystem.FilePath.getType(params.filename);
                var codeSection;
                if (fileType == 0 /* Template */) {
                    codeSection = this.footer.getTemplateSection(info.name);
                }
                else if (fileType == 1 /* Model */) {
                    codeSection = this.getModelCodeSection();
                }
                else if (fileType == 2 /* Controller */) {
                    codeSection = this.getControllerCodeSection();
                }
                if (!codeSection) {
                    return;
                }
                if (codeSection && codeSection.editor) {
                    this.footer.select(codeSection.id);
                    codeSection.loadFile(file);
                    var line = params.line;
                    if (params.methodName) {
                        var i = codeSection.editor.findCodeLine(params.methodName + "(");
                        if (i != -1) {
                            line = i;
                        }
                    }
                    codeSection.editor.scrollToLine(line + 1);
                }
            };
            Designer.prototype.getParentElement = function (element) {
                var parent = $('#rto-view-' + element.id).parent().closest('li[data-rto-kind]').get(0);
                if (parent) {
                    if (parent.id.length > 9 && parent.id.substr(0, 9) == "rto-view-") {
                        var id = parent.id.substr(9);
                        var pointer = this.getElementPointer(this.sourceTemplate, id);
                        if (pointer) {
                            return pointer.element;
                        }
                    }
                }
                return null;
            };
            Designer.prototype.autoApplyAttributesDialog = function () {
                if (this.attributeView.model) {
                    var model = IDE.activeDesigner.attributeView.model;
                    if (model.containsChanges()) {
                        var event = new Retool.ComponentEvent(null, null);
                        this.attributeView.context.viewModel.executeEventMethod({ event: event, methodName: "btnUpdate_onclick" });
                    }
                }
                return false;
            };
            Designer.prototype.showPartial = function (url) {
                var template = IDE.Ide.sourceApp.templates.get(url);
                if (template) {
                    this.show({ shiftClick: false, template: template });
                    return true;
                }
            };
            Designer.prototype.undo = function () {
                if (this.commandStack.canUndo()) {
                    var command = this.commandStack.undo();
                    command.undo(this.sourceTemplate);
                    this.refreshViewInspector(true);
                    IDE.activeDesigner.saveFile(this.sourceTemplate.file);
                    IDE.activeDesigner.refreshView();
                }
            };
            Designer.prototype.redo = function () {
                if (this.commandStack.canRedo()) {
                    var command = this.commandStack.redo();
                    command.redo(this.sourceTemplate);
                    this.refreshViewInspector(true);
                    IDE.activeDesigner.saveFile(this.sourceTemplate.file);
                    IDE.activeDesigner.refreshView();
                }
            };
            Designer.prototype.canUndo = function () {
                return this.commandStack && this.commandStack.canUndo();
            };
            Designer.prototype.canRedo = function () {
                return this.commandStack && this.commandStack.canRedo();
            };
            Designer.prototype.getCodeSnippetContent = function (snippetName) {
                return "\tvar email = new Email();\n" + "\temail.send();\n";
            };
            Designer.prototype.render = function () {
                this.renderer = new IDE.DesignerRenderer();
                this.renderer.render();
                $('#rto-toggle').show();
            };
            Designer.prototype.hideDropLists = function () {
            };
            Designer.prototype.goAction = function (action) {
                if (action == "designer.undo") {
                    this.undo();
                }
                else if (action == "designer.redo") {
                    this.redo();
                }
                else if (action == "designer.copy") {
                    this.viewInspector.copy();
                }
                else if (action == "close-demo") {
                    $('#rto-demo').remove();
                    $('#rto-ide').removeClass('rto-demo');
                }
            };
            Designer.prototype.saveFile = function (file, writeImmediate) {
                this.fileSaveQueue.add(file);
                if (writeImmediate) {
                    this.fileSaveQueue.writeQueue();
                }
            };
            Designer.prototype.saveFileBatch = function (files, options) {
                this.fileSaveQueue.addFiles(files);
                this.fileSaveQueue.writeQueue(options);
            };
            Designer.prototype.deleteFile = function (file) {
                this.fileSaveQueue.deleteFile(file);
            };
            Designer.prototype.deleteFiles = function (files) {
                this.fileSaveQueue.deleteFiles(files);
            };
            Designer.prototype.getFileSaveQueueRequest = function () {
                if (this.fileSaveQueue.hasFiles) {
                    return this.fileSaveQueue.mergeQueue();
                }
            };
            Designer.prototype.destroy = function () {
                this.hide();
                IDE.activeDesigner = null;
            };
            Designer.prototype.onLayoutChange = function () {
                $('#rto-toggle').show();
            };
            Designer.prototype.consoleLog = function (text) {
                if (this.jsConsole) {
                    this.jsConsole.log(text);
                }
            };
            Designer.prototype.updateExecutionLog = function (items) {
                if (this.executionLog) {
                    this.executionLog.add(items);
                }
            };
            Designer.prototype.canCopy = function () {
                return (this.attributeView.isElementEdit());
            };
            Designer.prototype.showDemo = function (name) {
                $('#rto-ide').addClass('rto-demo');
                $('#rto-demo').remove();
                var w = new Retool.Writer();
                w.writeTag("div", null, { id: "rto-demo" });
                w.writeTag("div", "banner").writeTag("button", "btn close-demo", { "data-url": "go:close-demo" }).text("Okay, got it").write('</button></div>');
                w.writeTag("img", null, { src: name });
                w.write('</div>');
                $('#rto-ide').append(w.getStream());
            };
            Designer.prototype.showBreakPoint = function (process, file, line) {
                /*
                var section = <ControllerCodeEditor>this.footer.getSection("controller-code");
                //  todo: check section visisble
                if (file == section.editor.file){
                    if (this.footer.activeSection != section){
                       this.footer.select('controller-code');
                    }
                    section.editor.setCurrentDebugLine(process,line - 1);
                }
                */
            };
            Designer.prototype.compileTemplate = function (app, sourceFile, logger) {
                return IDE.TemplateCompiler.compile(app, sourceFile, app.helpers, logger);
            };
            Designer.prototype.compileComponent = function (app, name, sourceFile, logger) {
                return IDE.ComponentCompiler.compile(name, sourceFile, app.helpers, logger);
            };
            Designer.prototype.compileProgram = function (code, options) {
                return IDE.JavascriptCompiler.compileProgram(code, options);
            };
            Designer.prototype.compileContent = function (app, file, logger) {
                var ext = Retool.FileSystem.PathInfo.getExtension(file.name);
                if (ext == "md") {
                    return IDE.MarkdownFileCompiler.compile(app, file, logger);
                }
                else if (ext == "txt") {
                    return IDE.TextFileCompiler.compile(app, file, logger);
                }
                return "";
            };
            Designer.prototype.footerVisible = function () {
                return this.footer && this.footer.visible;
            };
            Designer.prototype.getViewBuilder = function () {
                return new IDE.ViewBuilder(null);
            };
            Designer.prototype.showTooltip = function (options) {
                var show = function () {
                    var tooltip = $('#rto-tooltip');
                    if (!tooltip.length) {
                        $('#rto-ide').append('<div id="rto-tooltip" style="display:none" class="rto-tooltip rto-bottom"><div class="rto-tooltip-arrow"></div><div class="rto-tooltip-inner"></div></div>');
                    }
                    var $tooltip = $('#rto-tooltip');
                    $tooltip.find('.rto-tooltip-inner').text(options.text);
                    var ide = $('#rto-ide').offset();
                    var pos = $(options.elem).offset();
                    pos.top = pos.top - ide.top;
                    pos.left -= IDE.activeDesigner.ideOffset;
                    var p = "bottom";
                    /*
                    if (pos.top > $(window).height()/2){
                        p = "top";
                    }
                    */
                    var wid = $(options.elem).width();
                    var ht = $(options.elem).height();
                    var tw = $tooltip.width();
                    var left = pos.left - (tw / 2) + (wid / 2);
                    var top;
                    if (p == "bottom") {
                        top = pos.top + ht + 5;
                    }
                    else if (p == "top") {
                        top = pos.top - $tooltip.height() - 5;
                    }
                    if (left < 0) {
                        p = "right";
                        top = pos.top + 12;
                        left = pos.left + wid - 3;
                    }
                    if (left + tw > $(window).width()) {
                        p = "left";
                        top = pos.top + 12;
                        left = pos.left - tw + 3;
                    }
                    $tooltip.attr('class', "rto-tooltip rto-" + p);
                    $tooltip.css('left', left).css('top', top).show();
                };
                this.tooltipTimer = setTimeout(show, 500);
            };
            Designer.prototype.hideTooltip = function () {
                if (this.tooltipTimer) {
                    clearTimeout(this.tooltipTimer);
                }
                this.tooltipTimer = null;
                $('#rto-tooltip').hide();
            };
            Designer.prototype.setSignedIn = function (userInfo) {
                var user = new IDE.User();
                user.username = userInfo.username;
                user.avatar_url = userInfo.avatar_url;
                IDE.Ide.user = user;
                this.renderer.refreshNavbar();
            };
            Designer.prototype.appLoaded = function (appGlobal) {
                IDE.Ide.appLoaded(appGlobal);
            };
            Designer.prototype.loadProject = function () {
                this.renderer.loadProject();
            };
            Designer.prototype.getMethodHints = function (sourceCode, options) {
                return IDE.HintList.getMethods(sourceCode, options);
            };
            Designer.prototype.getCanvas = function (name) {
                return IDE.Ide.canvases.get(name);
            };
            return Designer;
        })();
        IDE.Designer = Designer;
        IDE.activeDesigner;
        function startDesigner(options) {
            if (!IDE.activeDesigner) {
                IDE.activeDesigner = new Designer();
                IDE.activeDesigner.visible = true;
                IDE.Ide.init();
                IDE.Ide.sourceApp = new Retool.Application("ide-loading");
                var initialView = IDE.Ide.getAppCanvas();
                options = options || {};
                var ownWindow = options.hasOwnWindow;
                if (ownWindow) {
                    IDE.activeDesigner.designerTopPercent = 0;
                    initialView = IDE.Ide.getAppCanvas();
                }
                IDE.activeDesigner.render();
                IDE.activeDesigner.resize();
                IDE.activeDesigner.updatePanelWidths();
                if (ownWindow) {
                    $('#rto-ide').css("top", 0);
                }
                /*
                if (initialView){
                    activeDesigner.attachToViewContainer({template:null});
                    activeDesigner.footer.select(Footer.APP_SECTION);
    
                }
                */
                Retool.VM.addType("SiteManager", null, new IDE.SiteManager(null));
                var cc = new IDE.CodeCompleteListBuilder();
                cc.buildForVMStatics();
            }
        }
        IDE.startDesigner = startDesigner;
        function loadApp(appModule) {
            var files = appModule.manifest();
            Retool.loadSchema(files);
        }
        IDE.loadApp = loadApp;
    })(IDE = Retool.IDE || (Retool.IDE = {}));
})(Retool || (Retool = {}));
// CodeMirror is the only global var we claim
window.CodeMirror = (function() {
  "use strict";

  // BROWSER SNIFFING

  // Crude, but necessary to handle a number of hard-to-feature-detect
  // bugs and behavior differences.
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var opera = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /windows/i.test(navigator.platform);

  var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (opera_version) opera_version = Number(opera_version[1]);
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
  var captureMiddleClick = gecko || (ie && !ie_lt9);

  // Optimize some code when these features are not used
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // CONSTRUCTOR

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options || {};
    // Determine effective options based on given values and defaults.
    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
      options[opt] = defaults[opt];
    setGuttersForLineNumbers(options);

    var docStart = typeof options.value == "string" ? 0 : options.value.first;
    var display = this.display = makeDisplay(place, docStart);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    if (options.autofocus && !mobile) focusInput(this);

    this.state = {keyMaps: [],
                  overlays: [],
                  modeGen: 0,
                  overwrite: false, focused: false,
                  suppressEdits: false, pasteIncoming: false,
                  draggingText: false,
                  highlight: new Delayed()};

    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(options.value, options.mode);
    operation(this, attachDoc)(this, doc);

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie) setTimeout(bind(resetInput, this, true), 20);

    registerEventHandlers(this);
    // IE throws unspecified error in certain cases, when
    // trying to access activeElement before onload
    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }
    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);
    else onBlur(this);

    operation(this, function() {
      for (var opt in optionHandlers)
        if (optionHandlers.propertyIsEnumerable(opt))
          optionHandlers[opt](this, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    })();
  }

  // DISPLAY CONSTRUCTOR

  function makeDisplay(place, docStart) {
    var d = {};

    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");
    if (webkit) input.style.width = "1000px";
    else input.setAttribute("wrap", "off");
    // if border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) input.style.border = "1px solid black";
    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");

    // Wraps and hides input textarea
    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The actual fake scrollbars.
    d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");
    d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    // DIVs containing the selection and the actual code
    d.lineDiv = elt("div", null, "CodeMirror-code");
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    // Blinky cursor, and element used to ensure cursor fits at the end of a line
    d.cursor = elt("div", "\u00a0", "CodeMirror-cursor");
    // Secondary cursor, shown when on a 'jump' in bi-directional text
    d.otherCursor = elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");
    // Used to measure text size
    d.measure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],
                         null, "position: relative; outline: none");
    // Moved around its parent to cover visible view
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the text, causes scrolling
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");
    // Will contain the gutters, if any
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Provides scrolling
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,
                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
    // Work around IE7 z-index bug
    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);

    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios) input.style.width = "0px";
    if (!webkit) d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";

    // Current visible range (may be bigger than the view window).
    d.viewOffset = d.lastSizeC = 0;
    d.showingFrom = d.showingTo = docStart;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = "";
    // Set to true when a non-horizontal-scrolling widget is added. As
    // an optimization, widget aligning is skipped when d is false.
    d.alignWidgets = false;
    // Flag that indicates whether we currently expect input to appear
    // (after some event like 'keypress' or 'input') and are polling
    // intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();

    d.cachedCharWidth = d.cachedTextHeight = null;
    d.measureLineCache = [];
    d.measureLineCachePos = 0;

    // Tracks when resetInput has punted to just putting a short
    // string instead of the (large) selection.
    d.inaccurateSelection = false;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    return d;
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      cm.display.wrapper.className += " CodeMirror-wrap";
      cm.display.sizer.style.minWidth = "";
    } else {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");
      computeMaxLength(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      else if (wrapping)
        return (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function keyMapChanged(cm) {
    var map = keyMap[cm.options.keyMap], style = map.style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +
      (style ? " cm-keymap-" + style : "");
    cm.state.disableInput = map.disableInput;
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
  }

  function lineLength(doc, line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find();
      cur = getLine(doc, found.from.line);
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find();
      len -= cur.text.length - found.from.ch;
      cur = getLine(doc, found.to.line);
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  function computeMaxLength(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(doc, d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(doc, line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = false;
    for (var i = 0; i < options.gutters.length; ++i) {
      if (options.gutters[i] == "CodeMirror-linenumbers") {
        if (options.lineNumbers) found = true;
        else options.gutters.splice(i--, 1);
      }
    }
    if (!found && options.lineNumbers)
      options.gutters.push("CodeMirror-linenumbers");
  }

  // SCROLLBARS

  // Re-synchronize the fake scrollbars with the actual size of the
  // content. Optionally force a scrollTop.
  function updateScrollbars(cm) {
    var d = cm.display, docHeight = cm.doc.height;
    var totalHeight = docHeight + paddingVert(d);
    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";
    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";
    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
    var needsH = d.scroller.scrollWidth > (d.scroller.clientWidth + 1);
    var needsV = scrollHeight > (d.scroller.clientHeight + 1);
    if (needsV) {
      d.scrollbarV.style.display = "block";
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarV.firstChild.style.height =
        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + "px";
    } else d.scrollbarV.style.display = "";
    if (needsH) {
      d.scrollbarH.style.display = "block";
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarH.firstChild.style.width =
        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + "px";
    } else d.scrollbarH.style.display = "";
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";
    } else d.scrollbarFiller.style.display = "";
    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";
      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";
    } else d.gutterFiller.style.display = "";

    if (mac_geLion && scrollbarWidth(d.measure) === 0)
      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";
  }

  function visibleLines(display, doc, viewPort) {
    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
    if (typeof viewPort == "number") top = viewPort;
    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}
    top = Math.floor(top - paddingTop(display));
    var bottom = Math.ceil(top + height);
    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};
  }

  // LINE NUMBERS

  function alignHorizontally(cm) {
    var display = cm.display;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, l = comp + "px";
    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {
      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  function compensateForHScroll(display) {
    return getRect(display.scroller).left - getRect(display.sizer).left;
  }

  // DISPLAY DRAWING

  function updateDisplay(cm, changes, viewPort) {
    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (;;) {
      if (!updateDisplayInner(cm, changes, visible)) break;
      updated = true;
      updateSelection(cm);
      updateScrollbars(cm);

      // Clip forced viewport to actual scrollable area
      if (viewPort)
        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight,
                            typeof viewPort == "number" ? viewPort : viewPort.top);
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
        break;
      changes = [];
    }

    if (updated) {
      signalLater(cm, "update", cm);
      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
        signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);
    }
    return updated;
  }

  // Uses a set of changes plus the current scroll position to
  // determine which DOM updates have to be made, and makes the
  // updates.
  function updateDisplayInner(cm, changes, visible) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.clientWidth) {
      display.showingFrom = display.showingTo = doc.first;
      display.viewOffset = 0;
      return;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (changes.length == 0 &&
        visible.from > display.showingFrom && visible.to < display.showingTo)
      return;

    if (maybeUpdateLineNumberWidth(cm))
      changes = [{from: doc.first, to: doc.first + doc.size}];
    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";
    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";

    // Used to determine which lines need their line numbers updated
    var positionsChangedFrom = Infinity;
    if (cm.options.lineNumbers)
      for (var i = 0; i < changes.length; ++i)
        if (changes[i].diff) { positionsChangedFrom = changes[i].from; break; }

    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);
    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);
    if (sawCollapsedSpans) {
      from = lineNo(visualLine(doc, getLine(doc, from)));
      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;
    }

    // Create a range of theoretically intact lines, and punch holes
    // in that using the change info.
    var intact = [{from: Math.max(display.showingFrom, doc.first),
                   to: Math.min(display.showingTo, end)}];
    if (intact[0].from >= intact[0].to) intact = [];
    else intact = computeIntact(intact, changes);
    // When merged lines are present, we might have to reduce the
    // intact ranges because changes in continued fragments of the
    // intact lines do require the lines to be redrawn.
    if (sawCollapsedSpans)
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i], merged;
        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
          var newTo = merged.find().from.line;
          if (newTo > range.from) range.to = newTo;
          else { intact.splice(i--, 1); break; }
        }
      }

    // Clip off the parts that won't be visible
    var intactLines = 0;
    for (var i = 0; i < intact.length; ++i) {
      var range = intact[i];
      if (range.from < from) range.from = from;
      if (range.to > to) range.to = to;
      if (range.from >= range.to) intact.splice(i--, 1);
      else intactLines += range.to - range.from;
    }
    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
      updateViewOffset(cm);
      return;
    }
    intact.sort(function(a, b) {return a.from - b.from;});

    // Avoid crashing on IE's "unspecified error" when in iframes
    try {
      var focused = document.activeElement;
    } catch(e) {}
    if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";
    patchDisplay(cm, from, to, intact, positionsChangedFrom);
    display.lineDiv.style.display = "";
    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();

    var different = from != display.showingFrom || to != display.showingTo ||
      display.lastSizeC != display.wrapper.clientHeight;
    // This is just a bogus formula that detects when the editor is
    // resized or the font size changes.
    if (different) {
      display.lastSizeC = display.wrapper.clientHeight;
      startWorker(cm, 400);
    }
    display.showingFrom = from; display.showingTo = to;

    var prevBottom = display.lineDiv.offsetTop;
    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {
      if (ie_lt8) {
        var bot = node.offsetTop + node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = getRect(node);
        height = box.bottom - box.top;
      }
      var diff = node.lineObj.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(node.lineObj, height);
        var widgets = node.lineObj.widgets;
        if (widgets) for (var i = 0; i < widgets.length; ++i)
          widgets[i].height = widgets[i].node.offsetHeight;
      }
    }
    updateViewOffset(cm);

    return true;
  }

  function updateViewOffset(cm) {
    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
    // Position the mover div to align with the current virtual scroll position
    cm.display.mover.style.top = off + "px";
  }

  function computeIntact(intact, changes) {
    for (var i = 0, l = changes.length || 0; i < l; ++i) {
      var change = changes[i], intact2 = [], diff = change.diff || 0;
      for (var j = 0, l2 = intact.length; j < l2; ++j) {
        var range = intact[j];
        if (change.to <= range.from && change.diff) {
          intact2.push({from: range.from + diff, to: range.to + diff});
        } else if (change.to <= range.from || change.from >= range.to) {
          intact2.push(range);
        } else {
          if (change.from > range.from)
            intact2.push({from: range.from, to: change.from});
          if (change.to < range.to)
            intact2.push({from: change.to + diff, to: range.to + diff});
        }
      }
      intact = intact2;
    }
    return intact;
  }

  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
    var dims = getDimensions(cm);
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
      removeChildren(display.lineDiv);
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
        node.lineObj = null;
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }

    var nextIntact = intact.shift(), lineN = from;
    cm.doc.iter(from, to, function(line) {
      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();
      if (lineIsHidden(cm.doc, line)) {
        if (line.height != 0) updateLineHeight(line, 0);
        if (line.widgets && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {
          var w = line.widgets[i];
          if (w.showIfHidden) {
            var prev = cur.previousSibling;
            if (/pre/i.test(prev.nodeName)) {
              var wrap = elt("div", null, null, "position: relative");
              prev.parentNode.replaceChild(wrap, prev);
              wrap.appendChild(prev);
              prev = wrap;
            }
            var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));
            if (!w.handleMouseEvents) wnode.ignoreEvents = true;
            positionLineWidget(w, wnode, prev, dims);
          }
        }
      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
        // This line is intact. Skip to the actual node. Update its
        // line number if needed.
        while (cur.lineObj != line) cur = rm(cur);
        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
        cur = cur.nextSibling;
      } else {
        // For lines with widgets, make an attempt to find and reuse
        // the existing element, so that widgets aren't needlessly
        // removed and re-inserted into the dom
        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }
        // This line needs to be generated.
        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
        if (lineNode != reuse) {
          container.insertBefore(lineNode, cur);
        } else {
          while (cur != reuse) cur = rm(cur);
          cur = cur.nextSibling;
        }

        lineNode.lineObj = line;
      }
      ++lineN;
    });
    while (cur) cur = rm(cur);
  }

  function buildLineElement(cm, line, lineNo, dims, reuse) {
    var lineElement = lineContent(cm, line);
    var markers = line.gutterMarkers, display = cm.display, wrap;

    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)
      return lineElement;

    // Lines with gutter elements, widgets or a background class need
    // to be wrapped again, and have the extra elements added to the
    // wrapper div

    if (reuse) {
      reuse.alignable = null;
      var isOk = true, widgetsSeen = 0, insertBefore = null;
      for (var n = reuse.firstChild, next; n; n = next) {
        next = n.nextSibling;
        if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
          reuse.removeChild(n);
        } else {
          for (var i = 0; i < line.widgets.length; ++i) {
            var widget = line.widgets[i];
            if (widget.node == n.firstChild) {
              if (!widget.above && !insertBefore) insertBefore = n;
              positionLineWidget(widget, n, reuse, dims);
              ++widgetsSeen;
              break;
            }
          }
          if (i == line.widgets.length) { isOk = false; break; }
        }
      }
      reuse.insertBefore(lineElement, insertBefore);
      if (isOk && widgetsSeen == line.widgets.length) {
        wrap = reuse;
        reuse.className = line.wrapClass || "";
      }
    }
    if (!wrap) {
      wrap = elt("div", null, line.wrapClass, "position: relative");
      wrap.appendChild(lineElement);
    }
    // Kludge to make sure the styled element lies behind the selection (by z-index)
    if (line.bgClass)
      wrap.insertBefore(elt("div", null, line.bgClass + " CodeMirror-linebackground"), wrap.firstChild);
    if (cm.options.lineNumbers || markers) {
      var gutterWrap = wrap.insertBefore(elt("div", null, null, "position: absolute; left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),
                                         wrap.firstChild);
      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        wrap.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineNo),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + display.lineNumInnerWidth + "px"));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                       dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
        }
    }
    if (ie_lt8) wrap.style.zIndex = 2;
    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.ignoreEvents = true;
      positionLineWidget(widget, node, wrap, dims);
      if (widget.above)
        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
    return wrap;
  }

  function positionLineWidget(widget, node, wrap, dims) {
    if (widget.noHScroll) {
      (wrap.alignable || (wrap.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // SELECTION / CURSOR

  function updateSelection(cm) {
    var display = cm.display;
    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
    if (collapsed || cm.options.showCursorWhenSelecting)
      updateSelectionCursor(cm);
    else
      display.cursor.style.display = display.otherCursor.style.display = "none";
    if (!collapsed)
      updateSelectionRange(cm);
    else
      display.selectionDiv.style.display = "none";

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, cm.doc.sel.head, "div");
      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                                        headPos.top + lineOff.top - wrapOff.top)) + "px";
      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                                         headPos.left + lineOff.left - wrapOff.left)) + "px";
    }
  }

  // No selection, plain cursor
  function updateSelectionCursor(cm) {
    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, "div");
    display.cursor.style.left = pos.left + "px";
    display.cursor.style.top = pos.top + "px";
    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
    display.cursor.style.display = "";

    if (pos.other) {
      display.otherCursor.style.display = "";
      display.otherCursor.style.left = pos.other.left + "px";
      display.otherCursor.style.top = pos.other.top + "px";
      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    } else { display.otherCursor.style.display = "none"; }
  }

  // Highlight selection
  function updateSelectionRange(cm) {
    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
    var fragment = document.createDocumentFragment();
    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = pl;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = pl;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = clientWidth;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < pl + 1) left = pl;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    if (sel.from.line == sel.to.line) {
      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
    } else {
      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);
      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);
      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;
      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(pl, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(pl, leftEnd.bottom, null, rightStart.top);
    }

    removeChildrenAndAdd(display.selectionDiv, fragment);
    display.selectionDiv.style.display = "";
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = "";
    display.blinker = setInterval(function() {
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";
    }, cm.options.cursorBlinkRate);
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.showingTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changed = [], prevChange;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {
      if (doc.frontier >= cm.display.showingFrom) { // Visible
        var oldStyles = line.styles;
        line.styles = highlightLine(cm, line, state);
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) {
          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;
          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});
        }
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changed.length)
      operation(cm, function() {
        for (var i = 0; i < changed.length; ++i)
          regChange(this, changed[i].start, changed[i].end);
      })();
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    for (var search = n, lim = n - 100; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingLeft(display) {
    var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));
    return e.offsetLeft;
  }

  function measureChar(cm, line, ch, data, bias) {
    var dir = -1;
    data = data || measureLine(cm, line);

    for (var pos = ch;; pos += dir) {
      var r = data[pos];
      if (r) break;
      if (dir < 0 && pos == 0) dir = 1;
    }
    bias = pos > ch ? "left" : pos < ch ? "right" : bias;
    if (bias == "left" && r.leftSide) r = r.leftSide;
    else if (bias == "right" && r.rightSide) r = r.rightSide;
    return {left: pos < ch ? r.right : r.left,
            right: pos > ch ? r.left : r.right,
            top: r.top,
            bottom: r.bottom};
  }

  function findCachedMeasurement(cm, line) {
    var cache = cm.display.measureLineCache;
    for (var i = 0; i < cache.length; ++i) {
      var memo = cache[i];
      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&
          cm.display.scroller.clientWidth == memo.width &&
          memo.classes == line.textClass + "|" + line.bgClass + "|" + line.wrapClass)
        return memo;
    }
  }

  function clearCachedMeasurement(cm, line) {
    var exists = findCachedMeasurement(cm, line);
    if (exists) exists.text = exists.measure = exists.markedSpans = null;
  }

  function measureLine(cm, line) {
    // First look in the cache
    var cached = findCachedMeasurement(cm, line);
    if (cached) return cached.measure;

    // Failing that, recompute and store result in cache
    var measure = measureLineInner(cm, line);
    var cache = cm.display.measureLineCache;
    var memo = {text: line.text, width: cm.display.scroller.clientWidth,
                markedSpans: line.markedSpans, measure: measure,
                classes: line.textClass + "|" + line.bgClass + "|" + line.wrapClass};
    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;
    else cache.push(memo);
    return measure;
  }

  function measureLineInner(cm, line) {
    var display = cm.display, measure = emptyArray(line.text.length);
    var pre = lineContent(cm, line, measure);

    // IE does not cache element positions of inline elements between
    // calls to getBoundingClientRect. This makes the loop below,
    // which gathers the positions of all the characters on the line,
    // do an amount of layout work quadratic to the number of
    // characters. When line wrapping is off, we try to improve things
    // by first subdividing the line into a bunch of inline blocks, so
    // that IE can reuse most of the layout information from caches
    // for those blocks. This does interfere with line wrapping, so it
    // doesn't work when wrapping is on, but in that case the
    // situation is slightly better, since IE does cache line-wrapping
    // information and only recomputes per-line.
    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
      var fragment = document.createDocumentFragment();
      var chunk = 10, n = pre.childNodes.length;
      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
        var wrap = elt("div", null, null, "display: inline-block");
        for (var j = 0; j < chunk && n; ++j) {
          wrap.appendChild(pre.firstChild);
          --n;
        }
        fragment.appendChild(wrap);
      }
      pre.appendChild(fragment);
    }

    removeChildrenAndAdd(display.measure, pre);

    var outer = getRect(display.lineDiv);
    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
    // Work around an IE7/8 bug where it will sometimes have randomly
    // replaced our pre with a clone at this point.
    if (ie_lt9 && display.measure.first != pre)
      removeChildrenAndAdd(display.measure, pre);

    function measureRect(rect) {
      var top = rect.top - outer.top, bot = rect.bottom - outer.top;
      if (bot > maxBot) bot = maxBot;
      if (top < 0) top = 0;
      for (var i = vranges.length - 2; i >= 0; i -= 2) {
        var rtop = vranges[i], rbot = vranges[i+1];
        if (rtop > bot || rbot < top) continue;
        if (rtop <= top && rbot >= bot ||
            top <= rtop && bot >= rbot ||
            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {
          vranges[i] = Math.min(top, rtop);
          vranges[i+1] = Math.max(bot, rbot);
          break;
        }
      }
      if (i < 0) { i = vranges.length; vranges.push(top, bot); }
      return {left: rect.left - outer.left,
              right: rect.right - outer.left,
              top: i, bottom: null};
    }
    function finishRect(rect) {
      rect.bottom = vranges[rect.top+1];
      rect.top = vranges[rect.top];
    }

    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {
      var node = cur, rect = null;
      // A widget might wrap, needs special care
      if (/\bCodeMirror-widget\b/.test(cur.className) && cur.getClientRects) {
        if (cur.firstChild.nodeType == 1) node = cur.firstChild;
        var rects = node.getClientRects();
        if (rects.length > 1) {
          rect = data[i] = measureRect(rects[0]);
          rect.rightSide = measureRect(rects[rects.length - 1]);
        }
      }
      if (!rect) rect = data[i] = measureRect(getRect(node));
      if (cur.measureRight) rect.right = getRect(cur.measureRight).left;
      if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));
    }
    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {
      finishRect(cur);
      if (cur.leftSide) finishRect(cur.leftSide);
      if (cur.rightSide) finishRect(cur.rightSide);
    }
    return data;
  }

  function measureLineWidth(cm, line) {
    var hasBadSpan = false;
    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {
      var sp = line.markedSpans[i];
      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;
    }
    var cached = !hasBadSpan && findCachedMeasurement(cm, line);
    if (cached) return measureChar(cm, line, line.text.length, cached.measure, "right").right;

    var pre = lineContent(cm, line);
    var end = pre.appendChild(zeroWidthElement(cm.display.measure));
    removeChildrenAndAdd(cm.display.measure, pre);
    return getRect(end).right - getRect(cm.display.lineDiv).left;
  }

  function clearCaches(cm) {
    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(cm, lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = getRect(cm.display.lineSpace);
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Context may be "window", "page", "div", or "local"/null
  // Result is in "div" coords
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = getRect(cm.display.sizer);
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = getRect(cm.display.lineSpace);
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);
  }

  function cursorCoords(cm, pos, context, lineObj, measurement) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!measurement) measurement = measureLine(cm, lineObj);
    function get(ch, right) {
      var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  function PosWithInfo(line, ch, outside, xRel) {
    var pos = new Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Coords must be lineSpace-local
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineNo > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    for (;;) {
      var lineObj = getLine(doc, lineNo);
      var found = coordsCharInner(cm, lineObj, lineNo, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find();
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineNo = mergedPos.to.line;
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(cm, lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var measurement = measureLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line",
                            lineObj, measurement);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar.test(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < 0 ? -1 : xDiff ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "x");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var width = anchor.offsetWidth;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap changes in such a way that each
  // change won't have to update the cursor and display (which would
  // be awkward, slow, and error-prone), but instead updates are
  // batched and then all combined and executed at once.

  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      // An array of ranges of lines that have to be updated. See
      // updateDisplay.
      changes: [],
      updateInput: null,
      userSelChange: null,
      textChanged: null,
      selectionChanged: false,
      cursorActivity: false,
      updateMaxLine: false,
      updateScrollPos: false,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++) delayedCallbacks = [];
  }

  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;

    if (op.updateMaxLine) computeMaxLength(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
      var width = measureLineWidth(cm, display.maxLine);
      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";
      display.maxLineChanged = false;
      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
    }
    var newScrollPos, updated;
    if (op.updateScrollPos) {
      newScrollPos = op.updateScrollPos;
    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible
      var coords = cursorCoords(cm, doc.sel.head);
      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
    }
    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null) {
      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);
      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    if (!updated && op.selectionChanged) updateSelection(cm);
    if (op.updateScrollPos) {
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
      alignHorizontally(cm);
      if (op.scrollToPos)
        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
    } else if (newScrollPos) {
      scrollCursorIntoView(cm);
    }
    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.userSelChange);

    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    if (op.textChanged)
      signal(cm, "change", cm, op.textChanged);
    if (op.cursorActivity) signal(cm, "cursorActivity", cm);
    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm1, f) {
    return function() {
      var cm = cm1 || this, withOp = !cm.curOp;
      if (withOp) startOperation(cm);
      try { var result = f.apply(cm, arguments); }
      finally { if (withOp) endOperation(cm); }
      return result;
    };
  }
  function docOperation(f) {
    return function() {
      var withOp = this.cm && !this.cm.curOp, result;
      if (withOp) startOperation(this.cm);
      try { result = f.apply(this, arguments); }
      finally { if (withOp) endOperation(this.cm); }
      return result;
    };
  }
  function runInOp(cm, f) {
    var withOp = !cm.curOp, result;
    if (withOp) startOperation(cm);
    try { result = f(); }
    finally { if (withOp) endOperation(cm); }
    return result;
  }

  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    cm.curOp.changes.push({from: from, to: to, diff: lendiff});
  }

  // INPUT HANDLING

  function slowPoll(cm) {
    if (cm.display.pollingFast) return;
    cm.display.poll.set(cm.options.pollInterval, function() {
      readInput(cm);
      if (cm.state.focused) slowPoll(cm);
    });
  }

  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
      else {cm.display.pollingFast = false; slowPoll(cm);}
    }
    cm.display.poll.set(20, p);
  }

  // prevInput is a hack to work with IME. If we reset the textarea
  // on every change, that breaks IME. So we look for changes
  // compared to the previous content instead. (Modern browsers have
  // events that indicate IME taking place, but these are not widely
  // supported or compatible enough yet to rely on.)
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput) return false;
    var text = input.value;
    if (text == prevInput && posEq(sel.from, sel.to)) return false;
    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
      resetInput(cm, true);
      return false;
    }

    var withOp = !cm.curOp;
    if (withOp) startOperation(cm);
    sel.shift = false;
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
    var from = sel.from, to = sel.to;
    if (same < prevInput.length)
      from = Pos(from.line, from.ch - (prevInput.length - same));
    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));

    var updateInput = cm.curOp.updateInput;
    var changeEvent = {from: from, to: to, text: splitLines(text.slice(same)),
                       origin: cm.state.pasteIncoming ? "paste" : "+input"};
    makeChange(cm.doc, changeEvent, "end");
    cm.curOp.updateInput = updateInput;
    signalLater(cm, "inputRead", cm, changeEvent);

    if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";
    else cm.display.prevInput = text;
    if (withOp) endOperation(cm);
    cm.state.pasteIncoming = false;
    return true;
  }

  function resetInput(cm, user) {
    var minimal, selected, doc = cm.doc;
    if (!posEq(doc.sel.from, doc.sel.to)) {
      cm.display.prevInput = "";
      minimal = hasCopyEvent &&
        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? "-" : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused) selectInput(cm.display.input);
      if (ie && !ie_lt9) cm.display.inputHasSelection = content;
    } else if (user) {
      cm.display.prevInput = cm.display.input.value = "";
      if (ie && !ie_lt9) cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }

  function focusInput(cm) {
    if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input))
      cm.display.input.focus();
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // EVENT HANDLERS

  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    if (ie)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
        extendSelection(cm.doc, word.from, word.to);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    on(d.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(d, e)) e_preventDefault(e);
    });
    // Gecko browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for Gecko.
    if (!captureMiddleClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });
    on(d.scrollbarV, "scroll", function() {
      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, "scroll", function() {
      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });

    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }
    on(d.scrollbarH, "mousedown", reFocus);
    on(d.scrollbarV, "mousedown", reFocus);
    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    var resizeTimer;
    function onResize() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        // Might be a text scaling operation, clear size caches.
        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;
        clearCaches(cm);
        runInOp(cm, bind(regChange, cm));
      }, 100);
    }
    on(window, "resize", onResize);
    // Above handler holds on to the editor and its data structures.
    // Here we poll to unregister it when the editor is no longer in
    // the document, so that it can be garbage-collected.
    function unregister() {
      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}
      if (p) setTimeout(unregister, 5000);
      else off(window, "resize", onResize);
    }
    setTimeout(unregister, 5000);

    on(d.input, "keyup", operation(cm, function(e) {      
      if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
      if (e.keyCode == 16) cm.doc.sel.shift = false;
    }));
    on(d.input, "input", bind(fastPoll, cm));
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));

    function drag_(e) {
      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;
      e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }
    on(d.scroller, "paste", function(e){
      if (eventInWidget(d, e)) return;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, "paste", function() {
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });

    function prepareCopy() {
      if (d.inaccurateSelection) {
        d.prevInput = "";
        d.inaccurateSelection = false;
        d.input.value = cm.getSelection();
        selectInput(d.input);
      }
    }
    on(d.input, "cut", prepareCopy);
    on(d.input, "copy", prepareCopy);

    // Needed to handle Tab key in KHTML
    if (khtml) on(d.sizer, "mouseup", function() {
        if (document.activeElement == d.input) d.input.blur();
        focusInput(cm);
    });
  }

  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;
    }
  }

  function posFromMouse(cm, e, liberal) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||
          target == display.scrollbarV || target == display.scrollbarV.firstChild ||
          target == display.scrollbarFiller || target == display.gutterFiller) return null;
    }
    var x, y, space = getRect(display.lineSpace);
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }
    return coordsChar(cm, x - space.left, y - space.top);
  }

  var lastClick, lastDoubleClick;
  function onMouseDown(e) {
    if (signalDOMEvent(this, e)) return;
    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
    sel.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);

    switch (e_button(e)) {
    case 3:
      if (captureMiddleClick) onContextMenu.call(cm, cm, e);
      return;
    case 2:
      if (start) extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      return;
    }
    // For button 1, if it was clicked inside the editor
    // (posFromMouse returning non-null), we have to adjust the
    // selection.
    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}

    if (!cm.state.focused) onFocus(cm);

    var now = +new Date, type = "single";
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
      type = "triple";
      e_preventDefault(e);
      setTimeout(bind(focusInput, cm), 20);
      selectLine(cm, start.line);
    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
      e_preventDefault(e);
      var word = findWordAt(getLine(doc, start.line).text, start);
      extendSelection(cm.doc, word.from, word.to);
    } else { lastClick = {time: now, pos: start}; }

    var last = start;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&
        !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {
      var dragEnd = operation(cm, function(e2) {
        if (webkit) display.scroller.draggable = false;
        cm.state.draggingText = false;
        off(document, "mouseup", dragEnd);
        off(display.scroller, "drop", dragEnd);
        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
          e_preventDefault(e2);
          extendSelection(cm.doc, start);
          focusInput(cm);
        }
      });
      // Let the drag handler handle this.
      if (webkit) display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      // IE's approach to draggable
      if (display.scroller.dragDrop) display.scroller.dragDrop();
      on(document, "mouseup", dragEnd);
      on(display.scroller, "drop", dragEnd);
      return;
    }
    e_preventDefault(e);
    if (type == "single") extendSelection(cm.doc, clipPos(doc, start));

    var startstart = sel.from, startend = sel.to, lastPos = start;

    function doSelect(cur) {
      if (posEq(lastPos, cur)) return;
      lastPos = cur;

      if (type == "single") {
        extendSelection(cm.doc, clipPos(doc, start), cur);
        return;
      }

      startstart = clipPos(doc, startstart);
      startend = clipPos(doc, startend);
      if (type == "double") {
        var word = findWordAt(getLine(doc, cur.line).text, cur);
        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);
        else extendSelection(cm.doc, startstart, word.to);
      } else if (type == "triple") {
        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
      }
    }

    var editorSize = getRect(display.wrapper);
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true);
      if (!cur) return;
      if (!posEq(cur, last)) {
        if (!cm.state.focused) onFocus(cm);
        last = cur;
        doSelect(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      focusInput(cm);
      off(document, "mousemove", move);
      off(document, "mouseup", up);
    }

    var move = operation(cm, function(e) {
      if (!ie && !e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  function clickInGutter(cm, e) {
    var display = cm.display;
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }

    if (mX >= Math.floor(getRect(display.gutters).right)) return false;
    e_preventDefault(e);
    if (!hasHandler(cm, "gutterClick")) return true;

    var lineBox = getRect(display.lineDiv);
    if (mY > lineBox.bottom) return true;
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && getRect(g).right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalLater(cm, "gutterClick", cm, line, gutter, e);
        break;
      }
    }
    return true;
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"}, "around");
          }
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else {
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
          setSelection(cm.doc, pos, pos);
          if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");
          cm.replaceSelection(text, null, "paste");
          focusInput(cm);
          onFocus(cm);
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    var txt = cm.getSelection();
    e.dataTransfer.setData("Text", txt);

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      if (opera) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (opera) img.parentNode.removeChild(img);
    }
  }

  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplay(cm, [], val);
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
    if (gecko) updateDisplay(cm, []);
    startWorker(cm, 100);
  }
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
        if (cur.lineObj) {
          cm.display.currentWheelTarget = cur;
          break;
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, [], {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
    var doc = cm.doc, prevShift = doc.sel.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) doc.sel.shift = false;
      done = bound(cm) != Pass;
    } finally {
      doc.sel.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }

  var maybeTransition;
  function handleKeyBinding(cm, e) {
    // Handle auto keymap transitions
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
      if (getKeyMap(cm.options.keyMap) == startMap) {
        cm.options.keyMap = (next.call ? next.call(null, cm) : next);
        keyMapChanged(cm);
      }
    }, 50);

    var name = keyName(e, true), handled = false;
    if (!name) return false;
    var keymaps = allKeyMaps(cm);
  
    if (e.shiftKey) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})
             || lookupKey(name, keymaps, function(b) {
                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                    return doHandleBinding(cm, b);
                });
    } else {
      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });
    }

    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }
      signalLater(cm, "keyHandled", cm, name, e);
    }
    return handled;
  }

  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),
                            function(b) { return doHandleBinding(cm, b, true); });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);
    }
    return handled;
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (!cm.state.focused) onFocus(cm);
    if (ie && e.keyCode == 27) { e.returnValue = false; }
    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
    var code = e.keyCode;
    // IE does strange things with escape.
    cm.doc.sel.shift = code == 16 || e.shiftKey;
    // First give onKeyEvent option a chance to handle this.
    var handled = handleKeyBinding(cm, e);
    if (opera) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("");
    }
  }

  function onKeyPress(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (this.options.electricChars && this.doc.mode.electricChars &&
        this.options.smartIndent && !isReadOnly(this) &&
        this.doc.mode.electricChars.indexOf(ch) > -1)
      setTimeout(operation(cm, function() {indentLine(cm, cm.doc.sel.to.line, "smart");}), 75);
    if (handleCharBinding(cm, e, ch)) return;
    if (ie && !ie_lt9) cm.display.inputHasSelection = null;
    fastPoll(cm);
  }

  function onFocus(cm) {
    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
        cm.display.wrapper.className += " CodeMirror-focused";
      resetInput(cm, true);
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);
  }

  var detectingSelectAll;
  function onContextMenu(cm, e) {
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    var display = cm.display, sel = cm.doc.sel;
    if (eventInWidget(display, e)) return;

    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || opera) return; // Opera is difficult.
    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
      operation(cm, setSelection)(cm.doc, pos, pos);

    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = "absolute";
    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: white; outline: none;" +
      "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";
    focusInput(cm);
    resetInput(cm, true);
    // Adds "Select all" to context menu in FF
    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";

    function prepareSelectAllHack() {
      if (display.input.selectionStart != null) {
        var extval = display.input.value = " " + (posEq(sel.from, sel.to) ? "" : display.input.value);
        display.prevInput = " ";
        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
      }
    }
    function rehide() {
      display.inputDiv.style.position = "relative";
      display.input.style.cssText = oldCSS;
      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);

      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null) {
        if (!ie || ie_lt9) prepareSelectAllHack();
        clearTimeout(detectingSelectAll);
        var i = 0, poll = function(){
          if (display.prevInput == " " && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);
          else resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && !ie_lt9) prepareSelectAllHack();
    if (captureMiddleClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }

  // UPDATING

  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Make sure a position will be valid after the given change.
  function clipPostChange(doc, change, pos) {
    if (!posLess(change.from, pos)) return clipPos(doc, pos);
    var diff = (change.text.length - 1) - (change.to.line - change.from.line);
    if (pos.line > change.to.line + diff) {
      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);
      return clipToLen(pos, getLine(doc, preLine).text.length);
    }
    if (pos.line == change.to.line + diff)
      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +
                       getLine(doc, change.to.line).text.length - change.to.ch);
    var inside = pos.line - change.from.line;
    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
  }

  // Hint can be null|"end"|"start"|"around"|{anchor,head}
  function computeSelAfterChange(doc, change, hint) {
    if (hint && typeof hint == "object") // Assumed to be {anchor, head} object
      return {anchor: clipPostChange(doc, change, hint.anchor),
              head: clipPostChange(doc, change, hint.head)};

    if (hint == "start") return {anchor: change.from, head: change.from};

    var end = changeEnd(change);
    if (hint == "around") return {anchor: change.from, head: end};
    if (hint == "end") return {anchor: end, head: end};

    // hint is null, leave the selection alone as much as possible
    var adjustPos = function(pos) {
      if (posLess(pos, change.from)) return pos;
      if (!posLess(change.to, pos)) return end;

      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) ch += end.ch - change.to.ch;
      return Pos(line, ch);
    };
    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};
  }

  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Replace the range from from to to by the strings in replacement.
  // change is a {from, to, text [, origin]} object
  function makeChange(doc, change, selUpdate, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 1; --i)
        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [""]});
      if (split.length)
        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);
    } else {
      makeChangeNoReadonly(doc, change, selUpdate);
    }
  }

  function makeChangeNoReadonly(doc, change, selUpdate) {
    var selAfter = computeSelAfterChange(doc, change, selUpdate);
    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  function makeChangeFromHistory(doc, type) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history;
    var event = (type == "undo" ? hist.done : hist.undone).pop();
    if (!event) return;

    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,
                anchorAfter: event.anchorBefore, headAfter: event.headBefore,
                generation: hist.generation};
    (type == "undo" ? hist.undone : hist.done).push(anti);
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        (type == "undo" ? hist.done : hist.undone).length = 0;
        return;
      }

      anti.changes.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change, null)
                    : {anchor: event.anchorBefore, head: event.headBefore};
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      var rebased = [];

      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  function shiftDoc(doc, distance) {
    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}
    doc.first += distance;
    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);
    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);
    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);
  }

  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
    else updateDoc(doc, change, spans, selAfter);
  }

  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
      cm.curOp.cursorActivity = true;

    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(doc, line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    regChange(cm, from.line, to.line + 1, lendiff);

    if (hasHandler(cm, "change")) {
      var changeObj = {from: from, to: to,
                       text: change.text,
                       removed: change.removed,
                       origin: change.origin};
      if (cm.curOp.textChanged) {
        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}
        cur.next = changeObj;
      } else cm.curOp.textChanged = changeObj;
    }
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);
  }

  // POSITION OBJECT

  function Pos(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  }
  CodeMirror.Pos = Pos;

  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}
  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}
  function copyPos(x) {return Pos(x.line, x.ch);}

  // SELECTION

  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}

  // If shift is held, this will move the selection anchor. Otherwise,
  // it'll set the whole selection.
  function extendSelection(doc, pos, other, bias) {
    if (doc.sel.shift || doc.sel.extend) {
      var anchor = doc.sel.anchor;
      if (other) {
        var posBefore = posLess(pos, anchor);
        if (posBefore != posLess(other, anchor)) {
          anchor = pos;
          pos = other;
        } else if (posBefore != posLess(pos, other)) {
          pos = other;
        }
      }
      setSelection(doc, anchor, pos, bias);
    } else {
      setSelection(doc, pos, other || pos, bias);
    }
    if (doc.cm) doc.cm.curOp.userSelChange = true;
  }

  function filterSelectionChange(doc, anchor, head) {
    var obj = {anchor: anchor, head: head};
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);
    return obj;
  }

  // Update the selection. Last two args are only used by
  // updateDoc, since they have to be expressed in the line
  // numbers before the update.
  function setSelection(doc, anchor, head, bias, checkAtomic) {
    if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      var filtered = filterSelectionChange(doc, anchor, head);
      head = filtered.head;
      anchor = filtered.anchor;
    }

    var sel = doc.sel;
    sel.goalColumn = null;
    // Skip over atomic spans.
    if (checkAtomic || !posEq(anchor, sel.anchor))
      anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");
    if (checkAtomic || !posEq(head, sel.head))
      head = skipAtomic(doc, head, bias, checkAtomic != "push");

    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;

    sel.anchor = anchor; sel.head = head;
    var inv = posLess(head, anchor);
    sel.from = inv ? head : anchor;
    sel.to = inv ? anchor : head;

    if (doc.cm)
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged =
        doc.cm.curOp.cursorActivity = true;

    signalLater(doc, "cursorActivity", doc);
  }

  function reCheckSelection(cm) {
    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");
  }

  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find()[dir < 0 ? "from" : "to"];
            if (posEq(newPos, curPos)) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SCROLLING

  function scrollCursorIntoView(cm) {
    var coords = scrollPosIntoView(cm, cm.doc.sel.head, cm.options.cursorScrollMargin);
    if (!cm.state.focused) return;
    var display = cm.display, box = getRect(display.sizer), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var hidden = display.cursor.style.display == "none";
      if (hidden) {
        display.cursor.style.display = "";
        display.cursor.style.left = coords.left + "px";
        display.cursor.style.top = (coords.top - display.viewOffset) + "px";
      }
      display.cursor.scrollIntoView(doScroll);
      if (hidden) display.cursor.style.display = "none";
    }
  }

  function scrollPosIntoView(cm, pos, margin) {
    if (margin == null) margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) return coords;
    }
  }

  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft) x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }

  function updateScrollPos(cm, left, top) {
    cm.curOp.updateScrollPos = {scrollLeft: left == null ? cm.doc.scrollLeft : left,
                                scrollTop: top == null ? cm.doc.scrollTop : top};
  }

  function addToScrollPos(cm, left, top) {
    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});
    var scroll = cm.display.scroller;
    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
  }

  // API UTILITIES

  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc;
    if (how == null) how = "add";
    if (how == "smart") {
      if (!cm.doc.mode.indent) how = "prev";
      else var state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (how == "smart") {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString)
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    line.stateAfter = null;
  }

  function changeLine(cm, handle, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no)) regChange(cm, no, no + 1);
    else return null;
    return line;
  }

  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur) ? "w"
          : !group ? null
          : /\s/.test(cur) ? null
          : "p";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }
        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  function findWordAt(line, pos) {
    var start = pos.ch, end = pos.ch;
    if (line) {
      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar
        : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
        : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
      while (start > 0 && check(line.charAt(start - 1))) --start;
      while (end < line.length && check(line.charAt(end))) ++end;
    }
    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};
  }

  function selectLine(cm, line) {
    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
  }

  // PROTOTYPE

  // The publicly visible API. Note that operation(null, f) means
  // 'wrap f in an operation, performed on its `this` parameter'

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); focusInput(this); onFocus(this); fastPoll(this);},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](map);
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: operation(null, function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: operation(null, function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: operation(null, function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: operation(null, function(how) {
      var sel = this.doc.sel;
      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {start: stream.start,
              end: stream.pos,
              string: stream.current(),
              className: style || null, // Deprecated, use 'type' instead
              type: style || null,
              state: state};
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      if (ch == 0) return styles[2];
      for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else return styles[mid * 2 + 2];
      }
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      if (!helpers.hasOwnProperty(type)) return;
      var help = helpers[type], mode = this.getModeAt(pos);
      return mode[type] && help[mode[type]] ||
        mode.helperType && help[mode.helperType] ||
        help[mode.name];
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, sel = this.doc.sel;
      if (start == null) pos = sel.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? sel.from : sel.to;
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first) line = this.doc.first;
      else if (line > last) { line = last; end = true; }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, getLine(this.doc, line), {top: 0, left: 0}, mode || "page").top +
        (end ? lineObj.height : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: operation(null, function(line, gutterID, value) {
      return changeLine(this, line, function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: operation(null, function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regChange(cm, i, i + 1);
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    addLineClass: operation(null, function(handle, where, cls) {
      return changeLine(this, handle, function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),

    removeLineClass: operation(null, function(handle, where, cls) {
      return changeLine(this, handle, function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: operation(null, function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),

    removeLineWidget: function(widget) { widget.clear(); },

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: operation(null, onKeyDown),

    execCommand: function(cmd) {return commands[cmd](this);},

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: operation(null, function(dir, unit) {
      var sel = this.doc.sel, pos;
      if (sel.shift || sel.extend || posEq(sel.from, sel.to))
        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
      else
        pos = dir < 0 ? sel.from : sel.to;
      extendSelection(this.doc, pos, pos, dir);
    }),

    deleteH: operation(null, function(dir, unit) {
      var sel = this.doc.sel;
      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");
      else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");
      this.curOp.userSelChange = true;
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: operation(null, function(dir, unit) {
      var sel = this.doc.sel;
      var pos = cursorCoords(this, sel.head, "div");
      if (sel.goalColumn != null) pos.left = sel.goalColumn;
      var target = findPosV(this, pos, dir, unit);

      if (unit == "page") addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top);
      extendSelection(this.doc, target, target, dir);
      sel.goalColumn = pos.left;
    }),

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        this.display.cursor.className += " CodeMirror-overwrite";
      else
        this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");
    },
    hasFocus: function() { return this.state.focused; },

    scrollTo: operation(null, function(x, y) {
      updateScrollPos(this, x, y);
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};
    },

    scrollIntoView: operation(null, function(pos, margin) {
      if (typeof pos == "number") pos = Pos(pos, 0);
      if (!margin) margin = 0;
      var coords = pos;

      if (!pos || pos.line != null) {
        this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
        this.curOp.scrollToPosMargin = margin;
        coords = cursorCoords(this, this.curOp.scrollToPos);
      }
      var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
    }),

    setSize: function(width, height) {
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) this.display.wrapper.style.width = interpret(width);
      if (height != null) this.display.wrapper.style.height = interpret(height);
      this.refresh();
    },

    operation: function(f){return runInOp(this, f);},

    refresh: operation(null, function() {
      clearCaches(this);
      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
      regChange(this);
    }),

    swapDoc: operation(null, function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this, true);
      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
      return old;
    }),

    getInputField: function(){return this.display.input;},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  var optionHandlers = CodeMirror.optionHandlers = {};

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    loadMode(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("electricChars", true);
  option("rtlMoveVisually", !windows);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", keyMapChanged);
  option("extraKeys", null);

  option("onKeyEvent", null);
  option("onDragEvent", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, updateScrollbars, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {onBlur(cm); cm.display.input.blur();}
    else if (!val) resetInput(cm, true);
  });
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true);
  option("pollInterval", 100);
  option("undoDepth", 40, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 500);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, function(cm){loadMode(cm); cm.refresh();}, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;

    return modeObj;
  };

  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {};
    helpers[type][name] = value;
  };

  // UTILITIES

  CodeMirror.isWordChar = isWordChar;

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because modes
  // sometimes need to do this.
  function copyState(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;

  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},
    killLine: function(cm) {
      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
      if (!sel && cm.getLine(from.line).length == from.ch)
        cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");
      else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");
    },
    deleteLine: function(cm) {
      var l = cm.getCursor().line;
      cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");
    },
    delLineLeft: function(cm) {
      var cur = cm.getCursor();
      cm.replaceRange("", Pos(cur.line, 0), cur, "+delete");
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelection(lineStart(cm, cm.getCursor().line));
    },
    goLineStartSmart: function(cm) {
      var cur = cm.getCursor(), start = lineStart(cm, cur.line);
      var line = cm.getLineHandle(start.line);
      var order = getOrder(line);
      if (!order || order[0].level == 0) {
        var firstNonWS = Math.max(0, line.text.search(/\S/));
        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
      } else cm.extendSelection(start);
    },
    goLineEnd: function(cm) {
      cm.extendSelection(lineEnd(cm, cm.getCursor().line));
    },
    goLineRight: function(cm) {
      var top = cm.charCoords(cm.getCursor(), "div").top + 5;
      cm.extendSelection(cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div"));
    },
    goLineLeft: function(cm) {
      var top = cm.charCoords(cm.getCursor(), "div").top + 5;
      cm.extendSelection(cm.coordsChar({left: 0, top: top}, "div"));
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t", "end", "+input");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.replaceSelection("  ", "end", "+input");
    },
    transposeChars: function(cm) {
      var cur = cm.getCursor(), line = cm.getLine(cur.line);
      if (cur.ch > 0 && cur.ch < line.length - 1)
        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),
                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
    },
    newlineAndIndent: function(cm) {
      operation(cm, function() {
        cm.replaceSelection("\n", "end", "+input");
        cm.indentLine(cm.getCursor().line, null, true);
      })();
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };

  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"
  };
  // Note that the save and find-related commands aren't defined by
  // default. Unknown commands are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    fallthrough: "basic"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };

  // KEYMAP DISPATCH

  function getKeyMap(val) {
    if (typeof val == "string") return keyMap[val];
    else return val;
  }

  function lookupKey(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false) return "stop";
      if (found != null && handle(found)) return true;
      if (map.nofallthrough) return "stop";

      var fallthrough = map.fallthrough;
      if (fallthrough == null) return false;
      if (Object.prototype.toString.call(fallthrough) != "[object Array]")
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        var done = lookup(fallthrough[i]);
        if (done) return done;
      }
      return false;
    }

    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done) return done != "stop";
    }
  }
  function isModifierKey(event) {
    var name = keyNames[event.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }
  function keyName(event, noShift) {
    if (opera && event.keyCode == 34 && event["char"]) return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) return false;
    if (event.altKey) name = "Alt-" + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
    if (!noShift && event.shiftKey) name = "Shift-" + name;
    return name;
  }
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.keyName = keyName;

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    if (!options) options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = document.body;
      // doc.activeElement occasionally throws on IE
      try { hasFocus = document.activeElement; } catch(e) {}
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    cm.save = save;
    cm.getTextArea = function() { return textarea; };
    cm.toTextArea = function() {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  // The character stream used by a mode's parser.
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
  }

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == 0;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue;
    },
    indentation: function() {return countColumn(this.string, null, this.tabSize);},
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);}
  };
  CodeMirror.StringStream = StringStream;

  // TEXTMARKERS

  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  }
  CodeMirror.TextMarker = TextMarker;
  eventMixin(TextMarker);

  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.to != null) max = lineNo(line);
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from != null)
        min = lineNo(line);
      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm);
    }
    if (withOp) endOperation(cm);
    signalLater(this, "clear");
  };

  TextMarker.prototype.find = function() {
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null || span.to != null) {
        var found = lineNo(line);
        if (span.from != null) from = Pos(found, span.from);
        if (span.to != null) to = Pos(found, span.to);
      }
    }
    if (this.type == "bookmark") return from;
    return from && {from: from, to: to};
  };

  TextMarker.prototype.changed = function() {
    var pos = this.find(), cm = this.doc.cm;
    if (!pos || !cm) return;
    var line = getLine(this.doc, pos.from.line);
    clearCachedMeasurement(cm, line);
    if (pos.from.line >= cm.display.showingFrom && pos.from.line < cm.display.showingTo) {
      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {
        if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);
        break;
      }
      runInOp(cm, function() { cm.curOp.selectionChanged = true; });
    }
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  function markText(doc, from, to, options, type) {
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type);
    if (type == "range" && !posLess(from, to)) return marker;
    if (options) copyObj(options, marker);
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;
    }
    if (marker.collapsed) sawCollapsedSpans = true;

    if (marker.addToHistory)
      addToHistory(doc, {from: from, to: to, origin: "markText"},
                   {head: doc.sel.head, anchor: doc.sel.anchor}, NaN);

    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
        updateMaxLine = true;
      var span = {from: null, to: null, marker: marker};
      size += line.text.length;
      if (curLine == from.line) {span.from = from.ch; size -= from.ch;}
      if (curLine == to.line) {span.to = to.ch; size -= line.text.length - to.ch;}
      if (marker.collapsed) {
        if (curLine == to.line) collapsedAtEnd = collapsedSpanAt(line, to.ch);
        if (curLine == from.line) collapsedAtStart = collapsedSpanAt(line, from.ch);
        else updateLineHeight(line, 0);
      }
      addMarkedSpan(line, span);
      ++curLine;
    });
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      if (collapsedAtStart != collapsedAtEnd)
        throw new Error("Inserting collapsed marker overlapping an existing one");
      marker.size = size;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      if (marker.atomic) reCheckSelection(cm);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0, me = this; i < markers.length; ++i) {
      markers[i].parent = this;
      on(markers[i], "clear", function(){me.clear();});
    }
  }
  CodeMirror.SharedTextMarker = SharedTextMarker;
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function() {
    return this.primary.find();
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.replacedWith;
    linkedDocs(doc, function(doc) {
      if (widget) options.replacedWith = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  // TEXTMARKER SPANS

  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || marker.type == "bookmark" && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push({from: span.from,
                                to: endsAfter ? null : span.to,
                                marker: marker});
      }
    }
    return nw;
  }

  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || marker.type == "bookmark" && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,
                                to: span.to == null ? null : span.to - endCh,
                                marker: marker});
      }
    }
    return nw;
  }

  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    if (sameLine && first) {
      // Make sure we didn't create any zero-length spans
      for (var i = 0; i < first.length; ++i)
        if (first[i].from != null && first[i].from == first[i].to && first[i].marker.type != "bookmark")
          first.splice(i--, 1);
      if (!first.length) first = null;
    }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find();
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;
        var newParts = [j, 1];
        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
          newParts.push({from: p.from, to: m.from});
        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  function collapsedSpanAt(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if ((sp.from == null || sp.from < ch) &&
          (sp.to == null || sp.to > ch) &&
          (!found || found.width < sp.marker.width))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAt(line, -1); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAt(line, line.text.length + 1); }

  function visualLine(doc, line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(doc, merged.find().from.line);
    return line;
  }

  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.replacedWith) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find().to, endLine = getLine(doc, end.line);
      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }

  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // LINE WIDGETS

  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.cm = cm;
    this.node = node;
  };
  eventMixin(LineWidget);
  function widgetOperation(f) {
    return function() {
      var withOp = !this.cm.curOp;
      if (withOp) startOperation(this.cm);
      try {var result = f.apply(this, arguments);}
      finally {if (withOp) endOperation(this.cm);}
      return result;
    };
  }
  LineWidget.prototype.clear = widgetOperation(function() {
    var ws = this.line.widgets, no = lineNo(this.line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) this.line.widgets = null;
    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;
    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
    if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);
    regChange(this.cm, no, no + 1);
  });
  LineWidget.prototype.changed = widgetOperation(function() {
    var oldH = this.height;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(this.line, this.line.height + diff);
    var no = lineNo(this.line);
    regChange(this.cm, no, no + 1);
  });

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(cm, handle, function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
        var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, 0, widget.height);
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);

  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Run the given mode's parser over a line, update the styles
  // array, which contains alternating fragments of text and CSS
  // classes.
  function runMode(cm, text, mode, state, f) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == "" && mode.blankLine) mode.blankLine(state);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        // Webkit seems to refuse to render text nodes longer than 57444 characters
        stream.pos = Math.min(text.length, stream.start + 50000);
        style = null;
      } else {
        style = mode.token(stream, state);
      }
      if (!flattenSpans || curStyle != style) {
        if (curStart < stream.start) f(stream.start, curStyle);
        curStart = stream.start; curStyle = style;
      }
      stream.start = stream.pos;
    }
    if (curStart < stream.pos) f(stream.pos, curStyle);
  }

  function highlightLine(cm, line, state) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen];
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {st.push(end, style);});

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = cur ? cur + " " + style : style;
          }
        }
      });
    }

    return st;
  }

  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen)
      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array.
  function processLine(cm, line, state) {
    var mode = cm.doc.mode;
    var stream = new StringStream(line.text, cm.options.tabSize);
    if (line.text == "" && mode.blankLine) mode.blankLine(state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      mode.token(stream, state);
      stream.start = stream.pos;
    }
  }

  var styleToClassCache = {};
  function styleToClass(style) {
    if (!style) return null;
    return styleToClassCache[style] ||
      (styleToClassCache[style] = "cm-" + style.replace(/ +/g, " cm-"));
  }

  function lineContent(cm, realLine, measure) {
    var merged, line = realLine, empty = true;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(cm.doc, merged.find().from.line);

    var builder = {pre: elt("pre"), col: 0, pos: 0, display: !measure,
                   measure: null, measuredSomething: false, cm: cm};
    if (line.textClass) builder.pre.className = line.textClass;

    do {
      if (line.text) empty = false;
      builder.measure = line == realLine && measure;
      builder.pos = 0;
      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
      if ((ie || webkit) && cm.getOption("lineWrapping"))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      var next = insertLineContent(line, builder, getLineStyles(cm, line));
      if (measure && line == realLine && !builder.measuredSomething) {
        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
        builder.measuredSomething = true;
      }
      if (next) line = getLine(cm.doc, next.to.line);
    } while (next);

    if (measure && !builder.measuredSomething && !measure[0])
      measure[0] = builder.pre.appendChild(empty ? elt("span", "\u00a0") : zeroWidthElement(cm.display.measure));
    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
      builder.pre.appendChild(document.createTextNode("\u00a0"));

    var order;
    // Work around problem with the reported dimensions of single-char
    // direction spans on IE (issue #1129). See also the comment in
    // cursorCoords.
    if (measure && ie && (order = getOrder(line))) {
      var l = order.length - 1;
      if (order[l].from == order[l].to) --l;
      var last = order[l], prev = order[l - 1];
      if (last.from + 1 == last.to && prev && last.level < prev.level) {
        var span = measure[builder.pos - 1];
        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),
                                               span.nextSibling);
      }
    }

    signal(cm, "renderLine", cm, realLine, builder.pre);
    return builder.pre;
  }

  var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
  function buildToken(builder, text, style, startStyle, endStyle, title) {
    if (!text) return;
    if (!tokenSpecialChars.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        tokenSpecialChars.lastIndex = pos;
        var m = tokenSpecialChars.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
          builder.col += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          builder.col += tabWidth;
        } else {
          var token = elt("span", "\u2022", "cm-invalidchar");
          token.title = "\\u" + m[0].charCodeAt(0).toString(16);
          content.appendChild(token);
          builder.col += 1;
        }
      }
    }
    if (style || startStyle || endStyle || builder.measure) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle);
      if (title) token.title = title;
      return builder.pre.appendChild(token);
    }
    builder.pre.appendChild(content);
  }

  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
    var wrapping = builder.cm.options.lineWrapping;
    for (var i = 0; i < text.length; ++i) {
      var ch = text.charAt(i), start = i == 0;
      if (ch >= "\ud800" && ch < "\udbff" && i < text.length - 1) {
        ch = text.slice(i, i + 2);
        ++i;
      } else if (i && wrapping && spanAffectsWrapping(text, i)) {
        builder.pre.appendChild(elt("wbr"));
      }
      var old = builder.measure[builder.pos];
      var span = builder.measure[builder.pos] =
        buildToken(builder, ch, style,
                   start && startStyle, i == text.length - 1 && endStyle);
      if (old) span.leftSide = old.leftSide || old;
      // In IE single-space nodes wrap differently than spaces
      // embedded in larger text nodes, except when set to
      // white-space: normal (issue #1268).
      if (ie && wrapping && ch == " " && i && !/\s/.test(text.charAt(i - 1)) &&
          i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
        span.style.whiteSpace = "normal";
      builder.pos += ch.length;
    }
    if (text.length) builder.measuredSomething = true;
  }

  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = " ";
      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
      out += " ";
      return out;
    }
    return function(builder, text, style, startStyle, endStyle, title) {
      return inner(builder, text.replace(/ {3,}/, split), style, startStyle, endStyle, title);
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.replacedWith;
    if (widget) {
      if (!builder.display) widget = widget.cloneNode(true);
      builder.pre.appendChild(widget);
      if (builder.measure) {
        if (size) {
          builder.measure[builder.pos] = widget;
        } else {
          var elt = builder.measure[builder.pos] = zeroWidthElement(builder.cm.display.measure);
          if (marker.type != "bookmark" || marker.insertLeft)
            builder.pre.insertBefore(elt, widget);
          else
            builder.pre.appendChild(elt);
        }
        builder.measuredSomething = true;
      }
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), styleToClass(styles[i+1]));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmark = null;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || collapsed.marker.size < m.size))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.replacedWith) foundBookmark = m;
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return collapsed.marker.find();
        }
        if (foundBookmark && !collapsed) buildCollapsedSpan(builder, 0, foundBookmark);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = styleToClass(styles[i++]);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // First adjust the line structure
    if (from.ch == 0 && to.ch == 0 && lastText == "") {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));      
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
    setSelection(doc, selAfter.anchor, selAfter.head, null, true);
  }

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    collapse: function(lines) {
      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));
    },
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;
    },
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.history = makeHistory();
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    insert: function(at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue"},
                 {head: top, anchor: top}, true);
    },
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},
    setLine: function(line, text) {
      if (isLine(this, line))
        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
    },
    removeLine: function(line) {
      if (line) replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
      else replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)));
    },

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(this, line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var sel = this.sel, pos;
      if (start == null || start == "head") pos = sel.head;
      else if (start == "anchor") pos = sel.anchor;
      else if (start == "end" || start === false) pos = sel.to;
      else pos = sel.from;
      return copyPos(pos);
    },
    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},

    setCursor: docOperation(function(line, ch, extend) {
      var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);
      if (extend) extendSelection(this, pos);
      else setSelection(this, pos, pos);
    }),
    setSelection: docOperation(function(anchor, head) {
      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));
    }),
    extendSelection: docOperation(function(from, to) {
      extendSelection(this, clipPos(this, from), to && clipPos(this, to));
    }),

    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},
    replaceSelection: function(code, collapse, origin) {
      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || "around");
    },
    undo: docOperation(function() {makeChangeFromHistory(this, "undo");}),
    redo: docOperation(function() {makeChangeFromHistory(this, "redo");}),

    setExtending: function(val) {this.sel.extend = val;},

    historySize: function() {
      var hist = this.history;
      return {undo: hist.done.length, redo: hist.undone.length};
    },
    clearHistory: function() {this.history = makeHistory(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration();
    },
    changeGeneration: function() {
      this.history.lastOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = makeHistory(this.history.maxGeneration);
      hist.done = histData.done.slice(0);
      hist.undone = histData.undone.slice(0);
    },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,
                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = makeHistory();
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  Doc.prototype.eachLine = Doc.prototype.iter;

  // The Doc methods that should be available on CodeMirror instances
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) computeMaxLength(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  function getLine(chunk, n) {
    n -= chunk.first;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  function updateLineHeight(line, height) {
    var diff = height - line.height;
    for (var n = line; n; n = n.parent) n.height += diff;
  }

  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0, e = chunk.children.length; i < e; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }

  function heightAtLine(cm, lineObj) {
    lineObj = visualLine(cm.doc, lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function makeHistory(startGen) {
    return {
      // Arrays of history events. Doing something adds an event to
      // done and clears undo. Undoing moves events from done to
      // undone, redoing moves them in the other direction.
      done: [], undone: [], undoDepth: Infinity,
      // Used to track when changes can be merged into a single undo
      // event
      lastTime: 0, lastOp: null, lastOrigin: null,
      // Used by the isClean() method
      generation: startGen || 1, maxGeneration: startGen || 1
    };
  }

  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  function historyChangeFromChange(doc, change) {
    var from = { line: change.from.line, ch: change.from.ch };
    var histChange = {from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  function addToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur = lst(hist.done);

    if (cur &&
        (hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*"))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;
    } else {
      // Can not be merged, start a new event.
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation,
             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,
             anchorAfter: selAfter.anchor, headAfter: selAfter.head};
      hist.done.push(cur);
      hist.generation = ++hist.maxGeneration;
      while (hist.done.length > hist.undoDepth)
        hist.done.shift();
    }
    hist.lastTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = change.origin;
  }

  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i], changes = event.changes, newChanges = [];
      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,
                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSel(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }
        if (to < cur.from.line) {
          cur.from.line += diff;
          cur.to.line += diff;
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!sub.copied) {
        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);
        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);
        sub.copied = true;
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      } else {
        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);
        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT OPERATORS

  function stopMethod() {e_stop(this);}
  // Ensure an event has a stop method.
  function addStop(event) {
    if (!event.stop) event.stop = stopMethod;
    return event;
  }

  function e_preventDefault(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  function on(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  }

  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }

  function signalDOMEvent(cm, e, override) {
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e);
  }

  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;

  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerCutOff = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  function Delayed() {this.id = null;}
  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
      if (string.charAt(i) == "\t") n += tabSize - (n % tabSize);
      else ++n;
    }
    return n;
  }
  CodeMirror.countColumn = countColumn;

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  function selectInput(node) {
    if (ios) { // Mobile Safari apparently has a bug where select() is broken.
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else {
      // Suppress mysterious IE10 errors
      try { node.select(); }
      catch(_e) {}
    }
  }

  function indexOf(collection, elt) {
    if (collection.indexOf) return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt) return i;
    return -1;
  }

  function createObj(base, props) {
    function Obj() {}
    Obj.prototype = base;
    var inst = new Obj();
    if (props) copyObj(props, inst);
    return inst;
  }

  function copyObj(obj, target) {
    if (!target) target = {};
    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
    return target;
  }

  function emptyArray(size) {
    for (var a = [], i = 0; i < size; ++i) a.push(undefined);
    return a;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordChar(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") setTextContent(e, content);
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function setTextContent(e, str) {
    if (ie_lt9) {
      e.innerHTML = "";
      e.appendChild(document.createTextNode(str));
    } else e.textContent = str;
  }

  function getRect(node) {
    return node.getBoundingClientRect();
  }
  CodeMirror.replaceGetRect = function(f) { getRect = f; };

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie_lt9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  // For a reason I have yet to figure out, some browsers disallow
  // word wrapping between certain characters *only* if a new inline
  // element is started between them. This makes it hard to reliably
  // measure the position of things, since that requires inserting an
  // extra span. This terribly fragile set of tests matches the
  // character combinations that suffer from this phenomenon on the
  // various browsers.
  function spanAffectsWrapping() { return false; }
  if (gecko) // Only for "$'"
    spanAffectsWrapping = function(str, i) {
      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;
    };
  else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
    spanAffectsWrapping = function(str, i) {
      return /\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(str.slice(i - 1, i + 1));
    };
  else if (webkit && !/Chrome\/(?:29|[3-9]\d|\d\d\d)\./.test(navigator.userAgent))
    spanAffectsWrapping = function(str, i) {
      if (i > 1 && str.charCodeAt(i - 1) == 45) {
        if (/\w/.test(str.charAt(i - 2)) && /[^\-?\.]/.test(str.charAt(i))) return true;
        if (i > 2 && /[\d\.,]/.test(str.charAt(i - 2)) && /[\d\.,]/.test(str.charAt(i))) return false;
      }
      return /[~!#%&*)=+}\]|\"\.>,:;][({[<]|-[^\-?\.\u2010-\u201f\u2026]|\?[\w~`@#$%\^&*(_=+{[|><]|[\w~`@#$%\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));
    };

  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null) return knownScrollbarWidth;
    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
    }
    if (zwspSupported) return elt("span", "\u200b");
    else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};
  CodeMirror.splitLines = splitLines;

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == 'function';
  })();

  // KEY NAMING

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 91: "Mod", 92: "Mod", 93: "Mod", 109: "-", 107: "=", 127: "Delete",
                  186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63276: "PageUp", 63277: "PageDown", 63275: "End", 63273: "Home",
                  63234: "Left", 63232: "Up", 63235: "Right", 63233: "Down", 63302: "Insert", 63272: "Delete"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(cm.doc, line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line;
    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
      lineN = merged.find().to.line;
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN, ch);
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) { bidiOther = null; return i; }
      if (cur.from == pos || cur.to == pos) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          bidiOther = found;
          return i;
        } else {
          bidiOther = i;
          return found;
        }
      }
    }
    bidiOther = null;
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
    return pos;
  }

  // This is somewhat involved. It is needed in order to move
  // 'visually' through bi-directional text -- i.e., pressing left
  // should make the cursor go left, even when in RTL text. The
  // tricky part is the 'jumps', where RTL and LTR text touch each
  // other. This often requires the cursor offset to move more than
  // one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar.test(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";
    function charType(code) {
      if (code <= 0xff) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);
      else if (0x700 <= code && code <= 0x8ac) return "r";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len - 1 && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len - 1 ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push({from: start, to: i, level: 0});
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, {from: nstart, to: j, level: 2});
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift({from: 0, to: m[0].length, level: 0});
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push({from: len - m[0].length, to: len, level: 0});
      }
      if (order[0].level != lst(order).level)
        order.push({from: len, to: len, level: order[0].level});

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "3.14.1";

  return CodeMirror;
})();
// TODO actually recognize syntax of TypeScript constructs

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonMode = parserConfig.json;
  var isTS = parserConfig.typescript;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this")
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "class": kw("class"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        "super": kw("super"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function nextUntilUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end && !escaped)
        return false;
      escaped = !escaped && next == "\\";
    }
    return escaped;
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }

  function jsTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'")
      return chain(stream, state, jsTokenString(ch));
    else if (/[\[\]{}\(\),;\:\.]/.test(ch))
      return ret(ch);
    else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    }
    else if (/\d/.test(ch) || ch == "-" && stream.eat(/\d/)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    }
    else if (ch == "/") {
      if (stream.eat("*")) {
        return chain(stream, state, jsTokenComment);
      }
      else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      }
      else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               /^[\[{}\(,;:]$/.test(state.lastType)) {
        nextUntilUnescaped(stream, "/");
        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
        return ret("regexp", "string-2");
      }
      else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", null, stream.current());
      }
    }
    else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    }
    else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", null, stream.current());
    }
    else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function jsTokenString(quote) {
    return function(stream, state) {
      if (!nextUntilUnescaped(stream, quote))
        state.tokenize = jsTokenBase;
      return ret("string", "string");
    };
  }

  function jsTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = jsTokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    return function(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(arguments.callee);
    };
  }

  function statement(type) {
    if (type == "var") return cont(pushlex("vardef"), vardef1, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse);
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), expect("("), pushlex(")"), forspec1, expect(")"),
                                   poplex, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), commasep(expressionNoComma, "]"), poplex, maybeop);
    if (type == "{") return cont(pushlex("}"), commasep(objprop, "}"), poplex, maybeop);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, maybeoperatorComma);
  }
  function maybeoperatorNoComma(type, value, me) {
    if (!me) me = maybeoperatorNoComma;
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expression);
      return cont(expression);
    }
    if (type == ";") return;
    if (type == "(") return cont(pushlex(")", "call"), commasep(expressionNoComma, ")"), poplex, me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
    } else if (type == "number" || type == "string") {
      cx.marked = type + " property";
    }
    if (atomicTypes.hasOwnProperty(type)) return cont(expect(":"), expressionNoComma);
  }
  function getterSetter(type) {
    if (type == ":") return cont(expression);
    if (type != "variable") return cont(expect(":"), expression);
    cx.marked = "property";
    return cont(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      else return pass(what, proceed);
    };
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (type == ":") return cont(typedef);
    return pass();
  }
  function typedef(type) {
    if (type == "variable"){cx.marked = "variable-3"; return cont();}
    return pass();
  }
  function vardef1(type, value) {
    if (type == "variable") {
      register(value);
      return isTS ? cont(maybetype, vardef2) : cont(vardef2);
    }
    return pass();
  }
  function vardef2(type, value) {
    if (value == "=") return cont(expressionNoComma, vardef2);
    if (type == ",") return cont(vardef1);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form"), statement, poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef1, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybein);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybein(_type, value) {
    if (value == "in") return cont(expression);
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in") return cont(expression);
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushlex(")"), pushcontext, commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type, value) {
    if (type == "variable") {register(value); return isTS ? cont(maybetype) : cont();}
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: jsTokenBase,
        lastType: null,
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        globalVars: parserConfig.globalVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (state.tokenize != jsTokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == jsTokenComment) return CodeMirror.Pass;
      if (state.tokenize != jsTokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse || /^else\b/.test(textAfter)) break;
      }
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? 4 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: ":{}",
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",

    helperType: jsonMode ? "json" : "javascript",
    jsonMode: jsonMode
  };
});

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMode("css", function(config) {
  return CodeMirror.getMode(config, "text/css");
});

CodeMirror.defineMode("css-base", function(config, parserConfig) {
  "use strict";

  var indentUnit = config.indentUnit,
      hooks = parserConfig.hooks || {},
      atMediaTypes = parserConfig.atMediaTypes || {},
      atMediaFeatures = parserConfig.atMediaFeatures || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = !!parserConfig.allowNested,
      type = null;

  function ret(style, tp) { type = tp; return style; }

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      // result[0] is style and result[1] is type
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {stream.eatWhile(/[\w\\\-]/); return ret("def", stream.current());}
    else if (ch == "=") ret(null, "compare");
    else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    }
    else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    }
    else if (/\d/.test(ch)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    }
    else if (ch === "-") {
      if (/\d/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^[^-]+-/)) {
        return ret("meta", "meta");
      }
    }
    else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    }
    else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    }
    else if (ch == ":") {
      return ret("operator", ch);
    }
    else if (/[;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    }
    else if (ch == "u" && stream.match("rl(")) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "variable");
    }
    else {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "variable");
    }
  }

  function tokenString(quote, nonInclusive) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped)
          break;
        escaped = !escaped && ch == "\\";
      }
      if (!escaped) {
        if (nonInclusive) stream.backUp(1);
        state.tokenize = tokenBase;
      }
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\']/, false))
      state.tokenize = tokenString(")", true);
    else
      state.tokenize = tokenBase;
    return ret(null, "(");
  }

  return {
    startState: function(base) {
      return {tokenize: tokenBase,
              baseIndent: base || 0,
              stack: [],
              lastToken: null};
    },

    token: function(stream, state) {

      // Use these terms when applicable (see http://www.xanthir.com/blog/b4E50)
      //
      // rule** or **ruleset:
      // A selector + braces combo, or an at-rule.
      //
      // declaration block:
      // A sequence of declarations.
      //
      // declaration:
      // A property + colon + value combo.
      //
      // property value:
      // The entire value of a property.
      //
      // component value:
      // A single piece of a property value. Like the 5px in
      // text-shadow: 0 0 5px blue;. Can also refer to things that are
      // multiple terms, like the 1-4 terms that make up the background-size
      // portion of the background shorthand.
      //
      // term:
      // The basic unit of author-facing CSS, like a single number (5),
      // dimension (5px), string ("foo"), or function. Officially defined
      //  by the CSS 2.1 grammar (look for the 'term' production)
      //
      //
      // simple selector:
      // A single atomic selector, like a type selector, an attr selector, a
      // class selector, etc.
      //
      // compound selector:
      // One or more simple selectors without a combinator. div.example is
      // compound, div > .example is not.
      //
      // complex selector:
      // One or more compound selectors chained with combinators.
      //
      // combinator:
      // The parts of selectors that express relationships. There are four
      // currently - the space (descendant combinator), the greater-than
      // bracket (child combinator), the plus sign (next sibling combinator),
      // and the tilda (following sibling combinator).
      //
      // sequence of selectors:
      // One or more of the named type of selector chained with commas.

      state.tokenize = state.tokenize || tokenBase;
      if (state.tokenize == tokenBase && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (style && typeof style != "string") style = ret(style[0], style[1]);

      // Changing style returned based on context
      var context = state.stack[state.stack.length-1];
      if (style == "variable") {
        if (type == "variable-definition") state.stack.push("propertyValue");
        return state.lastToken = "variable-2";
      } else if (style == "property") {
        var word = stream.current().toLowerCase();
        if (context == "propertyValue") {
          if (valueKeywords.hasOwnProperty(word)) {
            style = "string-2";
          } else if (colorKeywords.hasOwnProperty(word)) {
            style = "keyword";
          } else {
            style = "variable-2";
          }
        } else if (context == "rule") {
          if (!propertyKeywords.hasOwnProperty(word)) {
            style += " error";
          }
        } else if (context == "block") {
          // if a value is present in both property, value, or color, the order
          // of preference is property -> color -> value
          if (propertyKeywords.hasOwnProperty(word)) {
            style = "property";
          } else if (colorKeywords.hasOwnProperty(word)) {
            style = "keyword";
          } else if (valueKeywords.hasOwnProperty(word)) {
            style = "string-2";
          } else {
            style = "tag";
          }
        } else if (!context || context == "@media{") {
          style = "tag";
        } else if (context == "@media") {
          if (atMediaTypes[stream.current()]) {
            style = "attribute"; // Known attribute
          } else if (/^(only|not)$/.test(word)) {
            style = "keyword";
          } else if (word == "and") {
            style = "error"; // "and" is only allowed in @mediaType
          } else if (atMediaFeatures.hasOwnProperty(word)) {
            style = "error"; // Known property, should be in @mediaType(
          } else {
            // Unknown, expecting keyword or attribute, assuming attribute
            style = "attribute error";
          }
        } else if (context == "@mediaType") {
          if (atMediaTypes.hasOwnProperty(word)) {
            style = "attribute";
          } else if (word == "and") {
            style = "operator";
          } else if (/^(only|not)$/.test(word)) {
            style = "error"; // Only allowed in @media
          } else {
            // Unknown attribute or property, but expecting property (preceded
            // by "and"). Should be in parentheses
            style = "error";
          }
        } else if (context == "@mediaType(") {
          if (propertyKeywords.hasOwnProperty(word)) {
            // do nothing, remains "property"
          } else if (atMediaTypes.hasOwnProperty(word)) {
            style = "error"; // Known property, should be in parentheses
          } else if (word == "and") {
            style = "operator";
          } else if (/^(only|not)$/.test(word)) {
            style = "error"; // Only allowed in @media
          } else {
            style += " error";
          }
        } else if (context == "@import") {
          style = "tag";
        } else {
          style = "error";
        }
      } else if (style == "atom") {
        if(!context || context == "@media{" || context == "block") {
          style = "builtin";
        } else if (context == "propertyValue") {
          if (!/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
            style += " error";
          }
        } else {
          style = "error";
        }
      } else if (context == "@media" && type == "{") {
        style = "error";
      }

      // Push/pop context stack
      if (type == "{") {
        if (context == "@media" || context == "@mediaType") {
          state.stack[state.stack.length-1] = "@media{";
        }
        else {
          var newContext = allowNested ? "block" : "rule";
          state.stack.push(newContext);
        }
      }
      else if (type == "}") {
        if (context == "interpolation") style = "operator";
        state.stack.pop();
        if (context == "propertyValue") state.stack.pop();
      }
      else if (type == "interpolation") state.stack.push("interpolation");
      else if (type == "@media") state.stack.push("@media");
      else if (type == "@import") state.stack.push("@import");
      else if (context == "@media" && /\b(keyword|attribute)\b/.test(style))
        state.stack[state.stack.length-1] = "@mediaType";
      else if (context == "@mediaType" && stream.current() == ",")
        state.stack[state.stack.length-1] = "@media";
      else if (type == "(") {
        if (context == "@media" || context == "@mediaType") {
          // Make sure @mediaType is used to avoid error on {
          state.stack[state.stack.length-1] = "@mediaType";
          state.stack.push("@mediaType(");
        }
      }
      else if (type == ")") {
        if (context == "propertyValue" && state.stack[state.stack.length-2] == "@mediaType(") {
          // In @mediaType( without closing ; after propertyValue
          state.stack.pop();
          state.stack.pop();
        }
        else if (context == "@mediaType(") {
          state.stack.pop();
        }
      }
      else if (type == ":" && state.lastToken == "property") state.stack.push("propertyValue");
      else if (context == "propertyValue" && type == ";") state.stack.pop();
      else if (context == "@import" && type == ";") state.stack.pop();

      return state.lastToken = style;
    },

    indent: function(state, textAfter) {
      var n = state.stack.length;
      if (/^\}/.test(textAfter))
        n -= state.stack[n-1] == "propertyValue" ? 2 : 1;
      return state.baseIndent + n * indentUnit;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    fold: "brace"
  };
});

(function() {
  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i]] = true;
    }
    return keys;
  }

  var atMediaTypes = keySet([
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ]);

  var atMediaFeatures = keySet([
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid"
  ]);

  var propertyKeywords = keySet([
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-iteration-count",
    "animation-name", "animation-play-state", "animation-timing-function",
    "appearance", "azimuth", "backface-visibility", "background",
    "background-attachment", "background-clip", "background-color",
    "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid-cell", "grid-column", "grid-column-align",
    "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow",
    "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span",
    "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marker-offset", "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
    "region-break-before", "region-break-inside", "region-fragment",
    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size",
    "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "word-break",
    "word-spacing", "word-wrap", "z-index", "zoom",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters", "color-profile",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"
  ]);

  var colorKeywords = keySet([
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",
    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ]);

  var valueKeywords = keySet([
    "above", "absolute", "activeborder", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "column", "compact", "condensed", "contain", "content",
    "content-box", "context-menu", "continuous", "copy", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari",
    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",
    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",
    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer",
    "landscape", "lao", "large", "larger", "left", "level", "lighter",
    "line-through", "linear", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "malayalam", "match",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer",
    "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",
    "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",
    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "single", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke",
    "sub", "subpixel-antialiased", "super", "sw-resize", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ]);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    atMediaTypes: atMediaTypes,
    atMediaFeatures: atMediaFeatures,
    propertyKeywords: propertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    hooks: {
      "<": function(stream, state) {
        function tokenSGMLComment(stream, state) {
          var dashes = 0, ch;
          while ((ch = stream.next()) != null) {
            if (dashes >= 2 && ch == ">") {
              state.tokenize = null;
              break;
            }
            dashes = (ch == "-") ? dashes + 1 : 0;
          }
          return ["comment", "comment"];
        }
        if (stream.eat("!")) {
          state.tokenize = tokenSGMLComment;
          return tokenSGMLComment(stream, state);
        }
      },
      "/": function(stream, state) {
        if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        }
        return false;
      }
    },
    name: "css-base"
  });

  CodeMirror.defineMIME("text/x-scss", {
    atMediaTypes: atMediaTypes,
    atMediaFeatures: atMediaFeatures,
    propertyKeywords: propertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    allowNested: true,
    hooks: {
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.peek() == ":") {
          return ["variable", "variable-definition"];
        }
        return ["variable", "variable"];
      },
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "#": function(stream) {
        if (stream.eat("{")) {
          return ["operator", "interpolation"];
        } else {
          stream.eatWhile(/[\w\\\-]/);
          return ["atom", "hash"];
        }
      }
    },
    name: "css-base"
  });
})();
// Because sometimes you need to style the cursor's line.
//
// Adds an option 'styleActiveLine' which, when enabled, gives the
// active line's wrapping <div> the CSS class "CodeMirror-activeline",
// and gives its background <div> the class "CodeMirror-activeline-background".

(function() {
  "use strict";
  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";

  CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {
    var prev = old && old != CodeMirror.Init;
    if (val && !prev) {
      updateActiveLine(cm);
      cm.on("cursorActivity", updateActiveLine);
    } else if (!val && prev) {
      cm.off("cursorActivity", updateActiveLine);
      clearActiveLine(cm);
      delete cm.state.activeLine;
    }
  });

  function clearActiveLine(cm) {
    if ("activeLine" in cm.state) {
      cm.removeLineClass(cm.state.activeLine, "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLine, "background", BACK_CLASS);
    }
  }

  function updateActiveLine(cm) {
    var line = cm.getLineHandleVisualStart(cm.getCursor().line);
    if (cm.state.activeLine == line) return;
    clearActiveLine(cm);
    cm.addLineClass(line, "wrap", WRAP_CLASS);
    cm.addLineClass(line, "background", BACK_CLASS);
    cm.state.activeLine = line;
  }
})();
(function() {
  "use strict";

  CodeMirror.showHint = function(cm, getHints, options) {
    // We want a single cursor position.
    if (cm.somethingSelected()) return;
    if (getHints == null) getHints = cm.getHelper(cm.getCursor(), "hint");
    if (getHints == null) return;

    var completion = cm.state.completionActive;

    var filtering = false;
    
    if(completion && completion.widget)
    {
      var data = getHints(cm, options);
      if(data.prefix !== completion.widget.data.prefix)
      {
        completion.close();
      }
      else 
      {
        filtering = true;
        completion.widget.data = data;
        if(!completion.widget.applyFilter())
        {
          completion.widget.close();
        }
      }
    }

    if(!filtering) {
      completion = cm.state.completionActive = new Completion(cm, getHints, options || {});              
      CodeMirror.signal(cm, "startCompletion", cm);
      if (completion.options.async)
        getHints(cm, function(hints) { completion.showHints(hints); }, completion.options);
      else
        return completion.showHints(getHints(cm, completion.options));
    }
  };

  function Completion(cm, getHints, options) {
    this.cm = cm;
    this.getHints = getHints;
    this.options = options;
    this.widget = this.onClose = null;
  }

  Completion.prototype = {
    close: function() {
      if (!this.active()) return;

      if (this.widget) this.widget.close();
      if (this.onClose) this.onClose();
      this.cm.state.completionActive = null;
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function() {
      return this.cm.state.completionActive == this;
    },

    pick: function(data, i, ch) {      
      //get the current prefix, we need to check the cursor postion before we replace

      var completion = data.list[i];
      
      var currentPrefixInfo = this.options.retoolCodeEditorInstance.getPrefixInfo(this.cm, this.options);

      if(currentPrefixInfo) {

        var text = getText(completion);

        if(ch)
        {
          text += ch;
        }

        //if the prefix still matches and we are still on the same line
        // make sure the text we are text we are going to replace still matches the current filter 
        var filter = currentPrefixInfo.filter ? currentPrefixInfo.filter.toLowerCase() : "";
        var compareText = text.toLowerCase();
        if(data.from.line == currentPrefixInfo.from.line && data.prefix == currentPrefixInfo.prefix && (!filter || compareText.indexOf(filter) == 0)) {

          if (completion.hint) {
              completion.hint(this.cm, data, completion);
          }
          else {
              //use the latest from/to to do the text replacement.
              this.cm.replaceRange(text, currentPrefixInfo.from, currentPrefixInfo.to);
              this.close();
          }
        }
        else
        {
          // because closing characters can change the prefix, this condition will happen
          // append the character we are replacing at the end of the range we detected.
          // notice that we don't close the autosuggestions in this instance because we need
          // to keep suggesting with the new prefix.
          if(ch)
          {
            this.cm.replaceRange(ch, currentPrefixInfo.to, currentPrefixInfo.to);
          }
          //console.log('cursor information on replacement is old, we have to close the completion');
        }
      }
      else
      {
        //console.log('unable to perform autosuggestion replace, no current prefix found');
      }
    },

    showHints: function(data) {
      if (!data || !data.list.length || !this.active()) return this.close();
      this.showWidget(data);
    },

    showWidget: function(data) {
      this.widget = new Widget(this, data);
      CodeMirror.signal(data, "shown");

      var debounce = null, completion = this, finished;
      var closeOn = this.options.closeCharacters;
      var startPos = this.cm.getCursor(), startLen = this.cm.getLine(startPos.line).length;

      function done() {
        if (finished) return;
        finished = true;
        completion.close();
        completion.cm.off("cursorActivity", activity);
        CodeMirror.signal(data, "close");
      }
      function isDone() {
        if (finished) return true;
        if (!completion.widget) { done(); return true; }
      }

      function update() {
        if (isDone()) return;
        if (completion.options.async)
          completion.getHints(completion.cm, finishUpdate, completion.options);
        else
          finishUpdate(completion.getHints(completion.cm, completion.options));
      }
      function finishUpdate(data) {
        if (isDone()) return;
        if (!data || !data.list.length) return done();
        if(data.prefix != completion.widget.data.prefix)
        {
          completion.widget.close();
          completion.widget = new Widget(completion, data);
        }
        else
        {
          completion.widget.data = data;
          if(!completion.widget.applyFilter())
          {
            completion.widget.close();
          }
        }
      }

      function activity() {
        clearTimeout(debounce);     
        var pos = completion.cm.getCursor();
        var line = completion.cm.getLine(pos.line);
        var ch = line.charAt(pos.ch - 1);                  
        if(pos.ch && closeOn &&closeOn.test(ch)) {
            completion.close();
        } else {
          debounce = setTimeout(update, 170);
        }
      }
      this.cm.on("cursorActivity", activity);
      this.onClose = done;
    }
  };

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(options, handle) {
    var baseMap = {
      Up: function() {handle.moveFocus(-1);},
      Down: function() {handle.moveFocus(1);},
      PageUp: function() {handle.moveFocus(-handle.menuSize());},
      PageDown: function() {handle.moveFocus(handle.menuSize());},
      Home: function() {handle.setFocus(0);},
      End: function() {handle.setFocus(handle.length);},
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };

    if(options.retoolCodeEditorInstance.mode == "javascript")
    {
      baseMap["Shift-9"] = function() { handle.pickWithChar('('); }
      // baseMap["."] = function() { handle.pickWithChar('.'); }
      // baseMap["Space"] = function() { handle.pickWithChar(' '); }
    }
    if(options.retoolCodeEditorInstance.mode == "console")
    {
      baseMap["Space"] = function() { handle.pickWithChar(' '); }
      baseMap["Enter"] = function() { handle.pick(); return CodeMirror.Pass }
    }

    var ourMap = options.customKeys ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (options.customKeys)
      for (var key in options.customKeys) if (options.customKeys.hasOwnProperty(key))
        addBinding(key, options.customKeys[key]);
    if (options.extraKeys)
      for (var key in options.extraKeys) if (options.extraKeys.hasOwnProperty(key))
        addBinding(key, options.extraKeys[key]);
    return ourMap;
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    var widget = this, cm = completion.cm, options = completion.options;

    var hints = this.hints = document.createElement("ul");

    hints.className = "CodeMirror-hints";
    this.selectedHint = 0;

    var completions = data.list;

    this.filterIds = {}; 
    this.numResults = completions.length;

    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement("li")), cur = completions[i];
      var className = i ? "" : " current";
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);
      else {
        if (cur.icon){
          var iconSpan = document.createElement("span");
          iconSpan.className = "rto-glyph rto-toolbox rto-color" + cur.icon.color;
          iconSpan.appendChild(document.createTextNode(cur.icon.glyph));
          elt.appendChild(iconSpan);
        }
        elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
        if (cur.parameters){
          var span = document.createElement("span");
          span.className  = "rto-param";
          span.appendChild(document.createTextNode(cur.parameters));
          elt.appendChild(span);
        }
      }
      elt.hintId = i;
      this.filterIds[i] = i;      
    }

    var container = options.container;

    var containerBox = (container || document.body).getBoundingClientRect();

    var pos = cm.cursorCoords(options.alignWithWord !== false ? data.from : null);

    var left = pos.left - containerBox.left; 
    var top = pos.bottom - containerBox.top;
  

    var hintsContainer = document.createElement('div');
    hintsContainer.style.left = left + "px";
    hintsContainer.style.top = top + "px";

    hintsContainer.setAttribute('id', 'rto-code-complete');

    hintsContainer.appendChild(hints);
    
    (container || document.body).appendChild(hintsContainer);

    // die if we have no results
    if(!this.applyFilter())
    {
      this.close();
      return;
    }

    cm.addKeyMap(this.keyMap = buildKeyMap(options, {
      moveFocus: function(n) { 
        //widget.changeActive(widget.selectedHint + n); 
        if(widget.numResults == 0) return;
        var step = n < 0 ? -1: 1;
        var selectedHint = widget.selectedHint;
        var stepsNeeded = n;
        var stepsTaken = 0;
        var node;
        // find selected hint;
        var i = 0;
        var index = 0;
        for (var key in widget.filterIds){
          if (widget.filterIds[key] == selectedHint){
            i = index;
            break;
          }
          index++;
        }
        
        while(stepsTaken != stepsNeeded)
        {          
          i += step;
          if(i < 0) {
            i = 0;
          }
          else
          {
            if(i > widget.numResults - 1)
            {
              i = widget.numResults - 1
            }
          }
          node = widget.hints.childNodes[widget.filterIds[i]];
          if(!(/(?:^|\s)filtered(?!\S)/g.test(node.className)))
          {
            stepsTaken += step;
          }
        }
        widget.changeActive(widget.filterIds[i]);        
      },
      setFocus: function(n) { widget.changeActive(n); },
      menuSize: function() { return widget.screenAmount(); },
      length: completions.length,
      close: function() { completion.close(); },
      pick: function() { widget.pick(); },
      pickWithChar: function(ch) { widget.pick(ch); }
    }));

    if (options.closeOnUnfocus !== false) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
    }

    var startScroll = cm.getScrollInfo();
    cm.on("scroll", this.onScroll = function() {
      widget.setPosition();
    });

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = e.target || e.srcElement;
      if (t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
    });
    CodeMirror.on(hints, "click", function(e) {
      var t = e.target || e.srcElement;
      if (t.hintId != null) widget.changeActive(t.hintId);
    });
    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function(){cm.focus();}, 20);
    });

    CodeMirror.signal(data, "select", completions[0], hints.firstChild);
    return true;
  }

  Widget.prototype = {
    close: function() {
      this.completion.widget = null;
      var hintContainer = this.hints.parentNode;
      if(hintContainer && hintContainer.parentNode)
      {
        hintContainer.parentNode.removeChild(hintContainer);
      }
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus !== false) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    pick: function(char) {
      this.completion.pick(this.data, this.selectedHint, char);
    },

    changeActive: function(i) {
      if(this.numResults == 0) return;
      i = Math.max(this.filterIds[0], Math.min(i, this.filterIds[this.numResults - 1]));      
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      node.className = node.className.replace(" current", "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " current";
      var container = this.hints.parentNode;
      if (node.offsetTop < container.scrollTop)
        container.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > container.scrollTop + container.clientHeight)
        container.scrollTop = node.offsetTop + node.offsetHeight - container.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    },

    applyFilter: function() {
      var nodes = this.hints.childNodes;
      var index = 0;
      this.filterIds = {};
      this.numResults = 0;
      var filter = this.data.filter.toLowerCase();
      for(var i = 0; i < nodes.length; i++)
      {        
        var node = this.hints.childNodes[i];
        var text = this.data.list[i].text.toLowerCase();
        if(!filter || text.indexOf(filter) == 0)
        {
          node.className = node.className.replace( /(?:^|\s)filtered(?!\S)/g , '' );
          this.filterIds[index] = i;
          index++;
          this.numResults++;
        }
        else
        {
          if(!(/(?:^|\s)filtered(?!\S)/g.test(node.className)))
          {
            node.className += ' filtered';
          }
        }
      }
      if(this.numResults)
      {
        this.changeActive(this.filterIds[0]);
        this.setPosition();
        this.completion.options.retoolCodeEditorInstance.hideLintErrorDisplay();
        return true;
      }
    },

    setPosition: function() {
      var cm = this.completion.cm;
      var options = this.completion.options;
      var data = this.data;
      var hintsContainer = this.hints.parentNode;

      var pos = cm.cursorCoords(data.from,"window");

      var container = options.container;

      var containerBox = (container || document.body).getBoundingClientRect();

      var box = hintsContainer.getBoundingClientRect();


      if(pos.top < containerBox.top)
      {
        this.completion.close();
        return;
      }      

      var top = pos.bottom - containerBox.top;
      var left = pos.left - containerBox.left;

      if(pos.bottom + box.height > containerBox.bottom)
      {
        top = pos.top - containerBox.top - box.height;
      }

      if(box.right > containerBox.right)
      {
        left = pos.left - containerBox.left - box.width;
      }        

      hintsContainer.style.top = top + "px";  
      hintsContainer.style.left = left + "px";
    }   
  };
})();
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// Utility function that allows modes to be combined. The mode given
// as the base argument takes care of most of the normal mode
// functionality, but a second (typically simple) mode is used, which
// can override the style of text. Both modes get to parse all of the
// text, but when both assign a non-null style to a piece of code, the
// overlay wins, unless the combine argument was true and not overridden,
// or state.overlay.combineTokens was true, in which case the styles are
// combined.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.overlayMode = function(base, overlay, combine) {
  return {
    startState: function() {
      return {
        base: CodeMirror.startState(base),
        overlay: CodeMirror.startState(overlay),
        basePos: 0, baseCur: null,
        overlayPos: 0, overlayCur: null,
        streamSeen: null
      };
    },
    copyState: function(state) {
      return {
        base: CodeMirror.copyState(base, state.base),
        overlay: CodeMirror.copyState(overlay, state.overlay),
        basePos: state.basePos, baseCur: null,
        overlayPos: state.overlayPos, overlayCur: null
      };
    },

    token: function(stream, state) {
      if (stream != state.streamSeen ||
          Math.min(state.basePos, state.overlayPos) < stream.start) {
        state.streamSeen = stream;
        state.basePos = state.overlayPos = stream.start;
      }

      if (stream.start == state.basePos) {
        state.baseCur = base.token(stream, state.base);
        state.basePos = stream.pos;
      }
      if (stream.start == state.overlayPos) {
        stream.pos = stream.start;
        state.overlayCur = overlay.token(stream, state.overlay);
        state.overlayPos = stream.pos;
      }
      stream.pos = Math.min(state.basePos, state.overlayPos);

      // state.overlay.combineTokens always takes precedence over combine,
      // unless set to null
      if (state.overlayCur == null) return state.baseCur;
      else if (state.baseCur != null &&
               state.overlay.combineTokens ||
               combine && state.overlay.combineTokens == null)
        return state.baseCur + " " + state.overlayCur;
      else return state.overlayCur;
    },

    indent: base.indent && function(state, textAfter) {
      return base.indent(state.base, textAfter);
    },
    electricChars: base.electricChars,

    innerMode: function(state) { return {state: state.base, mode: base}; },

    blankLine: function(state) {
      if (base.blankLine) base.blankLine(state.base);
      if (overlay.blankLine) overlay.blankLine(state.overlay);
    }
  };
};

});// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../meta"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {

  var htmlFound = CodeMirror.modes.hasOwnProperty("xml");
  var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {name: "xml", htmlMode: true} : "text/plain");

  function getMode(name) {
    if (CodeMirror.findModeByName) {
      var found = CodeMirror.findModeByName(name);
      if (found) name = found.mime || found.mimes[0];
    }
    var mode = CodeMirror.getMode(cmCfg, name);
    return mode.name == "null" ? null : mode;
  }

  // Should characters that affect highlighting be highlighted separate?
  // Does not include characters that will be output (such as `1.` and `-` for lists)
  if (modeCfg.highlightFormatting === undefined)
    modeCfg.highlightFormatting = false;

  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
  // Excess `>` will emit `error` token.
  if (modeCfg.maxBlockquoteDepth === undefined)
    modeCfg.maxBlockquoteDepth = 0;

  // Should underscores in words open/close em/strong?
  if (modeCfg.underscoresBreakWords === undefined)
    modeCfg.underscoresBreakWords = true;

  // Turn on fenced code blocks? ("```" to start/end)
  if (modeCfg.fencedCodeBlocks === undefined) modeCfg.fencedCodeBlocks = false;

  // Turn on task lists? ("- [ ] " and "- [x] ")
  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

  // Turn on strikethrough syntax
  if (modeCfg.strikethrough === undefined)
    modeCfg.strikethrough = false;

  var codeDepth = 0;

  var header   = 'header'
  ,   code     = 'comment'
  ,   quote    = 'quote'
  ,   list1    = 'variable-2'
  ,   list2    = 'variable-3'
  ,   list3    = 'keyword'
  ,   hr       = 'hr'
  ,   image    = 'tag'
  ,   formatting = 'formatting'
  ,   linkinline = 'link'
  ,   linkemail = 'link'
  ,   linktext = 'link'
  ,   linkhref = 'string'
  ,   em       = 'em'
  ,   strong   = 'strong'
  ,   strikethrough = 'strikethrough';

  var hrRE = /^([*\-=_])(?:\s*\1){2,}\s*$/
  ,   ulRE = /^[*\-+]\s+/
  ,   olRE = /^[0-9]+\.\s+/
  ,   taskListRE = /^\[(x| )\](?=\s)/ // Must follow ulRE or olRE
  ,   atxHeaderRE = /^#+/
  ,   setextHeaderRE = /^(?:\={1,}|-{1,})$/
  ,   textRE = /^[^#!\[\]*_\\<>` "'(~]+/;

  function switchInline(stream, state, f) {
    state.f = state.inline = f;
    return f(stream, state);
  }

  function switchBlock(stream, state, f) {
    state.f = state.block = f;
    return f(stream, state);
  }


  // Blocks

  function blankLine(state) {
    // Reset linkTitle state
    state.linkTitle = false;
    // Reset EM state
    state.em = false;
    // Reset STRONG state
    state.strong = false;
    // Reset strikethrough state
    state.strikethrough = false;
    // Reset state.quote
    state.quote = 0;
    if (!htmlFound && state.f == htmlBlock) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    // Reset state.trailingSpace
    state.trailingSpace = 0;
    state.trailingSpaceNewLine = false;
    // Mark this line as blank
    state.thisLineHasContent = false;
    return null;
  }

  function blockNormal(stream, state) {

    var sol = stream.sol();

    var prevLineIsList = (state.list !== false);
    if (state.list !== false && state.indentationDiff >= 0) { // Continued list
      if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block
        state.indentation -= state.indentationDiff;
      }
      state.list = null;
    } else if (state.list !== false && state.indentation > 0) {
      state.list = null;
      state.listDepth = Math.floor(state.indentation / 4);
    } else if (state.list !== false) { // No longer a list
      state.list = false;
      state.listDepth = 0;
    }

    var match = null;
    if (state.indentationDiff >= 4) {
      state.indentation -= 4;
      stream.skipToEnd();
      return code;
    } else if (stream.eatSpace()) {
      return null;
    } else if (match = stream.match(atxHeaderRE)) {
      state.header = match[0].length <= 6 ? match[0].length : 6;
      if (modeCfg.highlightFormatting) state.formatting = "header";
      state.f = state.inline;
      return getType(state);
    } else if (state.prevLineHasContent && (match = stream.match(setextHeaderRE))) {
      state.header = match[0].charAt(0) == '=' ? 1 : 2;
      if (modeCfg.highlightFormatting) state.formatting = "header";
      state.f = state.inline;
      return getType(state);
    } else if (stream.eat('>')) {
      state.indentation++;
      state.quote = sol ? 1 : state.quote + 1;
      if (modeCfg.highlightFormatting) state.formatting = "quote";
      stream.eatSpace();
      return getType(state);
    } else if (stream.peek() === '[') {
      return switchInline(stream, state, footnoteLink);
    } else if (stream.match(hrRE, true)) {
      return hr;
    } else if ((!state.prevLineHasContent || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {
      var listType = null;
      if (stream.match(ulRE, true)) {
        listType = 'ul';
      } else {
        stream.match(olRE, true);
        listType = 'ol';
      }
      state.indentation += 4;
      state.list = true;
      state.listDepth++;
      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
        state.taskList = true;
      }
      state.f = state.inline;
      if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
      return getType(state);
    } else if (modeCfg.fencedCodeBlocks && stream.match(/^```[ \t]*([\w+#]*)/, true)) {
      // try switching mode
      state.localMode = getMode(RegExp.$1);
      if (state.localMode) state.localState = state.localMode.startState();
      state.f = state.block = local;
      if (modeCfg.highlightFormatting) state.formatting = "code-block";
      state.code = true;
      return getType(state);
    }

    return switchInline(stream, state, state.inline);
  }

  function htmlBlock(stream, state) {
    var style = htmlMode.token(stream, state.htmlState);
    if ((htmlFound && state.htmlState.tagStart === null && !state.htmlState.context) ||
        (state.md_inside && stream.current().indexOf(">") > -1)) {
      state.f = inlineNormal;
      state.block = blockNormal;
      state.htmlState = null;
    }
    return style;
  }

  function local(stream, state) {
    if (stream.sol() && stream.match("```", false)) {
      state.localMode = state.localState = null;
      state.f = state.block = leavingLocal;
      return null;
    } else if (state.localMode) {
      return state.localMode.token(stream, state.localState);
    } else {
      stream.skipToEnd();
      return code;
    }
  }

  function leavingLocal(stream, state) {
    stream.match("```");
    state.block = blockNormal;
    state.f = inlineNormal;
    if (modeCfg.highlightFormatting) state.formatting = "code-block";
    state.code = true;
    var returnType = getType(state);
    state.code = false;
    return returnType;
  }

  // Inline
  function getType(state) {
    var styles = [];

    if (state.formatting) {
      styles.push(formatting);

      if (typeof state.formatting === "string") state.formatting = [state.formatting];

      for (var i = 0; i < state.formatting.length; i++) {
        styles.push(formatting + "-" + state.formatting[i]);

        if (state.formatting[i] === "header") {
          styles.push(formatting + "-" + state.formatting[i] + "-" + state.header);
        }

        // Add `formatting-quote` and `formatting-quote-#` for blockquotes
        // Add `error` instead if the maximum blockquote nesting depth is passed
        if (state.formatting[i] === "quote") {
          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
            styles.push(formatting + "-" + state.formatting[i] + "-" + state.quote);
          } else {
            styles.push("error");
          }
        }
      }
    }

    if (state.taskOpen) {
      styles.push("meta");
      return styles.length ? styles.join(' ') : null;
    }
    if (state.taskClosed) {
      styles.push("property");
      return styles.length ? styles.join(' ') : null;
    }

    if (state.linkHref) {
      styles.push(linkhref);
      return styles.length ? styles.join(' ') : null;
    }

    if (state.strong) { styles.push(strong); }
    if (state.em) { styles.push(em); }
    if (state.strikethrough) { styles.push(strikethrough); }

    if (state.linkText) { styles.push(linktext); }

    if (state.code) { styles.push(code); }

    if (state.header) { styles.push(header); styles.push(header + "-" + state.header); }

    if (state.quote) {
      styles.push(quote);

      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
        styles.push(quote + "-" + state.quote);
      } else {
        styles.push(quote + "-" + modeCfg.maxBlockquoteDepth);
      }
    }

    if (state.list !== false) {
      var listMod = (state.listDepth - 1) % 3;
      if (!listMod) {
        styles.push(list1);
      } else if (listMod === 1) {
        styles.push(list2);
      } else {
        styles.push(list3);
      }
    }

    if (state.trailingSpaceNewLine) {
      styles.push("trailing-space-new-line");
    } else if (state.trailingSpace) {
      styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
    }

    return styles.length ? styles.join(' ') : null;
  }

  function handleText(stream, state) {
    if (stream.match(textRE, true)) {
      return getType(state);
    }
    return undefined;
  }

  function inlineNormal(stream, state) {
    var style = state.text(stream, state);
    if (typeof style !== 'undefined')
      return style;

    if (state.list) { // List marker (*, +, -, 1., etc)
      state.list = null;
      return getType(state);
    }

    if (state.taskList) {
      var taskOpen = stream.match(taskListRE, true)[1] !== "x";
      if (taskOpen) state.taskOpen = true;
      else state.taskClosed = true;
      if (modeCfg.highlightFormatting) state.formatting = "task";
      state.taskList = false;
      return getType(state);
    }

    state.taskOpen = false;
    state.taskClosed = false;

    if (state.header && stream.match(/^#+$/, true)) {
      if (modeCfg.highlightFormatting) state.formatting = "header";
      return getType(state);
    }

    // Get sol() value now, before character is consumed
    var sol = stream.sol();

    var ch = stream.next();

    if (ch === '\\') {
      stream.next();
      if (modeCfg.highlightFormatting) {
        var type = getType(state);
        return type ? type + " formatting-escape" : "formatting-escape";
      }
    }

    // Matches link titles present on next line
    if (state.linkTitle) {
      state.linkTitle = false;
      var matchCh = ch;
      if (ch === '(') {
        matchCh = ')';
      }
      matchCh = (matchCh+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
      if (stream.match(new RegExp(regex), true)) {
        return linkhref;
      }
    }

    // If this block is changed, it may need to be updated in GFM mode
    if (ch === '`') {
      var previousFormatting = state.formatting;
      if (modeCfg.highlightFormatting) state.formatting = "code";
      var t = getType(state);
      var before = stream.pos;
      stream.eatWhile('`');
      var difference = 1 + stream.pos - before;
      if (!state.code) {
        codeDepth = difference;
        state.code = true;
        return getType(state);
      } else {
        if (difference === codeDepth) { // Must be exact
          state.code = false;
          return t;
        }
        state.formatting = previousFormatting;
        return getType(state);
      }
    } else if (state.code) {
      return getType(state);
    }

    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
      stream.match(/\[[^\]]*\]/);
      state.inline = state.f = linkHref;
      return image;
    }

    if (ch === '[' && stream.match(/.*\](\(.*\)| ?\[.*\])/, false)) {
      state.linkText = true;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      return getType(state);
    }

    if (ch === ']' && state.linkText && stream.match(/\(.*\)| ?\[.*\]/, false)) {
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      state.linkText = false;
      state.inline = state.f = linkHref;
      return type;
    }

    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + linkinline;
    }

    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + linkemail;
    }

    if (ch === '<' && stream.match(/^\w/, false)) {
      if (stream.string.indexOf(">") != -1) {
        var atts = stream.string.substring(1,stream.string.indexOf(">"));
        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) {
          state.md_inside = true;
        }
      }
      stream.backUp(1);
      state.htmlState = CodeMirror.startState(htmlMode);
      return switchBlock(stream, state, htmlBlock);
    }

    if (ch === '<' && stream.match(/^\/\w*?>/)) {
      state.md_inside = false;
      return "tag";
    }

    var ignoreUnderscore = false;
    if (!modeCfg.underscoresBreakWords) {
      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
        var prevPos = stream.pos - 2;
        if (prevPos >= 0) {
          var prevCh = stream.string.charAt(prevPos);
          if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
            ignoreUnderscore = true;
          }
        }
      }
    }
    if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {
      if (sol && stream.peek() === ' ') {
        // Do nothing, surrounded by newline and space
      } else if (state.strong === ch && stream.eat(ch)) { // Remove STRONG
        if (modeCfg.highlightFormatting) state.formatting = "strong";
        var t = getType(state);
        state.strong = false;
        return t;
      } else if (!state.strong && stream.eat(ch)) { // Add STRONG
        state.strong = ch;
        if (modeCfg.highlightFormatting) state.formatting = "strong";
        return getType(state);
      } else if (state.em === ch) { // Remove EM
        if (modeCfg.highlightFormatting) state.formatting = "em";
        var t = getType(state);
        state.em = false;
        return t;
      } else if (!state.em) { // Add EM
        state.em = ch;
        if (modeCfg.highlightFormatting) state.formatting = "em";
        return getType(state);
      }
    } else if (ch === ' ') {
      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
        if (stream.peek() === ' ') { // Surrounded by spaces, ignore
          return getType(state);
        } else { // Not surrounded by spaces, back up pointer
          stream.backUp(1);
        }
      }
    }

    if (modeCfg.strikethrough) {
      if (ch === '~' && stream.eatWhile(ch)) {
        if (state.strikethrough) {// Remove strikethrough
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
          var t = getType(state);
          state.strikethrough = false;
          return t;
        } else if (stream.match(/^[^\s]/, false)) {// Add strikethrough
          state.strikethrough = true;
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
          return getType(state);
        }
      } else if (ch === ' ') {
        if (stream.match(/^~~/, true)) { // Probably surrounded by space
          if (stream.peek() === ' ') { // Surrounded by spaces, ignore
            return getType(state);
          } else { // Not surrounded by spaces, back up pointer
            stream.backUp(2);
          }
        }
      }
    }

    if (ch === ' ') {
      if (stream.match(/ +$/, false)) {
        state.trailingSpace++;
      } else if (state.trailingSpace) {
        state.trailingSpaceNewLine = true;
      }
    }

    return getType(state);
  }

  function linkInline(stream, state) {
    var ch = stream.next();

    if (ch === ">") {
      state.f = state.inline = inlineNormal;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + linkinline;
    }

    stream.match(/^[^>]+/, true);

    return linkinline;
  }

  function linkHref(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    var ch = stream.next();
    if (ch === '(' || ch === '[') {
      state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
      if (modeCfg.highlightFormatting) state.formatting = "link-string";
      state.linkHref = true;
      return getType(state);
    }
    return 'error';
  }

  function getLinkHrefInside(endChar) {
    return function(stream, state) {
      var ch = stream.next();

      if (ch === endChar) {
        state.f = state.inline = inlineNormal;
        if (modeCfg.highlightFormatting) state.formatting = "link-string";
        var returnState = getType(state);
        state.linkHref = false;
        return returnState;
      }

      if (stream.match(inlineRE(endChar), true)) {
        stream.backUp(1);
      }

      state.linkHref = true;
      return getType(state);
    };
  }

  function footnoteLink(stream, state) {
    if (stream.match(/^[^\]]*\]:/, false)) {
      state.f = footnoteLinkInside;
      stream.next(); // Consume [
      if (modeCfg.highlightFormatting) state.formatting = "link";
      state.linkText = true;
      return getType(state);
    }
    return switchInline(stream, state, inlineNormal);
  }

  function footnoteLinkInside(stream, state) {
    if (stream.match(/^\]:/, true)) {
      state.f = state.inline = footnoteUrl;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var returnType = getType(state);
      state.linkText = false;
      return returnType;
    }

    stream.match(/^[^\]]+/, true);

    return linktext;
  }

  function footnoteUrl(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    // Match URL
    stream.match(/^[^\s]+/, true);
    // Check for link title
    if (stream.peek() === undefined) { // End of line, set flag to check next line
      state.linkTitle = true;
    } else { // More content on line, check if link title
      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
    }
    state.f = state.inline = inlineNormal;
    return linkhref;
  }

  var savedInlineRE = [];
  function inlineRE(endChar) {
    if (!savedInlineRE[endChar]) {
      // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)
      endChar = (endChar+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      // Match any non-endChar, escaped character, as well as the closing
      // endChar.
      savedInlineRE[endChar] = new RegExp('^(?:[^\\\\]|\\\\.)*?(' + endChar + ')');
    }
    return savedInlineRE[endChar];
  }

  var mode = {
    startState: function() {
      return {
        f: blockNormal,

        prevLineHasContent: false,
        thisLineHasContent: false,

        block: blockNormal,
        htmlState: null,
        indentation: 0,

        inline: inlineNormal,
        text: handleText,

        formatting: false,
        linkText: false,
        linkHref: false,
        linkTitle: false,
        em: false,
        strong: false,
        header: 0,
        taskList: false,
        list: false,
        listDepth: 0,
        quote: 0,
        trailingSpace: 0,
        trailingSpaceNewLine: false,
        strikethrough: false
      };
    },

    copyState: function(s) {
      return {
        f: s.f,

        prevLineHasContent: s.prevLineHasContent,
        thisLineHasContent: s.thisLineHasContent,

        block: s.block,
        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
        indentation: s.indentation,

        localMode: s.localMode,
        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

        inline: s.inline,
        text: s.text,
        formatting: false,
        linkTitle: s.linkTitle,
        em: s.em,
        strong: s.strong,
        strikethrough: s.strikethrough,
        header: s.header,
        taskList: s.taskList,
        list: s.list,
        listDepth: s.listDepth,
        quote: s.quote,
        trailingSpace: s.trailingSpace,
        trailingSpaceNewLine: s.trailingSpaceNewLine,
        md_inside: s.md_inside
      };
    },

    token: function(stream, state) {

      // Reset state.formatting
      state.formatting = false;

      if (stream.sol()) {
        var forceBlankLine = !!state.header;

        // Reset state.header
        state.header = 0;

        if (stream.match(/^\s*$/, true) || forceBlankLine) {
          state.prevLineHasContent = false;
          blankLine(state);
          return forceBlankLine ? this.token(stream, state) : null;
        } else {
          state.prevLineHasContent = state.thisLineHasContent;
          state.thisLineHasContent = true;
        }

        // Reset state.taskList
        state.taskList = false;

        // Reset state.code
        state.code = false;

        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;

        state.f = state.block;
        var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length;
        var difference = Math.floor((indentation - state.indentation) / 4) * 4;
        if (difference > 4) difference = 4;
        var adjustedIndentation = state.indentation + difference;
        state.indentationDiff = adjustedIndentation - state.indentation;
        state.indentation = adjustedIndentation;
        if (indentation > 0) return null;
      }
      return state.f(stream, state);
    },

    innerMode: function(state) {
      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
      if (state.localState) return {state: state.localState, mode: state.localMode};
      return {state: state, mode: mode};
    },

    blankLine: blankLine,

    getType: getType,

    fold: "markdown"
  };
  return mode;
}, "xml");

CodeMirror.defineMIME("text/x-markdown", "markdown");

});// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../markdown/markdown"), require("../../addon/mode/overlay"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("gfm", function(config, modeConfig) {
  var codeDepth = 0;
  function blankLine(state) {
    state.code = false;
    return null;
  }
  var gfmOverlay = {
    startState: function() {
      return {
        code: false,
        codeBlock: false,
        ateSpace: false
      };
    },
    copyState: function(s) {
      return {
        code: s.code,
        codeBlock: s.codeBlock,
        ateSpace: s.ateSpace
      };
    },
    token: function(stream, state) {
      state.combineTokens = null;

      // Hack to prevent formatting override inside code blocks (block and inline)
      if (state.codeBlock) {
        if (stream.match(/^```/)) {
          state.codeBlock = false;
          return null;
        }
        stream.skipToEnd();
        return null;
      }
      if (stream.sol()) {
        state.code = false;
      }
      if (stream.sol() && stream.match(/^```/)) {
        stream.skipToEnd();
        state.codeBlock = true;
        return null;
      }
      // If this block is changed, it may need to be updated in Markdown mode
      if (stream.peek() === '`') {
        stream.next();
        var before = stream.pos;
        stream.eatWhile('`');
        var difference = 1 + stream.pos - before;
        if (!state.code) {
          codeDepth = difference;
          state.code = true;
        } else {
          if (difference === codeDepth) { // Must be exact
            state.code = false;
          }
        }
        return null;
      } else if (state.code) {
        stream.next();
        return null;
      }
      // Check if space. If so, links can be formatted later on
      if (stream.eatSpace()) {
        state.ateSpace = true;
        return null;
      }
      if (stream.sol() || state.ateSpace) {
        state.ateSpace = false;
        if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) {
          // User/Project@SHA
          // User@SHA
          // SHA
          state.combineTokens = true;
          return "link";
        } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
          // User/Project#Num
          // User#Num
          // #Num
          state.combineTokens = true;
          return "link";
        }
      }
      if (stream.match(/^((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?]))/i) &&
         stream.string.slice(stream.start - 2, stream.start) != "](") {
        // URLs
        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
        state.combineTokens = true;
        return "link";
      }
      stream.next();
      return null;
    },
    blankLine: blankLine
  };

  var markdownConfig = {
    underscoresBreakWords: false,
    taskLists: true,
    fencedCodeBlocks: true,
    strikethrough: true
  };
  for (var attr in modeConfig) {
    markdownConfig[attr] = modeConfig[attr];
  }
  markdownConfig.name = "markdown";
  CodeMirror.defineMIME("gfmBase", markdownConfig);
  return CodeMirror.overlayMode(CodeMirror.getMode(config, "gfmBase"), gfmOverlay);
}, "markdown");

});//2.1.4
var JSHINT;
(function () {
var require;
require=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],2:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":1}],3:[function(require,module,exports){
(function(){// jshint -W001

"use strict";

// Identifiers provided by the ECMAScript standard.

exports.reservedVars = {
	arguments : false,
	NaN       : false
};

exports.ecmaIdentifiers = {
	Array              : false,
	Boolean            : false,
	Date               : false,
	decodeURI          : false,
	decodeURIComponent : false,
	encodeURI          : false,
	encodeURIComponent : false,
	Error              : false,
	"eval"             : false,
	EvalError          : false,
	Function           : false,
	hasOwnProperty     : false,
	isFinite           : false,
	isNaN              : false,
	JSON               : false,
	Math               : false,
	Map                : false,
	Number             : false,
	Object             : false,
	parseInt           : false,
	parseFloat         : false,
	RangeError         : false,
	ReferenceError     : false,
	RegExp             : false,
	Set                : false,
	String             : false,
	SyntaxError        : false,
	TypeError          : false,
	URIError           : false,
	WeakMap            : false
};

// Global variables commonly provided by a web browser environment.

exports.browser = {
	ArrayBuffer          : false,
	ArrayBufferView      : false,
	Audio                : false,
	Blob                 : false,
	addEventListener     : false,
	applicationCache     : false,
	atob                 : false,
	blur                 : false,
	btoa                 : false,
	clearInterval        : false,
	clearTimeout         : false,
	close                : false,
	closed               : false,
	DataView             : false,
	DOMParser            : false,
	defaultStatus        : false,
	document             : false,
	Element              : false,
	ElementTimeControl   : false,
	event                : false,
	FileReader           : false,
	Float32Array         : false,
	Float64Array         : false,
	FormData             : false,
	focus                : false,
	frames               : false,
	getComputedStyle     : false,
	HTMLElement          : false,
	HTMLAnchorElement    : false,
	HTMLBaseElement      : false,
	HTMLBlockquoteElement: false,
	HTMLBodyElement      : false,
	HTMLBRElement        : false,
	HTMLButtonElement    : false,
	HTMLCanvasElement    : false,
	HTMLDirectoryElement : false,
	HTMLDivElement       : false,
	HTMLDListElement     : false,
	HTMLFieldSetElement  : false,
	HTMLFontElement      : false,
	HTMLFormElement      : false,
	HTMLFrameElement     : false,
	HTMLFrameSetElement  : false,
	HTMLHeadElement      : false,
	HTMLHeadingElement   : false,
	HTMLHRElement        : false,
	HTMLHtmlElement      : false,
	HTMLIFrameElement    : false,
	HTMLImageElement     : false,
	HTMLInputElement     : false,
	HTMLIsIndexElement   : false,
	HTMLLabelElement     : false,
	HTMLLayerElement     : false,
	HTMLLegendElement    : false,
	HTMLLIElement        : false,
	HTMLLinkElement      : false,
	HTMLMapElement       : false,
	HTMLMenuElement      : false,
	HTMLMetaElement      : false,
	HTMLModElement       : false,
	HTMLObjectElement    : false,
	HTMLOListElement     : false,
	HTMLOptGroupElement  : false,
	HTMLOptionElement    : false,
	HTMLParagraphElement : false,
	HTMLParamElement     : false,
	HTMLPreElement       : false,
	HTMLQuoteElement     : false,
	HTMLScriptElement    : false,
	HTMLSelectElement    : false,
	HTMLStyleElement     : false,
	HTMLTableCaptionElement: false,
	HTMLTableCellElement : false,
	HTMLTableColElement  : false,
	HTMLTableElement     : false,
	HTMLTableRowElement  : false,
	HTMLTableSectionElement: false,
	HTMLTextAreaElement  : false,
	HTMLTitleElement     : false,
	HTMLUListElement     : false,
	HTMLVideoElement     : false,
	history              : false,
	Int16Array           : false,
	Int32Array           : false,
	Int8Array            : false,
	Image                : false,
	length               : false,
	localStorage         : false,
	location             : false,
	MessageChannel       : false,
	MessageEvent         : false,
	MessagePort          : false,
	moveBy               : false,
	moveTo               : false,
	MutationObserver     : false,
	name                 : false,
	Node                 : false,
	NodeFilter           : false,
	navigator            : false,
	onbeforeunload       : true,
	onblur               : true,
	onerror              : true,
	onfocus              : true,
	onload               : true,
	onresize             : true,
	onunload             : true,
	open                 : false,
	openDatabase         : false,
	opener               : false,
	Option               : false,
	parent               : false,
	print                : false,
	removeEventListener  : false,
	resizeBy             : false,
	resizeTo             : false,
	screen               : false,
	scroll               : false,
	scrollBy             : false,
	scrollTo             : false,
	sessionStorage       : false,
	setInterval          : false,
	setTimeout           : false,
	SharedWorker         : false,
	status               : false,
	SVGAElement          : false,
	SVGAltGlyphDefElement: false,
	SVGAltGlyphElement   : false,
	SVGAltGlyphItemElement: false,
	SVGAngle             : false,
	SVGAnimateColorElement: false,
	SVGAnimateElement    : false,
	SVGAnimateMotionElement: false,
	SVGAnimateTransformElement: false,
	SVGAnimatedAngle     : false,
	SVGAnimatedBoolean   : false,
	SVGAnimatedEnumeration: false,
	SVGAnimatedInteger   : false,
	SVGAnimatedLength    : false,
	SVGAnimatedLengthList: false,
	SVGAnimatedNumber    : false,
	SVGAnimatedNumberList: false,
	SVGAnimatedPathData  : false,
	SVGAnimatedPoints    : false,
	SVGAnimatedPreserveAspectRatio: false,
	SVGAnimatedRect      : false,
	SVGAnimatedString    : false,
	SVGAnimatedTransformList: false,
	SVGAnimationElement  : false,
	SVGCSSRule           : false,
	SVGCircleElement     : false,
	SVGClipPathElement   : false,
	SVGColor             : false,
	SVGColorProfileElement: false,
	SVGColorProfileRule  : false,
	SVGComponentTransferFunctionElement: false,
	SVGCursorElement     : false,
	SVGDefsElement       : false,
	SVGDescElement       : false,
	SVGDocument          : false,
	SVGElement           : false,
	SVGElementInstance   : false,
	SVGElementInstanceList: false,
	SVGEllipseElement    : false,
	SVGExternalResourcesRequired: false,
	SVGFEBlendElement    : false,
	SVGFEColorMatrixElement: false,
	SVGFEComponentTransferElement: false,
	SVGFECompositeElement: false,
	SVGFEConvolveMatrixElement: false,
	SVGFEDiffuseLightingElement: false,
	SVGFEDisplacementMapElement: false,
	SVGFEDistantLightElement: false,
	SVGFEFloodElement    : false,
	SVGFEFuncAElement    : false,
	SVGFEFuncBElement    : false,
	SVGFEFuncGElement    : false,
	SVGFEFuncRElement    : false,
	SVGFEGaussianBlurElement: false,
	SVGFEImageElement    : false,
	SVGFEMergeElement    : false,
	SVGFEMergeNodeElement: false,
	SVGFEMorphologyElement: false,
	SVGFEOffsetElement   : false,
	SVGFEPointLightElement: false,
	SVGFESpecularLightingElement: false,
	SVGFESpotLightElement: false,
	SVGFETileElement     : false,
	SVGFETurbulenceElement: false,
	SVGFilterElement     : false,
	SVGFilterPrimitiveStandardAttributes: false,
	SVGFitToViewBox      : false,
	SVGFontElement       : false,
	SVGFontFaceElement   : false,
	SVGFontFaceFormatElement: false,
	SVGFontFaceNameElement: false,
	SVGFontFaceSrcElement: false,
	SVGFontFaceUriElement: false,
	SVGForeignObjectElement: false,
	SVGGElement          : false,
	SVGGlyphElement      : false,
	SVGGlyphRefElement   : false,
	SVGGradientElement   : false,
	SVGHKernElement      : false,
	SVGICCColor          : false,
	SVGImageElement      : false,
	SVGLangSpace         : false,
	SVGLength            : false,
	SVGLengthList        : false,
	SVGLineElement       : false,
	SVGLinearGradientElement: false,
	SVGLocatable         : false,
	SVGMPathElement      : false,
	SVGMarkerElement     : false,
	SVGMaskElement       : false,
	SVGMatrix            : false,
	SVGMetadataElement   : false,
	SVGMissingGlyphElement: false,
	SVGNumber            : false,
	SVGNumberList        : false,
	SVGPaint             : false,
	SVGPathElement       : false,
	SVGPathSeg           : false,
	SVGPathSegArcAbs     : false,
	SVGPathSegArcRel     : false,
	SVGPathSegClosePath  : false,
	SVGPathSegCurvetoCubicAbs: false,
	SVGPathSegCurvetoCubicRel: false,
	SVGPathSegCurvetoCubicSmoothAbs: false,
	SVGPathSegCurvetoCubicSmoothRel: false,
	SVGPathSegCurvetoQuadraticAbs: false,
	SVGPathSegCurvetoQuadraticRel: false,
	SVGPathSegCurvetoQuadraticSmoothAbs: false,
	SVGPathSegCurvetoQuadraticSmoothRel: false,
	SVGPathSegLinetoAbs  : false,
	SVGPathSegLinetoHorizontalAbs: false,
	SVGPathSegLinetoHorizontalRel: false,
	SVGPathSegLinetoRel  : false,
	SVGPathSegLinetoVerticalAbs: false,
	SVGPathSegLinetoVerticalRel: false,
	SVGPathSegList       : false,
	SVGPathSegMovetoAbs  : false,
	SVGPathSegMovetoRel  : false,
	SVGPatternElement    : false,
	SVGPoint             : false,
	SVGPointList         : false,
	SVGPolygonElement    : false,
	SVGPolylineElement   : false,
	SVGPreserveAspectRatio: false,
	SVGRadialGradientElement: false,
	SVGRect              : false,
	SVGRectElement       : false,
	SVGRenderingIntent   : false,
	SVGSVGElement        : false,
	SVGScriptElement     : false,
	SVGSetElement        : false,
	SVGStopElement       : false,
	SVGStringList        : false,
	SVGStylable          : false,
	SVGStyleElement      : false,
	SVGSwitchElement     : false,
	SVGSymbolElement     : false,
	SVGTRefElement       : false,
	SVGTSpanElement      : false,
	SVGTests             : false,
	SVGTextContentElement: false,
	SVGTextElement       : false,
	SVGTextPathElement   : false,
	SVGTextPositioningElement: false,
	SVGTitleElement      : false,
	SVGTransform         : false,
	SVGTransformList     : false,
	SVGTransformable     : false,
	SVGURIReference      : false,
	SVGUnitTypes         : false,
	SVGUseElement        : false,
	SVGVKernElement      : false,
	SVGViewElement       : false,
	SVGViewSpec          : false,
	SVGZoomAndPan        : false,
	TimeEvent            : false,
	top                  : false,
	Uint16Array          : false,
	Uint32Array          : false,
	Uint8Array           : false,
	Uint8ClampedArray    : false,
	WebSocket            : false,
	window               : false,
	Worker               : false,
	XMLHttpRequest       : false,
	XMLSerializer        : false,
	XPathEvaluator       : false,
	XPathException       : false,
	XPathExpression      : false,
	XPathNamespace       : false,
	XPathNSResolver      : false,
	XPathResult          : false
};

exports.devel = {
	alert  : false,
	confirm: false,
	console: false,
	Debug  : false,
	opera  : false,
	prompt : false
};

exports.worker = {
	importScripts: true,
	postMessage  : true,
	self         : true
};

// Widely adopted global names that are not part of ECMAScript standard
exports.nonstandard = {
	escape  : false,
	unescape: false
};

// Globals provided by popular JavaScript environments.

exports.couch = {
	"require" : false,
	respond   : false,
	getRow    : false,
	emit      : false,
	send      : false,
	start     : false,
	sum       : false,
	log       : false,
	exports   : false,
	module    : false,
	provides  : false
};

exports.node = {
	__filename    : false,
	__dirname     : false,
	Buffer        : false,
	DataView      : false,
	console       : false,
	exports       : true,  // In Node it is ok to exports = module.exports = foo();
	GLOBAL        : false,
	global        : false,
	module        : false,
	process       : false,
	require       : false,
	setTimeout    : false,
	clearTimeout  : false,
	setInterval   : false,
	clearInterval : false,
	setImmediate  : false, // v0.9.1+
	clearImmediate: false  // v0.9.1+
};

exports.phantom = {
	phantom      : true,
	require      : true,
	WebPage      : true
};

exports.rhino = {
	defineClass  : false,
	deserialize  : false,
	gc           : false,
	help         : false,
	importPackage: false,
	"java"       : false,
	load         : false,
	loadClass    : false,
	print        : false,
	quit         : false,
	readFile     : false,
	readUrl      : false,
	runCommand   : false,
	seal         : false,
	serialize    : false,
	spawn        : false,
	sync         : false,
	toint32      : false,
	version      : false
};

exports.shelljs = {
	target       : false,
	echo         : false,
	exit         : false,
	cd           : false,
	pwd          : false,
	ls           : false,
	find         : false,
	cp           : false,
	rm           : false,
	mv           : false,
	mkdir        : false,
	test         : false,
	cat          : false,
	sed          : false,
	grep         : false,
	which        : false,
	dirs         : false,
	pushd        : false,
	popd         : false,
	env          : false,
	exec         : false,
	chmod        : false,
	config       : false,
	error        : false,
	tempdir      : false
};

exports.wsh = {
	ActiveXObject            : true,
	Enumerator               : true,
	GetObject                : true,
	ScriptEngine             : true,
	ScriptEngineBuildVersion : true,
	ScriptEngineMajorVersion : true,
	ScriptEngineMinorVersion : true,
	VBArray                  : true,
	WSH                      : true,
	WScript                  : true,
	XDomainRequest           : true
};

// Globals provided by popular JavaScript libraries.

exports.dojo = {
	dojo     : false,
	dijit    : false,
	dojox    : false,
	define	 : false,
	"require": false
};

exports.jquery = {
	"$"    : false,
	jQuery : false
};

exports.mootools = {
	"$"           : false,
	"$$"          : false,
	Asset         : false,
	Browser       : false,
	Chain         : false,
	Class         : false,
	Color         : false,
	Cookie        : false,
	Core          : false,
	Document      : false,
	DomReady      : false,
	DOMEvent      : false,
	DOMReady      : false,
	Drag          : false,
	Element       : false,
	Elements      : false,
	Event         : false,
	Events        : false,
	Fx            : false,
	Group         : false,
	Hash          : false,
	HtmlTable     : false,
	Iframe        : false,
	IframeShim    : false,
	InputValidator: false,
	instanceOf    : false,
	Keyboard      : false,
	Locale        : false,
	Mask          : false,
	MooTools      : false,
	Native        : false,
	Options       : false,
	OverText      : false,
	Request       : false,
	Scroller      : false,
	Slick         : false,
	Slider        : false,
	Sortables     : false,
	Spinner       : false,
	Swiff         : false,
	Tips          : false,
	Type          : false,
	typeOf        : false,
	URI           : false,
	Window        : false
};

exports.prototypejs = {
	"$"               : false,
	"$$"              : false,
	"$A"              : false,
	"$F"              : false,
	"$H"              : false,
	"$R"              : false,
	"$break"          : false,
	"$continue"       : false,
	"$w"              : false,
	Abstract          : false,
	Ajax              : false,
	Class             : false,
	Enumerable        : false,
	Element           : false,
	Event             : false,
	Field             : false,
	Form              : false,
	Hash              : false,
	Insertion         : false,
	ObjectRange       : false,
	PeriodicalExecuter: false,
	Position          : false,
	Prototype         : false,
	Selector          : false,
	Template          : false,
	Toggle            : false,
	Try               : false,
	Autocompleter     : false,
	Builder           : false,
	Control           : false,
	Draggable         : false,
	Draggables        : false,
	Droppables        : false,
	Effect            : false,
	Sortable          : false,
	SortableObserver  : false,
	Sound             : false,
	Scriptaculous     : false
};

exports.yui = {
	YUI       : false,
	Y         : false,
	YUI_config: false
};


})()
},{}],4:[function(require,module,exports){
/*
 * Regular expressions. Some of these are stupidly long.
 */

/*jshint maxlen:1000 */

"use string";

// Unsafe comment or string (ax)
exports.unsafeString =
	/@cc|<\/?|script|\]\s*\]|<\s*!|&lt/i;

// Unsafe characters that are silently deleted by one or more browsers (cx)
exports.unsafeChars =
	/[\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;

// Characters in strings that need escaping (nx and nxg)
exports.needEsc =
	/[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;

exports.needEscGlobal =
	/[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

// Star slash (lx)
exports.starSlash = /\*\//;

// Identifier (ix)
exports.identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;

// JavaScript URL (jx)
exports.javascriptURL = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\s*:/i;

// Catches /* falls through */ comments (ft)
exports.fallsThrough = /^\s*\/\*\s*falls?\sthrough\s*\*\/\s*$/;

},{}],5:[function(require,module,exports){
"use strict";

var state = {
	syntax: {},

	reset: function () {
		this.tokens = {
			prev: null,
			next: null,
			curr: null
		};

		this.option = {};
		this.ignored = {};
		this.directive = {};
		this.jsonMode = false;
		this.jsonWarnings = [];
		this.lines = [];
		this.tab = "";
		this.cache = {}; // Node.JS doesn't have Map. Sniff.
	}
};

exports.state = state;

},{}],6:[function(require,module,exports){
(function(){"use strict";

exports.register = function (linter) {
	// Check for properties named __proto__. This special property was
	// deprecated and then re-introduced for ES6.

	linter.on("Identifier", function style_scanProto(data) {
		if (linter.getOption("proto")) {
			return;
		}

		if (data.name === "__proto__") {
			linter.warn("W103", {
				line: data.line,
				char: data.char,
				data: [ data.name ]
			});
		}
	});

	// Check for properties named __iterator__. This is a special property
	// available only in browsers with JavaScript 1.7 implementation.

	linter.on("Identifier", function style_scanIterator(data) {
		if (linter.getOption("iterator")) {
			return;
		}

		if (data.name === "__iterator__") {
			linter.warn("W104", {
				line: data.line,
				char: data.char,
				data: [ data.name ]
			});
		}
	});

	// Check for dangling underscores.

	linter.on("Identifier", function style_scanDangling(data) {
		if (!linter.getOption("nomen")) {
			return;
		}

		// Underscore.js
		if (data.name === "_") {
			return;
		}

		// In Node, __dirname and __filename should be ignored.
		if (linter.getOption("node")) {
			if (/^(__dirname|__filename)$/.test(data.name) && !data.isProperty) {
				return;
			}
		}

		if (/^(_+.*|.*_+)$/.test(data.name)) {
			linter.warn("W105", {
				line: data.line,
				char: data.from,
				data: [ "dangling '_'", data.name ]
			});
		}
	});

	// Check that all identifiers are using camelCase notation.
	// Exceptions: names like MY_VAR and _myVar.

	linter.on("Identifier", function style_scanCamelCase(data) {
		if (!linter.getOption("camelcase")) {
			return;
		}

		if (data.name.replace(/^_+/, "").indexOf("_") > -1 && !data.name.match(/^[A-Z0-9_]*$/)) {
			linter.warn("W106", {
				line: data.line,
				char: data.from,
				data: [ data.name ]
			});
		}
	});

	// Enforce consistency in style of quoting.

	linter.on("String", function style_scanQuotes(data) {
		var quotmark = linter.getOption("quotmark");
		var code;

		if (!quotmark) {
			return;
		}

		// If quotmark is set to 'single' warn about all double-quotes.

		if (quotmark === "single" && data.quote !== "'") {
			code = "W109";
		}

		// If quotmark is set to 'double' warn about all single-quotes.

		if (quotmark === "double" && data.quote !== "\"") {
			code = "W108";
		}

		// If quotmark is set to true, remember the first quotation style
		// and then warn about all others.

		if (quotmark === true) {
			if (!linter.getCache("quotmark")) {
				linter.setCache("quotmark", data.quote);
			}

			if (linter.getCache("quotmark") !== data.quote) {
				code = "W110";
			}
		}

		if (code) {
			linter.warn(code, {
				line: data.line,
				char: data.char,
			});
		}
	});

	linter.on("Number", function style_scanNumbers(data) {
		if (data.value.charAt(0) === ".") {
			// Warn about a leading decimal point.
			linter.warn("W008", {
				line: data.line,
				char: data.char,
				data: [ data.value ]
			});
		}

		if (data.value.substr(data.value.length - 1) === ".") {
			// Warn about a trailing decimal point.
			linter.warn("W047", {
				line: data.line,
				char: data.char,
				data: [ data.value ]
			});
		}

		if (/^00+/.test(data.value)) {
			// Multiple leading zeroes.
			linter.warn("W046", {
				line: data.line,
				char: data.char,
				data: [ data.value ]
			});
		}
	});

	// Warn about script URLs.

	linter.on("String", function style_scanJavaScriptURLs(data) {
		var re = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\s*:/i;

		if (linter.getOption("scripturl")) {
			return;
		}

		if (re.test(data.value)) {
			linter.warn("W107", {
				line: data.line,
				char: data.char
			});
		}
	});
};
})()
},{}],7:[function(require,module,exports){
(function(global){/*global window, global*/
var util = require("util")
var assert = require("assert")

var slice = Array.prototype.slice
var console
var times = {}

if (typeof global !== "undefined" && global.console) {
    console = global.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = window.console = {}
}

var functions = [
    [log, "log"]
    , [info, "info"]
    , [warn, "warn"]
    , [error, "error"]
    , [time, "time"]
    , [timeEnd, "timeEnd"]
    , [trace, "trace"]
    , [dir, "dir"]
    , [assert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = Date.now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    var duration = Date.now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function assert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}

})(window)
},{"util":8,"assert":9}],"jshint":[function(require,module,exports){
module.exports=require('E/GbHF');
},{}],"E/GbHF":[function(require,module,exports){
(function(){/*!
 * JSHint, by JSHint Community.
 *
 * This file (and this file only) is licensed under the same slightly modified
 * MIT license that JSLint is. It stops evil-doers everywhere:
 *
 *	 Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)
 *
 *	 Permission is hereby granted, free of charge, to any person obtaining
 *	 a copy of this software and associated documentation files (the "Software"),
 *	 to deal in the Software without restriction, including without limitation
 *	 the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *	 and/or sell copies of the Software, and to permit persons to whom
 *	 the Software is furnished to do so, subject to the following conditions:
 *
 *	 The above copyright notice and this permission notice shall be included
 *	 in all copies or substantial portions of the Software.
 *
 *	 The Software shall be used for Good, not Evil.
 *
 *	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *	 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *	 DEALINGS IN THE SOFTWARE.
 *
 */

/*jshint quotmark:double */
/*global console:true */
/*exported console */

var _        = require("underscore");
var events   = require("events");
var vars     = require("../shared/vars.js");
var messages = require("../shared/messages.js");
var Lexer    = require("./lex.js").Lexer;
var reg      = require("./reg.js");
var state    = require("./state.js").state;
var style    = require("./style.js");

// We need this module here because environments such as IE and Rhino
// don't necessarilly expose the 'console' API and browserify uses
// it to log things. It's a sad state of affair, really.
var console = require("console-browserify");

// We build the application inside a function so that we produce only a singleton
// variable. That function will be invoked immediately, and its return value is
// the JSHINT function itself.

var JSHINT = (function () {
	"use strict";

	var anonname, // The guessed name for anonymous functions.
		api, // Extension API

		// These are operators that should not be used with the ! operator.
		bang = {
			"<"  : true,
			"<=" : true,
			"==" : true,
			"===": true,
			"!==": true,
			"!=" : true,
			">"  : true,
			">=" : true,
			"+"  : true,
			"-"  : true,
			"*"  : true,
			"/"  : true,
			"%"  : true
		},

		// These are the JSHint boolean options.
		boolOptions = {
			asi         : true, // if automatic semicolon insertion should be tolerated
			bitwise     : true, // if bitwise operators should not be allowed
			boss        : true, // if advanced usage of assignments should be allowed
			browser     : true, // if the standard browser globals should be predefined
			camelcase   : true, // if identifiers should be required in camel case
			couch       : true, // if CouchDB globals should be predefined
			curly       : true, // if curly braces around all blocks should be required
			debug       : true, // if debugger statements should be allowed
			devel       : true, // if logging globals should be predefined (console, alert, etc.)
			dojo        : true, // if Dojo Toolkit globals should be predefined
			eqeqeq      : true, // if === should be required
			eqnull      : true, // if == null comparisons should be tolerated
			es3         : true, // if ES3 syntax should be allowed
			es5         : true, // if ES5 syntax should be allowed (is now set per default)
			esnext      : true, // if es.next specific syntax should be allowed
			moz         : true, // if mozilla specific syntax should be allowed
			evil        : true, // if eval should be allowed
			expr        : true, // if ExpressionStatement should be allowed as Programs
			forin       : true, // if for in statements must filter
			funcscope   : true, // if only function scope should be used for scope tests
			gcl         : true, // if JSHint should be compatible with Google Closure Linter
			globalstrict: true, // if global "use strict"; should be allowed (also enables 'strict')
			immed       : true, // if immediate invocations must be wrapped in parens
			iterator    : true, // if the `__iterator__` property should be allowed
			jquery      : true, // if jQuery globals should be predefined
			lastsemic   : true, // if semicolons may be ommitted for the trailing
			                    // statements inside of a one-line blocks.
			laxbreak    : true, // if line breaks should not be checked
			laxcomma    : true, // if line breaks should not be checked around commas
			loopfunc    : true, // if functions should be allowed to be defined within
			                    // loops
			mootools    : true, // if MooTools globals should be predefined
			multistr    : true, // allow multiline strings
			newcap      : true, // if constructor names must be capitalized
			noarg       : true, // if arguments.caller and arguments.callee should be
			                    // disallowed
			node        : true, // if the Node.js environment globals should be
			                    // predefined
			noempty     : true, // if empty blocks should be disallowed
			nonew       : true, // if using `new` for side-effects should be disallowed
			nonstandard : true, // if non-standard (but widely adopted) globals should
			                    // be predefined
			nomen       : true, // if names should be checked
			onevar      : true, // if only one var statement per function should be
			                    // allowed
			passfail    : true, // if the scan should stop on first error
			phantom     : true, // if PhantomJS symbols should be allowed
			plusplus    : true, // if increment/decrement should not be allowed
			proto       : true, // if the `__proto__` property should be allowed
			prototypejs : true, // if Prototype and Scriptaculous globals should be
			                    // predefined
			rhino       : true, // if the Rhino environment globals should be predefined
			shelljs     : true, // if ShellJS globals should be predefined
			undef       : true, // if variables should be declared before used
			scripturl   : true, // if script-targeted URLs should be tolerated
			shadow      : true, // if variable shadowing should be tolerated
			smarttabs   : true, // if smarttabs should be tolerated
			                    // (http://www.emacswiki.org/emacs/SmartTabs)
			strict      : true, // require the "use strict"; pragma
			sub         : true, // if all forms of subscript notation are tolerated
			supernew    : true, // if `new function () { ... };` and `new Object;`
			                    // should be tolerated
			trailing    : true, // if trailing whitespace rules apply
			validthis   : true, // if 'this' inside a non-constructor function is valid.
			                    // This is a function scoped option only.
			withstmt    : true, // if with statements should be allowed
			white       : true, // if strict whitespace rules apply
			worker      : true, // if Web Worker script symbols should be allowed
			wsh         : true, // if the Windows Scripting Host environment globals
			                    // should be predefined
			yui         : true, // YUI variables should be predefined

			// Obsolete options
			onecase     : true, // if one case switch statements should be allowed
			regexp      : true, // if the . should not be allowed in regexp literals
			regexdash   : true  // if unescaped first/last dash (-) inside brackets
			                    // should be tolerated
		},

		// These are the JSHint options that can take any value
		// (we use this object to detect invalid options)
		valOptions = {
			maxlen       : false,
			indent       : false,
			maxerr       : false,
			predef       : false,
			quotmark     : false, //'single'|'double'|true
			scope        : false,
			maxstatements: false, // {int} max statements per function
			maxdepth     : false, // {int} max nested block depth per function
			maxparams    : false, // {int} max params per function
			maxcomplexity: false, // {int} max cyclomatic complexity per function
			unused       : true,  // warn if variables are unused. Available options:
			                      //   false    - don't check for unused variables
			                      //   true     - "vars" + check last function param
			                      //   "vars"   - skip checking unused function params
			                      //   "strict" - "vars" + check all function params
			latedef      : false  // warn if the variable is used before its definition
			                      //   false    - don't emit any warnings
			                      //   true     - warn if any variable is used before its definition
			                      //   "nofunc" - warn for any variable but function declarations
		},

		// These are JSHint boolean options which are shared with JSLint
		// where the definition in JSHint is opposite JSLint
		invertedOptions = {
			bitwise : true,
			forin   : true,
			newcap  : true,
			nomen   : true,
			plusplus: true,
			regexp  : true,
			undef   : true,
			white   : true,

			// Inverted and renamed, use JSHint name here
			eqeqeq  : true,
			onevar  : true,
			strict  : true
		},

		// These are JSHint boolean options which are shared with JSLint
		// where the name has been changed but the effect is unchanged
		renamedOptions = {
			eqeq   : "eqeqeq",
			vars   : "onevar",
			windows: "wsh",
			sloppy : "strict"
		},

		declared, // Globals that were declared using /*global ... */ syntax.
		exported, // Variables that are used outside of the current file.

		functionicity = [
			"closure", "exception", "global", "label",
			"outer", "unused", "var"
		],

		funct, // The current function
		functions, // All of the functions

		global, // The global scope
		implied, // Implied globals
		inblock,
		indent,
		lookahead,
		lex,
		member,
		membersOnly,
		noreach,
		predefined,		// Global variables defined by option

		scope,  // The current scope
		stack,
		unuseds,
		urls,
		warnings,

		extraModules = [],
		emitter = new events.EventEmitter();

	function checkOption(name, t) {
		name = name.trim();

		if (/^[+-]W\d{3}$/g.test(name)) {
			return true;
		}

		if (valOptions[name] === undefined && boolOptions[name] === undefined) {
			if (t.type !== "jslint") {
				error("E001", t, name);
				return false;
			}
		}

		return true;
	}

	function isString(obj) {
		return Object.prototype.toString.call(obj) === "[object String]";
	}

	function isIdentifier(tkn, value) {
		if (!tkn)
			return false;

		if (!tkn.identifier || tkn.value !== value)
			return false;

		return true;
	}

	function isReserved(token) {
		if (!token.reserved) {
			return false;
		}

		if (token.meta && token.meta.isFutureReservedWord) {
			// ES3 FutureReservedWord in an ES5 environment.
			if (state.option.inES5(true) && !token.meta.es5) {
				return false;
			}

			// Some ES5 FutureReservedWord identifiers are active only
			// within a strict mode environment.
			if (token.meta.strictOnly) {
				if (!state.option.strict && !state.directive["use strict"]) {
					return false;
				}
			}

			if (token.isProperty) {
				return false;
			}
		}

		return true;
	}

	function supplant(str, data) {
		return str.replace(/\{([^{}]*)\}/g, function (a, b) {
			var r = data[b];
			return typeof r === "string" || typeof r === "number" ? r : a;
		});
	}

	function combine(t, o) {
		var n;
		for (n in o) {
			if (_.has(o, n) && !_.has(JSHINT.blacklist, n)) {
				t[n] = o[n];
			}
		}
	}

	function updatePredefined() {
		Object.keys(JSHINT.blacklist).forEach(function (key) {
			delete predefined[key];
		});
	}

	function assume() {
		if (state.option.es5) {
			warning("I003");
		}
		if (state.option.couch) {
			combine(predefined, vars.couch);
		}

		if (state.option.rhino) {
			combine(predefined, vars.rhino);
		}

		if (state.option.shelljs) {
			combine(predefined, vars.shelljs);
		}

		if (state.option.phantom) {
			combine(predefined, vars.phantom);
		}

		if (state.option.prototypejs) {
			combine(predefined, vars.prototypejs);
		}

		if (state.option.node) {
			combine(predefined, vars.node);
		}

		if (state.option.devel) {
			combine(predefined, vars.devel);
		}

		if (state.option.dojo) {
			combine(predefined, vars.dojo);
		}

		if (state.option.browser) {
			combine(predefined, vars.browser);
		}

		if (state.option.nonstandard) {
			combine(predefined, vars.nonstandard);
		}

		if (state.option.jquery) {
			combine(predefined, vars.jquery);
		}

		if (state.option.mootools) {
			combine(predefined, vars.mootools);
		}

		if (state.option.worker) {
			combine(predefined, vars.worker);
		}

		if (state.option.wsh) {
			combine(predefined, vars.wsh);
		}

		if (state.option.globalstrict && state.option.strict !== false) {
			state.option.strict = true;
		}

		if (state.option.yui) {
			combine(predefined, vars.yui);
		}

		// Let's assume that chronologically ES3 < ES5 < ES6/ESNext < Moz

		state.option.inMoz = function (strict) {
			if (strict) {
				return state.option.moz && !state.option.esnext;
			}
			return state.option.moz;
		};

		state.option.inESNext = function (strict) {
			if (strict) {
				return !state.option.moz && state.option.esnext;
			}
			return state.option.moz || state.option.esnext;
		};

		state.option.inES5 = function (/* strict */) {
			return !state.option.es3;
		};

		state.option.inES3 = function (strict) {
			if (strict) {
				return !state.option.moz && !state.option.esnext && state.option.es3;
			}
			return state.option.es3;
		};
	}

	// Produce an error warning.
	function quit(code, line, chr) {
		var percentage = Math.floor((line / state.lines.length) * 100);
		var message = messages.errors[code].desc;

		throw {
			name: "JSHintError",
			line: line,
			character: chr,
			message: message + " (" + percentage + "% scanned).",
			raw: message
		};
	}

	function isundef(scope, code, token, a) {
		return JSHINT.undefs.push([scope, code, token, a]);
	}

	function warning(code, t, a, b, c, d) {
		var ch, l, w, msg;

		if (/^W\d{3}$/.test(code)) {
			if (state.ignored[code])
				return;

			msg = messages.warnings[code];
		} else if (/E\d{3}/.test(code)) {
			msg = messages.errors[code];
		} else if (/I\d{3}/.test(code)) {
			msg = messages.info[code];
		}

		t = t || state.tokens.next;
		if (t.id === "(end)") {  // `~
			t = state.tokens.curr;
		}

		l = t.line || 0;
		ch = t.from || 0;

		w = {
			id: "(error)",
			raw: msg.desc,
			code: msg.code,
			evidence: state.lines[l - 1] || "",
			line: l,
			character: ch,
			scope: JSHINT.scope,
			a: a,
			b: b,
			c: c,
			d: d
		};

		w.reason = supplant(msg.desc, w);
		JSHINT.errors.push(w);

		if (state.option.passfail) {
			quit("E042", l, ch);
		}

		warnings += 1;
		if (warnings >= state.option.maxerr) {
			quit("E043", l, ch);
		}

		return w;
	}

	function warningAt(m, l, ch, a, b, c, d) {
		return warning(m, {
			line: l,
			from: ch
		}, a, b, c, d);
	}

	function error(m, t, a, b, c, d) {
		warning(m, t, a, b, c, d);
	}

	function errorAt(m, l, ch, a, b, c, d) {
		return error(m, {
			line: l,
			from: ch
		}, a, b, c, d);
	}

	// Tracking of "internal" scripts, like eval containing a static string
	function addInternalSrc(elem, src) {
		var i;
		i = {
			id: "(internal)",
			elem: elem,
			value: src
		};
		JSHINT.internals.push(i);
		return i;
	}

	function addlabel(t, type, tkn, islet) {
		// Define t in the current function in the current scope.
		if (type === "exception") {
			if (_.has(funct["(context)"], t)) {
				if (funct[t] !== true && !state.option.node) {
					warning("W002", state.tokens.next, t);
				}
			}
		}

		if (_.has(funct, t) && !funct["(global)"]) {
			if (funct[t] === true) {
				if (state.option.latedef) {
					if ((state.option.latedef === true && _.contains([funct[t], type], "unction")) ||
							!_.contains([funct[t], type], "unction")) {
						warning("W003", state.tokens.next, t);
					}
				}
			} else {
				if (!state.option.shadow && type !== "exception" ||
							(funct["(blockscope)"].getlabel(t))) {
					warning("W004", state.tokens.next, t);
				}
			}
		}

		// a double definition of a let variable in same block throws a TypeError
		if (funct["(blockscope)"] && funct["(blockscope)"].current.has(t)) {
			error("E044", state.tokens.next, t);
		}

		// if the identifier is from a let, adds it only to the current blockscope
		if (islet) {
			funct["(blockscope)"].current.add(t, type, state.tokens.curr);
		} else {

			funct[t] = type;

			if (tkn) {
				funct["(tokens)"][t] = tkn;
			}

			if (funct["(global)"]) {
				global[t] = funct;
				if (_.has(implied, t)) {
					if (state.option.latedef) {
						if ((state.option.latedef === true && _.contains([funct[t], type], "unction")) ||
								!_.contains([funct[t], type], "unction")) {
							warning("W003", state.tokens.next, t);
						}
					}

					delete implied[t];
				}
			} else {
				scope[t] = funct;
			}
		}
	}

	function doOption() {
		var nt = state.tokens.next;
		var body = nt.body.split(",").map(function (s) { return s.trim(); });
		var predef = {};

		if (nt.type === "globals") {
			body.forEach(function (g) {
				g = g.split(":");
				var key = g[0];
				var val = g[1];

				if (key.charAt(0) === "-") {
					key = key.slice(1);
					val = false;

					JSHINT.blacklist[key] = key;
					updatePredefined();
				} else {
					predef[key] = (val === "true");
				}
			});

			combine(predefined, predef);

			for (var key in predef) {
				if (_.has(predef, key)) {
					declared[key] = nt;
				}
			}
		}

		if (nt.type === "exported") {
			body.forEach(function (e) {
				exported[e] = true;
			});
		}

		if (nt.type === "members") {
			membersOnly = membersOnly || {};

			body.forEach(function (m) {
				var ch1 = m.charAt(0);
				var ch2 = m.charAt(m.length - 1);

				if (ch1 === ch2 && (ch1 === "\"" || ch1 === "'")) {
					m = m
						.substr(1, m.length - 2)
						.replace("\\b", "\b")
						.replace("\\t", "\t")
						.replace("\\n", "\n")
						.replace("\\v", "\v")
						.replace("\\f", "\f")
						.replace("\\r", "\r")
						.replace("\\\\", "\\")
						.replace("\\\"", "\"");
				}

				membersOnly[m] = false;
			});
		}

		var numvals = [
			"maxstatements",
			"maxparams",
			"maxdepth",
			"maxcomplexity",
			"maxerr",
			"maxlen",
			"indent"
		];

		if (nt.type === "jshint" || nt.type === "jslint") {
			body.forEach(function (g) {
				g = g.split(":");
				var key = (g[0] || "").trim();
				var val = (g[1] || "").trim();

				if (!checkOption(key, nt)) {
					return;
				}

				if (numvals.indexOf(key) >= 0) {

					// GH988 - numeric options can be disabled by setting them to `false`
					if (val !== "false") {
						val = +val;

						if (typeof val !== "number" || !isFinite(val) || val <= 0 || Math.floor(val) !== val) {
							error("E032", nt, g[1].trim());
							return;
						}

						if (key === "indent") {
							state.option["(explicitIndent)"] = true;
						}
						state.option[key] = val;
					} else {
						if (key === "indent") {
							state.option["(explicitIndent)"] = false;
						} else {
							state.option[key] = false;
						}
					}

					return;
				}

				if (key === "validthis") {
					// `validthis` is valid only within a function scope.
					if (funct["(global)"]) {
						error("E009");
					} else {
						if (val === "true" || val === "false") {
							state.option.validthis = (val === "true");
						} else {
							error("E002", nt);
						}
					}
					return;
				}

				if (key === "quotmark") {
					switch (val) {
					case "true":
					case "false":
						state.option.quotmark = (val === "true");
						break;
					case "double":
					case "single":
						state.option.quotmark = val;
						break;
					default:
						error("E002", nt);
					}
					return;
				}

				if (key === "unused") {
					switch (val) {
					case "true":
						state.option.unused = true;
						break;
					case "false":
						state.option.unused = false;
						break;
					case "vars":
					case "strict":
						state.option.unused = val;
						break;
					default:
						error("E002", nt);
					}
					return;
				}

				if (key === "latedef") {
					switch (val) {
					case "true":
						state.option.latedef = true;
						break;
					case "false":
						state.option.latedef = false;
						break;
					case "nofunc":
						state.option.latedef = "nofunc";
						break;
					default:
						error("E002", nt);
					}
					return;
				}

				var match = /^([+-])(W\d{3})$/g.exec(key);
				if (match) {
					// ignore for -W..., unignore for +W...
					state.ignored[match[2]] = (match[1] === "-");
					return;
				}

				var tn;
				if (val === "true" || val === "false") {
					if (nt.type === "jslint") {
						tn = renamedOptions[key] || key;
						state.option[tn] = (val === "true");

						if (invertedOptions[tn] !== undefined) {
							state.option[tn] = !state.option[tn];
						}
					} else {
						state.option[key] = (val === "true");
					}

					if (key === "newcap") {
						state.option["(explicitNewcap)"] = true;
					}
					return;
				}

				error("E002", nt);
			});

			assume();
		}
	}

	// We need a peek function. If it has an argument, it peeks that much farther
	// ahead. It is used to distinguish
	//	   for ( var i in ...
	// from
	//	   for ( var i = ...

	function peek(p) {
		var i = p || 0, j = 0, t;

		while (j <= i) {
			t = lookahead[j];
			if (!t) {
				t = lookahead[j] = lex.token();
			}
			j += 1;
		}
		return t;
	}

	// Produce the next token. It looks for programming errors.

	function advance(id, t) {
		switch (state.tokens.curr.id) {
		case "(number)":
			if (state.tokens.next.id === ".") {
				warning("W005", state.tokens.curr);
			}
			break;
		case "-":
			if (state.tokens.next.id === "-" || state.tokens.next.id === "--") {
				warning("W006");
			}
			break;
		case "+":
			if (state.tokens.next.id === "+" || state.tokens.next.id === "++") {
				warning("W007");
			}
			break;
		}

		if (state.tokens.curr.type === "(string)" || state.tokens.curr.identifier) {
			anonname = state.tokens.curr.value;
		}

		if (id && state.tokens.next.id !== id) {
			if (t) {
				if (state.tokens.next.id === "(end)") {
					error("E019", t, t.id);
				} else {
					error("E020", state.tokens.next, id, t.id, t.line, state.tokens.next.value);
				}
			} else if (state.tokens.next.type !== "(identifier)" || state.tokens.next.value !== id) {
				warning("W116", state.tokens.next, id, state.tokens.next.value);
			}
		}

		state.tokens.prev = state.tokens.curr;
		state.tokens.curr = state.tokens.next;
		for (;;) {
			state.tokens.next = lookahead.shift() || lex.token();

			if (!state.tokens.next) { // No more tokens left, give up
				quit("E041", state.tokens.curr.line);
			}

			if (state.tokens.next.id === "(end)" || state.tokens.next.id === "(error)") {
				return;
			}

			if (state.tokens.next.check) {
				state.tokens.next.check();
			}

			if (state.tokens.next.isSpecial) {
				doOption();
			} else {
				if (state.tokens.next.id !== "(endline)") {
					break;
				}
			}
		}
	}

	// This is the heart of JSHINT, the Pratt parser. In addition to parsing, it
	// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is
	// like .nud except that it is only used on the first token of a statement.
	// Having .fud makes it much easier to define statement-oriented languages like
	// JavaScript. I retained Pratt's nomenclature.

	// .nud  Null denotation
	// .fud  First null denotation
	// .led  Left denotation
	//  lbp  Left binding power
	//  rbp  Right binding power

	// They are elements of the parsing method called Top Down Operator Precedence.

	function expression(rbp, initial) {
		var left, isArray = false, isObject = false, isLetExpr = false;

		// if current expression is a let expression
		if (!initial && state.tokens.next.value === "let" && peek(0).value === "(") {
			if (!state.option.inMoz(true)) {
				warning("W118", state.tokens.next, "let expressions");
			}
			isLetExpr = true;
			// create a new block scope we use only for the current expression
			funct["(blockscope)"].stack();
			advance("let");
			advance("(");
			state.syntax["let"].fud.call(state.syntax["let"].fud, false);
			advance(")");
		}

		if (state.tokens.next.id === "(end)")
			error("E006", state.tokens.curr);

		advance();

		if (initial) {
			anonname = "anonymous";
			funct["(verb)"] = state.tokens.curr.value;
		}

		if (initial === true && state.tokens.curr.fud) {
			left = state.tokens.curr.fud();
		} else {
			if (state.tokens.curr.nud) {
				left = state.tokens.curr.nud();
			} else {
				error("E030", state.tokens.curr, state.tokens.curr.id);
			}

			var end_of_expr = state.tokens.next.identifier &&
									!state.tokens.curr.led &&
									state.tokens.curr.line !== state.tokens.next.line;
			while (rbp < state.tokens.next.lbp && !end_of_expr) {
				isArray = state.tokens.curr.value === "Array";
				isObject = state.tokens.curr.value === "Object";

				// #527, new Foo.Array(), Foo.Array(), new Foo.Object(), Foo.Object()
				// Line breaks in IfStatement heads exist to satisfy the checkJSHint
				// "Line too long." error.
				if (left && (left.value || (left.first && left.first.value))) {
					// If the left.value is not "new", or the left.first.value is a "."
					// then safely assume that this is not "new Array()" and possibly
					// not "new Object()"...
					if (left.value !== "new" ||
					  (left.first && left.first.value && left.first.value === ".")) {
						isArray = false;
						// ...In the case of Object, if the left.value and state.tokens.curr.value
						// are not equal, then safely assume that this not "new Object()"
						if (left.value !== state.tokens.curr.value) {
							isObject = false;
						}
					}
				}

				advance();

				if (isArray && state.tokens.curr.id === "(" && state.tokens.next.id === ")") {
					warning("W009", state.tokens.curr);
				}

				if (isObject && state.tokens.curr.id === "(" && state.tokens.next.id === ")") {
					warning("W010", state.tokens.curr);
				}

				if (left && state.tokens.curr.led) {
					left = state.tokens.curr.led(left);
				} else {
					error("E033", state.tokens.curr, state.tokens.curr.id);
				}
			}
		}
		if (isLetExpr) {
			funct["(blockscope)"].unstack();
		}
		return left;
	}


// Functions for conformance of style.

	function adjacent(left, right) {
		left = left || state.tokens.curr;
		right = right || state.tokens.next;
		if (state.option.white) {
			if (left.character !== right.from && left.line === right.line) {
				left.from += (left.character - left.from);
				warning("W011", left, left.value);
			}
		}
	}

	function nobreak(left, right) {
		left = left || state.tokens.curr;
		right = right || state.tokens.next;
		if (state.option.white && (left.character !== right.from || left.line !== right.line)) {
			warning("W012", right, right.value);
		}
	}

	function nospace(left, right) {
		left = left || state.tokens.curr;
		right = right || state.tokens.next;
		if (state.option.white && !left.comment) {
			if (left.line === right.line) {
				adjacent(left, right);
			}
		}
	}

	function nonadjacent(left, right) {
		if (state.option.white) {
			left = left || state.tokens.curr;
			right = right || state.tokens.next;

			if (left.value === ";" && right.value === ";") {
				return;
			}

			if (left.line === right.line && left.character === right.from) {
				left.from += (left.character - left.from);
				warning("W013", left, left.value);
			}
		}
	}

	function nobreaknonadjacent(left, right) {
		left = left || state.tokens.curr;
		right = right || state.tokens.next;
		if (!state.option.laxbreak && left.line !== right.line) {
			warning("W014", right, right.id);
		} else if (state.option.white) {
			left = left || state.tokens.curr;
			right = right || state.tokens.next;
			if (left.character === right.from) {
				left.from += (left.character - left.from);
				warning("W013", left, left.value);
			}
		}
	}

	function indentation(bias) {
		if (!state.option.white && !state.option["(explicitIndent)"]) {
			return;
		}

		if (state.tokens.next.id === "(end)") {
			return;
		}

		var i = indent + (bias || 0);
		if (state.tokens.next.from !== i) {
			warning("W015", state.tokens.next, state.tokens.next.value, i, state.tokens.next.from);
		}
	}

	function nolinebreak(t) {
		t = t || state.tokens.curr;
		if (t.line !== state.tokens.next.line) {
			warning("E022", t, t.value);
		}
	}


	function comma(opts) {
		opts = opts || {};

		if (!opts.peek) {
			if (state.tokens.curr.line !== state.tokens.next.line) {
				if (!state.option.laxcomma) {
					if (comma.first) {
						warning("I001");
						comma.first = false;
					}
					warning("W014", state.tokens.curr, state.tokens.next.value);
				}
			} else if (!state.tokens.curr.comment &&
					state.tokens.curr.character !== state.tokens.next.from && state.option.white) {
				state.tokens.curr.from += (state.tokens.curr.character - state.tokens.curr.from);
				warning("W011", state.tokens.curr, state.tokens.curr.value);
			}

			advance(",");
		}

		// TODO: This is a temporary solution to fight against false-positives in
		// arrays and objects with trailing commas (see GH-363). The best solution
		// would be to extract all whitespace rules out of parser.

		if (state.tokens.next.value !== "]" && state.tokens.next.value !== "}") {
			nonadjacent(state.tokens.curr, state.tokens.next);
		}

		if (state.tokens.next.identifier && !(opts.property && state.option.inES5())) {
			// Keywords that cannot follow a comma operator.
			switch (state.tokens.next.value) {
			case "break":
			case "case":
			case "catch":
			case "continue":
			case "default":
			case "do":
			case "else":
			case "finally":
			case "for":
			case "if":
			case "in":
			case "instanceof":
			case "return":
			case "yield":
			case "switch":
			case "throw":
			case "try":
			case "var":
			case "let":
			case "while":
			case "with":
				error("E024", state.tokens.next, state.tokens.next.value);
				return false;
			}
		}

		if (state.tokens.next.type === "(punctuator)") {
			switch (state.tokens.next.value) {
			case "}":
			case "]":
			case ",":
				if (opts.allowTrailing) {
					return true;
				}

				/* falls through */
			case ")":
				error("E024", state.tokens.next, state.tokens.next.value);
				return false;
			}
		}
		return true;
	}

	// Functional constructors for making the symbols that will be inherited by
	// tokens.

	function symbol(s, p) {
		var x = state.syntax[s];
		if (!x || typeof x !== "object") {
			state.syntax[s] = x = {
				id: s,
				lbp: p,
				value: s
			};
		}
		return x;
	}

	function delim(s) {
		return symbol(s, 0);
	}

	function stmt(s, f) {
		var x = delim(s);
		x.identifier = x.reserved = true;
		x.fud = f;
		return x;
	}

	function blockstmt(s, f) {
		var x = stmt(s, f);
		x.block = true;
		return x;
	}

	function reserveName(x) {
		var c = x.id.charAt(0);
		if ((c >= "a" && c <= "z") || (c >= "A" && c <= "Z")) {
			x.identifier = x.reserved = true;
		}
		return x;
	}

	function prefix(s, f) {
		var x = symbol(s, 150);
		reserveName(x);
		x.nud = (typeof f === "function") ? f : function () {
			this.right = expression(150);
			this.arity = "unary";
			if (this.id === "++" || this.id === "--") {
				if (state.option.plusplus) {
					warning("W016", this, this.id);
				} else if ((!this.right.identifier || isReserved(this.right)) &&
						this.right.id !== "." && this.right.id !== "[") {
					warning("W017", this);
				}
			}
			return this;
		};
		return x;
	}

	function type(s, f) {
		var x = delim(s);
		x.type = s;
		x.nud = f;
		return x;
	}

	function reserve(name, func) {
		var x = type(name, func);
		x.identifier = true;
		x.reserved = true;
		return x;
	}

	function FutureReservedWord(name, meta) {
		var x = type(name, (meta && meta.nud) || function () {
			return this;
		});

		meta = meta || {};
		meta.isFutureReservedWord = true;

		x.value = name;
		x.identifier = true;
		x.reserved = true;
		x.meta = meta;

		return x;
	}

	function reservevar(s, v) {
		return reserve(s, function () {
			if (typeof v === "function") {
				v(this);
			}
			return this;
		});
	}

	function infix(s, f, p, w) {
		var x = symbol(s, p);
		reserveName(x);
		x.led = function (left) {
			if (!w) {
				nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
				nonadjacent(state.tokens.curr, state.tokens.next);
			}
			if (s === "in" && left.id === "!") {
				warning("W018", left, "!");
			}
			if (typeof f === "function") {
				return f(left, this);
			} else {
				this.left = left;
				this.right = expression(p);
				return this;
			}
		};
		return x;
	}


	function application(s) {
		var x = symbol(s, 42);

		x.led = function (left) {
			if (!state.option.inESNext()) {
				warning("W104", state.tokens.curr, "arrow function syntax (=>)");
			}

			nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
			nonadjacent(state.tokens.curr, state.tokens.next);

			this.left = left;
			this.right = doFunction(undefined, undefined, false, left);
			return this;
		};
		return x;
	}

	function relation(s, f) {
		var x = symbol(s, 100);

		x.led = function (left) {
			nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
			nonadjacent(state.tokens.curr, state.tokens.next);
			var right = expression(100);

			if (isIdentifier(left, "NaN") || isIdentifier(right, "NaN")) {
				warning("W019", this);
			} else if (f) {
				f.apply(this, [left, right]);
			}

			if (!left || !right) {
				quit("E041", state.tokens.curr.line);
			}

			if (left.id === "!") {
				warning("W018", left, "!");
			}

			if (right.id === "!") {
				warning("W018", right, "!");
			}

			this.left = left;
			this.right = right;
			return this;
		};
		return x;
	}

	function isPoorRelation(node) {
		return node &&
			  ((node.type === "(number)" && +node.value === 0) ||
			   (node.type === "(string)" && node.value === "") ||
			   (node.type === "null" && !state.option.eqnull) ||
				node.type === "true" ||
				node.type === "false" ||
				node.type === "undefined");
	}

	function assignop(s) {
		symbol(s, 20).exps = true;

		return infix(s, function (left, that) {
			that.left = left;

			if (left) {
				if (predefined[left.value] === false &&
						scope[left.value]["(global)"] === true) {
					warning("W020", left);
				} else if (left["function"]) {
					warning("W021", left, left.value);
				}

				if (funct[left.value] === "const") {
					error("E013", left, left.value);
				}

				if (left.id === ".") {
					if (!left.left) {
						warning("E031", that);
					} else if (left.left.value === "arguments" && !state.directive["use strict"]) {
						warning("E031", that);
					}

					that.right = expression(19);
					return that;
				} else if (left.id === "[") {
					if (state.tokens.curr.left.first) {
						state.tokens.curr.left.first.forEach(function (t) {
							if (funct[t.value] === "const") {
								error("E013", t, t.value);
							}
						});
					} else if (!left.left) {
						warning("E031", that);
					} else if (left.left.value === "arguments" && !state.directive["use strict"]) {
						warning("E031", that);
					}
					that.right = expression(19);
					return that;
				} else if (left.identifier && !isReserved(left)) {
					if (funct[left.value] === "exception") {
						warning("W022", left);
					}
					that.right = expression(19);
					return that;
				}

				if (left === state.syntax["function"]) {
					warning("W023", state.tokens.curr);
				}
			}

			error("E031", that);
		}, 20);
	}


	function bitwise(s, f, p) {
		var x = symbol(s, p);
		reserveName(x);
		x.led = (typeof f === "function") ? f : function (left) {
			if (state.option.bitwise) {
				warning("W016", this, this.id);
			}
			this.left = left;
			this.right = expression(p);
			return this;
		};
		return x;
	}


	function bitwiseassignop(s) {
		symbol(s, 20).exps = true;
		return infix(s, function (left, that) {
			if (state.option.bitwise) {
				warning("W016", that, that.id);
			}
			nonadjacent(state.tokens.prev, state.tokens.curr);
			nonadjacent(state.tokens.curr, state.tokens.next);
			if (left) {
				if (left.id === "." || left.id === "[" ||
						(left.identifier && !isReserved(left))) {
					expression(19);
					return that;
				}
				if (left === state.syntax["function"]) {
					warning("W023", state.tokens.curr);
				}
				return that;
			}
			error("E031", that);
		}, 20);
	}


	function suffix(s) {
		var x = symbol(s, 150);

		x.led = function (left) {
			if (state.option.plusplus) {
				warning("W016", this, this.id);
			} else if ((!left.identifier || isReserved(left)) && left.id !== "." && left.id !== "[") {
				warning("W017", this);
			}

			this.left = left;
			return this;
		};
		return x;
	}

	// fnparam means that this identifier is being defined as a function
	// argument (see identifier())
	// prop means that this identifier is that of an object property

	function optionalidentifier(fnparam, prop) {
		if (!state.tokens.next.identifier) {
			return;
		}

		advance();

		var curr = state.tokens.curr;
		var meta = curr.meta || {};
		var val  = state.tokens.curr.value;

		if (!isReserved(curr)) {
			return val;
		}

		if (prop) {
			if (state.option.inES5() || meta.isFutureReservedWord) {
				return val;
			}
		}

		if (fnparam && val === "undefined") {
			return val;
		}

		// Display an info message about reserved words as properties
		// and ES5 but do it only once.
		if (prop && !api.getCache("displayed:I002")) {
			api.setCache("displayed:I002", true);
			warning("I002");
		}

		warning("W024", state.tokens.curr, state.tokens.curr.id);
		return val;
	}

	// fnparam means that this identifier is being defined as a function
	// argument
	// prop means that this identifier is that of an object property
	function identifier(fnparam, prop) {
		var i = optionalidentifier(fnparam, prop);
		if (i) {
			return i;
		}
		if (state.tokens.curr.id === "function" && state.tokens.next.id === "(") {
			warning("W025");
		} else {
			error("E030", state.tokens.next, state.tokens.next.value);
		}
	}


	function reachable(s) {
		var i = 0, t;
		if (state.tokens.next.id !== ";" || noreach) {
			return;
		}
		for (;;) {
			t = peek(i);
			if (t.reach) {
				return;
			}
			if (t.id !== "(endline)") {
				if (t.id === "function") {
					if (!state.option.latedef) {
						break;
					}

					warning("W026", t);
					break;
				}

				warning("W027", t, t.value, s);
				break;
			}
			i += 1;
		}
	}


	function statement(noindent) {
		var values;
		var i = indent, r, s = scope, t = state.tokens.next;

		if (t.id === ";") {
			advance(";");
			return;
		}

		// Is this a labelled statement?
		var res = isReserved(t);

		// We're being more tolerant here: if someone uses
		// a FutureReservedWord as a label, we warn but proceed
		// anyway.

		if (res && t.meta && t.meta.isFutureReservedWord && peek().id === ":") {
			warning("W024", t, t.id);
			res = false;
		}

		// detect a destructuring assignment
		if (_.has(["[", "{"], t.value)) {
			if (lookupBlockType().isDestAssign) {
				if (!state.option.inESNext()) {
					warning("W104", state.tokens.curr, "destructuring expression");
				}
				values = destructuringExpression();
				values.forEach(function (tok) {
					isundef(funct, "W117", tok.token, tok.id);
				});
				advance("=");
				destructuringExpressionMatch(values, expression(5, true));
				advance(";");
				return;
			}
		}
		if (t.identifier && !res && peek().id === ":") {
			advance();
			advance(":");
			scope = Object.create(s);
			addlabel(t.value, "label");

			if (!state.tokens.next.labelled && state.tokens.next.value !== "{") {
				warning("W028", state.tokens.next, t.value, state.tokens.next.value);
			}

			state.tokens.next.label = t.value;
			t = state.tokens.next;
		}

		// Is it a lonely block?

		if (t.id === "{") {
			block(true, true);
			return;
		}

		// Parse the statement.

		if (!noindent) {
			indentation();
		}
		r = expression(0, true);

		// Look for the final semicolon.

		if (!t.block) {
			if (!state.option.expr && (!r || !r.exps)) {
				warning("W030", state.tokens.curr);
			} else if (state.option.nonew && r && r.left && r.id === "(" && r.left.id === "new") {
				warning("W031", t);
			}

			if (state.tokens.next.id !== ";") {
				if (!state.option.asi) {
					// If this is the last statement in a block that ends on
					// the same line *and* option lastsemic is on, ignore the warning.
					// Otherwise, complain about missing semicolon.
					if (!state.option.lastsemic || state.tokens.next.id !== "}" ||
						state.tokens.next.line !== state.tokens.curr.line) {
						warningAt("W033", state.tokens.curr.line, state.tokens.curr.character);
					}
				}
			} else {
				adjacent(state.tokens.curr, state.tokens.next);
				advance(";");
				nonadjacent(state.tokens.curr, state.tokens.next);
			}
		}

		// Restore the indentation.

		indent = i;
		scope = s;
		return r;
	}


	function statements(startLine) {
		var a = [], p;

		while (!state.tokens.next.reach && state.tokens.next.id !== "(end)") {
			if (state.tokens.next.id === ";") {
				p = peek();

				if (!p || (p.id !== "(" && p.id !== "[")) {
					warning("W032");
				}

				advance(";");
			} else {
				a.push(statement(startLine === state.tokens.next.line));
			}
		}
		return a;
	}


	/*
	 * read all directives
	 * recognizes a simple form of asi, but always
	 * warns, if it is used
	 */
	function directives() {
		var i, p, pn;

		for (;;) {
			if (state.tokens.next.id === "(string)") {
				p = peek(0);
				if (p.id === "(endline)") {
					i = 1;
					do {
						pn = peek(i);
						i = i + 1;
					} while (pn.id === "(endline)");

					if (pn.id !== ";") {
						if (pn.id !== "(string)" && pn.id !== "(number)" &&
							pn.id !== "(regexp)" && pn.identifier !== true &&
							pn.id !== "}") {
							break;
						}
						warning("W033", state.tokens.next);
					} else {
						p = pn;
					}
				} else if (p.id === "}") {
					// Directive with no other statements, warn about missing semicolon
					warning("W033", p);
				} else if (p.id !== ";") {
					break;
				}

				indentation();
				advance();
				if (state.directive[state.tokens.curr.value]) {
					warning("W034", state.tokens.curr, state.tokens.curr.value);
				}

				if (state.tokens.curr.value === "use strict") {
					if (!state.option["(explicitNewcap)"])
						state.option.newcap = true;
					state.option.undef = true;
				}

				// there's no directive negation, so always set to true
				state.directive[state.tokens.curr.value] = true;

				if (p.id === ";") {
					advance(";");
				}
				continue;
			}
			break;
		}
	}


	/*
	 * Parses a single block. A block is a sequence of statements wrapped in
	 * braces.
	 *
	 * ordinary - true for everything but function bodies and try blocks.
	 * stmt		- true if block can be a single statement (e.g. in if/for/while).
	 * isfunc	- true if block is a function body
	 */
	function block(ordinary, stmt, isfunc, isfatarrow) {
		var a,
			b = inblock,
			old_indent = indent,
			m,
			s = scope,
			t,
			line,
			d;

		inblock = ordinary;

		if (!ordinary || !state.option.funcscope)
			scope = Object.create(scope);

		nonadjacent(state.tokens.curr, state.tokens.next);
		t = state.tokens.next;

		var metrics = funct["(metrics)"];
		metrics.nestedBlockDepth += 1;
		metrics.verifyMaxNestedBlockDepthPerFunction();

		if (state.tokens.next.id === "{") {
			advance("{");

			// create a new block scope
			funct["(blockscope)"].stack();

			line = state.tokens.curr.line;
			if (state.tokens.next.id !== "}") {
				indent += state.option.indent;
				while (!ordinary && state.tokens.next.from > indent) {
					indent += state.option.indent;
				}

				if (isfunc) {
					m = {};
					for (d in state.directive) {
						if (_.has(state.directive, d)) {
							m[d] = state.directive[d];
						}
					}
					directives();

					if (state.option.strict && funct["(context)"]["(global)"]) {
						if (!m["use strict"] && !state.directive["use strict"]) {
							warning("E007");
						}
					}
				}

				a = statements(line);

				metrics.statementCount += a.length;

				if (isfunc) {
					state.directive = m;
				}

				indent -= state.option.indent;
				if (line !== state.tokens.next.line) {
					indentation();
				}
			} else if (line !== state.tokens.next.line) {
				indentation();
			}
			advance("}", t);

			funct["(blockscope)"].unstack();

			indent = old_indent;
		} else if (!ordinary) {
			if (isfunc) {
				m = {};
				if (stmt && !isfatarrow && !state.option.inMoz(true)) {
					error("W118", state.tokens.curr, "function closure expressions");
				}

				if (!stmt) {
					for (d in state.directive) {
						if (_.has(state.directive, d)) {
							m[d] = state.directive[d];
						}
					}
				}
				expression(5);

				if (state.option.strict && funct["(context)"]["(global)"]) {
					if (!m["use strict"] && !state.directive["use strict"]) {
						warning("E007");
					}
				}
			} else {
				error("E021", state.tokens.next, "{", state.tokens.next.value);
			}
		} else {

			// check to avoid let declaration not within a block
			funct["(nolet)"] = true;

			if (!stmt || state.option.curly) {
				warning("W116", state.tokens.next, "{", state.tokens.next.value);
			}

			noreach = true;
			indent += state.option.indent;
			// test indentation only if statement is in new line
			a = [statement(state.tokens.next.line === state.tokens.curr.line)];
			indent -= state.option.indent;
			noreach = false;

			delete funct["(nolet)"];
		}
		funct["(verb)"] = null;
		if (!ordinary || !state.option.funcscope) scope = s;
		inblock = b;
		if (ordinary && state.option.noempty && (!a || a.length === 0)) {
			warning("W035");
		}
		metrics.nestedBlockDepth -= 1;
		return a;
	}


	function countMember(m) {
		if (membersOnly && typeof membersOnly[m] !== "boolean") {
			warning("W036", state.tokens.curr, m);
		}
		if (typeof member[m] === "number") {
			member[m] += 1;
		} else {
			member[m] = 1;
		}
	}


	function note_implied(tkn) {
		var name = tkn.value, line = tkn.line, a = implied[name];
		if (typeof a === "function") {
			a = false;
		}

		if (!a) {
			a = [line];
			implied[name] = a;
		} else if (a[a.length - 1] !== line) {
			a.push(line);
		}
	}


	// Build the syntax table by declaring the syntactic elements of the language.

	type("(number)", function () {
		return this;
	});

	type("(string)", function () {
		return this;
	});

	state.syntax["(identifier)"] = {
		type: "(identifier)",
		lbp: 0,
		identifier: true,
		nud: function () {
			var v = this.value,
				s = scope[v],
				f;

			if (typeof s === "function") {
				// Protection against accidental inheritance.
				s = undefined;
			} else if (typeof s === "boolean") {
				f = funct;
				funct = functions[0];
				addlabel(v, "var");
				s = funct;
				funct = f;
			}
			var block;
			if (_.has(funct, "(blockscope)")) {
				block = funct["(blockscope)"].getlabel(v);
			}

			// The name is in scope and defined in the current function.
			if (funct === s || block) {
				// Change 'unused' to 'var', and reject labels.
				// the name is in a block scope
				switch (block ? block[v]["(type)"] : funct[v]) {
				case "unused":
					if (block) block[v]["(type)"] = "var";
					else funct[v] = "var";
					break;
				case "unction":
					if (block) block[v]["(type)"] = "function";
					else funct[v] = "function";
					this["function"] = true;
					break;
				case "function":
					this["function"] = true;
					break;
				case "label":
					warning("W037", state.tokens.curr, v);
					break;
				}
			} else if (funct["(global)"]) {
				// The name is not defined in the function.  If we are in the global
				// scope, then we have an undefined variable.
				//
				// Operators typeof and delete do not raise runtime errors even if
				// the base object of a reference is null so no need to display warning
				// if we're inside of typeof or delete.

				if (typeof predefined[v] !== "boolean") {
					// Attempting to subscript a null reference will throw an
					// error, even within the typeof and delete operators
					if (!(anonname === "typeof" || anonname === "delete") ||
						(state.tokens.next && (state.tokens.next.value === "." ||
							state.tokens.next.value === "["))) {

						// if we're in a list comprehension, variables are declared
						// locally and used before being defined. So we check
						// the presence of the given variable in the comp array
						// before declaring it undefined.

						if (!funct["(comparray)"].check(v)) {
							isundef(funct, "W117", state.tokens.curr, v);
						}
					}
				}

				note_implied(state.tokens.curr);
			} else {
				// If the name is already defined in the current
				// function, but not as outer, then there is a scope error.

				switch (funct[v]) {
				case "closure":
				case "function":
				case "var":
				case "unused":
					warning("W038", state.tokens.curr, v);
					break;
				case "label":
					warning("W037", state.tokens.curr, v);
					break;
				case "outer":
				case "global":
					break;
				default:
					// If the name is defined in an outer function, make an outer entry,
					// and if it was unused, make it var.
					if (s === true) {
						funct[v] = true;
					} else if (s === null) {
						warning("W039", state.tokens.curr, v);
						note_implied(state.tokens.curr);
					} else if (typeof s !== "object") {
						// Operators typeof and delete do not raise runtime errors even
						// if the base object of a reference is null so no need to
						//
						// display warning if we're inside of typeof or delete.
						// Attempting to subscript a null reference will throw an
						// error, even within the typeof and delete operators
						if (!(anonname === "typeof" || anonname === "delete") ||
							(state.tokens.next &&
								(state.tokens.next.value === "." || state.tokens.next.value === "["))) {

							isundef(funct, "W117", state.tokens.curr, v);
						}
						funct[v] = true;
						note_implied(state.tokens.curr);
					} else {
						switch (s[v]) {
						case "function":
						case "unction":
							this["function"] = true;
							s[v] = "closure";
							funct[v] = s["(global)"] ? "global" : "outer";
							break;
						case "var":
						case "unused":
							s[v] = "closure";
							funct[v] = s["(global)"] ? "global" : "outer";
							break;
						case "closure":
							funct[v] = s["(global)"] ? "global" : "outer";
							break;
						case "label":
							warning("W037", state.tokens.curr, v);
						}
					}
				}
			}
			return this;
		},
		led: function () {
			error("E033", state.tokens.next, state.tokens.next.value);
		}
	};

	type("(regexp)", function () {
		return this;
	});

	// ECMAScript parser

	delim("(endline)");
	delim("(begin)");
	delim("(end)").reach = true;
	delim("(error)").reach = true;
	delim("}").reach = true;
	delim(")");
	delim("]");
	delim("\"").reach = true;
	delim("'").reach = true;
	delim(";");
	delim(":").reach = true;
	delim("#");

	reserve("else");
	reserve("case").reach = true;
	reserve("catch");
	reserve("default").reach = true;
	reserve("finally");
	reservevar("arguments", function (x) {
		if (state.directive["use strict"] && funct["(global)"]) {
			warning("E008", x);
		}
	});
	reservevar("eval");
	reservevar("false");
	reservevar("Infinity");
	reservevar("null");
	reservevar("this", function (x) {
		if (state.directive["use strict"] && !state.option.validthis && ((funct["(statement)"] &&
				funct["(name)"].charAt(0) > "Z") || funct["(global)"])) {
			warning("W040", x);
		}
	});
	reservevar("true");
	reservevar("undefined");

	assignop("=", "assign", 20);
	assignop("+=", "assignadd", 20);
	assignop("-=", "assignsub", 20);
	assignop("*=", "assignmult", 20);
	assignop("/=", "assigndiv", 20).nud = function () {
		error("E014");
	};
	assignop("%=", "assignmod", 20);

	bitwiseassignop("&=", "assignbitand", 20);
	bitwiseassignop("|=", "assignbitor", 20);
	bitwiseassignop("^=", "assignbitxor", 20);
	bitwiseassignop("<<=", "assignshiftleft", 20);
	bitwiseassignop(">>=", "assignshiftright", 20);
	bitwiseassignop(">>>=", "assignshiftrightunsigned", 20);
	infix(",", function (left, that) {
		var expr;
		that.exprs = [left];
		if (!comma({peek: true})) {
			return that;
		}
		while (true) {
			if (!(expr = expression(5)))  {
				break;
			}
			that.exprs.push(expr);
			if (state.tokens.next.value !== "," || !comma()) {
				break;
			}
		}
		return that;
	}, 5, true);
	infix("?", function (left, that) {
		that.left = left;
		that.right = expression(10);
		advance(":");
		that["else"] = expression(10);
		return that;
	}, 30);

	infix("||", "or", 40);
	infix("&&", "and", 50);
	bitwise("|", "bitor", 70);
	bitwise("^", "bitxor", 80);
	bitwise("&", "bitand", 90);
	relation("==", function (left, right) {
		var eqnull = state.option.eqnull && (left.value === "null" || right.value === "null");

		if (!eqnull && state.option.eqeqeq)
			warning("W116", this, "===", "==");
		else if (isPoorRelation(left))
			warning("W041", this, "===", left.value);
		else if (isPoorRelation(right))
			warning("W041", this, "===", right.value);

		return this;
	});
	relation("===");
	relation("!=", function (left, right) {
		var eqnull = state.option.eqnull &&
				(left.value === "null" || right.value === "null");

		if (!eqnull && state.option.eqeqeq) {
			warning("W116", this, "!==", "!=");
		} else if (isPoorRelation(left)) {
			warning("W041", this, "!==", left.value);
		} else if (isPoorRelation(right)) {
			warning("W041", this, "!==", right.value);
		}
		return this;
	});
	relation("!==");
	relation("<");
	relation(">");
	relation("<=");
	relation(">=");
	bitwise("<<", "shiftleft", 120);
	bitwise(">>", "shiftright", 120);
	bitwise(">>>", "shiftrightunsigned", 120);
	infix("in", "in", 120);
	infix("instanceof", "instanceof", 120);
	infix("+", function (left, that) {
		var right = expression(130);
		if (left && right && left.id === "(string)" && right.id === "(string)") {
			left.value += right.value;
			left.character = right.character;
			if (!state.option.scripturl && reg.javascriptURL.test(left.value)) {
				warning("W050", left);
			}
			return left;
		}
		that.left = left;
		that.right = right;
		return that;
	}, 130);
	prefix("+", "num");
	prefix("+++", function () {
		warning("W007");
		this.right = expression(150);
		this.arity = "unary";
		return this;
	});
	infix("+++", function (left) {
		warning("W007");
		this.left = left;
		this.right = expression(130);
		return this;
	}, 130);
	infix("-", "sub", 130);
	prefix("-", "neg");
	prefix("---", function () {
		warning("W006");
		this.right = expression(150);
		this.arity = "unary";
		return this;
	});
	infix("---", function (left) {
		warning("W006");
		this.left = left;
		this.right = expression(130);
		return this;
	}, 130);
	infix("*", "mult", 140);
	infix("/", "div", 140);
	infix("%", "mod", 140);

	suffix("++", "postinc");
	prefix("++", "preinc");
	state.syntax["++"].exps = true;

	suffix("--", "postdec");
	prefix("--", "predec");
	state.syntax["--"].exps = true;
	prefix("delete", function () {
		var p = expression(5);
		if (!p || (p.id !== "." && p.id !== "[")) {
			warning("W051");
		}
		this.first = p;
		return this;
	}).exps = true;

	prefix("~", function () {
		if (state.option.bitwise) {
			warning("W052", this, "~");
		}
		expression(150);
		return this;
	});

	prefix("...", function () {
		if (!state.option.inESNext()) {
			warning("W104", this, "spread/rest operator");
		}
		if (!state.tokens.next.identifier) {
			error("E030", state.tokens.next, state.tokens.next.value);
		}
		expression(150);
		return this;
	});

	prefix("!", function () {
		this.right = expression(150);
		this.arity = "unary";

		if (!this.right) { // '!' followed by nothing? Give up.
			quit("E041", this.line || 0);
		}

		if (bang[this.right.id] === true) {
			warning("W018", this, "!");
		}
		return this;
	});

	prefix("typeof", "typeof");
	prefix("new", function () {
		var c = expression(155), i;
		if (c && c.id !== "function") {
			if (c.identifier) {
				c["new"] = true;
				switch (c.value) {
				case "Number":
				case "String":
				case "Boolean":
				case "Math":
				case "JSON":
					warning("W053", state.tokens.prev, c.value);
					break;
				case "Function":
					if (!state.option.evil) {
						warning("W054");
					}
					break;
				case "Date":
				case "RegExp":
					break;
				default:
					if (c.id !== "function") {
						i = c.value.substr(0, 1);
						if (state.option.newcap && (i < "A" || i > "Z") && !_.has(global, c.value)) {
							warning("W055", state.tokens.curr);
						}
					}
				}
			} else {
				if (c.id !== "." && c.id !== "[" && c.id !== "(") {
					warning("W056", state.tokens.curr);
				}
			}
		} else {
			if (!state.option.supernew)
				warning("W057", this);
		}
		adjacent(state.tokens.curr, state.tokens.next);
		if (state.tokens.next.id !== "(" && !state.option.supernew) {
			warning("W058", state.tokens.curr, state.tokens.curr.value);
		}
		this.first = c;
		return this;
	});
	state.syntax["new"].exps = true;

	prefix("void").exps = true;

	infix(".", function (left, that) {
		adjacent(state.tokens.prev, state.tokens.curr);
		nobreak();
		var m = identifier(false, true);

		if (typeof m === "string") {
			countMember(m);
		}

		that.left = left;
		that.right = m;

		if (m && m === "hasOwnProperty" && state.tokens.next.value === "=") {
			warning("W001");
		}

		if (left && left.value === "arguments" && (m === "callee" || m === "caller")) {
			if (state.option.noarg)
				warning("W059", left, m);
			else if (state.directive["use strict"])
				error("E008");
		} else if (!state.option.evil && left && left.value === "document" &&
				(m === "write" || m === "writeln")) {
			warning("W060", left);
		}

		if (!state.option.evil && (m === "eval" || m === "execScript")) {
			warning("W061");
		}

		return that;
	}, 160, true);

	infix("(", function (left, that) {
		if (state.tokens.prev.id !== "}" && state.tokens.prev.id !== ")") {
			nobreak(state.tokens.prev, state.tokens.curr);
		}

		nospace();
		if (state.option.immed && left && !left.immed && left.id === "function") {
			warning("W062");
		}

		var n = 0;
		var p = [];

		if (left) {
			if (left.type === "(identifier)") {
				if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {
					if ("Number String Boolean Date Object".indexOf(left.value) === -1) {
						if (left.value === "Math") {
							warning("W063", left);
						} else if (state.option.newcap) {
							warning("W064", left);
						}
					}
				}
			}
		}

		if (state.tokens.next.id !== ")") {
			for (;;) {
				p[p.length] = expression(10);
				n += 1;
				if (state.tokens.next.id !== ",") {
					break;
				}
				comma();
			}
		}

		advance(")");
		nospace(state.tokens.prev, state.tokens.curr);

		if (typeof left === "object") {
			if (left.value === "parseInt" && n === 1) {
				warning("W065", state.tokens.curr);
			}
			if (!state.option.evil) {
				if (left.value === "eval" || left.value === "Function" ||
						left.value === "execScript") {
					warning("W061", left);

					if (p[0] && [0].id === "(string)") {
						addInternalSrc(left, p[0].value);
					}
				} else if (p[0] && p[0].id === "(string)" &&
					   (left.value === "setTimeout" ||
						left.value === "setInterval")) {
					warning("W066", left);
					addInternalSrc(left, p[0].value);

				// window.setTimeout/setInterval
				} else if (p[0] && p[0].id === "(string)" &&
					   left.value === "." &&
					   left.left.value === "window" &&
					   (left.right === "setTimeout" ||
						left.right === "setInterval")) {
					warning("W066", left);
					addInternalSrc(left, p[0].value);
				}
			}
			if (!left.identifier && left.id !== "." && left.id !== "[" &&
					left.id !== "(" && left.id !== "&&" && left.id !== "||" &&
					left.id !== "?") {
				warning("W067", left);
			}
		}

		that.left = left;
		return that;
	}, 155, true).exps = true;

	prefix("(", function () {
		nospace();
		var bracket, brackets = [];
		var pn, pn1, i = 0;
		var ret;

		do {
			pn = peek(i);
			i += 1;
			pn1 = peek(i);
			i += 1;
		} while (pn.value !== ")" && pn1.value !== "=>" && pn1.value !== ";" && pn1.type !== "(end)");

		if (state.tokens.next.id === "function") {
			state.tokens.next.immed = true;
		}

		var exprs = [];

		if (state.tokens.next.id !== ")") {
			for (;;) {
				if (pn1.value === "=>" && state.tokens.next.value === "{") {
					bracket = state.tokens.next;
					bracket.left = destructuringExpression();
					brackets.push(bracket);
					for (var t in bracket.left) {
						exprs.push(bracket.left[t].token);
					}
				} else {
					exprs.push(expression(5));
				}
				if (state.tokens.next.id !== ",") {
					break;
				}
				comma();
			}
		}

		advance(")", this);
		nospace(state.tokens.prev, state.tokens.curr);
		if (state.option.immed && exprs[0] && exprs[0].id === "function") {
			if (state.tokens.next.id !== "(" &&
			  (state.tokens.next.id !== "." || (peek().value !== "call" && peek().value !== "apply"))) {
				warning("W068", this);
			}
		}

		if (state.tokens.next.value === "=>") {
			return exprs;
		}
		if (!exprs.length) {
			return;
		}
		if (exprs.length > 1) {
			ret = Object.create(state.syntax[","]);
			ret.exprs = exprs;
		} else {
			ret = exprs[0];
		}
		if (ret) {
			ret.paren = true;
		}
		return ret;
	});

	application("=>");

	infix("[", function (left, that) {
		nobreak(state.tokens.prev, state.tokens.curr);
		nospace();
		var e = expression(5), s;
		if (e && e.type === "(string)") {
			if (!state.option.evil && (e.value === "eval" || e.value === "execScript")) {
				warning("W061", that);
			}

			countMember(e.value);
			if (!state.option.sub && reg.identifier.test(e.value)) {
				s = state.syntax[e.value];
				if (!s || !isReserved(s)) {
					warning("W069", state.tokens.prev, e.value);
				}
			}
		}
		advance("]", that);

		if (e && e.value === "hasOwnProperty" && state.tokens.next.value === "=") {
			warning("W001");
		}

		nospace(state.tokens.prev, state.tokens.curr);
		that.left = left;
		that.right = e;
		return that;
	}, 160, true);

	function comprehensiveArrayExpression() {
		var res = {};
		res.exps = true;
		funct["(comparray)"].stack();

		res.right = expression(5);
		advance("for");
		if (state.tokens.next.value === "each") {
			advance("each");
			if (!state.option.inMoz(true)) {
				warning("W118", state.tokens.curr, "for each");
			}
		}
		advance("(");
		funct["(comparray)"].setState("define");
		res.left = expression(5);
		advance(")");
		if (state.tokens.next.value === "if") {
			advance("if");
			advance("(");
			funct["(comparray)"].setState("filter");
			res.filter = expression(5);
			advance(")");
		}
		advance("]");
		funct["(comparray)"].unstack();
		return res;
	}

	prefix("[", function () {
		var blocktype = lookupBlockType(true);
		if (blocktype.isCompArray) {
			if (!state.option.inMoz(true)) {
				warning("W118", state.tokens.curr, "array comprehension");
			}
			return comprehensiveArrayExpression();
		} else if (blocktype.isDestAssign && !state.option.inESNext()) {
			warning("W104", state.tokens.curr, "destructuring assignment");
		}
		var b = state.tokens.curr.line !== state.tokens.next.line;
		this.first = [];
		if (b) {
			indent += state.option.indent;
			if (state.tokens.next.from === indent + state.option.indent) {
				indent += state.option.indent;
			}
		}
		while (state.tokens.next.id !== "(end)") {
			while (state.tokens.next.id === ",") {
				if (!state.option.inES5())
					warning("W070");
				advance(",");
			}
			if (state.tokens.next.id === "]") {
				break;
			}
			if (b && state.tokens.curr.line !== state.tokens.next.line) {
				indentation();
			}
			this.first.push(expression(10));
			if (state.tokens.next.id === ",") {
				comma({ allowTrailing: true });
				if (state.tokens.next.id === "]" && !state.option.inES5(true)) {
					warning("W070", state.tokens.curr);
					break;
				}
			} else {
				break;
			}
		}
		if (b) {
			indent -= state.option.indent;
			indentation();
		}
		advance("]", this);
		return this;
	}, 160);


	function property_name() {
		var id = optionalidentifier(false, true);

		if (!id) {
			if (state.tokens.next.id === "(string)") {
				id = state.tokens.next.value;
				advance();
			} else if (state.tokens.next.id === "(number)") {
				id = state.tokens.next.value.toString();
				advance();
			}
		}

		if (id === "hasOwnProperty") {
			warning("W001");
		}

		return id;
	}


	function functionparams(parsed) {
		var curr, next;
		var params = [];
		var ident;
		var tokens = [];
		var t;

		if (parsed) {
			if (parsed instanceof Array) {
				for (var i in parsed) {
					curr = parsed[i];
					if (_.contains(["{", "["], curr.id)) {
						for (t in curr.left) {
							t = tokens[t];
							if (t.id) {
								params.push(t.id);
								addlabel(t.id, "unused", t.token);
							}
						}
					} else if (curr.value === "...") {
						if (!state.option.inESNext()) {
							warning("W104", curr, "spread/rest operator");
						}
						continue;
					} else {
						addlabel(curr.value, "unused", curr);
					}
				}
				return params;
			} else {
				if (parsed.identifier === true) {
					addlabel(parsed.value, "unused", parsed);
					return [parsed];
				}
			}
		}

		next = state.tokens.next;

		advance("(");
		nospace();

		if (state.tokens.next.id === ")") {
			advance(")");
			return;
		}

		for (;;) {
			if (_.contains(["{", "["], state.tokens.next.id)) {
				tokens = destructuringExpression();
				for (t in tokens) {
					t = tokens[t];
					if (t.id) {
						params.push(t.id);
						addlabel(t.id, "unused", t.token);
					}
				}
			} else if (state.tokens.next.value === "...") {
				if (!state.option.inESNext()) {
					warning("W104", state.tokens.next, "spread/rest operator");
				}
				advance("...");
				nospace();
				ident = identifier(true);
				params.push(ident);
				addlabel(ident, "unused", state.tokens.curr);
			} else {
				ident = identifier(true);
				params.push(ident);
				addlabel(ident, "unused", state.tokens.curr);
			}
			if (state.tokens.next.id === ",") {
				comma();
			} else {
				advance(")", next);
				nospace(state.tokens.prev, state.tokens.curr);
				return params;
			}
		}
	}


	function doFunction(name, statement, generator, fatarrowparams) {
		var f;
		var oldOption = state.option;
		var oldIgnored = state.ignored;
		var oldScope  = scope;

		state.option = Object.create(state.option);
		state.ignored = Object.create(state.ignored);
		scope  = Object.create(scope);

		funct = {
			"(name)"      : name || "\"" + anonname + "\"",
			"(line)"      : state.tokens.next.line,
			"(character)" : state.tokens.next.character,
			"(context)"   : funct,
			"(breakage)"  : 0,
			"(loopage)"   : 0,
			"(metrics)"   : createMetrics(state.tokens.next),
			"(scope)"     : scope,
			"(statement)" : statement,
			"(tokens)"    : {},
			"(blockscope)": funct["(blockscope)"],
			"(comparray)" : funct["(comparray)"]
		};

		if (generator) {
			funct["(generator)"] = true;
		}

		f = funct;
		state.tokens.curr.funct = funct;

		functions.push(funct);

		if (name) {
			addlabel(name, "function");
		}

		funct["(params)"] = functionparams(fatarrowparams);

		funct["(metrics)"].verifyMaxParametersPerFunction(funct["(params)"]);

		block(false, true, true, fatarrowparams ? true:false);

		if (generator && funct["(generator)"] !== "yielded") {
			error("E047", state.tokens.curr);
		}

		funct["(metrics)"].verifyMaxStatementsPerFunction();
		funct["(metrics)"].verifyMaxComplexityPerFunction();
		funct["(unusedOption)"] = state.option.unused;

		scope = oldScope;
		state.option = oldOption;
		state.ignored = oldIgnored;
		funct["(last)"] = state.tokens.curr.line;
		funct["(lastcharacter)"] = state.tokens.curr.character;
		funct = funct["(context)"];

		return f;
	}

	function createMetrics(functionStartToken) {
		return {
			statementCount: 0,
			nestedBlockDepth: -1,
			ComplexityCount: 1,
			verifyMaxStatementsPerFunction: function () {
				if (state.option.maxstatements &&
					this.statementCount > state.option.maxstatements) {
					warning("W071", functionStartToken, this.statementCount);
				}
			},

			verifyMaxParametersPerFunction: function (params) {
				params = params || [];

				if (state.option.maxparams && params.length > state.option.maxparams) {
					warning("W072", functionStartToken, params.length);
				}
			},

			verifyMaxNestedBlockDepthPerFunction: function () {
				if (state.option.maxdepth &&
					this.nestedBlockDepth > 0 &&
					this.nestedBlockDepth === state.option.maxdepth + 1) {
					warning("W073", null, this.nestedBlockDepth);
				}
			},

			verifyMaxComplexityPerFunction: function () {
				var max = state.option.maxcomplexity;
				var cc = this.ComplexityCount;
				if (max && cc > max) {
					warning("W074", functionStartToken, cc);
				}
			}
		};
	}

	function increaseComplexityCount() {
		funct["(metrics)"].ComplexityCount += 1;
	}

	// Parse assignments that were found instead of conditionals.
	// For example: if (a = 1) { ... }

	function checkCondAssignment(expr) {
		var id, paren;
		if (expr) {
			id = expr.id;
			paren = expr.paren;
			if (id === "," && (expr = expr.exprs[expr.exprs.length - 1])) {
				id = expr.id;
				paren = paren || expr.paren;
			}
		}
		switch (id) {
		case "=":
		case "+=":
		case "-=":
		case "*=":
		case "%=":
		case "&=":
		case "|=":
		case "^=":
		case "/=":
			if (!paren && !state.option.boss) {
				warning("W084");
			}
		}
	}


	(function (x) {
		x.nud = function (isclassdef) {
			var b, f, i, p, t, g;
			var props = {}; // All properties, including accessors
			var tag = "";

			function saveProperty(name, tkn) {
				if (props[name] && _.has(props, name))
					warning("W075", state.tokens.next, i);
				else
					props[name] = {};

				props[name].basic = true;
				props[name].basictkn = tkn;
			}

			function saveSetter(name, tkn) {
				if (props[name] && _.has(props, name)) {
					if (props[name].basic || props[name].setter)
						warning("W075", state.tokens.next, i);
				} else {
					props[name] = {};
				}

				props[name].setter = true;
				props[name].setterToken = tkn;
			}

			function saveGetter(name) {
				if (props[name] && _.has(props, name)) {
					if (props[name].basic || props[name].getter)
						warning("W075", state.tokens.next, i);
				} else {
					props[name] = {};
				}

				props[name].getter = true;
				props[name].getterToken = state.tokens.curr;
			}

			b = state.tokens.curr.line !== state.tokens.next.line;
			if (b) {
				indent += state.option.indent;
				if (state.tokens.next.from === indent + state.option.indent) {
					indent += state.option.indent;
				}
			}

			for (;;) {
				if (state.tokens.next.id === "}") {
					break;
				}

				if (b) {
					indentation();
				}

				if (isclassdef && state.tokens.next.value === "static") {
					advance("static");
					tag = "static ";
				}

				if (state.tokens.next.value === "get" && peek().id !== ":") {
					advance("get");

					if (!state.option.inES5(!isclassdef)) {
						error("E034");
					}

					i = property_name();
					if (!i) {
						error("E035");
					}

					// It is a Syntax Error if PropName of MethodDefinition is
					// "constructor" and SpecialMethod of MethodDefinition is true.
					if (isclassdef && i === "constructor") {
						error("E049", state.tokens.next, "class getter method", i);
					}

					saveGetter(tag + i);
					t = state.tokens.next;
					adjacent(state.tokens.curr, state.tokens.next);
					f = doFunction();
					p = f["(params)"];

					if (p) {
						warning("W076", t, p[0], i);
					}

					adjacent(state.tokens.curr, state.tokens.next);
				} else if (state.tokens.next.value === "set" && peek().id !== ":") {
					advance("set");

					if (!state.option.inES5(!isclassdef)) {
						error("E034");
					}

					i = property_name();
					if (!i) {
						error("E035");
					}

					// It is a Syntax Error if PropName of MethodDefinition is
					// "constructor" and SpecialMethod of MethodDefinition is true.
					if (isclassdef && i === "constructor") {
						error("E049", state.tokens.next, "class setter method", i);
					}

					saveSetter(tag + i, state.tokens.next);
					t = state.tokens.next;
					adjacent(state.tokens.curr, state.tokens.next);
					f = doFunction();
					p = f["(params)"];

					if (!p || p.length !== 1) {
						warning("W077", t, i);
					}
				} else {
					g = false;
					if (state.tokens.next.value === "*" && state.tokens.next.type === "(punctuator)") {
						if (!state.option.inESNext()) {
							warning("W104", state.tokens.next, "generator functions");
						}
						advance("*");
						g = true;
					}
					i = property_name();
					saveProperty(tag + i, state.tokens.next);

					if (typeof i !== "string") {
						break;
					}

					if (state.tokens.next.value === "(") {
						if (!state.option.inESNext()) {
							warning("W104", state.tokens.curr, "concise methods");
						}
						doFunction(i, undefined, g);
					} else if (!isclassdef) {
						advance(":");
						nonadjacent(state.tokens.curr, state.tokens.next);
						expression(10);
					}
				}
				// It is a Syntax Error if PropName of MethodDefinition is "prototype".
				if (isclassdef && i === "prototype") {
					error("E049", state.tokens.next, "class method", i);
				}

				countMember(i);
				if (isclassdef) {
					tag = "";
					continue;
				}
				if (state.tokens.next.id === ",") {
					comma({ allowTrailing: true, property: true });
					if (state.tokens.next.id === ",") {
						warning("W070", state.tokens.curr);
					} else if (state.tokens.next.id === "}" && !state.option.inES5(true)) {
						warning("W070", state.tokens.curr);
					}
				} else {
					break;
				}
			}
			if (b) {
				indent -= state.option.indent;
				indentation();
			}
			advance("}", this);

			// Check for lonely setters if in the ES5 mode.
			if (state.option.inES5()) {
				for (var name in props) {
					if (_.has(props, name) && props[name].setter && !props[name].getter) {
						warning("W078", props[name].setterToken);
					}
				}
			}
			return this;
		};
		x.fud = function () {
			error("E036", state.tokens.curr);
		};
	}(delim("{")));

	function destructuringExpression() {
		var id, ids;
		var identifiers = [];
		if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "destructuring expression");
		}
		var nextInnerDE = function () {
			var ident;
			if (_.contains(["[", "{"], state.tokens.next.value)) {
				ids = destructuringExpression();
				for (var id in ids) {
					id = ids[id];
					identifiers.push({ id: id.id, token: id.token });
				}
			} else if (state.tokens.next.value === ",") {
				identifiers.push({ id: null, token: state.tokens.curr });
			} else {
				ident = identifier();
				if (ident)
					identifiers.push({ id: ident, token: state.tokens.curr });
			}
		};
		if (state.tokens.next.value === "[") {
			advance("[");
			nextInnerDE();
			while (state.tokens.next.value !== "]") {
				advance(",");
				nextInnerDE();
			}
			advance("]");
		} else if (state.tokens.next.value === "{") {
			advance("{");
			id = identifier();
			if (state.tokens.next.value === ":") {
				advance(":");
				nextInnerDE();
			} else {
				identifiers.push({ id: id, token: state.tokens.curr });
			}
			while (state.tokens.next.value !== "}") {
				advance(",");
				id = identifier();
				if (state.tokens.next.value === ":") {
					advance(":");
					nextInnerDE();
				} else {
					identifiers.push({ id: id, token: state.tokens.curr });
				}
			}
			advance("}");
		}
		return identifiers;
	}
	function destructuringExpressionMatch(tokens, value) {
		if (value.first) {
			_.zip(tokens, value.first).forEach(function (val) {
				var token = val[0];
				var value = val[1];
				if (token && value) {
					token.first = value;
				} else if (token && token.first && !value) {
					warning("W080", token.first, token.first.value);
				} /* else {
					XXX value is discarded: wouldn't it need a warning ?
				} */
			});
		}
	}

	var conststatement = stmt("const", function (prefix) {
		var tokens, value;
		// state variable to know if it is a lone identifier, or a destructuring statement.
		var lone;

		if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "const");
		}

		this.first = [];
		for (;;) {
			var names = [];
			nonadjacent(state.tokens.curr, state.tokens.next);
			if (_.contains(["{", "["], state.tokens.next.value)) {
				tokens = destructuringExpression();
				lone = false;
			} else {
				tokens = [ { id: identifier(), token: state.tokens.curr } ];
				lone = true;
			}
			for (var t in tokens) {
				t = tokens[t];
				if (funct[t.id] === "const") {
					warning("E011", null, t.id);
				}
				if (funct["(global)"] && predefined[t.id] === false) {
					warning("W079", t.token, t.id);
				}
				if (t.id) {
					addlabel(t.id, "const");
					names.push(t.token);
				}
			}
			if (prefix) {
				break;
			}

			this.first = this.first.concat(names);

			if (state.tokens.next.id !== "=") {
				warning("E012", state.tokens.curr, state.tokens.curr.value);
			}

			if (state.tokens.next.id === "=") {
				nonadjacent(state.tokens.curr, state.tokens.next);
				advance("=");
				nonadjacent(state.tokens.curr, state.tokens.next);
				if (state.tokens.next.id === "undefined") {
					warning("W080", state.tokens.prev, state.tokens.prev.value);
				}
				if (peek(0).id === "=" && state.tokens.next.identifier) {
					error("E037", state.tokens.next, state.tokens.next.value);
				}
				value = expression(5);
				if (lone) {
					tokens[0].first = value;
				} else {
					destructuringExpressionMatch(names, value);
				}
			}

			if (state.tokens.next.id !== ",") {
				break;
			}
			comma();
		}
		return this;
	});
	conststatement.exps = true;
	var varstatement = stmt("var", function (prefix) {
		// JavaScript does not have block scope. It only has function scope. So,
		// declaring a variable in a block can have unexpected consequences.
		var tokens, lone, value;

		if (funct["(onevar)"] && state.option.onevar) {
			warning("W081");
		} else if (!funct["(global)"]) {
			funct["(onevar)"] = true;
		}

		this.first = [];
		for (;;) {
			var names = [];
			nonadjacent(state.tokens.curr, state.tokens.next);
			if (_.contains(["{", "["], state.tokens.next.value)) {
				tokens = destructuringExpression();
				lone = false;
			} else {
				tokens = [ { id: identifier(), token: state.tokens.curr } ];
				lone = true;
			}
			for (var t in tokens) {
				t = tokens[t];
				if (state.option.inESNext() && funct[t.id] === "const") {
					warning("E011", null, t.id);
				}
				if (funct["(global)"] && predefined[t.id] === false) {
					warning("W079", t.token, t.id);
				}
				if (t.id) {
					addlabel(t.id, "unused", t.token);
					names.push(t.token);
				}
			}
			if (prefix) {
				break;
			}

			this.first = this.first.concat(names);

			if (state.tokens.next.id === "=") {
				nonadjacent(state.tokens.curr, state.tokens.next);
				advance("=");
				nonadjacent(state.tokens.curr, state.tokens.next);
				if (state.tokens.next.id === "undefined") {
					warning("W080", state.tokens.prev, state.tokens.prev.value);
				}
				if (peek(0).id === "=" && state.tokens.next.identifier) {
					error("E038", state.tokens.next, state.tokens.next.value);
				}
				value = expression(5);
				if (lone) {
					tokens[0].first = value;
				} else {
					destructuringExpressionMatch(names, value);
				}
			}

			if (state.tokens.next.id !== ",") {
				break;
			}
			comma();
		}
		return this;
	});
	varstatement.exps = true;
	var letstatement = stmt("let", function (prefix) {
		var tokens, lone, value, letblock;

		if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "let");
		}

		if (state.tokens.next.value === "(") {
			if (!state.option.inMoz(true)) {
				warning("W118", state.tokens.next, "let block");
			}
			advance("(");
			funct["(blockscope)"].stack();
			letblock = true;
		} else if (funct["(nolet)"]) {
			error("E048", state.tokens.curr);
		}

		if (funct["(onevar)"] && state.option.onevar) {
			warning("W081");
		} else if (!funct["(global)"]) {
			funct["(onevar)"] = true;
		}

		this.first = [];
		for (;;) {
			var names = [];
			nonadjacent(state.tokens.curr, state.tokens.next);
			if (_.contains(["{", "["], state.tokens.next.value)) {
				tokens = destructuringExpression();
				lone = false;
			} else {
				tokens = [ { id: identifier(), token: state.tokens.curr.value } ];
				lone = true;
			}
			for (var t in tokens) {
				t = tokens[t];
				if (state.option.inESNext() && funct[t.id] === "const") {
					warning("E011", null, t.id);
				}
				if (funct["(global)"] && predefined[t.id] === false) {
					warning("W079", t.token, t.id);
				}
				if (t.id && !funct["(nolet)"]) {
					addlabel(t.id, "unused", t.token, true);
					names.push(t.token);
				}
			}
			if (prefix) {
				break;
			}

			this.first = this.first.concat(names);

			if (state.tokens.next.id === "=") {
				nonadjacent(state.tokens.curr, state.tokens.next);
				advance("=");
				nonadjacent(state.tokens.curr, state.tokens.next);
				if (state.tokens.next.id === "undefined") {
					warning("W080", state.tokens.prev, state.tokens.prev.value);
				}
				if (peek(0).id === "=" && state.tokens.next.identifier) {
					error("E037", state.tokens.next, state.tokens.next.value);
				}
				value = expression(5);
				if (lone) {
					tokens[0].first = value;
				} else {
					destructuringExpressionMatch(names, value);
				}
			}

			if (state.tokens.next.id !== ",") {
				break;
			}
			comma();
		}
		if (letblock) {
			advance(")");
			block(true, true);
			this.block = true;
			funct["(blockscope)"].unstack();
		}

		return this;
	});
	letstatement.exps = true;

	blockstmt("class", function () {
		return classdef.call(this, true);
	});

	function classdef(stmt) {
		/*jshint validthis:true */
		if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "class");
		}
		if (stmt) {
			// BindingIdentifier
			this.name = identifier();
			addlabel(this.name, "unused", state.tokens.curr);
		} else if (state.tokens.next.identifier && state.tokens.next.value !== "extends") {
			// BindingIdentifier(opt)
			this.name = identifier();
		}
		classtail(this);
		return this;
	}

	function classtail(c) {
		var strictness = state.directive["use strict"];

		// ClassHeritage(opt)
		if (state.tokens.next.value === "extends") {
			advance("extends");
			c.heritage = expression(10);
		}

		// A ClassBody is always strict code.
		state.directive["use strict"] = true;
		advance("{");
		// ClassBody(opt)
		c.body = state.syntax["{"].nud(true);
		state.directive["use strict"] = strictness;
	}

	blockstmt("function", function () {
		var generator = false;
		if (state.tokens.next.value === "*") {
			advance("*");
			if (state.option.inESNext(true)) {
				generator = true;
			} else {
				warning("W119", state.tokens.curr, "function*");
			}
		}
		if (inblock) {
			warning("W082", state.tokens.curr);

		}
		var i = identifier();
		if (funct[i] === "const") {
			warning("E011", null, i);
		}
		adjacent(state.tokens.curr, state.tokens.next);
		addlabel(i, "unction", state.tokens.curr);

		doFunction(i, { statement: true }, generator);
		if (state.tokens.next.id === "(" && state.tokens.next.line === state.tokens.curr.line) {
			error("E039");
		}
		return this;
	});

	prefix("function", function () {
		var generator = false;
		if (state.tokens.next.value === "*") {
			if (!state.option.inESNext()) {
				warning("W119", state.tokens.curr, "function*");
			}
			advance("*");
			generator = true;
		}
		var i = optionalidentifier();
		if (i || state.option.gcl) {
			adjacent(state.tokens.curr, state.tokens.next);
		} else {
			nonadjacent(state.tokens.curr, state.tokens.next);
		}
		doFunction(i, undefined, generator);
		if (!state.option.loopfunc && funct["(loopage)"]) {
			warning("W083");
		}
		return this;
	});

	blockstmt("if", function () {
		var t = state.tokens.next;
		increaseComplexityCount();
		state.condition = true;
		advance("(");
		nonadjacent(this, t);
		nospace();
		checkCondAssignment(expression(0));
		advance(")", t);
		state.condition = false;
		nospace(state.tokens.prev, state.tokens.curr);
		block(true, true);
		if (state.tokens.next.id === "else") {
			nonadjacent(state.tokens.curr, state.tokens.next);
			advance("else");
			if (state.tokens.next.id === "if" || state.tokens.next.id === "switch") {
				statement(true);
			} else {
				block(true, true);
			}
		}
		return this;
	});

	blockstmt("try", function () {
		var b;

		function doCatch() {
			var oldScope = scope;
			var e;

			advance("catch");
			nonadjacent(state.tokens.curr, state.tokens.next);
			advance("(");

			scope = Object.create(oldScope);

			e = state.tokens.next.value;
			if (state.tokens.next.type !== "(identifier)") {
				e = null;
				warning("E030", state.tokens.next, e);
			}

			advance();

			funct = {
				"(name)"     : "(catch)",
				"(line)"     : state.tokens.next.line,
				"(character)": state.tokens.next.character,
				"(context)"  : funct,
				"(breakage)" : funct["(breakage)"],
				"(loopage)"  : funct["(loopage)"],
				"(scope)"    : scope,
				"(statement)": false,
				"(metrics)"  : createMetrics(state.tokens.next),
				"(catch)"    : true,
				"(tokens)"   : {},
				"(blockscope)": funct["(blockscope)"],
				"(comparray)": funct["(comparray)"]
			};

			if (e) {
				addlabel(e, "exception");
			}

			if (state.tokens.next.value === "if") {
				if (!state.option.inMoz(true)) {
					warning("W118", state.tokens.curr, "catch filter");
				}
				advance("if");
				expression(0);
			}

			advance(")");

			state.tokens.curr.funct = funct;
			functions.push(funct);

			block(false);

			scope = oldScope;

			funct["(last)"] = state.tokens.curr.line;
			funct["(lastcharacter)"] = state.tokens.curr.character;
			funct = funct["(context)"];
		}

		block(false);

		while (state.tokens.next.id === "catch") {
			increaseComplexityCount();
			if (b && (!state.option.inMoz(true))) {
				warning("W118", state.tokens.next, "multiple catch blocks");
			}
			doCatch();
			b = true;
		}

		if (state.tokens.next.id === "finally") {
			advance("finally");
			block(false);
			return;
		}

		if (!b) {
			error("E021", state.tokens.next, "catch", state.tokens.next.value);
		}

		return this;
	});

	blockstmt("while", function () {
		var t = state.tokens.next;
		funct["(breakage)"] += 1;
		funct["(loopage)"] += 1;
		increaseComplexityCount();
		advance("(");
		nonadjacent(this, t);
		nospace();
		checkCondAssignment(expression(0));
		advance(")", t);
		nospace(state.tokens.prev, state.tokens.curr);
		block(true, true);
		funct["(breakage)"] -= 1;
		funct["(loopage)"] -= 1;
		return this;
	}).labelled = true;

	blockstmt("with", function () {
		var t = state.tokens.next;
		if (state.directive["use strict"]) {
			error("E010", state.tokens.curr);
		} else if (!state.option.withstmt) {
			warning("W085", state.tokens.curr);
		}

		advance("(");
		nonadjacent(this, t);
		nospace();
		expression(0);
		advance(")", t);
		nospace(state.tokens.prev, state.tokens.curr);
		block(true, true);

		return this;
	});

	blockstmt("switch", function () {
		var t = state.tokens.next,
			g = false;
		funct["(breakage)"] += 1;
		advance("(");
		nonadjacent(this, t);
		nospace();
		checkCondAssignment(expression(0));
		advance(")", t);
		nospace(state.tokens.prev, state.tokens.curr);
		nonadjacent(state.tokens.curr, state.tokens.next);
		t = state.tokens.next;
		advance("{");
		nonadjacent(state.tokens.curr, state.tokens.next);
		indent += state.option.indent;
		this.cases = [];

		for (;;) {
			switch (state.tokens.next.id) {
			case "case":
				switch (funct["(verb)"]) {
				case "yield":
				case "break":
				case "case":
				case "continue":
				case "return":
				case "switch":
				case "throw":
					break;
				default:
					// You can tell JSHint that you don't use break intentionally by
					// adding a comment /* falls through */ on a line just before
					// the next `case`.
					if (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {
						warning("W086", state.tokens.curr, "case");
					}
				}
				indentation(-state.option.indent);
				advance("case");
				this.cases.push(expression(20));
				increaseComplexityCount();
				g = true;
				advance(":");
				funct["(verb)"] = "case";
				break;
			case "default":
				switch (funct["(verb)"]) {
				case "yield":
				case "break":
				case "continue":
				case "return":
				case "throw":
					break;
				default:
					// Do not display a warning if 'default' is the first statement or if
					// there is a special /* falls through */ comment.
					if (this.cases.length) {
						if (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {
							warning("W086", state.tokens.curr, "default");
						}
					}
				}
				indentation(-state.option.indent);
				advance("default");
				g = true;
				advance(":");
				break;
			case "}":
				indent -= state.option.indent;
				indentation();
				advance("}", t);
				funct["(breakage)"] -= 1;
				funct["(verb)"] = undefined;
				return;
			case "(end)":
				error("E023", state.tokens.next, "}");
				return;
			default:
				if (g) {
					switch (state.tokens.curr.id) {
					case ",":
						error("E040");
						return;
					case ":":
						g = false;
						statements();
						break;
					default:
						error("E025", state.tokens.curr);
						return;
					}
				} else {
					if (state.tokens.curr.id === ":") {
						advance(":");
						error("E024", state.tokens.curr, ":");
						statements();
					} else {
						error("E021", state.tokens.next, "case", state.tokens.next.value);
						return;
					}
				}
			}
		}
	}).labelled = true;

	stmt("debugger", function () {
		if (!state.option.debug) {
			warning("W087");
		}
		return this;
	}).exps = true;

	(function () {
		var x = stmt("do", function () {
			funct["(breakage)"] += 1;
			funct["(loopage)"] += 1;
			increaseComplexityCount();

			this.first = block(true, true);
			advance("while");
			var t = state.tokens.next;
			nonadjacent(state.tokens.curr, t);
			advance("(");
			nospace();
			checkCondAssignment(expression(0));
			advance(")", t);
			nospace(state.tokens.prev, state.tokens.curr);
			funct["(breakage)"] -= 1;
			funct["(loopage)"] -= 1;
			return this;
		});
		x.labelled = true;
		x.exps = true;
	}());

	blockstmt("for", function () {
		var s, t = state.tokens.next;
		var letscope = false;
		var foreachtok = null;

		if (t.value === "each") {
			foreachtok = t;
			advance("each");
			if (!state.option.inMoz(true)) {
				warning("W118", state.tokens.curr, "for each");
			}
		}

		funct["(breakage)"] += 1;
		funct["(loopage)"] += 1;
		increaseComplexityCount();
		advance("(");
		nonadjacent(this, t);
		nospace();

		// what kind of for() statement it is? for(of)? for(in)? for(;;)?
		var nextop; // contains the token of the "in" or "of" operator
		var i = 0;
		var inof = ["in", "of"];
		do {
			nextop = peek(i);
			++i;
		} while (!_.contains(inof, nextop.value) && nextop.value !== ";" &&
					nextop.type !== "(end)");

		// if we're in a for ( in|of ) statement
		if (_.contains(inof, nextop.value)) {
			if (!state.option.inESNext() && nextop.value === "of") {
				error("W104", nextop, "for of");
			}
			if (state.tokens.next.id === "var") {
				advance("var");
				state.syntax["var"].fud.call(state.syntax["var"].fud, true);
			} else if (state.tokens.next.id === "let") {
				advance("let");
				// create a new block scope
				letscope = true;
				funct["(blockscope)"].stack();
				state.syntax["let"].fud.call(state.syntax["let"].fud, true);
			} else {
				switch (funct[state.tokens.next.value]) {
				case "unused":
					funct[state.tokens.next.value] = "var";
					break;
				case "var":
					break;
				default:
					if (!funct["(blockscope)"].getlabel(state.tokens.next.value))
						warning("W088", state.tokens.next, state.tokens.next.value);
				}
				advance();
			}
			advance(nextop.value);
			expression(20);
			advance(")", t);
			s = block(true, true);
			if (state.option.forin && s && (s.length > 1 || typeof s[0] !== "object" ||
					s[0].value !== "if")) {
				warning("W089", this);
			}
			funct["(breakage)"] -= 1;
			funct["(loopage)"] -= 1;
		} else {
			if (foreachtok) {
				error("E045", foreachtok);
			}
			if (state.tokens.next.id !== ";") {
				if (state.tokens.next.id === "var") {
					advance("var");
					state.syntax["var"].fud.call(state.syntax["var"].fud);
				} else if (state.tokens.next.id === "let") {
					advance("let");
					// create a new block scope
					letscope = true;
					funct["(blockscope)"].stack();
					state.syntax["let"].fud.call(state.syntax["let"].fud);
				} else {
					for (;;) {
						expression(0, "for");
						if (state.tokens.next.id !== ",") {
							break;
						}
						comma();
					}
				}
			}
			nolinebreak(state.tokens.curr);
			advance(";");
			if (state.tokens.next.id !== ";") {
				checkCondAssignment(expression(0));
			}
			nolinebreak(state.tokens.curr);
			advance(";");
			if (state.tokens.next.id === ";") {
				error("E021", state.tokens.next, ")", ";");
			}
			if (state.tokens.next.id !== ")") {
				for (;;) {
					expression(0, "for");
					if (state.tokens.next.id !== ",") {
						break;
					}
					comma();
				}
			}
			advance(")", t);
			nospace(state.tokens.prev, state.tokens.curr);
			block(true, true);
			funct["(breakage)"] -= 1;
			funct["(loopage)"] -= 1;

		}
		// unstack loop blockscope
		if (letscope) {
			funct["(blockscope)"].unstack();
		}
		return this;
	}).labelled = true;


	stmt("break", function () {
		var v = state.tokens.next.value;

		if (funct["(breakage)"] === 0)
			warning("W052", state.tokens.next, this.value);

		if (!state.option.asi)
			nolinebreak(this);

		if (state.tokens.next.id !== ";" && !state.tokens.next.reach) {
			if (state.tokens.curr.line === state.tokens.next.line) {
				if (funct[v] !== "label") {
					warning("W090", state.tokens.next, v);
				} else if (scope[v] !== funct) {
					warning("W091", state.tokens.next, v);
				}
				this.first = state.tokens.next;
				advance();
			}
		}
		reachable("break");
		return this;
	}).exps = true;


	stmt("continue", function () {
		var v = state.tokens.next.value;

		if (funct["(breakage)"] === 0)
			warning("W052", state.tokens.next, this.value);

		if (!state.option.asi)
			nolinebreak(this);

		if (state.tokens.next.id !== ";" && !state.tokens.next.reach) {
			if (state.tokens.curr.line === state.tokens.next.line) {
				if (funct[v] !== "label") {
					warning("W090", state.tokens.next, v);
				} else if (scope[v] !== funct) {
					warning("W091", state.tokens.next, v);
				}
				this.first = state.tokens.next;
				advance();
			}
		} else if (!funct["(loopage)"]) {
			warning("W052", state.tokens.next, this.value);
		}
		reachable("continue");
		return this;
	}).exps = true;


	stmt("return", function () {
		if (this.line === state.tokens.next.line) {
			if (state.tokens.next.id === "(regexp)")
				warning("W092");

			if (state.tokens.next.id !== ";" && !state.tokens.next.reach) {
				nonadjacent(state.tokens.curr, state.tokens.next);
				this.first = expression(0);

				if (this.first &&
						this.first.type === "(punctuator)" && this.first.value === "=" && !state.option.boss) {
					warningAt("W093", this.first.line, this.first.character);
				}
			}
		} else {
			if (state.tokens.next.type === "(punctuator)" &&
				["[", "{", "+", "-"].indexOf(state.tokens.next.value) > -1) {
				nolinebreak(this); // always warn (Line breaking error)
			}
		}
		reachable("return");
		return this;
	}).exps = true;

	stmt("yield", function () {
		if (state.option.inESNext(true) && funct["(generator)"] !== true) {
			error("E046", state.tokens.curr, "yield");
		} else if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "yield");
		}
		funct["(generator)"] = "yielded";
		if (this.line === state.tokens.next.line) {
			if (state.tokens.next.id === "(regexp)")
				warning("W092");

			if (state.tokens.next.id !== ";" && !state.tokens.next.reach) {
				nonadjacent(state.tokens.curr, state.tokens.next);
				this.first = expression(0);

				if (this.first.type === "(punctuator)" && this.first.value === "=" && !state.option.boss) {
					warningAt("W093", this.first.line, this.first.character);
				}
			}
		} else if (!state.option.asi) {
			nolinebreak(this); // always warn (Line breaking error)
		}
		return this;
	}).exps = true;


	stmt("throw", function () {
		nolinebreak(this);
		nonadjacent(state.tokens.curr, state.tokens.next);
		this.first = expression(20);
		reachable("throw");
		return this;
	}).exps = true;

	// Future Reserved Words

	FutureReservedWord("abstract");
	FutureReservedWord("boolean");
	FutureReservedWord("byte");
	FutureReservedWord("char");
	FutureReservedWord("class", { es5: true, nud: classdef });
	FutureReservedWord("double");
	FutureReservedWord("enum", { es5: true });
	FutureReservedWord("export", { es5: true });
	FutureReservedWord("extends", { es5: true });
	FutureReservedWord("final");
	FutureReservedWord("float");
	FutureReservedWord("goto");
	FutureReservedWord("implements", { es5: true, strictOnly: true });
	FutureReservedWord("import", { es5: true });
	FutureReservedWord("int");
	FutureReservedWord("interface", { es5: true, strictOnly: true });
	FutureReservedWord("long");
	FutureReservedWord("native");
	FutureReservedWord("package", { es5: true, strictOnly: true });
	FutureReservedWord("private", { es5: true, strictOnly: true });
	FutureReservedWord("protected", { es5: true, strictOnly: true });
	FutureReservedWord("public", { es5: true, strictOnly: true });
	FutureReservedWord("short");
	FutureReservedWord("static", { es5: true, strictOnly: true });
	FutureReservedWord("super", { es5: true });
	FutureReservedWord("synchronized");
	FutureReservedWord("throws");
	FutureReservedWord("transient");
	FutureReservedWord("volatile");

	// this function is used to determine wether a squarebracket or a curlybracket
	// expression is a comprehension array, destructuring assignment or a json value.

	var lookupBlockType = function () {
		var pn, pn1;
		var i = 0;
		var bracketStack = 0;
		var ret = {};
		if (_.contains(["[", "{"], state.tokens.curr.value))
			bracketStack += 1;
		if (_.contains(["[", "{"], state.tokens.next.value))
			bracketStack += 1;
		if (_.contains(["]", "}"], state.tokens.next.value))
			bracketStack -= 1;
		do {
			pn = peek(i);
			pn1 = peek(i + 1);
			i = i + 1;
			if (_.contains(["[", "{"], pn.value)) {
				bracketStack += 1;
			} else if (_.contains(["]", "}"], pn.value)) {
				bracketStack -= 1;
			}
			if (pn.identifier && pn.value === "for" && bracketStack === 1) {
				ret.isCompArray = true;
				ret.notJson = true;
				break;
			}
			if (_.contains(["}", "]"], pn.value) && pn1.value === "=") {
				ret.isDestAssign = true;
				ret.notJson = true;
				break;
			}
			if (pn.value === ";") {
				ret.isBlock = true;
				ret.notJson = true;
			}
		} while (bracketStack > 0 && pn.id !== "(end)" && i < 15);
		return ret;
	};

	// Check whether this function has been reached for a destructuring assign with undeclared values
	function destructuringAssignOrJsonValue() {
		// lookup for the assignment (esnext only)
		// if it has semicolons, it is a block, so go parse it as a block
		// or it's not a block, but there are assignments, check for undeclared variables

		var block = lookupBlockType();
		if (block.notJson) {
			if (!state.option.inESNext() && block.isDestAssign) {
				warning("W104", state.tokens.curr, "destructuring assignment");
			}
			statements();
		// otherwise parse json value
		} else {
			state.option.laxbreak = true;
			state.jsonMode = true;
			jsonValue();
		}
	}

	// array comprehension parsing function
	// parses and defines the three states of the list comprehension in order
	// to avoid defining global variables, but keeping them to the list comprehension scope
	// only. The order of the states are as follows:
	//  * "use" which will be the returned iterative part of the list comprehension
	//  * "define" which will define the variables local to the list comprehension
	//  * "filter" which will help filter out values

	var arrayComprehension = function () {
		var CompArray = function () {
			this.mode = "use";
			this.variables = [];
		};
		var _carrays = [];
		var _current;
		function declare(v) {
			var l = _current.variables.filter(function (elt) {
				// if it has, change its undef state
				if (elt.value === v) {
					elt.undef = false;
					return v;
				}
			}).length;
			return l !== 0;
		}
		function use(v) {
			var l = _current.variables.filter(function (elt) {
				// and if it has been defined
				if (elt.value === v && !elt.undef) {
					if (elt.unused === true) {
						elt.unused = false;
					}
					return v;
				}
			}).length;
			// otherwise we warn about it
			return (l === 0);
		}
		return {stack: function () {
					_current = new CompArray();
					_carrays.push(_current);
				},
				unstack: function () {
					_current.variables.filter(function (v) {
						if (v.unused)
							warning("W098", v.token, v.value);
						if (v.undef)
							isundef(v.funct, "W117", v.token, v.value);
					});
					_carrays.splice(_carrays[_carrays.length - 1], 1);
					_current = _carrays[_carrays.length - 1];
				},
				setState: function (s) {
					if (_.contains(["use", "define", "filter"], s))
						_current.mode = s;
				},
				check: function (v) {
					// When we are in "use" state of the list comp, we enqueue that var
					if (_current && _current.mode === "use") {
						_current.variables.push({funct: funct,
													token: state.tokens.curr,
													value: v,
													undef: true,
													unused: false});
						return true;
					// When we are in "define" state of the list comp,
					} else if (_current && _current.mode === "define") {
						// check if the variable has been used previously
						if (!declare(v)) {
							_current.variables.push({funct: funct,
														token: state.tokens.curr,
														value: v,
														undef: false,
														unused: true});
						}
						return true;
					// When we are in "filter" state,
					} else if (_current && _current.mode === "filter") {
						// we check whether current variable has been declared
						if (use(v)) {
							// if not we warn about it
							isundef(funct, "W117", state.tokens.curr, v);
						}
						return true;
					}
					return false;
				}
				};
	};


	// Parse JSON

	function jsonValue() {

		function jsonObject() {
			var o = {}, t = state.tokens.next;
			advance("{");
			if (state.tokens.next.id !== "}") {
				for (;;) {
					if (state.tokens.next.id === "(end)") {
						error("E026", state.tokens.next, t.line);
					} else if (state.tokens.next.id === "}") {
						warning("W094", state.tokens.curr);
						break;
					} else if (state.tokens.next.id === ",") {
						error("E028", state.tokens.next);
					} else if (state.tokens.next.id !== "(string)") {
						warning("W095", state.tokens.next, state.tokens.next.value);
					}
					if (o[state.tokens.next.value] === true) {
						warning("W075", state.tokens.next, state.tokens.next.value);
					} else if ((state.tokens.next.value === "__proto__" &&
						!state.option.proto) || (state.tokens.next.value === "__iterator__" &&
						!state.option.iterator)) {
						warning("W096", state.tokens.next, state.tokens.next.value);
					} else {
						o[state.tokens.next.value] = true;
					}
					advance();
					advance(":");
					jsonValue();
					if (state.tokens.next.id !== ",") {
						break;
					}
					advance(",");
				}
			}
			advance("}");
		}

		function jsonArray() {
			var t = state.tokens.next;
			advance("[");
			if (state.tokens.next.id !== "]") {
				for (;;) {
					if (state.tokens.next.id === "(end)") {
						error("E027", state.tokens.next, t.line);
					} else if (state.tokens.next.id === "]") {
						warning("W094", state.tokens.curr);
						break;
					} else if (state.tokens.next.id === ",") {
						error("E028", state.tokens.next);
					}
					jsonValue();
					if (state.tokens.next.id !== ",") {
						break;
					}
					advance(",");
				}
			}
			advance("]");
		}

		switch (state.tokens.next.id) {
		case "{":
			jsonObject();
			break;
		case "[":
			jsonArray();
			break;
		case "true":
		case "false":
		case "null":
		case "(number)":
		case "(string)":
			advance();
			break;
		case "-":
			advance("-");
			if (state.tokens.curr.character !== state.tokens.next.from) {
				warning("W011", state.tokens.curr);
			}
			adjacent(state.tokens.curr, state.tokens.next);
			advance("(number)");
			break;
		default:
			error("E003", state.tokens.next);
		}
	}

	var blockScope = function () {
		var _current = {};
		var _variables = [_current];

		function _checkBlockLabels() {
			for (var t in _current) {
				if (_current[t]["(type)"] === "unused") {
					if (state.option.unused) {
						var tkn = _current[t]["(token)"];
						var line = tkn.line;
						var chr  = tkn.character;
						warningAt("W098", line, chr, t);
					}
				}
			}
		}

		return {
			stack: function () {
				_current = {};
				_variables.push(_current);
			},

			unstack: function () {
				_checkBlockLabels();
				_variables.splice(_variables.length - 1, 1);
				_current = _.last(_variables);
			},

			getlabel: function (l) {
				for (var i = _variables.length - 1 ; i >= 0; --i) {
					if (_.has(_variables[i], l)) {
						return _variables[i];
					}
				}
			},

			current: {
				has: function (t) {
					return _.has(_current, t);
				},
				add: function (t, type, tok) {
					_current[t] = { "(type)" : type,
									"(token)": tok };
				}
			}
		};
	};

	// The actual JSHINT function itself.
	var itself = function (s, o, g) {
		var i, k, x;
		var optionKeys;
		var newOptionObj = {};
		var newIgnoredObj = {};

		state.reset();

		if (o && o.scope) {
			JSHINT.scope = o.scope;
		} else {
			JSHINT.errors = [];
			JSHINT.undefs = [];
			JSHINT.internals = [];
			JSHINT.blacklist = {};
			JSHINT.scope = "(main)";
		}

		predefined = Object.create(null);
		combine(predefined, vars.ecmaIdentifiers);
		combine(predefined, vars.reservedVars);

		combine(predefined, g || {});

		declared = Object.create(null);
		exported = Object.create(null);

		function each(obj, cb) {
			if (!obj)
				return;

			if (!Array.isArray(obj) && typeof obj === "object")
				obj = Object.keys(obj);

			obj.forEach(cb);
		}

		if (o) {
			each(o.predef || null, function (item) {
				var slice, prop;

				if (item[0] === "-") {
					slice = item.slice(1);
					JSHINT.blacklist[slice] = slice;
				} else {
					prop = Object.getOwnPropertyDescriptor(o.predef, item);
					predefined[item] = prop ? prop.value : false;
				}
			});

			each(o.exported || null, function (item) {
				exported[item] = true;
			});

			delete o.predef;
			delete o.exported;

			optionKeys = Object.keys(o);
			for (x = 0; x < optionKeys.length; x++) {
				if (/^-W\d{3}$/g.test(optionKeys[x])) {
					newIgnoredObj[optionKeys[x].slice(1)] = true;
				} else {
					newOptionObj[optionKeys[x]] = o[optionKeys[x]];

					if (optionKeys[x] === "newcap" && o[optionKeys[x]] === false)
						newOptionObj["(explicitNewcap)"] = true;

					if (optionKeys[x] === "indent")
						newOptionObj["(explicitIndent)"] = o[optionKeys[x]] === false ? false : true;
				}
			}
		}

		state.option = newOptionObj;
		state.ignored = newIgnoredObj;

		state.option.indent = state.option.indent || 4;
		state.option.maxerr = state.option.maxerr || 50;

		indent = 1;
		global = Object.create(predefined);
		scope = global;
		funct = {
			"(global)":   true,
			"(name)":	  "(global)",
			"(scope)":	  scope,
			"(breakage)": 0,
			"(loopage)":  0,
			"(tokens)":   {},
			"(metrics)":   createMetrics(state.tokens.next),
			"(blockscope)": blockScope(),
			"(comparray)": arrayComprehension()
		};
		functions = [funct];
		urls = [];
		stack = null;
		member = {};
		membersOnly = null;
		implied = {};
		inblock = false;
		lookahead = [];
		warnings = 0;
		unuseds = [];

		if (!isString(s) && !Array.isArray(s)) {
			errorAt("E004", 0);
			return false;
		}

		api = {
			get isJSON() {
				return state.jsonMode;
			},

			getOption: function (name) {
				return state.option[name] || null;
			},

			getCache: function (name) {
				return state.cache[name];
			},

			setCache: function (name, value) {
				state.cache[name] = value;
			},

			warn: function (code, data) {
				warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
			},

			on: function (names, listener) {
				names.split(" ").forEach(function (name) {
					emitter.on(name, listener);
				}.bind(this));
			}
		};

		emitter.removeAllListeners();
		(extraModules || []).forEach(function (func) {
			func(api);
		});

		state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax["(begin)"];

		lex = new Lexer(s);

		lex.on("warning", function (ev) {
			warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
		});

		lex.on("error", function (ev) {
			errorAt.apply(null, [ ev.code, ev.line, ev.character ].concat(ev.data));
		});

		lex.on("fatal", function (ev) {
			quit("E041", ev.line, ev.from);
		});

		lex.on("Identifier", function (ev) {
			emitter.emit("Identifier", ev);
		});

		lex.on("String", function (ev) {
			emitter.emit("String", ev);
		});

		lex.on("Number", function (ev) {
			emitter.emit("Number", ev);
		});

		lex.start();

		// Check options
		for (var name in o) {
			if (_.has(o, name)) {
				checkOption(name, state.tokens.curr);
			}
		}

		assume();

		// combine the passed globals after we've assumed all our options
		combine(predefined, g || {});

		//reset values
		comma.first = true;

		try {
			advance();
			switch (state.tokens.next.id) {
			case "{":
			case "[":
				destructuringAssignOrJsonValue();
				break;
			default:
				directives();

				if (state.directive["use strict"]) {
					if (!state.option.globalstrict && !state.option.node) {
						warning("W097", state.tokens.prev);
					}
				}

				statements();
			}
			advance((state.tokens.next && state.tokens.next.value !== ".")	? "(end)" : undefined);
			funct["(blockscope)"].unstack();

			var markDefined = function (name, context) {
				do {
					if (typeof context[name] === "string") {
						// JSHINT marks unused variables as 'unused' and
						// unused function declaration as 'unction'. This
						// code changes such instances back 'var' and
						// 'closure' so that the code in JSHINT.data()
						// doesn't think they're unused.

						if (context[name] === "unused")
							context[name] = "var";
						else if (context[name] === "unction")
							context[name] = "closure";

						return true;
					}

					context = context["(context)"];
				} while (context);

				return false;
			};

			var clearImplied = function (name, line) {
				if (!implied[name])
					return;

				var newImplied = [];
				for (var i = 0; i < implied[name].length; i += 1) {
					if (implied[name][i] !== line)
						newImplied.push(implied[name][i]);
				}

				if (newImplied.length === 0)
					delete implied[name];
				else
					implied[name] = newImplied;
			};

			var warnUnused = function (name, tkn, type, unused_opt) {
				var line = tkn.line;
				var chr  = tkn.character;

				if (unused_opt === undefined) {
					unused_opt = state.option.unused;
				}

				if (unused_opt === true) {
					unused_opt = "last-param";
				}

				var warnable_types = {
					"vars": ["var"],
					"last-param": ["var", "param"],
					"strict": ["var", "param", "last-param"]
				};

				if (unused_opt) {
					if (warnable_types[unused_opt] && warnable_types[unused_opt].indexOf(type) !== -1) {
						warningAt("W098", line, chr, name);
					}
				}

				unuseds.push({
					name: name,
					line: line,
					character: chr
				});
			};

			var checkUnused = function (func, key) {
				var type = func[key];
				var tkn = func["(tokens)"][key];

				if (key.charAt(0) === "(")
					return;

				if (type !== "unused" && type !== "unction")
					return;

				// Params are checked separately from other variables.
				if (func["(params)"] && func["(params)"].indexOf(key) !== -1)
					return;

				// Variable is in global scope and defined as exported.
				if (func["(global)"] && _.has(exported, key)) {
					return;
				}

				warnUnused(key, tkn, "var");
			};

			// Check queued 'x is not defined' instances to see if they're still undefined.
			for (i = 0; i < JSHINT.undefs.length; i += 1) {
				k = JSHINT.undefs[i].slice(0);

				if (markDefined(k[2].value, k[0])) {
					clearImplied(k[2].value, k[2].line);
				} else if (state.option.undef) {
					warning.apply(warning, k.slice(1));
				}
			}

			functions.forEach(function (func) {
				if (func["(unusedOption)"] === false) {
					return;
				}

				for (var key in func) {
					if (_.has(func, key)) {
						checkUnused(func, key);
					}
				}

				if (!func["(params)"])
					return;

				var params = func["(params)"].slice();
				var param  = params.pop();
				var type, unused_opt;

				while (param) {
					type = func[param];
					unused_opt = func["(unusedOption)"] || state.option.unused;
					unused_opt = unused_opt === true ? "last-param" : unused_opt;

					// 'undefined' is a special case for (function (window, undefined) { ... })();
					// patterns.

					if (param === "undefined")
						return;

					if (type === "unused" || type === "unction") {
						warnUnused(param, func["(tokens)"][param], "param", func["(unusedOption)"]);
					} else if (unused_opt === "last-param") {
						return;
					}

					param = params.pop();
				}
			});

			for (var key in declared) {
				if (_.has(declared, key) && !_.has(global, key)) {
					warnUnused(key, declared[key], "var");
				}
			}

		} catch (err) {
			if (err && err.name === "JSHintError") {
				var nt = state.tokens.next || {};
				JSHINT.errors.push({
					scope     : "(main)",
					raw       : err.raw,
					reason    : err.message,
					line      : err.line || nt.line,
					character : err.character || nt.from
				}, null);
			} else {
				throw err;
			}
		}

		// Loop over the listed "internals", and check them as well.

		if (JSHINT.scope === "(main)") {
			o = o || {};

			for (i = 0; i < JSHINT.internals.length; i += 1) {
				k = JSHINT.internals[i];
				o.scope = k.elem;
				itself(k.value, o, g);
			}
		}

		return JSHINT.errors.length === 0;
	};

	// Modules.
	itself.addModule = function (func) {
		extraModules.push(func);
	};

	itself.addModule(style.register);

	// Data summary.
	itself.data = function () {
		var data = {
			functions: [],
			options: state.option
		};
		var implieds = [];
		var members = [];
		var fu, f, i, j, n, globals;

		if (itself.errors.length) {
			data.errors = itself.errors;
		}

		if (state.jsonMode) {
			data.json = true;
		}

		for (n in implied) {
			if (_.has(implied, n)) {
				implieds.push({
					name: n,
					line: implied[n]
				});
			}
		}

		if (implieds.length > 0) {
			data.implieds = implieds;
		}

		if (urls.length > 0) {
			data.urls = urls;
		}

		globals = Object.keys(scope);
		if (globals.length > 0) {
			data.globals = globals;
		}

		for (i = 1; i < functions.length; i += 1) {
			f = functions[i];
			fu = {};

			for (j = 0; j < functionicity.length; j += 1) {
				fu[functionicity[j]] = [];
			}

			for (j = 0; j < functionicity.length; j += 1) {
				if (fu[functionicity[j]].length === 0) {
					delete fu[functionicity[j]];
				}
			}

			fu.name = f["(name)"];
			fu.param = f["(params)"];
			fu.line = f["(line)"];
			fu.character = f["(character)"];
			fu.last = f["(last)"];
			fu.lastcharacter = f["(lastcharacter)"];
			data.functions.push(fu);
		}

		if (unuseds.length > 0) {
			data.unused = unuseds;
		}

		members = [];
		for (n in member) {
			if (typeof member[n] === "number") {
				data.member = member;
				break;
			}
		}

		return data;
	};

	itself.jshint = itself;

	return itself;
}());

// Make JSHINT a Node module, if possible.
if (typeof exports === "object" && exports) {
	exports.JSHINT = JSHINT;
}

})()
},{"events":2,"../shared/vars.js":3,"../shared/messages.js":10,"./lex.js":11,"./reg.js":4,"./state.js":5,"./style.js":6,"console-browserify":7,"underscore":12}],10:[function(require,module,exports){
(function(){"use strict";

var _ = require("underscore");

var errors = {
	// JSHint options
	E001: "Bad option: '{a}'.",
	E002: "Bad option value.",

	// JSHint input
	E003: "Expected a JSON value.",
	E004: "Input is neither a string nor an array of strings.",
	E005: "Input is empty.",
	E006: "Unexpected early end of program.",

	// Strict mode
	E007: "Missing \"use strict\" statement.",
	E008: "Strict violation.",
	E009: "Option 'validthis' can't be used in a global scope.",
	E010: "'with' is not allowed in strict mode.",

	// Constants
	E011: "const '{a}' has already been declared.",
	E012: "const '{a}' is initialized to 'undefined'.",
	E013: "Attempting to override '{a}' which is a constant.",

	// Regular expressions
	E014: "A regular expression literal can be confused with '/='.",
	E015: "Unclosed regular expression.",
	E016: "Invalid regular expression.",

	// Tokens
	E017: "Unclosed comment.",
	E018: "Unbegun comment.",
	E019: "Unmatched '{a}'.",
	E020: "Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.",
	E021: "Expected '{a}' and instead saw '{b}'.",
	E022: "Line breaking error '{a}'.",
	E023: "Missing '{a}'.",
	E024: "Unexpected '{a}'.",
	E025: "Missing ':' on a case clause.",
	E026: "Missing '}' to match '{' from line {a}.",
	E027: "Missing ']' to match '[' form line {a}.",
	E028: "Illegal comma.",
	E029: "Unclosed string.",

	// Everything else
	E030: "Expected an identifier and instead saw '{a}'.",
	E031: "Bad assignment.", // FIXME: Rephrase
	E032: "Expected a small integer or 'false' and instead saw '{a}'.",
	E033: "Expected an operator and instead saw '{a}'.",
	E034: "get/set are ES5 features.",
	E035: "Missing property name.",
	E036: "Expected to see a statement and instead saw a block.",
	E037: "Constant {a} was not declared correctly.",
	E038: "Variable {a} was not declared correctly.",
	E039: "Function declarations are not invocable. Wrap the whole function invocation in parens.",
	E040: "Each value should have its own case label.",
	E041: "Unrecoverable syntax error.",
	E042: "Stopping.",
	E043: "Too many errors.",
	E044: "'{a}' is already defined and can't be redefined.",
	E045: "Invalid for each loop.",
	E046: "A yield statement shall be within a generator function (with syntax: `function*`)",
	E047: "A generator function shall contain a yield statement.",
	E048: "Let declaration not directly within block.",
	E049: "A {a} cannot be named '{b}'."
};

var warnings = {
	W001: "'hasOwnProperty' is a really bad name.",
	W002: "Value of '{a}' may be overwritten in IE 8 and earlier.",
	W003: "'{a}' was used before it was defined.",
	W004: "'{a}' is already defined.",
	W005: "A dot following a number can be confused with a decimal point.",
	W006: "Confusing minuses.",
	W007: "Confusing pluses.",
	W008: "A leading decimal point can be confused with a dot: '{a}'.",
	W009: "The array literal notation [] is preferrable.",
	W010: "The object literal notation {} is preferrable.",
	W011: "Unexpected space after '{a}'.",
	W012: "Unexpected space before '{a}'.",
	W013: "Missing space after '{a}'.",
	W014: "Bad line breaking before '{a}'.",
	W015: "Expected '{a}' to have an indentation at {b} instead at {c}.",
	W016: "Unexpected use of '{a}'.",
	W017: "Bad operand.",
	W018: "Confusing use of '{a}'.",
	W019: "Use the isNaN function to compare with NaN.",
	W020: "Read only.",
	W021: "'{a}' is a function.",
	W022: "Do not assign to the exception parameter.",
	W023: "Expected an identifier in an assignment and instead saw a function invocation.",
	W024: "Expected an identifier and instead saw '{a}' (a reserved word).",
	W025: "Missing name in function declaration.",
	W026: "Inner functions should be listed at the top of the outer function.",
	W027: "Unreachable '{a}' after '{b}'.",
	W028: "Label '{a}' on {b} statement.",
	W030: "Expected an assignment or function call and instead saw an expression.",
	W031: "Do not use 'new' for side effects.",
	W032: "Unnecessary semicolon.",
	W033: "Missing semicolon.",
	W034: "Unnecessary directive \"{a}\".",
	W035: "Empty block.",
	W036: "Unexpected /*member '{a}'.",
	W037: "'{a}' is a statement label.",
	W038: "'{a}' used out of scope.",
	W039: "'{a}' is not allowed.",
	W040: "Possible strict violation.",
	W041: "Use '{a}' to compare with '{b}'.",
	W042: "Avoid EOL escaping.",
	W043: "Bad escaping of EOL. Use option multistr if needed.",
	W044: "Bad or unnecessary escaping.",
	W045: "Bad number '{a}'.",
	W046: "Don't use extra leading zeros '{a}'.",
	W047: "A trailing decimal point can be confused with a dot: '{a}'.",
	W048: "Unexpected control character in regular expression.",
	W049: "Unexpected escaped character '{a}' in regular expression.",
	W050: "JavaScript URL.",
	W051: "Variables should not be deleted.",
	W052: "Unexpected '{a}'.",
	W053: "Do not use {a} as a constructor.",
	W054: "The Function constructor is a form of eval.",
	W055: "A constructor name should start with an uppercase letter.",
	W056: "Bad constructor.",
	W057: "Weird construction. Is 'new' unnecessary?",
	W058: "Missing '()' invoking a constructor.",
	W059: "Avoid arguments.{a}.",
	W060: "document.write can be a form of eval.",
	W061: "eval can be harmful.",
	W062: "Wrap an immediate function invocation in parens " +
		"to assist the reader in understanding that the expression " +
		"is the result of a function, and not the function itself.",
	W063: "Math is not a function.",
	W064: "Missing 'new' prefix when invoking a constructor.",
	W065: "Missing radix parameter.",
	W066: "Implied eval. Consider passing a function instead of a string.",
	W067: "Bad invocation.",
	W068: "Wrapping non-IIFE function literals in parens is unnecessary.",
	W069: "['{a}'] is better written in dot notation.",
	W070: "Extra comma. (it breaks older versions of IE)",
	W071: "This function has too many statements. ({a})",
	W072: "This function has too many parameters. ({a})",
	W073: "Blocks are nested too deeply. ({a})",
	W074: "This function's cyclomatic complexity is too high. ({a})",
	W075: "Duplicate key '{a}'.",
	W076: "Unexpected parameter '{a}' in get {b} function.",
	W077: "Expected a single parameter in set {a} function.",
	W078: "Setter is defined without getter.",
	W079: "Redefinition of '{a}'.",
	W080: "It's not necessary to initialize '{a}' to 'undefined'.",
	W081: "Too many var statements.",
	W082: "Function declarations should not be placed in blocks. " +
		"Use a function expression or move the statement to the top of " +
		"the outer function.",
	W083: "Don't make functions within a loop.",
	W084: "Expected a conditional expression and instead saw an assignment.",
	W085: "Don't use 'with'.",
	W086: "Expected a 'break' statement before '{a}'.",
	W087: "Forgotten 'debugger' statement?",
	W088: "Creating global 'for' variable. Should be 'for (var {a} ...'.",
	W089: "The body of a for in should be wrapped in an if statement to filter " +
		"unwanted properties from the prototype.",
	W090: "'{a}' is not a statement label.",
	W091: "'{a}' is out of scope.",
	W092: "Wrap the /regexp/ literal in parens to disambiguate the slash operator.",
	W093: "Did you mean to return a conditional instead of an assignment?",
	W094: "Unexpected comma.",
	W095: "Expected a string and instead saw {a}.",
	W096: "The '{a}' key may produce unexpected results.",
	W097: "Use the function form of \"use strict\".",
	W098: "'{a}' is defined but never used.",
	W099: "Mixed spaces and tabs.",
	W100: "This character may get silently deleted by one or more browsers.",
	W101: "Line is too long.",
	W102: "Trailing whitespace.",
	W103: "The '{a}' property is deprecated.",
	W104: "'{a}' is only available in JavaScript 1.7.",
	W105: "Unexpected {a} in '{b}'.",
	W106: "Identifier '{a}' is not in camel case.",
	W107: "Script URL.",
	W108: "Strings must use doublequote.",
	W109: "Strings must use singlequote.",
	W110: "Mixed double and single quotes.",
	W112: "Unclosed string.",
	W113: "Control character in string: {a}.",
	W114: "Avoid {a}.",
	W115: "Octal literals are not allowed in strict mode.",
	W116: "Expected '{a}' and instead saw '{b}'.",
	W117: "'{a}' is not defined.",
	W118: "'{a}' is only available in Mozilla JavaScript extensions (use moz option).",
	W119: "'{a}' is only available in ES6 (use esnext option)."
};

var info = {
	I001: "Comma warnings can be turned off with 'laxcomma'.",
	I002: "Reserved words as properties can be used under the 'es5' option.",
	I003: "ES5 option is now set per default"
};

exports.errors = {};
exports.warnings = {};
exports.info = {};

_.each(errors, function (desc, code) {
	exports.errors[code] = { code: code, desc: desc };
});

_.each(warnings, function (desc, code) {
	exports.warnings[code] = { code: code, desc: desc };
});

_.each(info, function (desc, code) {
	exports.info[code] = { code: code, desc: desc };
});

})()
},{"underscore":12}],11:[function(require,module,exports){
(function(){/*
 * Lexical analysis and token construction.
 */

"use strict";

var _      = require("underscore");
var events = require("events");
var reg    = require("./reg.js");
var state  = require("./state.js").state;

// Some of these token types are from JavaScript Parser API
// while others are specific to JSHint parser.
// JS Parser API: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

var Token = {
	Identifier: 1,
	Punctuator: 2,
	NumericLiteral: 3,
	StringLiteral: 4,
	Comment: 5,
	Keyword: 6,
	NullLiteral: 7,
	BooleanLiteral: 8,
	RegExp: 9
};

// This is auto generated from the unicode tables.
// The tables are at:
// http://www.fileformat.info/info/unicode/category/Lu/list.htm
// http://www.fileformat.info/info/unicode/category/Ll/list.htm
// http://www.fileformat.info/info/unicode/category/Lt/list.htm
// http://www.fileformat.info/info/unicode/category/Lm/list.htm
// http://www.fileformat.info/info/unicode/category/Lo/list.htm
// http://www.fileformat.info/info/unicode/category/Nl/list.htm

var unicodeLetterTable = [
	170, 170, 181, 181, 186, 186, 192, 214,
	216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750,
	880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908,
	910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366,
	1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610,
	1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775,
	1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957,
	1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069,
	2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2308, 2361,
	2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431,
	2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482,
	2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,
	2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608,
	2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654,
	2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736,
	2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785,
	2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867,
	2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929,
	2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970,
	2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001,
	3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123,
	3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212,
	3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261,
	3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344,
	3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,
	3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526,
	3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716,
	3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743,
	3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760,
	3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805,
	3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138,
	4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198,
	4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4304, 4346,
	4348, 4348, 4352, 4680, 4682, 4685, 4688, 4694, 4696, 4696,
	4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789,
	4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880,
	4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740,
	5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900,
	5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000,
	6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312,
	6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516,
	6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823,
	6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7104, 7141,
	7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409,
	7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013,
	8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061,
	8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140,
	8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,
	8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455,
	8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486,
	8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521,
	8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358,
	11360, 11492, 11499, 11502, 11520, 11557, 11568, 11621,
	11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694,
	11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726,
	11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295,
	12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438,
	12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589,
	12593, 12686, 12704, 12730, 12784, 12799, 13312, 13312,
	19893, 19893, 19968, 19968, 40907, 40907, 40960, 42124,
	42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539,
	42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783,
	42786, 42888, 42891, 42894, 42896, 42897, 42912, 42921,
	43002, 43009, 43011, 43013, 43015, 43018, 43020, 43042,
	43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,
	43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442,
	43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595,
	43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697,
	43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714,
	43739, 43741, 43777, 43782, 43785, 43790, 43793, 43798,
	43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032,
	55203, 55203, 55216, 55238, 55243, 55291, 63744, 64045,
	64048, 64109, 64112, 64217, 64256, 64262, 64275, 64279,
	64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316,
	64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433,
	64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,
	65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370,
	65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495,
	65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594,
	65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786,
	65856, 65908, 66176, 66204, 66208, 66256, 66304, 66334,
	66352, 66378, 66432, 66461, 66464, 66499, 66504, 66511,
	66513, 66517, 66560, 66717, 67584, 67589, 67592, 67592,
	67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669,
	67840, 67861, 67872, 67897, 68096, 68096, 68112, 68115,
	68117, 68119, 68121, 68147, 68192, 68220, 68352, 68405,
	68416, 68437, 68448, 68466, 68608, 68680, 69635, 69687,
	69763, 69807, 73728, 74606, 74752, 74850, 77824, 78894,
	92160, 92728, 110592, 110593, 119808, 119892, 119894, 119964,
	119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980,
	119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069,
	120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121,
	120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144,
	120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570,
	120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686,
	120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779,
	131072, 131072, 173782, 173782, 173824, 173824, 177972, 177972,
	177984, 177984, 178205, 178205, 194560, 195101
];

var identifierStartTable = [];

for (var i = 0; i < 128; i++) {
	identifierStartTable[i] =
		i === 36 ||           // $
		i >= 65 && i <= 90 || // A-Z
		i === 95 ||           // _
		i >= 97 && i <= 122;  // a-z
}

var identifierPartTable = [];

for (var i = 0; i < 128; i++) {
	identifierPartTable[i] =
		identifierStartTable[i] || // $, _, A-Z, a-z
		i >= 48 && i <= 57;        // 0-9
}

// Object that handles postponed lexing verifications that checks the parsed
// environment state.

function asyncTrigger() {
	var _checks = [];

	return {
		push: function (fn) {
			_checks.push(fn);
		},

		check: function () {
			for (var check = 0; check < _checks.length; ++check) {
				_checks[check]();
			}

			_checks.splice(0, _checks.length);
		}
	};
}

/*
 * Lexer for JSHint.
 *
 * This object does a char-by-char scan of the provided source code
 * and produces a sequence of tokens.
 *
 *   var lex = new Lexer("var i = 0;");
 *   lex.start();
 *   lex.token(); // returns the next token
 *
 * You have to use the token() method to move the lexer forward
 * but you don't have to use its return value to get tokens. In addition
 * to token() method returning the next token, the Lexer object also
 * emits events.
 *
 *   lex.on("Identifier", function (data) {
 *     if (data.name.indexOf("_") >= 0) {
 *       // Produce a warning.
 *     }
 *   });
 *
 * Note that the token() method returns tokens in a JSLint-compatible
 * format while the event emitter uses a slightly modified version of
 * Mozilla's JavaScript Parser API. Eventually, we will move away from
 * JSLint format.
 */
function Lexer(source) {
	var lines = source;

	if (typeof lines === "string") {
		lines = lines
			.replace(/\r\n/g, "\n")
			.replace(/\r/g, "\n")
			.split("\n");
	}

	// If the first line is a shebang (#!), make it a blank and move on.
	// Shebangs are used by Node scripts.

	if (lines[0] && lines[0].substr(0, 2) === "#!") {
		lines[0] = "";
	}

	this.emitter = new events.EventEmitter();
	this.source = source;
	this.setLines(lines);
	this.prereg = true;

	this.line = 0;
	this.char = 1;
	this.from = 1;
	this.input = "";

	for (var i = 0; i < state.option.indent; i += 1) {
		state.tab += " ";
	}
}

Lexer.prototype = {
	_lines: [],

	getLines: function () {
		this._lines = state.lines;
		return this._lines;
	},

	setLines: function (val) {
		this._lines = val;
		state.lines = this._lines;
	},

	/*
	 * Return the next i character without actually moving the
	 * char pointer.
	 */
	peek: function (i) {
		return this.input.charAt(i || 0);
	},

	/*
	 * Move the char pointer forward i times.
	 */
	skip: function (i) {
		i = i || 1;
		this.char += i;
		this.input = this.input.slice(i);
	},

	/*
	 * Subscribe to a token event. The API for this method is similar
	 * Underscore.js i.e. you can subscribe to multiple events with
	 * one call:
	 *
	 *   lex.on("Identifier Number", function (data) {
	 *     // ...
	 *   });
	 */
	on: function (names, listener) {
		names.split(" ").forEach(function (name) {
			this.emitter.on(name, listener);
		}.bind(this));
	},

	/*
	 * Trigger a token event. All arguments will be passed to each
	 * listener.
	 */
	trigger: function () {
		this.emitter.emit.apply(this.emitter, Array.prototype.slice.call(arguments));
	},

	/*
	 * Postpone a token event. the checking condition is set as
	 * last parameter, and the trigger function is called in a
	 * stored callback. To be later called using the check() function
	 * by the parser. This avoids parser's peek() to give the lexer
	 * a false context.
	 */
	triggerAsync: function (type, args, checks, fn) {
		checks.push(function () {
			if (fn()) {
				this.trigger(type, args);
			}
		}.bind(this));
	},

	/*
	 * Extract a punctuator out of the next sequence of characters
	 * or return 'null' if its not possible.
	 *
	 * This method's implementation was heavily influenced by the
	 * scanPunctuator function in the Esprima parser's source code.
	 */
	scanPunctuator: function () {
		var ch1 = this.peek();
		var ch2, ch3, ch4;

		switch (ch1) {
		// Most common single-character punctuators
		case ".":
			if ((/^[0-9]$/).test(this.peek(1))) {
				return null;
			}
			if (this.peek(1) === "." && this.peek(2) === ".") {
				return {
					type: Token.Punctuator,
					value: "..."
				};
			}
			/* falls through */
		case "(":
		case ")":
		case ";":
		case ",":
		case "{":
		case "}":
		case "[":
		case "]":
		case ":":
		case "~":
		case "?":
			return {
				type: Token.Punctuator,
				value: ch1
			};

		// A pound sign (for Node shebangs)
		case "#":
			return {
				type: Token.Punctuator,
				value: ch1
			};

		// We're at the end of input
		case "":
			return null;
		}

		// Peek more characters

		ch2 = this.peek(1);
		ch3 = this.peek(2);
		ch4 = this.peek(3);

		// 4-character punctuator: >>>=

		if (ch1 === ">" && ch2 === ">" && ch3 === ">" && ch4 === "=") {
			return {
				type: Token.Punctuator,
				value: ">>>="
			};
		}

		// 3-character punctuators: === !== >>> <<= >>=

		if (ch1 === "=" && ch2 === "=" && ch3 === "=") {
			return {
				type: Token.Punctuator,
				value: "==="
			};
		}

		if (ch1 === "!" && ch2 === "=" && ch3 === "=") {
			return {
				type: Token.Punctuator,
				value: "!=="
			};
		}

		if (ch1 === ">" && ch2 === ">" && ch3 === ">") {
			return {
				type: Token.Punctuator,
				value: ">>>"
			};
		}

		if (ch1 === "<" && ch2 === "<" && ch3 === "=") {
			return {
				type: Token.Punctuator,
				value: "<<="
			};
		}

		if (ch1 === ">" && ch2 === ">" && ch3 === "=") {
			return {
				type: Token.Punctuator,
				value: ">>="
			};
		}

		// Fat arrow punctuator
		if (ch1 === "=" && ch2 === ">") {
			return {
				type: Token.Punctuator,
				value: ch1 + ch2
			};
		}

		// 2-character punctuators: <= >= == != ++ -- << >> && ||
		// += -= *= %= &= |= ^= (but not /=, see below)
		if (ch1 === ch2 && ("+-<>&|".indexOf(ch1) >= 0)) {
			return {
				type: Token.Punctuator,
				value: ch1 + ch2
			};
		}

		if ("<>=!+-*%&|^".indexOf(ch1) >= 0) {
			if (ch2 === "=") {
				return {
					type: Token.Punctuator,
					value: ch1 + ch2
				};
			}

			return {
				type: Token.Punctuator,
				value: ch1
			};
		}

		// Special case: /=. We need to make sure that this is an
		// operator and not a regular expression.

		if (ch1 === "/") {
			if (ch2 === "=" && /\/=(?!(\S*\/[gim]?))/.test(this.input)) {
				// /= is not a part of a regular expression, return it as a
				// punctuator.
				return {
					type: Token.Punctuator,
					value: "/="
				};
			}

			return {
				type: Token.Punctuator,
				value: "/"
			};
		}

		return null;
	},

	/*
	 * Extract a comment out of the next sequence of characters and/or
	 * lines or return 'null' if its not possible. Since comments can
	 * span across multiple lines this method has to move the char
	 * pointer.
	 *
	 * In addition to normal JavaScript comments (// and /*) this method
	 * also recognizes JSHint- and JSLint-specific comments such as
	 * /*jshint, /*jslint, /*globals and so on.
	 */
	scanComments: function () {
		var ch1 = this.peek();
		var ch2 = this.peek(1);
		var rest = this.input.substr(2);
		var startLine = this.line;
		var startChar = this.char;

		// Create a comment token object and make sure it
		// has all the data JSHint needs to work with special
		// comments.

		function commentToken(label, body, opt) {
			var special = ["jshint", "jslint", "members", "member", "globals", "global", "exported"];
			var isSpecial = false;
			var value = label + body;
			var commentType = "plain";
			opt = opt || {};

			if (opt.isMultiline) {
				value += "*/";
			}

			special.forEach(function (str) {
				if (isSpecial) {
					return;
				}

				// Don't recognize any special comments other than jshint for single-line
				// comments. This introduced many problems with legit comments.
				if (label === "//" && str !== "jshint") {
					return;
				}

				if (body.substr(0, str.length) === str) {
					isSpecial = true;
					label = label + str;
					body = body.substr(str.length);
				}

				if (!isSpecial && body.charAt(0) === " " && body.substr(1, str.length) === str) {
					isSpecial = true;
					label = label + " " + str;
					body = body.substr(str.length + 1);
				}

				if (!isSpecial) {
					return;
				}

				switch (str) {
				case "member":
					commentType = "members";
					break;
				case "global":
					commentType = "globals";
					break;
				default:
					commentType = str;
				}
			});

			return {
				type: Token.Comment,
				commentType: commentType,
				value: value,
				body: body,
				isSpecial: isSpecial,
				isMultiline: opt.isMultiline || false,
				isMalformed: opt.isMalformed || false
			};
		}

		// End of unbegun comment. Raise an error and skip that input.
		if (ch1 === "*" && ch2 === "/") {
			this.trigger("error", {
				code: "E018",
				line: startLine,
				character: startChar
			});

			this.skip(2);
			return null;
		}

		// Comments must start either with // or /*
		if (ch1 !== "/" || (ch2 !== "*" && ch2 !== "/")) {
			return null;
		}

		// One-line comment
		if (ch2 === "/") {
			this.skip(this.input.length); // Skip to the EOL.
			return commentToken("//", rest);
		}

		var body = "";

		/* Multi-line comment */
		if (ch2 === "*") {
			this.skip(2);

			while (this.peek() !== "*" || this.peek(1) !== "/") {
				if (this.peek() === "") { // End of Line
					body += "\n";

					// If we hit EOF and our comment is still unclosed,
					// trigger an error and end the comment implicitly.
					if (!this.nextLine()) {
						this.trigger("error", {
							code: "E017",
							line: startLine,
							character: startChar
						});

						return commentToken("/*", body, {
							isMultiline: true,
							isMalformed: true
						});
					}
				} else {
					body += this.peek();
					this.skip();
				}
			}

			this.skip(2);
			return commentToken("/*", body, { isMultiline: true });
		}
	},

	/*
	 * Extract a keyword out of the next sequence of characters or
	 * return 'null' if its not possible.
	 */
	scanKeyword: function () {
		var result = /^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input);
		var keywords = [
			"if", "in", "do", "var", "for", "new",
			"try", "let", "this", "else", "case",
			"void", "with", "enum", "while", "break",
			"catch", "throw", "const", "yield", "class",
			"super", "return", "typeof", "delete",
			"switch", "export", "import", "default",
			"finally", "extends", "function", "continue",
			"debugger", "instanceof"
		];

		if (result && keywords.indexOf(result[0]) >= 0) {
			return {
				type: Token.Keyword,
				value: result[0]
			};
		}

		return null;
	},

	/*
	 * Extract a JavaScript identifier out of the next sequence of
	 * characters or return 'null' if its not possible. In addition,
	 * to Identifier this method can also produce BooleanLiteral
	 * (true/false) and NullLiteral (null).
	 */
	scanIdentifier: function () {
		var id = "";
		var index = 0;
		var type, char;

		// Detects any character in the Unicode categories "Uppercase
		// letter (Lu)", "Lowercase letter (Ll)", "Titlecase letter
		// (Lt)", "Modifier letter (Lm)", "Other letter (Lo)", or
		// "Letter number (Nl)".
		//
		// Both approach and unicodeLetterTable were borrowed from
		// Google's Traceur.

		function isUnicodeLetter(code) {
			for (var i = 0; i < unicodeLetterTable.length;) {
				if (code < unicodeLetterTable[i++]) {
					return false;
				}

				if (code <= unicodeLetterTable[i++]) {
					return true;
				}
			}

			return false;
		}

		function isHexDigit(str) {
			return (/^[0-9a-fA-F]$/).test(str);
		}

		var readUnicodeEscapeSequence = function () {
			/*jshint validthis:true */
			index += 1;

			if (this.peek(index) !== "u") {
				return null;
			}

			var ch1 = this.peek(index + 1);
			var ch2 = this.peek(index + 2);
			var ch3 = this.peek(index + 3);
			var ch4 = this.peek(index + 4);
			var code;

			if (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {
				code = parseInt(ch1 + ch2 + ch3 + ch4, 16);

				if (isUnicodeLetter(code)) {
					index += 5;
					return "\\u" + ch1 + ch2 + ch3 + ch4;
				}

				return null;
			}

			return null;
		}.bind(this);

		var getIdentifierStart = function () {
			/*jshint validthis:true */
			var chr = this.peek(index);
			var code = chr.charCodeAt(0);

			if (code === 92) {
				return readUnicodeEscapeSequence();
			}

			if (code < 128) {
				if (identifierStartTable[code]) {
					index += 1;
					return chr;
				}

				return null;
			}

			if (isUnicodeLetter(code)) {
				index += 1;
				return chr;
			}

			return null;
		}.bind(this);

		var getIdentifierPart = function () {
			/*jshint validthis:true */
			var chr = this.peek(index);
			var code = chr.charCodeAt(0);

			if (code === 92) {
				return readUnicodeEscapeSequence();
			}

			if (code < 128) {
				if (identifierPartTable[code]) {
					index += 1;
					return chr;
				}

				return null;
			}

			if (isUnicodeLetter(code)) {
				index += 1;
				return chr;
			}

			return null;
		}.bind(this);

		char = getIdentifierStart();
		if (char === null) {
			return null;
		}

		id = char;
		for (;;) {
			char = getIdentifierPart();

			if (char === null) {
				break;
			}

			id += char;
		}

		switch (id) {
		case "true":
		case "false":
			type = Token.BooleanLiteral;
			break;
		case "null":
			type = Token.NullLiteral;
			break;
		default:
			type = Token.Identifier;
		}

		return {
			type: type,
			value: id
		};
	},

	/*
	 * Extract a numeric literal out of the next sequence of
	 * characters or return 'null' if its not possible. This method
	 * supports all numeric literals described in section 7.8.3
	 * of the EcmaScript 5 specification.
	 *
	 * This method's implementation was heavily influenced by the
	 * scanNumericLiteral function in the Esprima parser's source code.
	 */
	scanNumericLiteral: function () {
		var index = 0;
		var value = "";
		var length = this.input.length;
		var char = this.peek(index);
		var bad;

		function isDecimalDigit(str) {
			return (/^[0-9]$/).test(str);
		}

		function isOctalDigit(str) {
			return (/^[0-7]$/).test(str);
		}

		function isHexDigit(str) {
			return (/^[0-9a-fA-F]$/).test(str);
		}

		function isIdentifierStart(ch) {
			return (ch === "$") || (ch === "_") || (ch === "\\") ||
				(ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z");
		}

		// Numbers must start either with a decimal digit or a point.

		if (char !== "." && !isDecimalDigit(char)) {
			return null;
		}

		if (char !== ".") {
			value = this.peek(index);
			index += 1;
			char = this.peek(index);

			if (value === "0") {
				// Base-16 numbers.
				if (char === "x" || char === "X") {
					index += 1;
					value += char;

					while (index < length) {
						char = this.peek(index);
						if (!isHexDigit(char)) {
							break;
						}
						value += char;
						index += 1;
					}

					if (value.length <= 2) { // 0x
						return {
							type: Token.NumericLiteral,
							value: value,
							isMalformed: true
						};
					}

					if (index < length) {
						char = this.peek(index);
						if (isIdentifierStart(char)) {
							return null;
						}
					}

					return {
						type: Token.NumericLiteral,
						value: value,
						base: 16,
						isMalformed: false
					};
				}

				// Base-8 numbers.
				if (isOctalDigit(char)) {
					index += 1;
					value += char;
					bad = false;

					while (index < length) {
						char = this.peek(index);

						// Numbers like '019' (note the 9) are not valid octals
						// but we still parse them and mark as malformed.

						if (isDecimalDigit(char)) {
							bad = true;
						} else if (!isOctalDigit(char)) {
							break;
						}
						value += char;
						index += 1;
					}

					if (index < length) {
						char = this.peek(index);
						if (isIdentifierStart(char)) {
							return null;
						}
					}

					return {
						type: Token.NumericLiteral,
						value: value,
						base: 8,
						isMalformed: false
					};
				}

				// Decimal numbers that start with '0' such as '09' are illegal
				// but we still parse them and return as malformed.

				if (isDecimalDigit(char)) {
					index += 1;
					value += char;
				}
			}

			while (index < length) {
				char = this.peek(index);
				if (!isDecimalDigit(char)) {
					break;
				}
				value += char;
				index += 1;
			}
		}

		// Decimal digits.

		if (char === ".") {
			value += char;
			index += 1;

			while (index < length) {
				char = this.peek(index);
				if (!isDecimalDigit(char)) {
					break;
				}
				value += char;
				index += 1;
			}
		}

		// Exponent part.

		if (char === "e" || char === "E") {
			value += char;
			index += 1;
			char = this.peek(index);

			if (char === "+" || char === "-") {
				value += this.peek(index);
				index += 1;
			}

			char = this.peek(index);
			if (isDecimalDigit(char)) {
				value += char;
				index += 1;

				while (index < length) {
					char = this.peek(index);
					if (!isDecimalDigit(char)) {
						break;
					}
					value += char;
					index += 1;
				}
			} else {
				return null;
			}
		}

		if (index < length) {
			char = this.peek(index);
			if (isIdentifierStart(char)) {
				return null;
			}
		}

		return {
			type: Token.NumericLiteral,
			value: value,
			base: 10,
			isMalformed: !isFinite(value)
		};
	},

	/*
	 * Extract a string out of the next sequence of characters and/or
	 * lines or return 'null' if its not possible. Since strings can
	 * span across multiple lines this method has to move the char
	 * pointer.
	 *
	 * This method recognizes pseudo-multiline JavaScript strings:
	 *
	 *   var str = "hello\
	 *   world";
	 */
	scanStringLiteral: function (checks) {
		/*jshint loopfunc:true */
		var quote = this.peek();

		// String must start with a quote.
		if (quote !== "\"" && quote !== "'") {
			return null;
		}

		// In JSON strings must always use double quotes.
		this.triggerAsync("warning", {
			code: "W108",
			line: this.line,
			character: this.char // +1?
		}, checks, function () { return state.jsonMode && quote !== "\""; });

		var value = "";
		var startLine = this.line;
		var startChar = this.char;
		var allowNewLine = false;

		this.skip();

		while (this.peek() !== quote) {
			while (this.peek() === "") { // End Of Line

				// If an EOL is not preceded by a backslash, show a warning
				// and proceed like it was a legit multi-line string where
				// author simply forgot to escape the newline symbol.
				//
				// Another approach is to implicitly close a string on EOL
				// but it generates too many false positives.

				if (!allowNewLine) {
					this.trigger("warning", {
						code: "W112",
						line: this.line,
						character: this.char
					});
				} else {
					allowNewLine = false;

					// Otherwise show a warning if multistr option was not set.
					// For JSON, show warning no matter what.

					this.triggerAsync("warning", {
						code: "W043",
						line: this.line,
						character: this.char
					}, checks, function () { return !state.option.multistr; });

					this.triggerAsync("warning", {
						code: "W042",
						line: this.line,
						character: this.char
					}, checks, function () { return state.jsonMode && state.option.multistr; });
				}

				// If we get an EOF inside of an unclosed string, show an
				// error and implicitly close it at the EOF point.

				if (!this.nextLine()) {
					this.trigger("error", {
						code: "E029",
						line: startLine,
						character: startChar
					});

					return {
						type: Token.StringLiteral,
						value: value,
						isUnclosed: true,
						quote: quote
					};
				}
			}

			allowNewLine = false;
			var char = this.peek();
			var jump = 1; // A length of a jump, after we're done
			              // parsing this character.

			if (char < " ") {
				// Warn about a control character in a string.
				this.trigger("warning", {
					code: "W113",
					line: this.line,
					character: this.char,
					data: [ "<non-printable>" ]
				});
			}

			// Special treatment for some escaped characters.

			if (char === "\\") {
				this.skip();
				char = this.peek();

				switch (char) {
				case "'":
					this.triggerAsync("warning", {
						code: "W114",
						line: this.line,
						character: this.char,
						data: [ "\\'" ]
					}, checks, function () {return state.jsonMode; });
					break;
				case "b":
					char = "\b";
					break;
				case "f":
					char = "\f";
					break;
				case "n":
					char = "\n";
					break;
				case "r":
					char = "\r";
					break;
				case "t":
					char = "\t";
					break;
				case "0":
					char = "\0";

					// Octal literals fail in strict mode.
					// Check if the number is between 00 and 07.
					var n = parseInt(this.peek(1), 10);
					this.triggerAsync("warning", {
						code: "W115",
						line: this.line,
						character: this.char
					}, checks,
					function () { return n >= 0 && n <= 7 && state.directive["use strict"]; });
					break;
				case "u":
					char = String.fromCharCode(parseInt(this.input.substr(1, 4), 16));
					jump = 5;
					break;
				case "v":
					this.triggerAsync("warning", {
						code: "W114",
						line: this.line,
						character: this.char,
						data: [ "\\v" ]
					}, checks, function () { return state.jsonMode; });

					char = "\v";
					break;
				case "x":
					var	x = parseInt(this.input.substr(1, 2), 16);

					this.triggerAsync("warning", {
						code: "W114",
						line: this.line,
						character: this.char,
						data: [ "\\x-" ]
					}, checks, function () { return state.jsonMode; });

					char = String.fromCharCode(x);
					jump = 3;
					break;
				case "\\":
				case "\"":
				case "/":
					break;
				case "":
					allowNewLine = true;
					char = "";
					break;
				case "!":
					if (value.slice(value.length - 2) === "<") {
						break;
					}

					/*falls through */
				default:
					// Weird escaping.
					this.trigger("warning", {
						code: "W044",
						line: this.line,
						character: this.char
					});
				}
			}

			value += char;
			this.skip(jump);
		}

		this.skip();
		return {
			type: Token.StringLiteral,
			value: value,
			isUnclosed: false,
			quote: quote
		};
	},

	/*
	 * Extract a regular expression out of the next sequence of
	 * characters and/or lines or return 'null' if its not possible.
	 *
	 * This method is platform dependent: it accepts almost any
	 * regular expression values but then tries to compile and run
	 * them using system's RegExp object. This means that there are
	 * rare edge cases where one JavaScript engine complains about
	 * your regular expression while others don't.
	 */
	scanRegExp: function () {
		var index = 0;
		var length = this.input.length;
		var char = this.peek();
		var value = char;
		var body = "";
		var flags = [];
		var malformed = false;
		var isCharSet = false;
		var terminated;

		var scanUnexpectedChars = function () {
			// Unexpected control character
			if (char < " ") {
				malformed = true;
				this.trigger("warning", {
					code: "W048",
					line: this.line,
					character: this.char
				});
			}

			// Unexpected escaped character
			if (char === "<") {
				malformed = true;
				this.trigger("warning", {
					code: "W049",
					line: this.line,
					character: this.char,
					data: [ char ]
				});
			}
		}.bind(this);

		// Regular expressions must start with '/'
		if (!this.prereg || char !== "/") {
			return null;
		}

		index += 1;
		terminated = false;

		// Try to get everything in between slashes. A couple of
		// cases aside (see scanUnexpectedChars) we don't really
		// care whether the resulting expression is valid or not.
		// We will check that later using the RegExp object.

		while (index < length) {
			char = this.peek(index);
			value += char;
			body += char;

			if (isCharSet) {
				if (char === "]") {
					if (this.peek(index - 1) !== "\\" || this.peek(index - 2) === "\\") {
						isCharSet = false;
					}
				}

				if (char === "\\") {
					index += 1;
					char = this.peek(index);
					body += char;
					value += char;

					scanUnexpectedChars();
				}

				index += 1;
				continue;
			}

			if (char === "\\") {
				index += 1;
				char = this.peek(index);
				body += char;
				value += char;

				scanUnexpectedChars();

				if (char === "/") {
					index += 1;
					continue;
				}

				if (char === "[") {
					index += 1;
					continue;
				}
			}

			if (char === "[") {
				isCharSet = true;
				index += 1;
				continue;
			}

			if (char === "/") {
				body = body.substr(0, body.length - 1);
				terminated = true;
				index += 1;
				break;
			}

			index += 1;
		}

		// A regular expression that was never closed is an
		// error from which we cannot recover.

		if (!terminated) {
			this.trigger("error", {
				code: "E015",
				line: this.line,
				character: this.from
			});

			return void this.trigger("fatal", {
				line: this.line,
				from: this.from
			});
		}

		// Parse flags (if any).

		while (index < length) {
			char = this.peek(index);
			if (!/[gim]/.test(char)) {
				break;
			}
			flags.push(char);
			value += char;
			index += 1;
		}

		// Check regular expression for correctness.

		try {
			new RegExp(body, flags.join(""));
		} catch (err) {
			malformed = true;
			this.trigger("error", {
				code: "E016",
				line: this.line,
				character: this.char,
				data: [ err.message ] // Platform dependent!
			});
		}

		return {
			type: Token.RegExp,
			value: value,
			flags: flags,
			isMalformed: malformed
		};
	},

	/*
	 * Scan for any occurence of mixed tabs and spaces. If smarttabs option
	 * is on, ignore tabs followed by spaces.
	 *
	 * Tabs followed by one space followed by a block comment are allowed.
	 */
	scanMixedSpacesAndTabs: function () {
		var at, match;

		if (state.option.smarttabs) {
			// Negative look-behind for "//"
			match = this.input.match(/(\/\/|^\s?\*)? \t/);
			at = match && !match[1] ? 0 : -1;
		} else {
			at = this.input.search(/ \t|\t [^\*]/);
		}

		return at;
	},

	/*
	 * Scan for characters that get silently deleted by one or more browsers.
	 */
	scanUnsafeChars: function () {
		return this.input.search(reg.unsafeChars);
	},

	/*
	 * Produce the next raw token or return 'null' if no tokens can be matched.
	 * This method skips over all space characters.
	 */
	next: function (checks) {
		this.from = this.char;

		// Move to the next non-space character.
		var start;
		if (/\s/.test(this.peek())) {
			start = this.char;

			while (/\s/.test(this.peek())) {
				this.from += 1;
				this.skip();
			}

			if (this.peek() === "") { // EOL
				if (!/^\s*$/.test(this.getLines()[this.line - 1]) && state.option.trailing) {
					this.trigger("warning", { code: "W102", line: this.line, character: start });
				}
			}
		}

		// Methods that work with multi-line structures and move the
		// character pointer.

		var match = this.scanComments() ||
			this.scanStringLiteral(checks);

		if (match) {
			return match;
		}

		// Methods that don't move the character pointer.

		match =
			this.scanRegExp() ||
			this.scanPunctuator() ||
			this.scanKeyword() ||
			this.scanIdentifier() ||
			this.scanNumericLiteral();

		if (match) {
			this.skip(match.value.length);
			return match;
		}

		// No token could be matched, give up.

		return null;
	},

	/*
	 * Switch to the next line and reset all char pointers. Once
	 * switched, this method also checks for mixed spaces and tabs
	 * and other minor warnings.
	 */
	nextLine: function () {
		var char;

		if (this.line >= this.getLines().length) {
			return false;
		}

		this.input = this.getLines()[this.line];
		this.line += 1;
		this.char = 1;
		this.from = 1;

		char = this.scanMixedSpacesAndTabs();
		if (char >= 0) {
			this.trigger("warning", { code: "W099", line: this.line, character: char + 1 });
		}

		this.input = this.input.replace(/\t/g, state.tab);
		char = this.scanUnsafeChars();

		if (char >= 0) {
			this.trigger("warning", { code: "W100", line: this.line, character: char });
		}

		// If there is a limit on line length, warn when lines get too
		// long.

		if (state.option.maxlen && state.option.maxlen < this.input.length) {
			this.trigger("warning", { code: "W101", line: this.line, character: this.input.length });
		}

		return true;
	},

	/*
	 * This is simply a synonym for nextLine() method with a friendlier
	 * public name.
	 */
	start: function () {
		this.nextLine();
	},

	/*
	 * Produce the next token. This function is called by advance() to get
	 * the next token. It retuns a token in a JSLint-compatible format.
	 */
	token: function () {
		/*jshint loopfunc:true */
		var checks = asyncTrigger();
		var token;


		function isReserved(token, isProperty) {
			if (!token.reserved) {
				return false;
			}

			if (token.meta && token.meta.isFutureReservedWord) {
				// ES3 FutureReservedWord in an ES5 environment.
				if (state.option.inES5(true) && !token.meta.es5) {
					return false;
				}

				// Some ES5 FutureReservedWord identifiers are active only
				// within a strict mode environment.
				if (token.meta.strictOnly) {
					if (!state.option.strict && !state.directive["use strict"]) {
						return false;
					}
				}

				if (isProperty) {
					return false;
				}
			}

			return true;
		}

		// Produce a token object.
		var create = function (type, value, isProperty) {
			/*jshint validthis:true */
			var obj;

			if (type !== "(endline)" && type !== "(end)") {
				this.prereg = false;
			}

			if (type === "(punctuator)") {
				switch (value) {
				case ".":
				case ")":
				case "~":
				case "#":
				case "]":
					this.prereg = false;
					break;
				default:
					this.prereg = true;
				}

				obj = Object.create(state.syntax[value] || state.syntax["(error)"]);
			}

			if (type === "(identifier)") {
				if (value === "return" || value === "case" || value === "typeof") {
					this.prereg = true;
				}

				if (_.has(state.syntax, value)) {
					obj = Object.create(state.syntax[value] || state.syntax["(error)"]);

					// If this can't be a reserved keyword, reset the object.
					if (!isReserved(obj, isProperty && type === "(identifier)")) {
						obj = null;
					}
				}
			}

			if (!obj) {
				obj = Object.create(state.syntax[type]);
			}

			obj.identifier = (type === "(identifier)");
			obj.type = obj.type || type;
			obj.value = value;
			obj.line = this.line;
			obj.character = this.char;
			obj.from = this.from;

			if (isProperty && obj.identifier) {
				obj.isProperty = isProperty;
			}

			obj.check = checks.check;

			return obj;
		}.bind(this);

		for (;;) {
			if (!this.input.length) {
				return create(this.nextLine() ? "(endline)" : "(end)", "");
			}

			token = this.next(checks);

			if (!token) {
				if (this.input.length) {
					// Unexpected character.
					this.trigger("error", {
						code: "E024",
						line: this.line,
						character: this.char,
						data: [ this.peek() ]
					});

					this.input = "";
				}

				continue;
			}

			switch (token.type) {
			case Token.StringLiteral:
				this.triggerAsync("String", {
					line: this.line,
					char: this.char,
					from: this.from,
					value: token.value,
					quote: token.quote
				}, checks, function () { return true; });

				return create("(string)", token.value);
			case Token.Identifier:
				this.trigger("Identifier", {
					line: this.line,
					char: this.char,
					from: this.form,
					name: token.value,
					isProperty: state.tokens.curr.id === "."
				});

				/* falls through */
			case Token.Keyword:
			case Token.NullLiteral:
			case Token.BooleanLiteral:
				return create("(identifier)", token.value, state.tokens.curr.id === ".");

			case Token.NumericLiteral:
				if (token.isMalformed) {
					this.trigger("warning", {
						code: "W045",
						line: this.line,
						character: this.char,
						data: [ token.value ]
					});
				}

				this.triggerAsync("warning", {
					code: "W114",
					line: this.line,
					character: this.char,
					data: [ "0x-" ]
				}, checks, function () { return token.base === 16 && state.jsonMode; });

				this.triggerAsync("warning", {
					code: "W115",
					line: this.line,
					character: this.char
				}, checks, function () {
					return state.directive["use strict"] && token.base === 8; 
				});

				this.trigger("Number", {
					line: this.line,
					char: this.char,
					from: this.from,
					value: token.value,
					base: token.base,
					isMalformed: token.malformed
				});

				return create("(number)", token.value);

			case Token.RegExp:
				return create("(regexp)", token.value);

			case Token.Comment:
				state.tokens.curr.comment = true;

				if (token.isSpecial) {
					return {
						value: token.value,
						body: token.body,
						type: token.commentType,
						isSpecial: token.isSpecial,
						line: this.line,
						character: this.char,
						from: this.from
					};
				}

				break;

			case "":
				break;

			default:
				return create("(punctuator)", token.value);
			}
		}
	}
};

exports.Lexer = Lexer;

})()
},{"events":2,"./reg.js":4,"./state.js":5,"underscore":12}],8:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":2}],9:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":8,"buffer":13}],12:[function(require,module,exports){
(function(){//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

})()
},{}],14:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],13:[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":9,"./buffer_ieee754":14,"base64-js":15}],15:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},["E/GbHF"])
;
JSHINT = require('jshint').JSHINT;
}());/*
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
throwError: true, generateStatement: true, peek: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true,
parseStatement: true, parseSourceElement: true */

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    
    factory((root.esprima = {}));

}(Retool.IDE.JavascriptParser, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        SyntaxTreeDelegate,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        delegate,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        XJSIdentifier: 11,
        XJSText: 12        
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.XJSIdentifier] = 'XJSIdentifier';
    TokenName[Token.XJSText] = 'XJSText';    
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ["(", "{", "[", "in", "typeof", "instanceof", "new",
                    "return", "case", "delete", "throw", "void",
                    // assignment operators
                    "=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=",
                    "&=", "|=", "^=", ",",
                    // binary/unary operators
                    "+", "-", "*", "/", "%", "++", "--", "<<", ">>", ">>>", "&",
                    "|", "^", "!", "~", "&&", "||", "?", ":", "===", "==", ">=",
                    "<=", "<", ">", "!=", "!=="];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassDeclaration: 'ClassDeclaration',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        HTMLExpressionStatement: 'HTMLExpressionStatement', 
        XJSIdentifier: 'XJSIdentifier',
        XJSNamespacedName: 'XJSNamespacedName',
        XJSMemberExpression: 'XJSMemberExpression',
        XJSEmptyExpression: 'XJSEmptyExpression',
        XJSExpressionContainer: 'XJSExpressionContainer',
        XJSElement: 'XJSElement',
        XJSClosingElement: 'XJSClosingElement',
        XJSOpeningElement: 'XJSOpeningElement',
        XJSAttribute: 'XJSAttribute',
        XJSSpreadAttribute: 'XJSSpreadAttribute',
        XJSText: 'XJSText',               
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode',
        InvalidXJSAttributeValue: 'XJS value should be either an expression or a quoted XJS text',    
        ExpectedXJSClosingTag: 'Expected corresponding XJS closing tag for %0',   
        AdjacentXJSElements: 'Adjacent XJS elements must be wrapped in an enclosing tag',                 
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 32) ||  // space
            (ch === 9) ||      // tab
            (ch === 0xB) ||
            (ch === 0xC) ||
            (ch === 0xA0) ||
            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
      //  case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class'); // || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function skipComment() {
        var ch, blockComment, lineComment;

        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source.charCodeAt(index);

            if (lineComment) {
                ++index;
                if (isLineTerminator(ch)) {
                    lineComment = false;
                    if (ch === 13 && source.charCodeAt(index) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch)) {
                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source.charCodeAt(index++);
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    // Block comment ends with '*/' (char #42, char #47).
                    if (ch === 42) {
                        ch = source.charCodeAt(index);
                        if (ch === 47) {
                            ++index;
                            blockComment = false;
                        }
                    }
                }
            } else if (ch === 47) {
                ch = source.charCodeAt(index + 1);
                // Line comment starts with '//' (char #47, char #47).
                if (ch === 47) {
                    index += 2;
                    lineComment = true;
                } else if (ch === 42) {
                    // Block comment starts with '/*' (char #47, char #42).
                    index += 2;
                    blockComment = true;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (char #92, char #117) denotes an escaped character.
        if (ch === 92) {
            if (source.charCodeAt(index) !== 117) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (char #92, char #117) denotes an escaped character.
            if (ch === 92) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 117) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 92) {
                // Blackslash (char #92) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function getTypeNameIdentifier(){
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isIdentifierPart(ch)) {
                ++index;
            } 
            else if (ch == 46 && ((index + 1) < length) && source[index + 1] >= 'A' && source[index + 1] <='Z')
                index += 2 ;
            else {
                break;
            }
        }

        return source.slice(start, index);

    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (char #92) starts an escaped character.
        if (source[index] >= 'A' && source[index] <='Z'){
            id = getTypeNameIdentifier();
        }
        else {
            id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();
        }

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        switch (code) {

        // Check for most common single-character punctuators.
        case 46:   // . dot
        case 40:   // ( open bracket
        case 41:   // ) close bracket
        case 59:   // ; semicolon
        case 44:   // , comma
        case 123:  // { open curly brace
        case 125:  // } close curly brace
        case 91:   // [
        case 93:   // ]
        case 58:   // :
        case 63:   // ?
        case 126:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 40) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 123) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (char #61) marks an assignment or comparison operator.
            if (code2 === 61) {
                switch (code) {
                case 37:  // %
                case 38:  // &
                case 42:  // *:
                case 43:  // +
                case 45:  // -
                case 47:  // /
                case 60:  // <
                case 62:  // >
                case 94:  // ^
                case 124: // |
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };

                case 33: // !
                case 61: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 61) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                default:
                    break;
                }
            }
            break;
        }

        // Peek more characters.

        ch2 = source[index + 1];
        ch3 = source[index + 2];
        ch4 = source[index + 3];

        // 4-character punctuator: >>>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            if (ch4 === '=') {
                index += 4;
                return {
                    type: Token.Punctuator,
                    value: '>>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // 3-character punctuators: === !== >>> <<= >>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '<<=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||

        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch1 + ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanOctalLiteral(start) {
        var number = '0' + source[index++];
        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: true,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (isOctalDigit(ch)) {
                    return scanOctalLiteral(start);
                }

                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'u':
                    case 'x':
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\v';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanRegExp() {
        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;

        lookahead = null;
        skipComment();

        start = index;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        while (index < length) {
            ch = source[index++];
            str += ch;
            if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '\\') {
                    ch = source[index++];
                    // ECMA-262 7.8.5
                    if (isLineTerminator(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnterminatedRegExp);
                    }
                    str += ch;
                } else if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        pattern = str.substr(1, str.length - 2);

        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                } else {
                    str += '\\';
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }

        peek();


        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
        return {
            literal: str,
            value: value,
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return scanRegExp();
        }
        if (prevToken.type === "Punctuator") {
            if (prevToken.value === ")") {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === "Keyword" &&
                        (checkToken.value === "if" ||
                         checkToken.value === "while" ||
                         checkToken.value === "for" ||
                         checkToken.value === "with")) {
                    return scanRegExp();
                }
                return scanPunctuator();
            }
            if (prevToken.value === "}") {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === "Keyword") {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === "Keyword") {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return scanRegExp();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return scanRegExp();
            }
            return scanRegExp();
        }
        if (prevToken.type === "Keyword") {
            return scanRegExp();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        if (!state.inXJSChild) {
            skipComment();
        }

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [index, index]
            };
        }

        if (state.inXJSChild) {
            return advanceXJSChild();
        }

        ch = source.charCodeAt(index);

        // Very common: ( and ) and ;
        if (ch === 40 || ch === 41 || ch === 58) {
            return scanPunctuator();
        }

        // String literal starts with single quote (#39) or double quote (#34).
        if (ch === 39 || ch === 34) {
            if (state.inXJSTag) {
                return scanXJSStringLiteral();
            }
            return scanStringLiteral();
        }

        if (state.inXJSTag && isXJSIdentifierStart(ch)) {
            return scanXJSIdentifier();
        }

        if (ch === 96) {
            return scanTemplate();
        }
        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Dot (.) char #46 can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) char #47 can also start a regex.
        if (extra.tokenize && ch === 47) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = advance();

        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    SyntaxTreeDelegate = {

        name: 'SyntaxTree',

        postProcess: function (node) {
            return node;
        },

        createArrayExpression: function (elements) {
            return {
                type: Syntax.ArrayExpression,
                elements: elements
            };
        },

        createAssignmentExpression: function (operator, left, right) {
            return {
                type: Syntax.AssignmentExpression,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBinaryExpression: function (operator, left, right) {
            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
                        Syntax.BinaryExpression;
            return {
                type: type,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBlockStatement: function (body) {
            return {
                type: Syntax.BlockStatement,
                body: body
            };
        },

        createBreakStatement: function (label) {
            return {
                type: Syntax.BreakStatement,
                label: label
            };
        },

        createCallExpression: function (callee, args) {
            return {
                type: Syntax.CallExpression,
                callee: callee,
                'arguments': args
            };
        },

        createCatchClause: function (param, body) {
            return {
                type: Syntax.CatchClause,
                param: param,
                body: body
            };
        },

        createClassDeclaration: function(id,baseId,body) {
            return {
                type: Syntax.ClassDeclaration,
                id:id,
                body:body,
                baseId:baseId
            }
        },

        createConditionalExpression: function (test, consequent, alternate) {
            return {
                type: Syntax.ConditionalExpression,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createContinueStatement: function (label) {
            return {
                type: Syntax.ContinueStatement,
                label: label
            };
        },

        createDebuggerStatement: function () {
            return {
                type: Syntax.DebuggerStatement
            };
        },

        createDoWhileStatement: function (body, test) {
            return {
                type: Syntax.DoWhileStatement,
                body: body,
                test: test
            };
        },

        createEmptyStatement: function () {
            return {
                type: Syntax.EmptyStatement
            };
        },

        createExpressionStatement: function (expression) {
            return {
                type: Syntax.ExpressionStatement,
                expression: expression
            };
        },

        createForStatement: function (init, test, update, body) {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        },

        createForInStatement: function (left, right, body) {
            return {
                type: Syntax.ForInStatement,
                left: left,
                right: right,
                body: body,
                each: false
            };
        },

        createFunctionDeclaration: function (id, params, defaults, body) {
            return {
                type: Syntax.FunctionDeclaration,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },

        createFunctionExpression: function (id, params, defaults, body) {
            return {
                type: Syntax.FunctionExpression,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },

        createIdentifier: function (name) {
            return {
                type: Syntax.Identifier,
                name: name
            };
        },

        createIfStatement: function (test, consequent, alternate) {
            return {
                type: Syntax.IfStatement,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createLabeledStatement: function (label, body) {
            return {
                type: Syntax.LabeledStatement,
                label: label,
                body: body
            };
        },

        createLiteral: function (token) {
            return {
                type: Syntax.Literal,
                value: token.value,
                raw: source.slice(token.range[0], token.range[1])
            };
        },

        createMemberExpression: function (accessor, object, property) {
            return {
                type: Syntax.MemberExpression,
                computed: accessor === '[',
                object: object,
                property: property
            };
        },

        createNewExpression: function (callee, args) {
            return {
                type: Syntax.NewExpression,
                callee: callee,
                'arguments': args
            };
        },

        createObjectExpression: function (properties) {
            return {
                type: Syntax.ObjectExpression,
                properties: properties
            };
        },

        createPostfixExpression: function (operator, argument) {
            return {
                type: Syntax.UpdateExpression,
                operator: operator,
                argument: argument,
                prefix: false
            };
        },

        createProgram: function (body) {
            return {
                type: Syntax.Program,
                body: body
            };
        },

        createProperty: function (kind, key, value) {
            return {
                type: Syntax.Property,
                key: key,
                value: value,
                kind: kind
            };
        },

        createReturnStatement: function (argument) {
            return {
                type: Syntax.ReturnStatement,
                argument: argument
            };
        },

        createSequenceExpression: function (expressions) {
            return {
                type: Syntax.SequenceExpression,
                expressions: expressions
            };
        },

        createSwitchCase: function (test, consequent) {
            return {
                type: Syntax.SwitchCase,
                test: test,
                consequent: consequent
            };
        },

        createSwitchStatement: function (discriminant, cases) {
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant,
                cases: cases
            };
        },

        createThisExpression: function () {
            return {
                type: Syntax.ThisExpression
            };
        },

        createThrowStatement: function (argument) {
            return {
                type: Syntax.ThrowStatement,
                argument: argument
            };
        },

        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            return {
                type: Syntax.TryStatement,
                block: block,
                guardedHandlers: guardedHandlers,
                handlers: handlers,
                finalizer: finalizer
            };
        },

        createUnaryExpression: function (operator, argument) {
            if (operator === '++' || operator === '--') {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            }
            return {
                type: Syntax.UnaryExpression,
                operator: operator,
                argument: argument
            };
        },

        createVariableDeclaration: function (declarations, kind) {
            return {
                type: Syntax.VariableDeclaration,
                declarations: declarations,
                kind: kind
            };
        },

        createVariableDeclarator: function (id, init) {
            return {
                type: Syntax.VariableDeclarator,
                id: id,
                init: init
            };
        },

        createWhileStatement: function (test, body) {
            return {
                type: Syntax.WhileStatement,
                test: test,
                body: body
            };
        },

        createWithStatement: function (object, body) {
            return {
                type: Syntax.WithStatement,
                object: object,
                body: body
            };
        },

        createHTMLExpressionStatement: function (expression) {
            return {
                type: Syntax.HTMLExpressionStatement,
                expression: expression
            };
        },

        createXJSAttribute: function (name, value) {
            return {
                type: Syntax.XJSAttribute,
                name: name,
                value: value || null
            };
        },

        createXJSSpreadAttribute: function (argument) {
            return {
                type: Syntax.XJSSpreadAttribute,
                argument: argument
            };
        },

        createXJSIdentifier: function (name) {
            return {
                type: Syntax.XJSIdentifier,
                name: name
            };
        },

        createXJSNamespacedName: function (namespace, name) {
            return {
                type: Syntax.XJSNamespacedName,
                namespace: namespace,
                name: name
            };
        },

        createXJSMemberExpression: function (object, property) {
            return {
                type: Syntax.XJSMemberExpression,
                object: object,
                property: property
            };
        },

        createXJSElement: function (openingElement, closingElement, children) {
            return {
                type: Syntax.XJSElement,
                openingElement: openingElement,
                closingElement: closingElement,
                children: children
            };
        },

        createXJSEmptyExpression: function () {
            return {
                type: Syntax.XJSEmptyExpression
            };
        },

        createXJSExpressionContainer: function (expression) {
            return {
                type: Syntax.XJSExpressionContainer,
                expression: expression
            };
        },

        createXJSOpeningElement: function (name, attributes, selfClosing) {
            return {
                type: Syntax.XJSOpeningElement,
                name: name,
                selfClosing: selfClosing,
                attributes: attributes
            };
        },

        createXJSClosingElement: function (name) {
            return {
                type: Syntax.XJSClosingElement,
                name: name
            };
        },        
    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.range[0];
            error.lineNumber = token.lineNumber;
            error.column = token.range[0] - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

            try {
                throw new Error("test");
            }
            catch(e) {
                console.log(e.stack);
            }


        error.description = msg;
        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator
    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var line;

        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            return;
        }

        if (match(';')) {
            lex();
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [];

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        expect(']');

        return delegate.createArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body;

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return delegate.createFunctionExpression(null, param, [], body);
    }

    function parseObjectPropertyKey() {
        var token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return delegate.createLiteral(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key, id, value, param;

        token = lookahead;

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                value = parsePropertyFunction([]);
                return delegate.createProperty('get', key, value);
            }
            if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    throwUnexpected(lex());
                }
                param = [ parseVariableIdentifier() ];
                expect(')');
                value = parsePropertyFunction(param, token);
                return delegate.createProperty('set', key, value);
            }
            expect(':');
            value = parseAssignmentExpression();
            return delegate.createProperty('init', id, value);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            value = parseAssignmentExpression();
            return delegate.createProperty('init', key, value);
        }
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String;

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return delegate.createObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token;

        type = lookahead.type;

        if (type === Token.Identifier) {
            return delegate.createIdentifier(lex().value);
        }

        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            return delegate.createLiteral(lex());
        }

        if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                return delegate.createThisExpression();
            }

            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
        }

        if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            return delegate.createLiteral(token);
        }

        if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            return delegate.createLiteral(token);
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('/') || match('/=')) {
            return delegate.createLiteral(scanRegExp());
        }

        return throwUnexpected(lex());
    }

    function parseHTMLExpression() {
        return parseXJSElement();
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args;

        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return delegate.createNewExpression(callee, args);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(')) {
            if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            }
        }

        return expr;
    }


    function parseLeftHandSideExpression() {
        var expr, property;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[')) {
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr = parseLeftHandSideExpressionAllowCall(), token;

        if (lookahead.type !== Token.Punctuator) {
            return expr;
        }

        if ((match('++') || match('--')) && !peekLineTerminator()) {
            // 11.3.1, 11.3.2
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPostfix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            token = lex();
            expr = delegate.createPostfixExpression(token.value, expr);
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            return parsePostfixExpression();
        }

        if (match('++') || match('--')) {
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            return delegate.createUnaryExpression(token.value, expr);
        }

        if (match('+') || match('-') || match('~') || match('!')) {
            token = lex();
            expr = parseUnaryExpression();
            return delegate.createUnaryExpression(token.value, expr);
        }

        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
            return expr;
        }

        return parsePostfixExpression();
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var expr, token, prec, previousAllowIn, stack, right, operator, left, i;

        previousAllowIn = state.allowIn;
        state.allowIn = true;

        expr = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token, previousAllowIn);
        if (prec === 0) {
            return expr;
        }
        token.prec = prec;
        lex();

        stack = [expr, token, parseUnaryExpression()];

        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                stack.push(delegate.createBinaryExpression(operator, left, right));
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            stack.push(parseUnaryExpression());
        }

        state.allowIn = previousAllowIn;

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }
        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate;

        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = delegate.createConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var token, left, right;

        token = lookahead;
        left = parseConditionalExpression();

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(left)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            token = lex();
            right = parseAssignmentExpression();
            return delegate.createAssignmentExpression(token.value, left, right);
        }

        return left;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr = parseAssignmentExpression();

        if (match(',')) {
            expr = delegate.createSequenceExpression([ expr ]);

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expr.expressions.push(parseAssignmentExpression());
            }

        }
        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block;

        expect('{');

        block = parseStatementList();

        expect('}');

        return delegate.createBlockStatement(block);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseVariableDeclaration(kind) {
        var id = parseVariableIdentifier(),
            init = null;

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return delegate.createVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement() {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return delegate.createVariableDeclaration(declarations, 'var');
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations;

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return delegate.createVariableDeclaration(declarations, kind);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        expect(';');
        return delegate.createEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var expr = parseExpression();
        consumeSemicolon();
        return delegate.createExpressionStatement(expr);
    }

    // HTML Enhancements

    var XHTMLEntities = {
        quot: '\u0022',
        amp: '&',
        apos: '\u0027',
        lt: '<',
        gt: '>',
        nbsp: '\u00A0',
        iexcl: '\u00A1',
        cent: '\u00A2',
        pound: '\u00A3',
        curren: '\u00A4',
        yen: '\u00A5',
        brvbar: '\u00A6',
        sect: '\u00A7',
        uml: '\u00A8',
        copy: '\u00A9',
        ordf: '\u00AA',
        laquo: '\u00AB',
        not: '\u00AC',
        shy: '\u00AD',
        reg: '\u00AE',
        macr: '\u00AF',
        deg: '\u00B0',
        plusmn: '\u00B1',
        sup2: '\u00B2',
        sup3: '\u00B3',
        acute: '\u00B4',
        micro: '\u00B5',
        para: '\u00B6',
        middot: '\u00B7',
        cedil: '\u00B8',
        sup1: '\u00B9',
        ordm: '\u00BA',
        raquo: '\u00BB',
        frac14: '\u00BC',
        frac12: '\u00BD',
        frac34: '\u00BE',
        iquest: '\u00BF',
        Agrave: '\u00C0',
        Aacute: '\u00C1',
        Acirc: '\u00C2',
        Atilde: '\u00C3',
        Auml: '\u00C4',
        Aring: '\u00C5',
        AElig: '\u00C6',
        Ccedil: '\u00C7',
        Egrave: '\u00C8',
        Eacute: '\u00C9',
        Ecirc: '\u00CA',
        Euml: '\u00CB',
        Igrave: '\u00CC',
        Iacute: '\u00CD',
        Icirc: '\u00CE',
        Iuml: '\u00CF',
        ETH: '\u00D0',
        Ntilde: '\u00D1',
        Ograve: '\u00D2',
        Oacute: '\u00D3',
        Ocirc: '\u00D4',
        Otilde: '\u00D5',
        Ouml: '\u00D6',
        times: '\u00D7',
        Oslash: '\u00D8',
        Ugrave: '\u00D9',
        Uacute: '\u00DA',
        Ucirc: '\u00DB',
        Uuml: '\u00DC',
        Yacute: '\u00DD',
        THORN: '\u00DE',
        szlig: '\u00DF',
        agrave: '\u00E0',
        aacute: '\u00E1',
        acirc: '\u00E2',
        atilde: '\u00E3',
        auml: '\u00E4',
        aring: '\u00E5',
        aelig: '\u00E6',
        ccedil: '\u00E7',
        egrave: '\u00E8',
        eacute: '\u00E9',
        ecirc: '\u00EA',
        euml: '\u00EB',
        igrave: '\u00EC',
        iacute: '\u00ED',
        icirc: '\u00EE',
        iuml: '\u00EF',
        eth: '\u00F0',
        ntilde: '\u00F1',
        ograve: '\u00F2',
        oacute: '\u00F3',
        ocirc: '\u00F4',
        otilde: '\u00F5',
        ouml: '\u00F6',
        divide: '\u00F7',
        oslash: '\u00F8',
        ugrave: '\u00F9',
        uacute: '\u00FA',
        ucirc: '\u00FB',
        uuml: '\u00FC',
        yacute: '\u00FD',
        thorn: '\u00FE',
        yuml: '\u00FF',
        OElig: '\u0152',
        oelig: '\u0153',
        Scaron: '\u0160',
        scaron: '\u0161',
        Yuml: '\u0178',
        fnof: '\u0192',
        circ: '\u02C6',
        tilde: '\u02DC',
        Alpha: '\u0391',
        Beta: '\u0392',
        Gamma: '\u0393',
        Delta: '\u0394',
        Epsilon: '\u0395',
        Zeta: '\u0396',
        Eta: '\u0397',
        Theta: '\u0398',
        Iota: '\u0399',
        Kappa: '\u039A',
        Lambda: '\u039B',
        Mu: '\u039C',
        Nu: '\u039D',
        Xi: '\u039E',
        Omicron: '\u039F',
        Pi: '\u03A0',
        Rho: '\u03A1',
        Sigma: '\u03A3',
        Tau: '\u03A4',
        Upsilon: '\u03A5',
        Phi: '\u03A6',
        Chi: '\u03A7',
        Psi: '\u03A8',
        Omega: '\u03A9',
        alpha: '\u03B1',
        beta: '\u03B2',
        gamma: '\u03B3',
        delta: '\u03B4',
        epsilon: '\u03B5',
        zeta: '\u03B6',
        eta: '\u03B7',
        theta: '\u03B8',
        iota: '\u03B9',
        kappa: '\u03BA',
        lambda: '\u03BB',
        mu: '\u03BC',
        nu: '\u03BD',
        xi: '\u03BE',
        omicron: '\u03BF',
        pi: '\u03C0',
        rho: '\u03C1',
        sigmaf: '\u03C2',
        sigma: '\u03C3',
        tau: '\u03C4',
        upsilon: '\u03C5',
        phi: '\u03C6',
        chi: '\u03C7',
        psi: '\u03C8',
        omega: '\u03C9',
        thetasym: '\u03D1',
        upsih: '\u03D2',
        piv: '\u03D6',
        ensp: '\u2002',
        emsp: '\u2003',
        thinsp: '\u2009',
        zwnj: '\u200C',
        zwj: '\u200D',
        lrm: '\u200E',
        rlm: '\u200F',
        ndash: '\u2013',
        mdash: '\u2014',
        lsquo: '\u2018',
        rsquo: '\u2019',
        sbquo: '\u201A',
        ldquo: '\u201C',
        rdquo: '\u201D',
        bdquo: '\u201E',
        dagger: '\u2020',
        Dagger: '\u2021',
        bull: '\u2022',
        hellip: '\u2026',
        permil: '\u2030',
        prime: '\u2032',
        Prime: '\u2033',
        lsaquo: '\u2039',
        rsaquo: '\u203A',
        oline: '\u203E',
        frasl: '\u2044',
        euro: '\u20AC',
        image: '\u2111',
        weierp: '\u2118',
        real: '\u211C',
        trade: '\u2122',
        alefsym: '\u2135',
        larr: '\u2190',
        uarr: '\u2191',
        rarr: '\u2192',
        darr: '\u2193',
        harr: '\u2194',
        crarr: '\u21B5',
        lArr: '\u21D0',
        uArr: '\u21D1',
        rArr: '\u21D2',
        dArr: '\u21D3',
        hArr: '\u21D4',
        forall: '\u2200',
        part: '\u2202',
        exist: '\u2203',
        empty: '\u2205',
        nabla: '\u2207',
        isin: '\u2208',
        notin: '\u2209',
        ni: '\u220B',
        prod: '\u220F',
        sum: '\u2211',
        minus: '\u2212',
        lowast: '\u2217',
        radic: '\u221A',
        prop: '\u221D',
        infin: '\u221E',
        ang: '\u2220',
        and: '\u2227',
        or: '\u2228',
        cap: '\u2229',
        cup: '\u222A',
        'int': '\u222B',
        there4: '\u2234',
        sim: '\u223C',
        cong: '\u2245',
        asymp: '\u2248',
        ne: '\u2260',
        equiv: '\u2261',
        le: '\u2264',
        ge: '\u2265',
        sub: '\u2282',
        sup: '\u2283',
        nsub: '\u2284',
        sube: '\u2286',
        supe: '\u2287',
        oplus: '\u2295',
        otimes: '\u2297',
        perp: '\u22A5',
        sdot: '\u22C5',
        lceil: '\u2308',
        rceil: '\u2309',
        lfloor: '\u230A',
        rfloor: '\u230B',
        lang: '\u2329',
        rang: '\u232A',
        loz: '\u25CA',
        spades: '\u2660',
        clubs: '\u2663',
        hearts: '\u2665',
        diams: '\u2666'
    };    

    function parseHTMLExpressionStatement() {        
        var marker = markerCreate(), expr = parseHTMLExpression();
        return markerApply(marker, delegate.createHTMLExpressionStatement(expr));
    }

    function lookahead2() {
        var adv, pos, line, start, result;

        // If we are collecting the tokens, don't grab the next one yet.
        adv = (typeof extra.advance === 'function') ? extra.advance : advance;

        pos = index;
        line = lineNumber;
        start = lineStart;

        // Scan for the next immediate token.
        if (lookahead === null) {
            lookahead = adv();
        }
        index = lookahead.range[1];
        lineNumber = lookahead.lineNumber;
        lineStart = lookahead.lineStart;

        // Grab the token right after.
        result = adv();
        index = pos;
        lineNumber = line;
        lineStart = start;

        return result;
    }    

    function markerCreate() {
        if (!extra.loc && !extra.range) {
            return undefined;
        }
        skipComment();
        return {offset: index, line: lineNumber, col: index - lineStart};
    }

    function markerApply(marker, node) {
        if (extra.range) {
            node.range = [marker.offset, index];
        }
        if (extra.loc) {
            node.loc = {
                start: {
                    line: marker.line,
                    column: marker.col
                },
                end: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
            node = delegate.postProcess(node);
        }
        if (extra.attachComment) {
            processComment(node);
        }
        return node;
    }

    function markerCreatePreserveWhitespace() {
        if (!extra.loc && !extra.range) {
            return undefined;
        }
        return {offset: index, line: lineNumber, col: index - lineStart};
    }        

    function getQualifiedXJSName(object) {
        if (object.type === Syntax.XJSIdentifier) {
            return object.name;
        }
        if (object.type === Syntax.XJSNamespacedName) {
            return object.namespace.name + ':' + object.name.name;
        }
        if (object.type === Syntax.XJSMemberExpression) {
            return (
                getQualifiedXJSName(object.object) + '.' +
                getQualifiedXJSName(object.property)
            );
        }
    }

    function isXJSIdentifierStart(ch) {
        // exclude backslash (\)
        return (ch !== 92) && isIdentifierStart(ch);
    }

    function isXJSIdentifierPart(ch) {
        // exclude backslash (\) and add hyphen (-)
        return (ch !== 92) && (ch === 45 || isIdentifierPart(ch));
    }

    function scanXJSIdentifier() {
        var ch, start, value = '';

        start = index;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isXJSIdentifierPart(ch)) {
                break;
            }
            value += source[index++];
        }

        return {
            type: Token.XJSIdentifier,
            value: value,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanXJSEntity() {
        var ch, str = '', start = index, count = 0, code;
        ch = source[index];
        assert(ch === '&', 'Entity must start with an ampersand');
        index++;
        while (index < length && count++ < 10) {
            ch = source[index++];
            if (ch === ';') {
                break;
            }
            str += ch;
        }

        // Well-formed entity (ending was found).
        if (ch === ';') {
            // Numeric entity.
            if (str[0] === '#') {
                if (str[1] === 'x') {
                    code = +('0' + str.substr(1));
                } else {
                    // Removing leading zeros in order to avoid treating as octal in old browsers.
                    code = +str.substr(1).replace(Regex.LeadingZeros, '');
                }

                if (!isNaN(code)) {
                    return String.fromCharCode(code);
                }
            } else if (XHTMLEntities[str]) {
                return XHTMLEntities[str];
            }
        }

        // Treat non-entity sequences as regular text.
        index = start + 1;
        return '&';
    }

    function scanXJSText(stopChars) {
        var ch, str = '', start;
        start = index;
        while (index < length) {
            ch = source[index];
            if (stopChars.indexOf(ch) !== -1) {
                break;
            }
            if (ch === '&') {
                str += scanXJSEntity();
            } else {
                index++;
                if (ch === '\r' && source[index] === '\n') {
                    str += ch;
                    ch = source[index];
                    index++;
                }
                if (isLineTerminator(ch.charCodeAt(0))) {
                    ++lineNumber;
                    lineStart = index;
                }
                str += ch;
            }
        }
        return {
            type: Token.XJSText,
            value: str,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanXJSStringLiteral() {
        var innerToken, quote, start;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        innerToken = scanXJSText([quote]);

        if (quote !== source[index]) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        ++index;

        innerToken.range = [start, index];

        return innerToken;
    }

    /**
     * Between XJS opening and closing tags (e.g. <foo>HERE</foo>), anything that
     * is not another XJS tag and is not an expression wrapped by {} is text.
     */
    function advanceXJSChild() {
        var ch = source.charCodeAt(index);

        // { (60)
        if (ch !== 60) {
            return scanXJSText(['<']);
        }

        return scanPunctuator();
    }

    function parseXJSIdentifier() {
        var token, marker = markerCreate();

        if(lookahead.type === Token.Punctuator && lookahead.value === "/") {
            lex();
            if(lookahead.type === Token.XJSIdentifier && lookahead.value === "script") {
                lex();
                lex();
                throw new Error("end of script");
            }
        }
        if (lookahead.type !== Token.XJSIdentifier) {            
            throwUnexpected(lookahead);
        }

        token = lex();
        return markerApply(marker, delegate.createXJSIdentifier(token.value));
    }

    function parseXJSNamespacedName() {
        var namespace, name, marker = markerCreate();

        namespace = parseXJSIdentifier();
        expect(':');
        name = parseXJSIdentifier();

        return markerApply(marker, delegate.createXJSNamespacedName(namespace, name));
    }

    function parseXJSMemberExpression() {
        var marker = markerCreate(),
            expr = parseXJSIdentifier();

        while (match('.')) {
            lex();
            expr = markerApply(marker, delegate.createXJSMemberExpression(expr, parseXJSIdentifier()));
        }

        return expr;
    }

    function parseXJSElementName() {
        if (lookahead2().value === ':') {
            return parseXJSNamespacedName();
        }
        if (lookahead2().value === '.') {
            return parseXJSMemberExpression();
        }

        return parseXJSIdentifier();
    }

    function parseXJSAttributeName() {
        if (lookahead2().value === ':') {
            return parseXJSNamespacedName();
        }

        return parseXJSIdentifier();
    }

    function parseXJSAttributeValue() {
        var value, marker;
        if (match('<')) {
            value = parseXJSElement();
        } else if (lookahead.type === Token.XJSText) {
            marker = markerCreate();
            value = markerApply(marker, delegate.createLiteral(lex()));
        } else {
            throwError({}, Messages.InvalidXJSAttributeValue);
        }
        return value;
    }

    function parseXJSEmptyExpression() {
        var marker = markerCreatePreserveWhitespace();
        while (source.charAt(index) !== '}') {
            index++;
        }
        return markerApply(marker, delegate.createXJSEmptyExpression());
    }

    function parseXJSAttribute() {
        var name, marker;

        marker = markerCreate();

        name = parseXJSAttributeName();

        // HTML empty attribute
        if (match('=')) {
            lex();
            return markerApply(marker, delegate.createXJSAttribute(name, parseXJSAttributeValue()));
        }

        return markerApply(marker, delegate.createXJSAttribute(name));
    }

    function parseXJSChild() {
        var token, marker;
        if (!match('<')) {
            marker = markerCreatePreserveWhitespace();
            token = markerApply(marker, delegate.createLiteral(lex()));
        } else {
            token = parseXJSElement();
        }
        return token;
    }

    function parseXJSClosingElement() {
        var name, origInXJSChild, origInXJSTag, marker = markerCreate();
        origInXJSChild = state.inXJSChild;
        origInXJSTag = state.inXJSTag;
        state.inXJSChild = false;
        state.inXJSTag = true;
        expect('<');
        expect('/');
        name = parseXJSElementName();
        // Because advance() (called by lex() called by expect()) expects there
        // to be a valid token after >, it needs to know whether to look for a
        // standard JS token or an XJS text node
        state.inXJSChild = origInXJSChild;
        state.inXJSTag = origInXJSTag;
        expect('>');
        return markerApply(marker, delegate.createXJSClosingElement(name));
    }

    function parseXJSOpeningElement() {
        var name, attribute, attributes = [], selfClosing = false, origInXJSChild, origInXJSTag, marker = markerCreate();

        origInXJSChild = state.inXJSChild;
        origInXJSTag = state.inXJSTag;
        state.inXJSChild = false;
        state.inXJSTag = true;

        expect('<');

        name = parseXJSElementName();

        while (index < length &&
                lookahead.value !== '/' &&
                lookahead.value !== '>') {
            attributes.push(parseXJSAttribute());
        }

        state.inXJSTag = origInXJSTag;

        if (lookahead.value === '/') {
            expect('/');
            // Because advance() (called by lex() called by expect()) expects
            // there to be a valid token after >, it needs to know whether to
            // look for a standard JS token or an XJS text node
            state.inXJSChild = origInXJSChild;
            expect('>');
            selfClosing = true;
        } else {
            state.inXJSChild = true;
            expect('>');
        }
        return markerApply(marker, delegate.createXJSOpeningElement(name, attributes, selfClosing));
    }

    function parseXJSElement() {
        var openingElement, closingElement = null, children = [], origInXJSChild, origInXJSTag, marker = markerCreate();

        origInXJSChild = state.inXJSChild;
        origInXJSTag = state.inXJSTag;
        openingElement = parseXJSOpeningElement();

        if(openingElement.name.name === "script") {
            state = {
                allowIn: true,
                labelSet: {},
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false
            };            
            var program = parseProgram(null, true);
            children.push(program);
        } else if (!openingElement.selfClosing) {
            while (index < length) {
                state.inXJSChild = false; // Call lookahead2() with inXJSChild = false because </ should not be considered in the child
                if (lookahead.value === '<' && lookahead2().value === '/') {
                    break;
                }
                state.inXJSChild = true;
                children.push(parseXJSChild());
            }
            state.inXJSChild = origInXJSChild;
            state.inXJSTag = origInXJSTag;

            closingElement = parseXJSClosingElement();
            if (getQualifiedXJSName(closingElement.name) !== getQualifiedXJSName(openingElement.name)) {
                throwError({}, Messages.ExpectedXJSClosingTag, getQualifiedXJSName(openingElement.name));
            }
        }

        // When (erroneously) writing two adjacent tags like
        //
        //     var x = <div>one</div><div>two</div>;
        //
        // the default error message is a bit incomprehensible. Since it's
        // rarely (never?) useful to write a less-than sign after an XJS
        // element, we disallow it here in the parser in order to provide a
        // better error message. (In the rare case that the less-than operator
        // was intended, the left tag can be wrapped in parentheses.)
        /*
        if (!origInXJSChild && match('<')) {
            throwError(lookahead, Messages.AdjacentXJSElements);
        }
        */

        return markerApply(marker, delegate.createXJSElement(openingElement, closingElement, children));
    }         

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return delegate.createIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return delegate.createDoWhileStatement(body, test);
    }

    function parseWhileStatement() {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return delegate.createWhileStatement(test, body);
    }

    function parseForVariableDeclaration() {
        var token = lex(),
            declarations = parseVariableDeclarationList();

        return delegate.createVariableDeclaration(declarations, token.value);
    }

    function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = true;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = true;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwError({}, Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                delegate.createForStatement(init, test, update, body) :
                delegate.createForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement() {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 59) {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return delegate.createContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement() {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return delegate.createBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement() {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 32) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return delegate.createReturnStatement(argument);
            }
        }

        if (peekLineTerminator()) {
            return delegate.createReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return delegate.createReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement() {
        var object, body;

        if (strict) {
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return delegate.createWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test,
            consequent = [],
            statement;

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }

        return delegate.createSwitchCase(test, consequent);
    }

    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        if (match('}')) {
            lex();
            return delegate.createSwitchStatement(discriminant);
        }

        cases = [];

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return delegate.createSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement() {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return delegate.createThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body;

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead);
        }

        param = parseExpression();
        // 12.14.1
        if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return delegate.createCatchClause(param, body);
    }

    function parseTryStatement() {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return delegate.createTryStatement(block, [], handlers, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement() {
        expectKeyword('debugger');

        consumeSemicolon();

        return delegate.createDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key;

        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement();
            case '{':
                return parseBlock();
            case '(':
                return parseExpressionStatement();
            case '<':
                return parseHTMLExpressionStatement();
            default:
                break;
            }
        }

        if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement();
            case 'class':
                return parseClassDeclaration();
            case 'continue':
                return parseContinueStatement();
            case 'debugger':
                return parseDebuggerStatement();
            case 'do':
                return parseDoWhileStatement();
            case 'for':
                return parseForStatement();
            case 'function':
                return parseFunctionDeclaration();
            case 'if':
                return parseIfStatement();
            case 'return':
                return parseReturnStatement();
            case 'switch':
                return parseSwitchStatement();
            case 'throw':
                return parseThrowStatement();
            case 'try':
                return parseTryStatement();
            case 'var':
                return parseVariableStatement();
            case 'while':
                return parseWhileStatement();
            case 'with':
                return parseWithStatement();
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return delegate.createLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return delegate.createExpressionStatement(expr);
    }

    // 13 Function Definition
    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;

        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return delegate.createBlockStatement(sourceElements);
    }

    function parseParams(firstRestricted) {
        var param, params = [], token, stricted, paramSet, key, message;
        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead;
                param = parseVariableIdentifier();
                key = '$' + token.value;
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[key] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return {
            params: params,
            stricted: stricted,
            firstRestricted: firstRestricted,
            message: message
        };
    }

    function parseClassDeclaration(){

        var id,baseId, body,sourceElement, sourceElements = [], token,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;

        expectKeyword('class');
        token = lookahead;
        id = parseVariableIdentifier();
        if (matchKeyword("extends")){
            lex();
            token = lookahead;
            baseId = parseVariableIdentifier();
        }

        expect('{');
        body = parseClassSourceElements();
        expect('}');

        return delegate.createClassDeclaration(id,baseId,body);

    }

    function parseClassSourceElements(){
        var sourceElement, sourceElements = [], 
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement(true);
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

         state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return delegate.createBlockStatement(sourceElements);
    }

    function parseFunctionDeclaration(impliedFunction) {
        // impliedFunction is true when declaring a function within a class declaration, the function keyword is implied

        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;
        if (!impliedFunction){
            expectKeyword('function');
        }
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return delegate.createFunctionDeclaration(id, params, [], body);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict;

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return delegate.createFunctionExpression(id, params, [], body);
    }

    // 14 Program

    function parseSourceElement(inClassDeclaration, inProgramDeclaration) {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (lookahead.type === Token.Identifier && inClassDeclaration) {
            return parseFunctionDeclaration(true);
        }
        if(match('{') && inProgramDeclaration) {
            return parseObjectInitialiser();
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements(inClassDeclaration, inProgramDeclaration) {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement(null, inProgramDeclaration);
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {

            try {
                sourceElement = parseSourceElement(inClassDeclaration, inProgramDeclaration);                             
            } catch(err) {
                if(err.message === "end of script") {
                    break;
                } else {
                    throw err;
                }
            }
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

   
    function parseProgram(impliedClassDefinition, inProgramDeclaration) {
        var body;
        strict = false;
        peek();
        if (impliedClassDefinition){
            body = parseClassSourceElements();
        }
        else {
            body = parseSourceElements(null, inProgramDeclaration);
        }
        return delegate.createProgram(body);
    }

    // The following functions are needed only when the option to preserve
    // the comments is active.

    function addComment(type, value, start, end, loc) {
        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (extra.comments.length > 0) {
            if (extra.comments[extra.comments.length - 1].range[1] > start) {
                return;
            }
        }

        extra.comments.push({
            type: type,
            value: value,
            range: [start, end],
            loc: loc
        });
    }

    function scanComment() {
        var comment, ch, loc, start, blockComment, lineComment;

        comment = '';
        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source[index];

            if (lineComment) {
                ch = source[index++];
                if (isLineTerminator(ch.charCodeAt(0))) {
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    lineComment = false;
                    addComment('Line', comment, start, index - 1, loc);
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    comment = '';
                } else if (index >= length) {
                    lineComment = false;
                    comment += ch;
                    loc.end = {
                        line: lineNumber,
                        column: length - lineStart
                    };
                    addComment('Line', comment, start, length, loc);
                } else {
                    comment += ch;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch.charCodeAt(0))) {
                    if (ch === '\r' && source[index + 1] === '\n') {
                        ++index;
                        comment += '\r\n';
                    } else {
                        comment += ch;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source[index++];
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    comment += ch;
                    if (ch === '*') {
                        ch = source[index];
                        if (ch === '/') {
                            comment = comment.substr(0, comment.length - 1);
                            blockComment = false;
                            ++index;
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Block', comment, start, index, loc);
                            comment = '';
                        }
                    }
                }
            } else if (ch === '/') {
                ch = source[index + 1];
                if (ch === '/') {
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart
                        }
                    };
                    start = index;
                    index += 2;
                    lineComment = true;
                    if (index >= length) {
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        lineComment = false;
                        addComment('Line', comment, start, index, loc);
                    }
                } else if (ch === '*') {
                    start = index;
                    index += 2;
                    blockComment = true;
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart - 2
                        }
                    };
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch.charCodeAt(0))) {
                ++index;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++index;
                if (ch ===  '\r' && source[index] === '\n') {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function filterCommentLocation() {
        var i, entry, comment, comments = [];

        for (i = 0; i < extra.comments.length; ++i) {
            entry = extra.comments[i];
            comment = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                comment.range = entry.range;
            }
            if (extra.loc) {
                comment.loc = entry.loc;
            }
            comments.push(comment);
        }

        extra.comments = comments;
    }

    function collectToken() {
        var start, loc, token, range, value;

        skipComment();
        start = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = extra.advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            range = [token.range[0], token.range[1]];
            value = source.slice(token.range[0], token.range[1]);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: range,
                loc: loc
            });
        }

        return token;
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = extra.scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function createLocationMarker() {
        var marker = {};

        marker.range = [index, index];
        marker.loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            },
            end: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        marker.end = function () {
            this.range[1] = index;
            this.loc.end.line = lineNumber;
            this.loc.end.column = index - lineStart;
        };

        marker.applyGroup = function (node) {
            if (extra.range) {
                node.groupRange = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.groupLoc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
                node = delegate.postProcess(node);
            }
        };

        marker.apply = function (node) {
            if (extra.range) {
                node.range = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.loc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
                node = delegate.postProcess(node);
            }
        };

        return marker;
    }

    function trackGroupExpression() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();
        expect('(');

        expr = parseExpression();

        expect(')');

        marker.end();
        marker.applyGroup(expr);

        return expr;
    }

    function trackLeftHandSideExpression() {
        var marker, expr, property;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[')) {
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
                marker.end();
                marker.apply(expr);
            } else {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function trackLeftHandSideExpressionAllowCall() {
        var marker, expr, args, property;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(')) {
            if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
                marker.end();
                marker.apply(expr);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
                marker.end();
                marker.apply(expr);
            } else {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function filterGroup(node) {
        var n, i, entry;

        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};
        for (i in node) {
            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {
                entry = node[i];
                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {
                    n[i] = entry;
                } else {
                    n[i] = filterGroup(entry);
                }
            }
        }
        return n;
    }

    function wrapTrackingFunction(range, loc) {

        return function (parseFunction) {

            function isBinary(node) {
                return node.type === Syntax.LogicalExpression ||
                    node.type === Syntax.BinaryExpression;
            }

            function visit(node) {
                var start, end;

                if (isBinary(node.left)) {
                    visit(node.left);
                }
                if (isBinary(node.right)) {
                    visit(node.right);
                }

                if (range) {
                    if (node.left.groupRange || node.right.groupRange) {
                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];
                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];
                        node.range = [start, end];
                    } else if (typeof node.range === 'undefined') {
                        start = node.left.range[0];
                        end = node.right.range[1];
                        node.range = [start, end];
                    }
                }
                if (loc) {
                    if (node.left.groupLoc || node.right.groupLoc) {
                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;
                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;
                        node.loc = {
                            start: start,
                            end: end
                        };
                        node = delegate.postProcess(node);
                    } else if (typeof node.loc === 'undefined') {
                        node.loc = {
                            start: node.left.loc.start,
                            end: node.right.loc.end
                        };
                        node = delegate.postProcess(node);
                    }
                }
            }

            return function () {
                var marker, node;

                skipComment();

                marker = createLocationMarker();
                node = parseFunction.apply(null, arguments);
                marker.end();

                if (range && typeof node.range === 'undefined') {
                    marker.apply(node);
                }

                if (loc && typeof node.loc === 'undefined') {
                    marker.apply(node);
                }

                if (isBinary(node)) {
                    visit(node);
                }

                return node;
            };
        };
    }

    function patch() {

        var wrapTracking;

        if (extra.comments) {
            extra.skipComment = skipComment;
            skipComment = scanComment;
        }

        if (extra.range || extra.loc) {

            extra.parseGroupExpression = parseGroupExpression;
            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;
            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;
            parseGroupExpression = trackGroupExpression;
            parseLeftHandSideExpression = trackLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;

            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);

            extra.parseAssignmentExpression = parseAssignmentExpression;
            extra.parseBinaryExpression = parseBinaryExpression;
            extra.parseBlock = parseBlock;
            extra.parseFunctionSourceElements = parseFunctionSourceElements;
            extra.parseCatchClause = parseCatchClause;
            extra.parseComputedMember = parseComputedMember;
            extra.parseConditionalExpression = parseConditionalExpression;
            extra.parseConstLetDeclaration = parseConstLetDeclaration;
            extra.parseExpression = parseExpression;
            extra.parseForVariableDeclaration = parseForVariableDeclaration;
            extra.parseFunctionDeclaration = parseFunctionDeclaration;
            extra.parseFunctionExpression = parseFunctionExpression;
            extra.parseNewExpression = parseNewExpression;
            extra.parseNonComputedProperty = parseNonComputedProperty;
            extra.parseObjectProperty = parseObjectProperty;
            extra.parseObjectPropertyKey = parseObjectPropertyKey;
            extra.parsePostfixExpression = parsePostfixExpression;
            extra.parsePrimaryExpression = parsePrimaryExpression;
            extra.parseProgram = parseProgram;
            extra.parsePropertyFunction = parsePropertyFunction;
            extra.parseStatement = parseStatement;
            extra.parseSwitchCase = parseSwitchCase;
            extra.parseUnaryExpression = parseUnaryExpression;
            extra.parseVariableDeclaration = parseVariableDeclaration;
            extra.parseVariableIdentifier = parseVariableIdentifier;

            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);
            parseBinaryExpression = wrapTracking(extra.parseBinaryExpression);
            parseBlock = wrapTracking(extra.parseBlock);
            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);
            parseCatchClause = wrapTracking(extra.parseCatchClause);
            parseComputedMember = wrapTracking(extra.parseComputedMember);
            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);
            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);
            parseExpression = wrapTracking(extra.parseExpression);
            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);
            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);
            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);
            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);
            parseNewExpression = wrapTracking(extra.parseNewExpression);
            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);
            parseObjectProperty = wrapTracking(extra.parseObjectProperty);
            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);
            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);
            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);
            parseProgram = wrapTracking(extra.parseProgram);
            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);
            parseStatement = wrapTracking(extra.parseStatement);
            parseSwitchCase = wrapTracking(extra.parseSwitchCase);
            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);
            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);
            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);
        }

        if (typeof extra.tokens !== 'undefined') {
            extra.advance = advance;
            extra.scanRegExp = scanRegExp;

            advance = collectToken;
            scanRegExp = collectRegex;
        }
    }

    function unpatch() {
        if (typeof extra.skipComment === 'function') {
            skipComment = extra.skipComment;
        }

        if (extra.range || extra.loc) {
            parseAssignmentExpression = extra.parseAssignmentExpression;
            parseBinaryExpression = extra.parseBinaryExpression;
            parseBlock = extra.parseBlock;
            parseFunctionSourceElements = extra.parseFunctionSourceElements;
            parseCatchClause = extra.parseCatchClause;
            parseComputedMember = extra.parseComputedMember;
            parseConditionalExpression = extra.parseConditionalExpression;
            parseConstLetDeclaration = extra.parseConstLetDeclaration;
            parseExpression = extra.parseExpression;
            parseForVariableDeclaration = extra.parseForVariableDeclaration;
            parseFunctionDeclaration = extra.parseFunctionDeclaration;
            parseFunctionExpression = extra.parseFunctionExpression;
            parseGroupExpression = extra.parseGroupExpression;
            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;
            parseNewExpression = extra.parseNewExpression;
            parseNonComputedProperty = extra.parseNonComputedProperty;
            parseObjectProperty = extra.parseObjectProperty;
            parseObjectPropertyKey = extra.parseObjectPropertyKey;
            parsePrimaryExpression = extra.parsePrimaryExpression;
            parsePostfixExpression = extra.parsePostfixExpression;
            parseProgram = extra.parseProgram;
            parsePropertyFunction = extra.parsePropertyFunction;
            parseStatement = extra.parseStatement;
            parseSwitchCase = extra.parseSwitchCase;
            parseUnaryExpression = extra.parseUnaryExpression;
            parseVariableDeclaration = extra.parseVariableDeclaration;
            parseVariableIdentifier = extra.parseVariableIdentifier;
        }

        if (typeof extra.scanRegExp === 'function') {
            advance = extra.advance;
            scanRegExp = extra.scanRegExp;
        }
    }

    // This is used to modify the delegate.

    function extend(object, properties) {
        var entry, result = {};

        for (entry in object) {
            if (object.hasOwnProperty(entry)) {
                result[entry] = object[entry];
            }
        }

        for (entry in properties) {
            if (properties.hasOwnProperty(entry)) {
                result[entry] = properties[entry];
            }
        }

        return result;
    }

    function tokenize(code, options) {
        var toString,
            token,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        if (length > 0) {
            if (typeof source[0] === 'undefined') {
                // Try first to convert to a string. This is good as fast path
                // for old IE which understands string indexing for string
                // literals only and not for string object.
                if (code instanceof String) {
                    source = code.valueOf();
                }
            }
        }

        patch();

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            token = lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    token = lex();
                } catch (lexError) {
                    token = lookahead;
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                filterCommentLocation();
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false
        };
        var impliedClass = false;

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                delegate = extend(delegate, {
                    'postProcess': function (node) {
                        node.loc.source = toString(options.source);
                        return node;
                    }
                });
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
        }

        if (length > 0) {
            if (typeof source[0] === 'undefined') {
                // Try first to convert to a string. This is good as fast path
                // for old IE which understands string indexing for string
                // literals only and not for string object.
                if (code instanceof String) {
                    source = code.valueOf();
                }
            }
        }

        patch();
        try {
            program = parseProgram(impliedClass);
            if (typeof extra.comments !== 'undefined') {
                filterCommentLocation();
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
            if (extra.range || extra.loc) {
                program.body = filterGroup(program.body);
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }

        return program;
    }

    // Sync with package.json and component.json.
    exports.version = '1.1.0-dev';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */!function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a="function"==typeof require&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require){var parser=require("emmet/lib/parser/abbreviation");Emmet={},Emmet.expand=function(src){return parser.expand(src,{profile:"plain"})}},{"emmet/lib/parser/abbreviation":31}],2:[function(require,module,exports){(function(__dirname){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function intersection(arr1,arr2){var result=[],smaller=arr1,larger=arr2;return smaller.length>larger.length&&(smaller=arr2,larger=arr1),larger.forEach(function(item){~smaller.indexOf(item)&&result.push(item)}),result}function parseDB(data,optimized){"string"==typeof data&&(data=JSON.parse(data)),optimized||(data=optimize(data)),vendorsDB=data.vendors,cssDB=data.css,erasDB=data.era}function optimize(data){return"string"==typeof data&&(data=JSON.parse(data)),{vendors:parseVendors(data),css:parseCSS(data),era:parseEra(data)}}function parseVendors(data){var out={};return Object.keys(data.agents).forEach(function(name){var agent=data.agents[name];out[name]={prefix:agent.prefix,versions:agent.versions}}),out}function parseCSS(data){{var out={};data.cats.CSS}return Object.keys(data.data).forEach(function(name){var section=data.data[name];name in cssSections&&cssSections[name].forEach(function(kw){out[kw]=section.stats})}),out}function parseEra(data){return Object.keys(data.eras).sort(function(a,b){return parseInt(a.substr(1))-parseInt(b.substr(1))})}function getVendorsList(){var allVendors=Object.keys(vendorsDB),vendors=prefs.getArray("caniuse.vendors");return vendors&&"all"!=vendors[0]?intersection(allVendors,vendors):allVendors}function getVersionSlice(){var era=prefs.get("caniuse.era"),ix=erasDB.indexOf(era);return~ix||(ix=erasDB.indexOf("e-2")),ix}var prefs=require("./preferences"),utils=require("../utils/common");prefs.define("caniuse.enabled",!0,"Enable support of Can I Use database. When enabled,		CSS abbreviation resolver will look at Can I Use database first before detecting		CSS properties that should be resolved"),prefs.define("caniuse.vendors","all","A comma-separated list vendor identifiers		(as described in Can I Use database) that should be supported		when resolving vendor-prefixed properties. Set value to <code>all</code>		to support all available properties"),prefs.define("caniuse.era","e-2","Browser era, as defined in Can I Use database.		Examples: <code>e0</code> (current version), <code>e1</code> (near future)		<code>e-2</code> (2 versions back) and so on.");var cssSections={"border-image":["border-image"],"css-boxshadow":["box-shadow"],"css3-boxsizing":["box-sizing"],multicolumn:["column-width","column-count","columns","column-gap","column-rule-color","column-rule-style","column-rule-width","column-rule","column-span","column-fill"],"border-radius":["border-radius","border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],transforms2d:["transform"],"css-hyphens":["hyphens"],"css-transitions":["transition","transition-property","transition-duration","transition-timing-function","transition-delay"],"font-feature":["font-feature-settings"],"css-animation":["animation","animation-name","animation-duration","animation-timing-function","animation-iteration-count","animation-direction","animation-play-state","animation-delay","animation-fill-mode","@keyframes"],"css-gradients":["linear-gradient"],"css-masks":["mask-image","mask-source-type","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask","mask-type","mask-box-image-source","mask-box-image-slice","mask-box-image-width","mask-box-image-outset","mask-box-image-repeat","mask-box-image","clip-path","clip-rule"],"css-featurequeries":["@supports"],flexbox:["flex","inline-flex","flex-direction","flex-wrap","flex-flow","order","flex"],calc:["calc"],"object-fit":["object-fit","object-position"],"css-grid":["grid","inline-grid","grid-template-rows","grid-template-columns","grid-template-areas","grid-template","grid-auto-rows","grid-auto-columns"," grid-auto-flow","grid-auto-position","grid"," grid-row-start","grid-column-start","grid-row-end","grid-column-end","grid-column","grid-row","grid-area","justify-self","justify-items","align-self","align-items"],"css-repeating-gradients":["repeating-linear-gradient"],"css-filters":["filter"],"user-select-none":["user-select"],"intrinsic-width":["min-content","max-content","fit-content","fill-available"],"css3-tabsize":["tab-size"]},cssDB=null,vendorsDB=null,erasDB=null,db=null;return function(r){if("undefined"==typeof define||!define.amd)try{var fs=r("fs"),path=r("path");db=fs.readFileSync(path.join(__dirname,"../caniuse.json"),{encoding:"utf8"})}catch(e){}}(require),db&&parseDB(db),{load:parseDB,optimize:optimize,resolvePrefixes:function(property){if(!(prefs.get("caniuse.enabled")&&cssDB&&property in cssDB))return null;var prefixes=[],propStats=cssDB[property],versions=getVersionSlice();return getVendorsList().forEach(function(vendor){for(var v,vendorVesions=vendorsDB[vendor].versions.slice(versions),i=0;i<vendorVesions.length;i++)if(v=vendorVesions[i],v&&~propStats[vendor][v].indexOf("x")){prefixes.push(vendorsDB[vendor].prefix);break}}),utils.unique(prefixes).sort(function(a,b){return b.length-a.length})}}})}).call(this,"/node_modules/emmet/lib/assets")},{"../utils/common":43,"./preferences":7}],3:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require,exports,module){function commonFactory(value){return{data:value}}var factories={},reAttrs=/([@\!]?)([\w\-:]+)\s*=\s*(['"])(.*?)\3/g;return module=module||{},module.exports={add:function(name,factory){var that=this;factories[name]=function(){var elem=factory.apply(that,arguments);return elem&&(elem.type=name),elem}},get:function(name){return factories[name]},create:function(name){var args=[].slice.call(arguments,1),factory=this.get(name);return factory?factory.apply(this,args):null},is:function(elem,type){return this.type(elem)===type},type:function(elem){return elem&&elem.type}},module.exports.add("element",function(elementName,attrs,isEmpty){var ret={name:elementName,is_empty:!!isEmpty};if(attrs)if(ret.attributes=[],Array.isArray(attrs))ret.attributes=attrs;else if("string"==typeof attrs)for(var m;m=reAttrs.exec(attrs);)ret.attributes.push({name:m[2],value:m[4],isDefault:"@"==m[1],isImplied:"!"==m[1]});else ret.attributes=Object.keys(attrs).map(function(name){return{name:name,value:attrs[name]}});return ret}),module.exports.add("snippet",commonFactory),module.exports.add("reference",commonFactory),module.exports.add("empty",function(){return{}}),module.exports})},{}],4:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function HandlerList(){this._list=[]}var utils=require("../utils/common");return HandlerList.prototype={add:function(fn,options){var order=this._list.length;options&&"order"in options&&(order=1e4*options.order),this._list.push(utils.extend({},options,{order:order,fn:fn}))},remove:function(fn){var item=utils.find(this._list,function(item){return item.fn===fn});item&&this._list.splice(this._list.indexOf(item),1)},list:function(){return this._list.sort(function(a,b){return b.order-a.order})},listFn:function(){return this.list().map(function(item){return item.fn})},exec:function(skipValue,args){args=args||[];var result=null;return utils.find(this.list(),function(h){return result=h.fn.apply(h,args),result!==skipValue?!0:void 0}),result}},{create:function(){return new HandlerList}}})},{"../utils/common":43}],5:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function openTag(i,match){return{name:match[1],selfClose:!!match[3],range:range(i,match[0]),type:"open"}}function closeTag(i,match){return{name:match[1],range:range(i,match[0]),type:"close"}}function comment(i,match){return{range:range(i,"number"==typeof match?match-i:match[0]),type:"comment"}}function createMatcher(text){var m,memo={};return{open:function(i){var m=this.matches(i);return m&&"open"==m.type?m:null},close:function(i){var m=this.matches(i);return m&&"close"==m.type?m:null},matches:function(i){var key="p"+i;if(!(key in memo)&&(memo[key]=!1,"<"==text.charAt(i))){var substr=text.slice(i);(m=substr.match(reOpenTag))?memo[key]=openTag(i,m):(m=substr.match(reCloseTag))&&(memo[key]=closeTag(i,m))}return memo[key]},text:function(){return text},clean:function(){memo=text=m=null}}}function matches(text,pos,pattern){return text.substring(pos,pos+pattern.length)==pattern}function findClosingPair(open,matcher){for(var stack=[],tag=null,text=matcher.text(),pos=open.range.end,len=text.length;len>pos;pos++){if(matches(text,pos,"<!--"))for(var j=pos;len>j;j++)if(matches(text,j,"-->")){pos=j+3;break}if(tag=matcher.matches(pos)){if("open"!=tag.type||tag.selfClose){if("close"==tag.type){if(!stack.length)return tag.name==open.name?tag:null;if(stack[stack.length-1]==tag.name)stack.pop();else{for(var found=!1;stack.length&&!found;){var last=stack.pop();last==tag.name&&(found=!0)}if(!stack.length&&!found)return tag.name==open.name?tag:null}}}else stack.push(tag.name);pos=tag.range.end-1}}}var range=require("./range"),reOpenTag=/^<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/,reCloseTag=/^<\/([\w\:\-]+)[^>]*>/;return{find:function(text,pos){for(var j,jl,matcher=createMatcher(text),open=null,close=null,i=pos;i>=0;i--)if(open=matcher.open(i)){if(open.selfClose){if(open.range.cmp(pos,"lt","gt"))break;continue}if(close=findClosingPair(open,matcher)){var r=range.create2(open.range.start,close.range.end);if(r.contains(pos))break}else if(open.range.contains(pos))break;open=null}else if(matches(text,i,"-->")){for(j=i-1;j>=0&&!matches(text,j,"-->");j--)if(matches(text,j,"<!--")){i=j;break}}else if(matches(text,i,"<!--")){for(j=i+4,jl=text.length;jl>j;j++)if(matches(text,j,"-->")){j+=3;break}open=comment(i,j);break}if(matcher.clean(),open){var outerRange=null,innerRange=null;if(close?(outerRange=range.create2(open.range.start,close.range.end),innerRange=range.create2(open.range.end,close.range.start)):outerRange=innerRange=range.create2(open.range.start,open.range.end),"comment"==open.type){var _c=outerRange.substring(text);innerRange.start+=_c.length-_c.replace(/^<\!--\s*/,"").length,innerRange.end-=_c.length-_c.replace(/\s*-->$/,"").length}return{open:open,close:close,type:"comment"==open.type?"comment":"tag",innerRange:innerRange,innerContent:function(){return this.innerRange.substring(text)},outerRange:outerRange,outerContent:function(){return this.outerRange.substring(text)},range:innerRange.length()&&innerRange.cmp(pos,"lte","gte")?innerRange:outerRange,content:function(){return this.range.substring(text)},source:text}}},tag:function(text,pos){var result=this.find(text,pos);return result&&"tag"==result.type?result:void 0}}})},{"./range":9}],6:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(){return{log:function(){"undefined"!=typeof console&&console.log&&console.log.apply(console,arguments)}}})},{}],7:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function toBoolean(val){return"string"==typeof val?(val=val.toLowerCase(),"yes"==val||"true"==val||"1"==val):!!val}function isValueObj(obj){return"object"==typeof obj&&!Array.isArray(obj)&&"value"in obj&&Object.keys(obj).length<3}var utils=require("../utils/common"),preferences={},defaults={},_dbgDefaults=null,_dbgPreferences=null;return{define:function(name,value,description){var prefs=name;"string"==typeof name&&(prefs={},prefs[name]={value:value,description:description}),Object.keys(prefs).forEach(function(k){var v=prefs[k];defaults[k]=isValueObj(v)?v:{value:v}})},set:function(name,value){var prefs=name;"string"==typeof name&&(prefs={},prefs[name]=value),Object.keys(prefs).forEach(function(k){var v=prefs[k];if(!(k in defaults))throw new Error('Property "'+k+'" is not defined. You should define it first with `define` method of current module');if(v!==defaults[k].value){switch(typeof defaults[k].value){case"boolean":v=toBoolean(v);break;case"number":v=parseInt(v+"",10)||0;break;default:null!==v&&(v+="")}preferences[k]=v}else k in preferences&&delete preferences[k]})},get:function(name){return name in preferences?preferences[name]:name in defaults?defaults[name].value:void 0},getArray:function(name){var val=this.get(name);return"undefined"==typeof val||null===val||""===val?null:(val=val.split(",").map(utils.trim),val.length?val:null)},getDict:function(name){var result={};return this.getArray(name).forEach(function(val){var parts=val.split(":");result[parts[0]]=parts[1]}),result},description:function(name){return name in defaults?defaults[name].description:void 0},remove:function(name){Array.isArray(name)||(name=[name]),name.forEach(function(key){key in preferences&&delete preferences[key],key in defaults&&delete defaults[key]})},list:function(){return Object.keys(defaults).sort().map(function(key){return{name:key,value:this.get(key),type:typeof defaults[key].value,description:defaults[key].description}},this)},load:function(json){Object.keys(json).forEach(function(key){this.set(key,json[key])},this)},exportModified:function(){return utils.extend({},preferences)},reset:function(){preferences={}},_startTest:function(){_dbgDefaults=defaults,_dbgPreferences=preferences,defaults={},preferences={}},_stopTest:function(){defaults=_dbgDefaults,preferences=_dbgPreferences}}})},{"../utils/common":43}],8:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function OutputProfile(options){utils.extend(this,defaultProfile,options)}function stringCase(str,caseValue){switch(String(caseValue||"").toLowerCase()){case"lower":return str.toLowerCase();case"upper":return str.toUpperCase()}return str}function createProfile(name,options){return profiles[name.toLowerCase()]=new OutputProfile(options)}function createDefaultProfiles(){createProfile("xhtml"),createProfile("html",{self_closing_tag:!1,compact_bool:!0}),createProfile("xml",{self_closing_tag:!0,tag_nl:!0}),createProfile("plain",{tag_nl:!1,indent:!1,place_cursor:!1}),createProfile("line",{tag_nl:!1,indent:!1,extraFilters:"s"}),createProfile("css",{tag_nl:!0}),createProfile("css_line",{tag_nl:!1})}var utils=require("../utils/common"),resources=require("./resources"),prefs=require("./preferences");prefs.define("profile.allowCompactBoolean",!0,'This option can be used to globally disable compact form of boolean attribues (attributes where name and value are equal). With compactform enabled, HTML tags can be outputted as <code>&lt;div contenteditable&gt;</code> instead of <code>&lt;div contenteditable="contenteditable"&gt;</code>'),prefs.define("profile.booleanAttributes","^contenteditable|seamless$","A regular expression for attributes that should be boolean by default.If attribute name matches this expression, you dont have to write dot after attribute name in Emmet abbreviation to mark it as boolean.");var profiles={},defaultProfile={tag_case:"asis",attr_case:"asis",attr_quotes:"double",tag_nl:"decide",tag_nl_leaf:!1,place_cursor:!0,indent:!0,inline_break:3,compact_bool:!1,self_closing_tag:"xhtml",filters:"",extraFilters:""};return OutputProfile.prototype={tagName:function(name){return stringCase(name,this.tag_case)},attributeName:function(name){return stringCase(name,this.attr_case)},attributeQuote:function(){return"single"==this.attr_quotes?"'":'"'},selfClosing:function(){return"xhtml"==this.self_closing_tag?" /":this.self_closing_tag===!0?"/":""},cursor:function(){return this.place_cursor?utils.getCaretPlaceholder():""},isBoolean:function(name,value){if(name==value)return!0;var boolAttrs=prefs.get("profile.booleanAttributes");return!value&&boolAttrs?(boolAttrs=new RegExp(boolAttrs,"i"),boolAttrs.test(name)):!1},allowCompactBoolean:function(){return this.compact_bool&&prefs.get("profile.allowCompactBoolean")}},createDefaultProfiles(),{create:function(name,options){return 2==arguments.length?createProfile(name,options):new OutputProfile(utils.defaults(name||{},defaultProfile))},get:function(name,syntax){if(!name&&syntax){var profile=resources.findItem(syntax,"profile");profile&&(name=profile)}return name?name instanceof OutputProfile?name:"string"==typeof name&&name.toLowerCase()in profiles?profiles[name.toLowerCase()]:this.create(name):profiles.plain},remove:function(name){name=(name||"").toLowerCase(),name in profiles&&delete profiles[name]},reset:function(){profiles={},createDefaultProfiles()},stringCase:stringCase}})},{"../utils/common":43,"./preferences":7,"./resources":10}],9:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require,exports,module){function cmp(a,b,op){switch(op){case"eq":case"==":return a===b;case"lt":case"<":return b>a;case"lte":case"<=":return b>=a;case"gt":case">":return a>b;case"gte":case">=":return a>=b}}function Range(start,len){"object"==typeof start&&"start"in start?(this.start=Math.min(start.start,start.end),this.end=Math.max(start.start,start.end)):Array.isArray(start)?(this.start=start[0],this.end=start[1]):(len="string"==typeof len?len.length:+len,this.start=start,this.end=start+len)}return Range.prototype={length:function(){return Math.abs(this.end-this.start)},equal:function(range){return this.cmp(range,"eq","eq")},shift:function(delta){return this.start+=delta,this.end+=delta,this},overlap:function(range){return range.start<=this.end&&range.end>=this.start},intersection:function(range){if(this.overlap(range)){var start=Math.max(range.start,this.start),end=Math.min(range.end,this.end);return new Range(start,end-start)}return null},union:function(range){if(this.overlap(range)){var start=Math.min(range.start,this.start),end=Math.max(range.end,this.end);return new Range(start,end-start)}return null},inside:function(loc){return this.cmp(loc,"lte","gt")},contains:function(loc){return this.cmp(loc,"lt","gt")},include:function(r){return this.cmp(r,"lte","gte")},cmp:function(loc,left,right){var a,b;return loc instanceof Range?(a=loc.start,b=loc.end):a=b=loc,cmp(this.start,a,left||"<=")&&cmp(this.end,b,right||">")},substring:function(str){return this.length()>0?str.substring(this.start,this.end):""},clone:function(){return new Range(this.start,this.length())},toArray:function(){return[this.start,this.end]},toString:function(){return this.valueOf()},valueOf:function(){return"{"+this.start+", "+this.length()+"}"}},module.exports=function(start,len){return"undefined"==typeof start||null===start?null:start instanceof Range?start:("object"==typeof start&&"start"in start&&"end"in start&&(len=start.end-start.start,start=start.start),new Range(start,len))},module.exports.create=module.exports,module.exports.isRange=function(val){return val instanceof Range},module.exports.create2=function(start,end){return"number"==typeof start&&"number"==typeof end&&(end-=start),this.create(start,end)},module.exports.sort=function(ranges,reverse){return ranges=ranges.sort(function(a,b){return a.start===b.start?b.end-a.end:a.start-b.start}),reverse&&ranges.reverse(),ranges},module.exports})},{}],10:[function(require,module,exports){(function(__dirname){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require,exports){function each(obj,fn){obj&&Object.keys(obj).forEach(function(key){fn(obj[key],key)})}function normalizeCaretPlaceholder(text){return utils.replaceUnescapedSymbol(text,"|",utils.getCaretPlaceholder())}function parseItem(name,value,type){return value=normalizeCaretPlaceholder(value),"snippets"==type?elements.create("snippet",value):"abbreviations"==type?parseAbbreviation(name,value):void 0}function parseAbbreviation(key,value){key=utils.trim(key);var m;return(m=reTag.exec(value))?elements.create("element",m[1],m[2],"/"==m[4]):elements.create("reference",value)}function normalizeName(str){return str.replace(/:$/,"").replace(/:/g,"-")}function expandSnippetsDefinition(snippets){var out={};return each(snippets,function(val,key){for(var items=key.split("|"),i=items.length-1;i>=0;i--)out[items[i]]=val}),out}var handlerList=require("./handlerList"),utils=require("../utils/common"),elements=require("./elements"),stringScore=(require("../assets/logger"),require("../vendor/stringScore")),cssResolver=require("../resolver/css"),VOC_SYSTEM="system",VOC_USER="user",cache={},reTag=/^<(\w+\:?[\w\-]*)((?:\s+[@\!]?[\w\:\-]+\s*=\s*(['"]).*?\3)*)\s*(\/?)>/,systemSettings={},userSettings={},resolvers=handlerList.create();return utils.extend(exports,{setVocabulary:function(data,type){cache={};var voc={};each(data,function(section,syntax){var _section={};each(section,function(subsection,name){("abbreviations"==name||"snippets"==name)&&(subsection=expandSnippetsDefinition(subsection)),_section[name]=subsection}),voc[syntax]=_section}),type==VOC_SYSTEM?systemSettings=voc:userSettings=voc},getVocabulary:function(name){return name==VOC_SYSTEM?systemSettings:userSettings},getMatchedResource:function(node,syntax){return resolvers.exec(null,utils.toArray(arguments))||this.findSnippet(syntax,node.name())},getVariable:function(name){return(this.getSection("variables")||{})[name]},setVariable:function(name,value){var voc=this.getVocabulary("user")||{};"variables"in voc||(voc.variables={}),voc.variables[name]=value,this.setVocabulary(voc,"user")},hasSyntax:function(syntax){return syntax in this.getVocabulary(VOC_USER)||syntax in this.getVocabulary(VOC_SYSTEM)},addResolver:function(fn,options){resolvers.add(fn,options)},removeResolver:function(fn){resolvers.remove(fn)},getSection:function(name){if(!name)return null;name in cache||(cache[name]=utils.deepMerge({},systemSettings[name],userSettings[name]));for(var key,data=cache[name],subsections=utils.toArray(arguments,1);data&&(key=subsections.shift());){if(!(key in data))return null;data=data[key]}return data},findItem:function(topSection,subsection){for(var data=this.getSection(topSection);data;){if(subsection in data)return data[subsection];data=this.getSection(data["extends"])}},findSnippet:function(syntax,name,memo){if(!syntax||!name)return null;memo=memo||[];var names=[name];~name.indexOf("-")&&names.push(name.replace(/\-/g,":"));var data=this.getSection(syntax),matchedItem=null;return["snippets","abbreviations"].some(function(sectionName){var data=this.getSection(syntax,sectionName);return data?names.some(function(n){return data[n]?matchedItem=parseItem(n,data[n],sectionName):void 0}):void 0},this),memo.push(syntax),matchedItem||!data["extends"]||~memo.indexOf(data["extends"])?matchedItem:this.findSnippet(data["extends"],name,memo)},fuzzyFindSnippet:function(syntax,name,minScore){var result=this.fuzzyFindMatches(syntax,name,minScore)[0];return result?result.value.parsedValue:void 0},fuzzyFindMatches:function(syntax,name,minScore){minScore=minScore||.3,name=normalizeName(name);var snippets=this.getAllSnippets(syntax);return Object.keys(snippets).map(function(key){var value=snippets[key];return{key:key,score:stringScore.score(value.nk,name,.1),value:value}}).filter(function(item){return item.score>=minScore}).sort(function(a,b){return a.score-b.score}).reverse()},getAllSnippets:function(syntax){var cacheKey="all-"+syntax;if(!cache[cacheKey]){var stack=[],sectionKey=syntax,memo=[];do{var section=this.getSection(sectionKey);if(!section)break;["snippets","abbreviations"].forEach(function(sectionName){var stackItem={};each(section[sectionName]||null,function(v,k){stackItem[k]={nk:normalizeName(k),value:v,parsedValue:parseItem(k,v,sectionName),type:sectionName}}),stack.push(stackItem)}),memo.push(sectionKey),sectionKey=section["extends"]}while(sectionKey&&!~memo.indexOf(sectionKey));cache[cacheKey]=utils.extend.apply(utils,stack.reverse())}return cache[cacheKey]},getNewline:function(){var nl=this.getVariable("newline");return"string"==typeof nl?nl:"\n"},setNewline:function(str){this.setVariable("newline",str),this.setVariable("nl",str)}}),exports.addResolver(cssResolver.resolve.bind(cssResolver)),function(r){if("undefined"==typeof define||!define.amd)try{var fs=r("fs"),path=r("path"),defaultSnippets=fs.readFileSync(path.join(__dirname,"../snippets.json"),{encoding:"utf8"});exports.setVocabulary(JSON.parse(defaultSnippets),VOC_SYSTEM)}catch(e){}}(require),exports})}).call(this,"/node_modules/emmet/lib/assets")},{"../assets/logger":6,"../resolver/css":39,"../utils/common":43,"../vendor/stringScore":47,"./elements":3,"./handlerList":4}],11:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require,exports,module){function StringStream(string){this.pos=this.start=0,this.string=string,this._length=string.length}return StringStream.prototype={eol:function(){return this.pos>=this._length},sol:function(){return 0===this.pos},peek:function(){return this.string.charAt(this.pos)},next:function(){return this.pos<this._length?this.string.charAt(this.pos++):void 0},eat:function(match){var ok,ch=this.string.charAt(this.pos);return ok="string"==typeof match?ch==match:ch&&(match.test?match.test(ch):match(ch)),ok?(++this.pos,ch):void 0},eatWhile:function(match){for(var start=this.pos;this.eat(match););return this.pos>start},eatSpace:function(){for(var start=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>start},skipToEnd:function(){this.pos=this._length},skipTo:function(ch){var found=this.string.indexOf(ch,this.pos);return found>-1?(this.pos=found,!0):void 0},skipToPair:function(open,close,skipString){for(var ch,braceCount=0,pos=this.pos,len=this._length;len>pos;)if(ch=this.string.charAt(pos++),ch==open)braceCount++;else if(ch==close){if(braceCount--,1>braceCount)return this.pos=pos,!0}else!skipString||'"'!=ch&&"'"!=ch||this.skipString(ch);return!1},skipQuoted:function(noBackup){var ch=this.string.charAt(noBackup?this.pos:this.pos-1);return'"'===ch||"'"===ch?(noBackup&&this.pos++,this.skipString(ch)):void 0},skipString:function(quote){for(var ch,pos=this.pos,len=this._length;len>pos;)if(ch=this.string.charAt(pos++),"\\"!=ch&&ch==quote)return this.pos=pos,!0;return!1},backUp:function(n){this.pos-=n},match:function(pattern,consume,caseInsensitive){if("string"!=typeof pattern){var match=this.string.slice(this.pos).match(pattern);return match&&consume!==!1&&(this.pos+=match[0].length),match}var cased=caseInsensitive?function(str){return str.toLowerCase()}:function(str){return str};return cased(this.string).indexOf(cased(pattern),this.pos)==this.pos?(consume!==!1&&(this.pos+=pattern.length),!0):void 0},current:function(backUp){return this.string.slice(this.start,this.pos-(backUp?1:0))}},module.exports=function(string){return new StringStream(string)},module.exports.create=module.exports,module.exports})},{}],12:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){var utils=require("../utils/common"),stringStream=require("./stringStream"),resources=require("./resources"),startPlaceholderNum=100,tabstopIndex=0,defaultOptions={replaceCarets:!1,escape:function(ch){return"\\"+ch},tabstop:function(data){return data.token},variable:function(data){return data.token}};return{extract:function(text,options){var placeholders={carets:""},marks=[];options=utils.extend({},defaultOptions,options,{tabstop:function(data){var token=data.token,ret="";return"cursor"==data.placeholder?marks.push({start:data.start,end:data.start+token.length,group:"carets",value:""}):("placeholder"in data&&(placeholders[data.group]=data.placeholder),data.group in placeholders&&(ret=placeholders[data.group]),marks.push({start:data.start,end:data.start+token.length,group:data.group,value:ret})),token}}),options.replaceCarets&&(text=text.replace(new RegExp(utils.escapeForRegexp(utils.getCaretPlaceholder()),"g"),"${0:cursor}")),text=this.processText(text,options);var buf="",lastIx=0,tabStops=marks.map(function(mark){buf+=text.substring(lastIx,mark.start);var pos=buf.length,ph=placeholders[mark.group]||"";return buf+=ph,lastIx=mark.end,{group:mark.group,start:pos,end:pos+ph.length}});return buf+=text.substring(lastIx),{text:buf,tabstops:tabStops.sort(function(a,b){return a.start-b.start})}},processText:function(text,options){options=utils.extend({},defaultOptions,options);for(var ch,m,a,buf="",stream=stringStream.create(text);ch=stream.next();)if("\\"!=ch||stream.eol()){if(a=ch,"$"==ch)if(stream.start=stream.pos-1,m=stream.match(/^[0-9]+/))a=options.tabstop({start:buf.length,group:stream.current().substr(1),token:stream.current()});else if(m=stream.match(/^\{([a-z_\-][\w\-]*)\}/))a=options.variable({start:buf.length,name:m[1],token:stream.current()});else if(m=stream.match(/^\{([0-9]+)(:.+?)?\}/,!1)){stream.skipToPair("{","}");var obj={start:buf.length,group:m[1],token:stream.current()},placeholder=obj.token.substring(obj.group.length+2,obj.token.length-1);placeholder&&(obj.placeholder=placeholder.substr(1)),a=options.tabstop(obj)}buf+=a}else buf+=options.escape(stream.next());return buf},upgrade:function(node,offset){var maxNum=0,options={tabstop:function(data){var group=parseInt(data.group,10);return group>maxNum&&(maxNum=group),data.placeholder?"${"+(group+offset)+":"+data.placeholder+"}":"${"+(group+offset)+"}"}};return["start","end","content"].forEach(function(p){node[p]=this.processText(node[p],options)},this),maxNum},variablesResolver:function(node){var placeholderMemo={};return function(str,varName){if("child"==varName)return str;if("cursor"==varName)return utils.getCaretPlaceholder();var attr=node.attribute(varName);if("undefined"!=typeof attr&&attr!==str)return attr;var varValue=resources.getVariable(varName);return varValue?varValue:(placeholderMemo[varName]||(placeholderMemo[varName]=startPlaceholderNum++),"${"+placeholderMemo[varName]+":"+varName+"}")}},replaceVariables:function(str,vars){vars=vars||{};var resolver="function"==typeof vars?vars:function(str,p1){return p1 in vars?vars[p1]:null};return this.processText(str,{variable:function(data){var newValue=resolver(data.token,data.name,data);return null===newValue&&(newValue=resources.getVariable(data.name)),(null===newValue||"undefined"==typeof newValue)&&(newValue=data.token),newValue}})},resetTabstopIndex:function(){tabstopIndex=0,startPlaceholderNum=100},abbrOutputProcessor:function(text,node){var maxNum=0,that=this,tsOptions={tabstop:function(data){var group=parseInt(data.group,10);if(0===group)return"${0}";if(group>maxNum&&(maxNum=group),data.placeholder){var ix=group+tabstopIndex,placeholder=that.processText(data.placeholder,tsOptions);return"${"+ix+":"+placeholder+"}"}return"${"+(group+tabstopIndex)+"}"}};return text=this.processText(text,tsOptions),text=this.replaceVariables(text,this.variablesResolver(node)),tabstopIndex+=maxNum+1,text
}}})},{"../utils/common":43,"./resources":10,"./stringStream":11}],13:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(){function TokenIterator(tokens){this.tokens=tokens,this._position=0,this.reset()}return TokenIterator.prototype={next:function(){if(this.hasNext()){var token=this.tokens[++this._i];return this._position=token.start,token}return this._i=this._il,null},current:function(){return this.tokens[this._i]},peek:function(){return this.tokens[this._i+i]},position:function(){return this._position},hasNext:function(){return this._i<this._il-1},reset:function(){this._i=0,this._il=this.tokens.length},item:function(){return this.tokens[this._i]},itemNext:function(){return this.tokens[this._i+1]},itemPrev:function(){return this.tokens[this._i-1]},nextUntil:function(type,callback){for(var token,test="string"==typeof type?function(t){return t.type==type}:type;(token=this.next())&&(callback&&callback.call(this,token),!test.call(this,token)););}},{create:function(tokens){return new TokenIterator(tokens)}}})},{}],14:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function EditContainer(source,options){this.options=utils.extend({offset:0},options),this.source=source,this._children=[],this._positions={name:0},this.initialize.apply(this,arguments)}function EditElement(parent,nameToken,valueToken){this.parent=parent,this._name=nameToken.value,this._value=valueToken?valueToken.value:"",this._positions={name:nameToken.start,value:valueToken?valueToken.start:-1},this.initialize.apply(this,arguments)}var range=require("../assets/range"),utils=require("../utils/common"),klass=require("../vendor/klass");return EditContainer.extend=klass.extend,EditContainer.prototype={type:"container",initialize:function(){},_pos:function(num,isAbsolute){return num+(isAbsolute?this.options.offset:0)},_updateSource:function(value,start,end){var r=range.create(start,"undefined"==typeof end?0:end-start),delta=value.length-r.length(),update=function(obj){Object.keys(obj).forEach(function(k){obj[k]>=r.end&&(obj[k]+=delta)})};update(this._positions);var recursiveUpdate=function(items){items.forEach(function(item){update(item._positions),"container"==item.type&&recursiveUpdate(item.list())})};recursiveUpdate(this.list()),this.source=utils.replaceSubstring(this.source,value,r)},add:function(name,value){var item=new EditElement(name,value);return this._children.push(item),item},get:function(name){return"number"==typeof name?this.list()[name]:"string"==typeof name?utils.find(this.list(),function(prop){return prop.name()===name}):name},getAll:function(name){Array.isArray(name)||(name=[name]);var names=[],indexes=[];return name.forEach(function(item){"string"==typeof item?names.push(item):"number"==typeof item&&indexes.push(item)}),this.list().filter(function(attribute,i){return~indexes.indexOf(i)||~names.indexOf(attribute.name())})},list:function(){return this._children},remove:function(name){var element=this.get(name);if(element){this._updateSource("",element.fullRange());var ix=this._children.indexOf(element);~ix&&this._children.splice(ix,1)}},indexOf:function(item){return this.list().indexOf(this.get(item))},value:function(name,value,pos){var element=this.get(name);return element?element.value(value):"undefined"!=typeof value?this.add(name,value,pos):void 0},values:function(name){return this.getAll(name).map(function(element){return element.value()})},name:function(val){return"undefined"!=typeof val&&this._name!==(val=String(val))&&(this._updateSource(val,this._positions.name,this._positions.name+this._name.length),this._name=val),this._name},nameRange:function(isAbsolute){return range.create(this._positions.name+(isAbsolute?this.options.offset:0),this.name())},range:function(isAbsolute){return range.create(isAbsolute?this.options.offset:0,this.valueOf())},itemFromPosition:function(pos,isAbsolute){return utils.find(this.list(),function(elem){return elem.range(isAbsolute).inside(pos)})},toString:function(){return this.valueOf()},valueOf:function(){return this.source}},EditElement.extend=klass.extend,EditElement.prototype={type:"element",initialize:function(){},_pos:function(num,isAbsolute){return num+(isAbsolute?this.parent.options.offset:0)},value:function(val){return"undefined"!=typeof val&&this._value!==(val=String(val))&&(this.parent._updateSource(val,this.valueRange()),this._value=val),this._value},name:function(val){return"undefined"!=typeof val&&this._name!==(val=String(val))&&(this.parent._updateSource(val,this.nameRange()),this._name=val),this._name},namePosition:function(isAbsolute){return this._pos(this._positions.name,isAbsolute)},valuePosition:function(isAbsolute){return this._pos(this._positions.value,isAbsolute)},range:function(isAbsolute){return range.create(this.namePosition(isAbsolute),this.valueOf())},fullRange:function(isAbsolute){return this.range(isAbsolute)},nameRange:function(isAbsolute){return range.create(this.namePosition(isAbsolute),this.name())},valueRange:function(isAbsolute){return range.create(this.valuePosition(isAbsolute),this.value())},toString:function(){return this.valueOf()},valueOf:function(){return this.name()+this.value()}},{EditContainer:EditContainer,EditElement:EditElement,createToken:function(start,value,type){var obj={start:start||0,value:value||"",type:type};return obj.end=obj.start+obj.value.length,obj}}})},{"../assets/range":9,"../utils/common":43,"../vendor/klass":46}],15:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function trimWhitespaceInRange(rng,text,mask){mask=mask||WHITESPACE_REMOVE_FROM_START|WHITESPACE_REMOVE_FROM_END,text=rng.substring(text);var m;return mask&WHITESPACE_REMOVE_FROM_START&&(m=text.match(reSpaceStart))&&(rng.start+=m[0].length),mask&WHITESPACE_REMOVE_FROM_END&&(m=text.match(reSpaceEnd))&&(rng.end-=m[0].length),rng.end<rng.start&&(rng.end=rng.start),rng}function consumeSingleProperty(it,text){var name,value,end,token=it.current();if(!token)return null;for(var ws={white:1,line:1,comment:1};(token=it.current())&&token.type in ws;)it.next();if(!it.hasNext())return null;token=it.current(),name=range(token.start,token.value);for(var isAtProperty="@"==token.value.charAt(0);token=it.next();)if(name.end=token.end,":"==token.type||"white"==token.type){if(name.end=token.start,it.next(),":"==token.type||isAtProperty)break}else if(";"==token.type||"line"==token.type){name.end=token.start,value=range(token.start,0),it.next();break}if(token=it.current(),!value&&token){"line"==token.type&&(lastNewline=token),value=range(token.start,token.value);for(var lastNewline;token=it.next();)if(value.end=token.end,"line"==token.type)lastNewline=token;else{if("}"==token.type||";"==token.type){value.end=token.start,";"==token.type&&(end=range(token.start,token.value)),it.next();break}if(":"==token.type&&lastNewline){value.end=lastNewline.start,it._i=it.tokens.indexOf(lastNewline);break}}}return value||(value=range(name.end,0)),{name:trimWhitespaceInRange(name,text),value:trimWhitespaceInRange(value,text,WHITESPACE_REMOVE_FROM_START|(end?WHITESPACE_REMOVE_FROM_END:0)),end:end||range(value.end,0)}}function findParts(str){var ch,stream=stringStream.create(str),result=[],sep=/[\s\u00a0,;]/,add=function(){stream.next(),result.push(range(stream.start,stream.current())),stream.start=stream.pos};for(stream.eatSpace(),stream.start=stream.pos;ch=stream.next();)if('"'==ch||"'"==ch){if(stream.next(),!stream.skipTo(ch))break;add()}else if("("==ch){if(stream.backUp(1),!stream.skipToPair("(",")"))break;stream.backUp(1),add()}else sep.test(ch)&&(result.push(range(stream.start,stream.current().length-1)),stream.eatWhile(sep),stream.start=stream.pos);return add(),utils.unique(result.filter(function(item){return!!item.length()}))}function consumeProperties(node,source,offset){var list=extractPropertiesFromSource(source,offset);list.forEach(function(property){node._children.push(new CSSEditElement(node,editTree.createToken(property.name.start,property.nameText),editTree.createToken(property.value.start,property.valueText),editTree.createToken(property.end.start,property.endText)))})}function extractPropertiesFromSource(source,offset){offset=offset||0,source=source.replace(reSpaceEnd,"");var out=[];if(!source)return out;for(var property,tokens=cssParser.parse(source),it=tokenIterator.create(tokens);property=consumeSingleProperty(it,source);)out.push({nameText:property.name.substring(source),name:property.name.shift(offset),valueText:property.value.substring(source),value:property.value.shift(offset),endText:property.end.substring(source),end:property.end.shift(offset)});return out}var utils=require("../utils/common"),editTree=require("./base"),cssParser=require("../parser/css"),cssSections=require("../utils/cssSections"),range=require("../assets/range"),stringStream=require("../assets/stringStream"),tokenIterator=require("../assets/tokenIterator"),defaultOptions={styleBefore:"\n	",styleSeparator:": ",offset:0},reSpaceStart=/^\s+/,reSpaceEnd=/\s+$/,WHITESPACE_REMOVE_FROM_START=1,WHITESPACE_REMOVE_FROM_END=2,CSSEditContainer=editTree.EditContainer.extend({initialize:function(source,options){utils.extend(this.options,defaultOptions,options),Array.isArray(source)&&(source=cssParser.toSource(source));var allRules=cssSections.findAllRules(source),currentRule=allRules.shift(),topLevelRules=[];allRules.forEach(function(r){var isTopLevel=!utils.find(topLevelRules,function(tr){return tr.contains(r)});isTopLevel&&topLevelRules.push(r)});var selectorRange=range.create2(currentRule.start,currentRule._selectorEnd);this._name=selectorRange.substring(source),this._positions.name=selectorRange.start,this._positions.contentStart=currentRule._contentStart+1;var sectionOffset=currentRule._contentStart+1,that=(currentRule.end-1,this);topLevelRules.forEach(function(r){consumeProperties(that,source.substring(sectionOffset,r.start),sectionOffset);utils.extend({},that.options,{offset:r.start+that.options.offset});sectionOffset=r.end}),consumeProperties(this,source.substring(sectionOffset,currentRule.end-1),sectionOffset),this._saveStyle()},_saveStyle:function(){var start=this._positions.contentStart,source=this.source;this.list().forEach(function(p){if("container"!==p.type){p.styleBefore=source.substring(start,p.namePosition());var lines=utils.splitByLines(p.styleBefore);lines.length>1&&(p.styleBefore="\n"+lines[lines.length-1]),p.styleSeparator=source.substring(p.nameRange().end,p.valuePosition());var parts=p.styleBefore.split("*/");p.styleBefore=parts[parts.length-1],p.styleSeparator=p.styleSeparator.replace(/\/\*.*?\*\//g,""),start=p.range().end}})},namePosition:function(isAbsolute){return this._pos(this._positions.name,isAbsolute)},valuePosition:function(isAbsolute){return this._pos(this._positions.contentStart,isAbsolute)},valueRange:function(isAbsolute){return range.create2(this.valuePosition(isAbsolute),this._pos(this.valueOf().length,isAbsolute)-1)},add:function(name,value,pos){var list=this.list(),start=this._positions.contentStart,styles=utils.pick(this.options,"styleBefore","styleSeparator");"undefined"==typeof pos&&(pos=list.length);var donor=list[pos];donor?start=donor.fullRange().start:(donor=list[pos-1])&&(donor.end(";"),start=donor.range().end),donor&&(styles=utils.pick(donor,"styleBefore","styleSeparator"));var nameToken=editTree.createToken(start+styles.styleBefore.length,name),valueToken=editTree.createToken(nameToken.end+styles.styleSeparator.length,value),property=new CSSEditElement(this,nameToken,valueToken,editTree.createToken(valueToken.end,";"));return utils.extend(property,styles),this._updateSource(property.styleBefore+property.toString(),start),this._children.splice(pos,0,property),property}}),CSSEditElement=editTree.EditElement.extend({initialize:function(rule,name,value,end){this.styleBefore=rule.options.styleBefore,this.styleSeparator=rule.options.styleSeparator,this._end=end.value,this._positions.end=end.start},valueParts:function(isAbsolute){var parts=findParts(this.value());if(isAbsolute){var offset=this.valuePosition(!0);parts.forEach(function(p){p.shift(offset)})}return parts},value:function(val){var isUpdating="undefined"!=typeof val,allItems=this.parent.list();if(isUpdating&&this.isIncomplete()){var self=this,donor=utils.find(allItems,function(item){return item!==self&&!item.isIncomplete()});this.styleSeparator=donor?donor.styleSeparator:this.parent.options.styleSeparator,this.parent._updateSource(this.styleSeparator,range(this.valueRange().start,0))}var value=this.constructor.__super__.value.apply(this,arguments);if(isUpdating){var ix=allItems.indexOf(this);ix===allItems.length-1||this.end()||this.end(";")}return value},isIncomplete:function(){return this.nameRange().end===this.valueRange().start},end:function(val){return"undefined"!=typeof val&&this._end!==val&&(this.parent._updateSource(val,this._positions.end,this._positions.end+this._end.length),this._end=val),this._end},fullRange:function(isAbsolute){var r=this.range(isAbsolute);return r.start-=this.styleBefore.length,r},valueOf:function(){return this.name()+this.styleSeparator+this.value()+this.end()}});return{parse:function(source,options){return new CSSEditContainer(source,options)},parseFromPosition:function(content,pos,isBackward){var bounds=cssSections.locateRule(content,pos,isBackward);return bounds&&bounds.inside(pos)?this.parse(bounds.substring(content),{offset:bounds.start}):null},propertyFromPosition:function(css,pos){var cssProp=null,cssRule="string"==typeof css?this.parseFromPosition(css,pos,!0):css;return cssRule&&(cssProp=cssRule.itemFromPosition(pos,!0),cssProp||(cssProp=utils.find(cssRule.list(),function(elem){return elem.range(!0).end==pos}))),cssProp},baseName:function(name){return name.replace(/^\s*\-\w+\-/,"")},findParts:findParts,extractPropertiesFromSource:extractPropertiesFromSource}})},{"../assets/range":9,"../assets/stringStream":11,"../assets/tokenIterator":13,"../parser/css":32,"../utils/common":43,"../utils/cssSections":44,"./base":14}],16:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){var editTree=require("./base"),xmlParser=require("../parser/xml"),range=require("../assets/range"),utils=require("../utils/common"),defaultOptions={styleBefore:" ",styleSeparator:"=",styleQuote:'"',offset:0},startTag=/^<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/m,XMLEditContainer=editTree.EditContainer.extend({initialize:function(source){utils.defaults(this.options,defaultOptions),this._positions.name=1;var attrToken=null,tokens=xmlParser.parse(source);tokens.forEach(function(token){switch(token.value=range.create(token).substring(source),token.type){case"tag":/^<[^\/]+/.test(token.value)&&(this._name=token.value.substring(1));break;case"attribute":attrToken&&this._children.push(new XMLEditElement(this,attrToken)),attrToken=token;break;case"string":this._children.push(new XMLEditElement(this,attrToken,token)),attrToken=null}},this),attrToken&&this._children.push(new XMLEditElement(this,attrToken)),this._saveStyle()},_saveStyle:function(){var start=this.nameRange().end,source=this.source;this.list().forEach(function(p){p.styleBefore=source.substring(start,p.namePosition()),-1!==p.valuePosition()&&(p.styleSeparator=source.substring(p.namePosition()+p.name().length,p.valuePosition()-p.styleQuote.length)),start=p.range().end})},add:function(name,value,pos){var list=this.list(),start=this.nameRange().end,styles=utils.pick(this.options,"styleBefore","styleSeparator","styleQuote");"undefined"==typeof pos&&(pos=list.length);var donor=list[pos];donor?start=donor.fullRange().start:(donor=list[pos-1])&&(start=donor.range().end),donor&&(styles=utils.pick(donor,"styleBefore","styleSeparator","styleQuote")),value=styles.styleQuote+value+styles.styleQuote;var attribute=new XMLEditElement(this,editTree.createToken(start+styles.styleBefore.length,name),editTree.createToken(start+styles.styleBefore.length+name.length+styles.styleSeparator.length,value));return utils.extend(attribute,styles),this._updateSource(attribute.styleBefore+attribute.toString(),start),this._children.splice(pos,0,attribute),attribute},addClass:function(value){var attr=this.get("class");if(value=utils.trim(value),!attr)return this.add("class",value);var classVal=attr.value(),classList=" "+classVal.replace(/\n/g," ")+" ";~classList.indexOf(" "+value+" ")||attr.value(classVal+" "+value)},removeClass:function(value){var attr=this.get("class");if(value=utils.trim(value),attr){var reClass=new RegExp("(^|\\s+)"+utils.escapeForRegexp(value)),classVal=attr.value().replace(reClass,"");utils.trim(classVal)?attr.value(classVal):this.remove("class")}}}),XMLEditElement=editTree.EditElement.extend({initialize:function(parent,nameToken,valueToken){this.styleBefore=parent.options.styleBefore,this.styleSeparator=parent.options.styleSeparator;var value="",quote=parent.options.styleQuote;valueToken&&(value=valueToken.value,quote=value.charAt(0),'"'==quote||"'"==quote?value=value.substring(1):quote="",quote&&value.charAt(value.length-1)==quote&&(value=value.substring(0,value.length-1))),this.styleQuote=quote,this._value=value,this._positions.value=valueToken?valueToken.start+quote.length:-1},fullRange:function(isAbsolute){var r=this.range(isAbsolute);return r.start-=this.styleBefore.length,r},valueOf:function(){return this.name()+this.styleSeparator+this.styleQuote+this.value()+this.styleQuote}});return{parse:function(source,options){return new XMLEditContainer(source,options)},parseFromPosition:function(content,pos,isBackward){var bounds=this.extractTag(content,pos,isBackward);return bounds&&bounds.inside(pos)?this.parse(bounds.substring(content),{offset:bounds.start}):null},extractTag:function(content,pos,isBackward){var i,len=content.length,maxLen=Math.min(2e3,len),r=null,match=function(pos){var m;return"<"==content.charAt(pos)&&(m=content.substr(pos,maxLen).match(startTag))?range.create(pos,m[0]):void 0};for(i=pos;i>=0&&!(r=match(i));i--);if(r&&(r.inside(pos)||isBackward))return r;if(!r&&isBackward)return null;for(i=pos;len>i;i++)if(r=match(i))return r}}})},{"../assets/range":9,"../parser/xml":38,"../utils/common":43,"./base":14}],17:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function getSeparators(){return{element:prefs.get("bem.elementSeparator"),modifier:prefs.get("bem.modifierSeparator")}}function bemParse(item){if(abbreviationUtils.isSnippet(item))return item;item.__bem={block:"",element:"",modifier:""};var classNames=normalizeClassName(item.attribute("class")).split(" "),reBlockName=/^[a-z]\-/i;return item.__bem.block=utils.find(classNames,function(name){return reBlockName.test(name)}),item.__bem.block||(reBlockName=/^[a-z]/i,item.__bem.block=utils.find(classNames,function(name){return reBlockName.test(name)})||""),classNames=classNames.map(function(name){return processClassName(name,item)}),classNames=utils.unique(utils.flatten(classNames)).join(" "),classNames&&item.attribute("class",classNames),item}function normalizeClassName(className){className=(" "+(className||"")+" ").replace(/\s+/g," ");var shortSymbol=prefs.get("bem.shortElementPrefix");if(shortSymbol){var re=new RegExp("\\s("+utils.escapeForRegexp(shortSymbol)+"+)","g");className=className.replace(re,function(str,p1){return" "+utils.repeatString(getSeparators().element,p1.length)})}return utils.trim(className)}function processClassName(name,item){name=transformClassName(name,item,"element"),name=transformClassName(name,item,"modifier");var block="",element="",modifier="",separators=getSeparators();if(~name.indexOf(separators.element)){var elements=name.split(separators.element);block=elements.shift();var modifiers=elements.pop().split(separators.modifier);elements.push(modifiers.shift()),element=elements.join(separators.element),modifier=modifiers.join(separators.modifier)}else if(~name.indexOf(separators.modifier)){var blockModifiers=name.split(separators.modifier);block=blockModifiers.shift(),modifier=blockModifiers.join(separators.modifier)}if(block||element||modifier){block||(block=item.__bem.block);var prefix=block,result=[];return element?(prefix+=separators.element+element,result.push(prefix)):result.push(prefix),modifier&&result.push(prefix+separators.modifier+modifier),item.__bem.block=block,item.__bem.element=element,item.__bem.modifier=modifier,result}return name}function transformClassName(name,item,entityType){var separators=getSeparators(),reSep=new RegExp("^("+separators[entityType]+")+","g");if(reSep.test(name)){for(var depth=0,cleanName=name.replace(reSep,function(str){return depth=str.length/separators[entityType].length,""}),donor=item;donor.parent&&depth--;)donor=donor.parent;if(donor&&donor.__bem||(donor=item),donor&&donor.__bem){var prefix=donor.__bem.block;return"modifier"==entityType&&donor.__bem.element&&(prefix+=separators.element+donor.__bem.element),prefix+separators[entityType]+cleanName}}return name}function process(tree,profile){return tree.name&&bemParse(tree,profile),tree.children.forEach(function(item){process(item,profile),!abbreviationUtils.isSnippet(item)&&item.start&&(shouldRunHtmlFilter=!0)}),tree}var htmlFilter=require("./html"),prefs=require("../assets/preferences"),abbreviationUtils=require("../utils/abbreviation"),utils=require("../utils/common");prefs.define("bem.elementSeparator","__","Class names element separator."),prefs.define("bem.modifierSeparator","_","Class names modifier separator."),prefs.define("bem.shortElementPrefix","-","Symbol for describing short block-element notation. Class names prefixed with this symbol will be treated as element name for parents block name. Each symbol instance traverses one level up in parsed tree for block name lookup. Empty value will disable short notation.");var shouldRunHtmlFilter=!1;return function(tree,profile){return shouldRunHtmlFilter=!1,tree=process(tree,profile),shouldRunHtmlFilter&&(tree=htmlFilter(tree,profile)),tree}})},{"../assets/preferences":7,"../utils/abbreviation":41,"../utils/common":43,"./html":23}],18:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function addComments(node,templateBefore,templateAfter){var trigger=prefs.get("filter.commentTrigger");if("*"!=trigger){var shouldAdd=utils.find(trigger.split(","),function(name){return!!node.attribute(utils.trim(name))});if(!shouldAdd)return}var ctx={node:node,name:node.name(),padding:node.parent?node.parent.padding:"",attr:function(name,before,after){var attr=node.attribute(name);return attr?(before||"")+attr+(after||""):""}},nodeBefore=templateBefore?templateBefore(ctx):"",nodeAfter=templateAfter?templateAfter(ctx):"";node.start=node.start.replace(/</,nodeBefore+"<"),node.end=node.end.replace(/>/,">"+nodeAfter)}function process(tree,before,after){return tree.children.forEach(function(item){abbrUtils.isBlock(item)&&addComments(item,before,after),process(item,before,after)}),tree}{var prefs=require("../assets/preferences"),utils=require("../utils/common"),template=require("../utils/template"),abbrUtils=require("../utils/abbreviation");require("./main")}return prefs.define("filter.commentAfter",'\n<!-- /<%= attr("id", "#") %><%= attr("class", ".") %> -->',"A definition of comment that should be placed <i>after</i> matched element when <code>comment</code> filter is applied. This definition is an ERB-style template passed to <code>_.template()</code> function (see Underscore.js docs for details). In template context, the following properties and functions are availabe:\n<ul><li><code>attr(name, before, after)</code>  a function that outputsspecified attribute value concatenated with <code>before</code> and <code>after</code> strings. If attribute doesn't exists, the empty string will be returned.</li><li><code>node</code>  current node (instance of <code>AbbreviationNode</code>)</li><li><code>name</code>  name of current tag</li><li><code>padding</code>  current string padding, can be used for formatting</li></ul>"),prefs.define("filter.commentBefore","","A definition of comment that should be placed <i>before</i> matched element when <code>comment</code> filter is applied. For more info, read description of <code>filter.commentAfter</code> property"),prefs.define("filter.commentTrigger","id, class","A comma-separated list of attribute names that should exist in abbreviatoin where comment should be added. If you wish to add comment for every element, set this option to <code>*</code>"),function(tree){var templateBefore=template(prefs.get("filter.commentBefore")),templateAfter=template(prefs.get("filter.commentAfter"));return process(tree,templateBefore,templateAfter)}})},{"../assets/preferences":7,"../utils/abbreviation":41,"../utils/common":43,"../utils/template":45,"./main":25}],19:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(){function isVeryFirstChild(item){return item.parent&&!item.parent.parent&&!item.index()}return function process(tree,profile,level){return level=level||0,tree.children.forEach(function(item){isVeryFirstChild(item)||profile.tag_nl===!1||(item.start="\n"+item.start),process(item,profile,level+1)}),tree}})},{}],20:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(){function escapeChars(str){return str.replace(/([<>&])/g,function(str,p1){return charMap[p1]})}var charMap={"<":"&lt;",">":"&gt;","&":"&amp;"};return function process(tree){return tree.children.forEach(function(item){item.start=escapeChars(item.start),item.end=escapeChars(item.end),item.content=escapeChars(item.content),process(item)}),tree}})},{}],21:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function getIndentation(node){var items=prefs.getArray("format.noIndentTags")||[];return~items.indexOf(node.name())?"":"	"}function hasBlockSibling(item){return item.parent&&abbrUtils.hasBlockChildren(item.parent)}function isVeryFirstChild(item){return item.parent&&!item.parent.parent&&!item.index()}function shouldAddLineBreak(node,profile){return profile.tag_nl===!0||abbrUtils.isBlock(node)?!0:node.parent&&profile.inline_break?shouldFormatInline(node.parent,profile):!1}function shouldBreakChild(node,profile){return node.children.length&&shouldAddLineBreak(node.children[0],profile)}function shouldFormatInline(node,profile){var nodeCount=0;return!!utils.find(node.children,function(child){return child.isTextNode()||!abbrUtils.isInline(child)?nodeCount=0:abbrUtils.isInline(child)&&nodeCount++,nodeCount>=profile.inline_break?!0:void 0})}function isRoot(item){return!item.parent}function processSnippet(item,profile){return item.start=item.end="",!isVeryFirstChild(item)&&profile.tag_nl!==!1&&shouldAddLineBreak(item,profile)&&(isRoot(item.parent)||!abbrUtils.isInline(item.parent))&&(item.start="\n"+item.start),item}function shouldBreakInsideInline(node,profile){var hasBlockElems=node.children.some(function(child){return abbrUtils.isSnippet(child)?!1:!abbrUtils.isInline(child)});return hasBlockElems?!0:shouldFormatInline(node,profile)}function processTag(item,profile){item.start=item.end=placeholder;var isUnary=abbrUtils.isUnary(item),nl="\n",indent=getIndentation(item);if(profile.tag_nl!==!1){var forceNl=profile.tag_nl===!0&&(profile.tag_nl_leaf||item.children.length);if(!forceNl){var forceIndentTags=prefs.getArray("format.forceIndentationForTags")||[];forceNl=~forceIndentTags.indexOf(item.name())}item.isTextNode()||(shouldAddLineBreak(item,profile)?(isVeryFirstChild(item)||abbrUtils.isSnippet(item.parent)&&!item.index()||(item.start=nl+item.start),(abbrUtils.hasBlockChildren(item)||shouldBreakChild(item,profile)||forceNl&&!isUnary)&&(item.end=nl+item.end),(abbrUtils.hasTagsInContent(item)||forceNl&&!item.children.length&&!isUnary)&&(item.start+=nl+indent)):abbrUtils.isInline(item)&&hasBlockSibling(item)&&!isVeryFirstChild(item)?item.start=nl+item.start:abbrUtils.isInline(item)&&shouldBreakInsideInline(item,profile)&&(item.end=nl+item.end),item.padding=indent)}return item}{var utils=require("../utils/common"),abbrUtils=require("../utils/abbreviation"),prefs=require("../assets/preferences");require("../assets/resources")}prefs.define("format.noIndentTags","html","A comma-separated list of tag names that should not get inner indentation."),prefs.define("format.forceIndentationForTags","body","A comma-separated list of tag names that should <em>always</em> get inner indentation.");var placeholder="%s";return function process(tree,profile,level){return level=level||0,tree.children.forEach(function(item){abbrUtils.isSnippet(item)?processSnippet(item,profile,level):processTag(item,profile,level),process(item,profile,level+1)}),tree}})},{"../assets/preferences":7,"../assets/resources":10,"../utils/abbreviation":41,"../utils/common":43}],22:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function transformClassName(className){return utils.trim(className).replace(/\s+/g,".")}function condenseDataAttrs(attrs){var out=[],data=null,reData=/^data-/i;return attrs.forEach(function(attr){reData.test(attr.name)?(data||(data=[],out.push({name:"data",value:data})),data.push(utils.extend({},attr,{name:attr.name.replace(reData,"")}))):out.push(attr)}),out}function stringifyAttrs(attrs,profile){var attrQuote=profile.attributeQuote();return"{"+attrs.map(function(attr){var value=attrQuote+attr.value+attrQuote;return Array.isArray(attr.value)?value=stringifyAttrs(attr.value,profile):attr.isBoolean&&(value="true"),":"+attr.name+" => "+value}).join(", ")+"}"}function makeAttributesString(tag,profile){var attrs="",otherAttrs=[],cursor=(profile.attributeQuote(),profile.cursor());return tag.attributeList().forEach(function(a){var attrName=profile.attributeName(a.name);switch(attrName.toLowerCase()){case"id":attrs+="#"+(a.value||cursor);break;case"class":attrs+="."+transformClassName(a.value||cursor);break;default:otherAttrs.push({name:attrName,value:a.value||cursor,isBoolean:profile.isBoolean(a.name,a.value)})}}),otherAttrs.length&&(attrs+=stringifyAttrs(condenseDataAttrs(otherAttrs),profile)),attrs}function processTag(item,profile){if(!item.parent)return item;var attrs=makeAttributesString(item,profile),cursor=profile.cursor(),isUnary=abbrUtils.isUnary(item),selfClosing=profile.self_closing_tag&&isUnary?"/":"",start="",tagName="%"+profile.tagName(item.name());"%div"==tagName.toLowerCase()&&attrs&&-1==attrs.indexOf("{")&&(tagName=""),item.end="",start=tagName+attrs+selfClosing,item.content&&!/^\s/.test(item.content)&&(item.content=" "+item.content);var placeholder="%s";return item.start=utils.replaceSubstring(item.start,start,item.start.indexOf(placeholder),placeholder),item.children.length||isUnary||(item.start+=cursor),item}var utils=require("../utils/common"),abbrUtils=require("../utils/abbreviation"),formatFilter=require("./format");return function process(tree,profile,level){return level=level||0,level||(tree=formatFilter(tree,"_format",profile)),tree.children.forEach(function(item){abbrUtils.isSnippet(item)||processTag(item,profile,level),process(item,profile,level+1)
}),tree}})},{"../utils/abbreviation":41,"../utils/common":43,"./format":21}],23:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function makeAttributesString(node,profile){var attrQuote=profile.attributeQuote(),cursor=profile.cursor();return node.attributeList().map(function(a){var isBoolean=profile.isBoolean(a.name,a.value),attrName=profile.attributeName(a.name),attrValue=isBoolean?attrName:a.value;return isBoolean&&profile.allowCompactBoolean()?" "+attrName:" "+attrName+"="+attrQuote+(attrValue||cursor)+attrQuote}).join("")}function processTag(item,profile){if(!item.parent)return item;var attrs=makeAttributesString(item,profile),cursor=profile.cursor(),isUnary=abbrUtils.isUnary(item),start="",end="";if(!item.isTextNode()){var tagName=profile.tagName(item.name());isUnary?(start="<"+tagName+attrs+profile.selfClosing()+">",item.end=""):(start="<"+tagName+attrs+">",end="</"+tagName+">")}var placeholder="%s";return item.start=utils.replaceSubstring(item.start,start,item.start.indexOf(placeholder),placeholder),item.end=utils.replaceSubstring(item.end,end,item.end.indexOf(placeholder),placeholder),item.children.length||isUnary||~item.content.indexOf(cursor)||tabStops.extract(item.content).tabstops.length||(item.start+=cursor),item}var abbrUtils=require("../utils/abbreviation"),utils=require("../utils/common"),tabStops=require("../assets/tabStops"),formatFilter=require("./format");return function process(tree,profile,level){return level=level||0,level||(tree=formatFilter(tree,profile,level)),tree.children.forEach(function(item){abbrUtils.isSnippet(item)||processTag(item,profile,level),process(item,profile,level+1)}),tree}})},{"../assets/tabStops":12,"../utils/abbreviation":41,"../utils/common":43,"./format":21}],24:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function transformClassName(className){return utils.trim(className).replace(/\s+/g,".")}function stringifyAttrs(attrs,profile){var attrQuote=profile.attributeQuote();return"("+attrs.map(function(attr){return attr.isBoolean?attr.name:attr.name+"="+attrQuote+attr.value+attrQuote}).join(", ")+")"}function makeAttributesString(tag,profile){var attrs="",otherAttrs=[],cursor=(profile.attributeQuote(),profile.cursor());return tag.attributeList().forEach(function(a){var attrName=profile.attributeName(a.name);switch(attrName.toLowerCase()){case"id":attrs+="#"+(a.value||cursor);break;case"class":attrs+="."+transformClassName(a.value||cursor);break;default:otherAttrs.push({name:attrName,value:a.value||cursor,isBoolean:profile.isBoolean(a.name,a.value)})}}),otherAttrs.length&&(attrs+=stringifyAttrs(otherAttrs,profile)),attrs}function processTagContent(item){if(item.content){var content=tabStops.replaceVariables(item.content,function(str,name){return"nl"===name||"newline"===name?"\n":str});if(reNl.test(content)&&!reIndentedText.test(content)){var pad="| ";item.content="\n"+pad+utils.padString(content,pad)}else reSpace.test(content)||(item.content=" "+content)}}function processTag(item,profile){if(!item.parent)return item;var attrs=makeAttributesString(item,profile),cursor=profile.cursor(),isUnary=abbrUtils.isUnary(item),tagName=profile.tagName(item.name());"div"==tagName.toLowerCase()&&attrs&&"("!=attrs.charAt(0)&&(tagName=""),item.end="";var start=tagName+attrs;processTagContent(item);var placeholder="%s";return item.start=utils.replaceSubstring(item.start,start,item.start.indexOf(placeholder),placeholder),item.children.length||isUnary||(item.start+=cursor),item}var utils=require("../utils/common"),abbrUtils=require("../utils/abbreviation"),formatFilter=require("./format"),tabStops=require("../assets/tabStops"),profile=require("../assets/profile"),reNl=/[\n\r]/,reIndentedText=/^\s*\|/,reSpace=/^\s/;return function process(tree,curProfile,level){return level=level||0,level||(tree=formatFilter(tree,profile.get("xml"))),tree.children.forEach(function(item){abbrUtils.isSnippet(item)||processTag(item,curProfile,level),process(item,curProfile,level+1)}),tree}})},{"../assets/profile":8,"../assets/tabStops":12,"../utils/abbreviation":41,"../utils/common":43,"./format":21}],25:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function list(filters){return filters?"string"==typeof filters?filters.split(/[\|,]/g):filters:[]}var utils=require("../utils/common"),profile=require("../assets/profile"),resources=require("../assets/resources"),registeredFilters={html:require("./html"),haml:require("./haml"),jade:require("./jade"),slim:require("./slim"),xsl:require("./xsl"),css:require("./css"),bem:require("./bem"),c:require("./comment"),e:require("./escape"),s:require("./singleLine"),t:require("./trim")},basicFilters="html";return{add:function(name,fn){registeredFilters[name]=fn},apply:function(tree,filters,profileName){return profileName=profile.get(profileName),list(filters).forEach(function(filter){var name=utils.trim(filter.toLowerCase());name&&name in registeredFilters&&(tree=registeredFilters[name](tree,profileName))}),tree},composeList:function(syntax,profileName,additionalFilters){profileName=profile.get(profileName);var filters=list(profileName.filters||resources.findItem(syntax,"filters")||basicFilters);return profileName.extraFilters&&(filters=filters.concat(list(profileName.extraFilters))),additionalFilters&&(filters=filters.concat(list(additionalFilters))),filters&&filters.length||(filters=list(basicFilters)),filters},extract:function(abbr){var filters="";return abbr=abbr.replace(/\|([\w\|\-]+)$/,function(str,p1){return filters=p1,""}),[abbr,list(filters)]}}})},{"../assets/profile":8,"../assets/resources":10,"../utils/common":43,"./bem":17,"./comment":18,"./css":19,"./escape":20,"./haml":22,"./html":23,"./jade":24,"./singleLine":26,"./slim":27,"./trim":28,"./xsl":29}],26:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){var abbrUtils=require("../utils/abbreviation"),rePad=/^\s+/,reNl=/[\n\r]/g;return function process(tree){return tree.children.forEach(function(item){abbrUtils.isSnippet(item)||(item.start=item.start.replace(rePad,""),item.end=item.end.replace(rePad,"")),item.start=item.start.replace(reNl,""),item.end=item.end.replace(reNl,""),item.content=item.content.replace(reNl,""),process(item)}),tree}})},{"../utils/abbreviation":41}],27:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function transformClassName(className){return utils.trim(className).replace(/\s+/g,".")}function getAttrWrapper(){var start=" ",end="";switch(prefs.get("slim.attributesWrapper")){case"round":start="(",end=")";break;case"square":start="[",end="]";break;case"curly":start="{",end="}"}return{start:start,end:end}}function stringifyAttrs(attrs,profile){var attrQuote=profile.attributeQuote(),attrWrap=getAttrWrapper();return attrWrap.start+attrs.map(function(attr){var value=attrQuote+attr.value+attrQuote;if(attr.isBoolean){if(attrWrap.end)return attr.name;value="true"}return attr.name+"="+value}).join(" ")+attrWrap.end}function makeAttributesString(tag,profile){var attrs="",otherAttrs=[],cursor=(profile.attributeQuote(),profile.cursor());return tag.attributeList().forEach(function(a){var attrName=profile.attributeName(a.name);switch(attrName.toLowerCase()){case"id":attrs+="#"+(a.value||cursor);break;case"class":attrs+="."+transformClassName(a.value||cursor);break;default:otherAttrs.push({name:attrName,value:a.value||cursor,isBoolean:profile.isBoolean(a.name,a.value)})}}),otherAttrs.length&&(attrs+=stringifyAttrs(otherAttrs,profile)),attrs}function processTagContent(item){if(item.content){var content=tabStops.replaceVariables(item.content,function(str,name){return"nl"===name||"newline"===name?"\n":str});if(reNl.test(content)&&!reIndentedText.test(content)){var pad="  ";item.content="\n| "+utils.padString(content,pad)}else reSpace.test(content)||(item.content=" "+content)}}function processTag(item,profile){if(!item.parent)return item;var attrs=makeAttributesString(item,profile),cursor=profile.cursor(),isUnary=abbrUtils.isUnary(item),selfClosing=profile.self_closing_tag&&isUnary?"/":"",tagName=profile.tagName(item.name());"div"==tagName.toLowerCase()&&attrs&&-1=="([{".indexOf(attrs.charAt(0))&&(tagName=""),item.end="";var start=tagName+attrs+selfClosing;processTagContent(item);var placeholder="%s";return item.start=utils.replaceSubstring(item.start,start,item.start.indexOf(placeholder),placeholder),item.children.length||isUnary||(item.start+=cursor),item}var utils=require("../utils/common"),abbrUtils=require("../utils/abbreviation"),formatFilter=require("./format"),tabStops=require("../assets/tabStops"),prefs=require("../assets/preferences"),profile=require("../assets/profile"),reNl=/[\n\r]/,reIndentedText=/^\s*\|/,reSpace=/^\s/;return prefs.define("slim.attributesWrapper","none","Defines how attributes will be wrapped:<ul><li><code>none</code>  no wrapping;</li><li><code>round</code>  wrap attributes with round braces;</li><li><code>square</code>  wrap attributes with round braces;</li><li><code>curly</code>  wrap attributes with curly braces.</li></ul>"),function process(tree,curProfile,level){return level=level||0,level||(tree=formatFilter(tree,profile.get("xml"))),tree.children.forEach(function(item){abbrUtils.isSnippet(item)||processTag(item,curProfile,level),process(item,curProfile,level+1)}),tree}})},{"../assets/preferences":7,"../assets/profile":8,"../assets/tabStops":12,"../utils/abbreviation":41,"../utils/common":43,"./format":21}],28:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function process(tree,re){return tree.children.forEach(function(item){item.content&&(item.content=item.content.replace(re,"")),process(item,re)}),tree}var prefs=require("../assets/preferences");return prefs.define("filter.trimRegexp","[\\s|\\u00a0]*[\\d|#|\\-|*|\\u2022]+\\.?\\s*","Regular expression used to remove list markers (numbers, dashes, bullets, etc.) in <code>t</code> (trim) filter. The trim filter is useful for wrapping with abbreviation lists, pased from other documents (for example, Word documents)."),function(tree){var re=new RegExp(prefs.get("filter.trimRegexp"));return process(tree,re)}})},{"../assets/preferences":7}],29:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function trimAttribute(node){node.start=node.start.replace(/\s+select\s*=\s*(['"]).*?\1/,"")}var abbrUtils=require("../utils/abbreviation"),tags={"xsl:variable":1,"xsl:with-param":1};return function process(tree){return tree.children.forEach(function(item){!abbrUtils.isSnippet(item)&&(item.name()||"").toLowerCase()in tags&&item.children.length&&trimAttribute(item),process(item)}),tree}})},{"../utils/abbreviation":41}],30:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function randint(from,to){return Math.round(Math.random()*(to-from)+from)}function sample(arr,count){for(var len=arr.length,iterations=Math.min(len,count),result=[];result.length<iterations;){var randIx=randint(0,len-1);~result.indexOf(randIx)||result.push(randIx)}return result.map(function(ix){return arr[ix]})}function choice(val){return"string"==typeof val?val.charAt(randint(0,val.length-1)):val[randint(0,val.length-1)]}function sentence(words,end){return words.length&&(words[0]=words[0].charAt(0).toUpperCase()+words[0].substring(1)),words.join(" ")+(end||choice("?!..."))}function insertCommas(words){var len=words.length;if(!(2>len)){var totalCommas=0;totalCommas=len>3&&6>=len?randint(0,1):len>6&&12>=len?randint(0,2):randint(1,4);for(var pos,word,i=0;totalCommas>i;i++)pos=randint(0,words.length-2),word=words[pos],","!==word.charAt(word.length-1)&&(words[pos]+=",")}}function paragraph(lang,wordCount,startWithCommon){var data=langs[lang];if(!data)return"";var words,result=[],totalWords=0;for(wordCount=parseInt(wordCount,10),startWithCommon&&data.common&&(words=data.common.slice(0,wordCount),words.length>5&&(words[4]+=","),totalWords+=words.length,result.push(sentence(words,".")));wordCount>totalWords;)words=sample(data.words,Math.min(randint(2,30),wordCount-totalWords)),totalWords+=words.length,insertCommas(words),result.push(sentence(words));return result.join(" ")}var prefs=require("../assets/preferences"),langs={en:{common:["lorem","ipsum","dolor","sit","amet","consectetur","adipisicing","elit"],words:["exercitationem","perferendis","perspiciatis","laborum","eveniet","sunt","iure","nam","nobis","eum","cum","officiis","excepturi","odio","consectetur","quasi","aut","quisquam","vel","eligendi","itaque","non","odit","tempore","quaerat","dignissimos","facilis","neque","nihil","expedita","vitae","vero","ipsum","nisi","animi","cumque","pariatur","velit","modi","natus","iusto","eaque","sequi","illo","sed","ex","et","voluptatibus","tempora","veritatis","ratione","assumenda","incidunt","nostrum","placeat","aliquid","fuga","provident","praesentium","rem","necessitatibus","suscipit","adipisci","quidem","possimus","voluptas","debitis","sint","accusantium","unde","sapiente","voluptate","qui","aspernatur","laudantium","soluta","amet","quo","aliquam","saepe","culpa","libero","ipsa","dicta","reiciendis","nesciunt","doloribus","autem","impedit","minima","maiores","repudiandae","ipsam","obcaecati","ullam","enim","totam","delectus","ducimus","quis","voluptates","dolores","molestiae","harum","dolorem","quia","voluptatem","molestias","magni","distinctio","omnis","illum","dolorum","voluptatum","ea","quas","quam","corporis","quae","blanditiis","atque","deserunt","laboriosam","earum","consequuntur","hic","cupiditate","quibusdam","accusamus","ut","rerum","error","minus","eius","ab","ad","nemo","fugit","officia","at","in","id","quos","reprehenderit","numquam","iste","fugiat","sit","inventore","beatae","repellendus","magnam","recusandae","quod","explicabo","doloremque","aperiam","consequatur","asperiores","commodi","optio","dolor","labore","temporibus","repellat","veniam","architecto","est","esse","mollitia","nulla","a","similique","eos","alias","dolore","tenetur","deleniti","porro","facere","maxime","corrupti"]},sp:{common:["mujer","uno","dolor","ms","de","poder","mismo","si"],words:["ejercicio","preferencia","perspicacia","laboral","pao","suntuoso","molde","namibia","planeador","mirar","dems","oficinista","excepcin","odio","consecuencia","casi","auto","chicharra","velo","elixir","ataque","no","odio","temporal","curum","dignsimo","facilismo","letra","nihilista","expedicin","alma","alveolar","aparte","len","animal","como","paria","belleza","modo","natividad","justo","ataque","squito","pillo","sed","ex","y","voluminoso","temporalidad","verdades","racional","asuncin","incidente","marejada","placenta","amanecer","fuga","previsor","presentacin","lejos","necesariamente","sospechoso","adiposidad","quindo","pcima","voluble","dbito","sinti","accesorio","falda","sapiencia","volutas","queso","permacultura","laudo","soluciones","entero","pan","litro","tonelada","culpa","libertario","mosca","dictado","reincidente","nascimiento","dolor","escolar","impedimento","mnima","mayores","repugnante","dulce","obcecado","montaa","enigma","total","deletreo","dcima","cbala","fotografa","dolores","molesto","olvido","paciencia","resiliencia","voluntad","molestias","magnfico","distincin","ovni","marejada","cerro","torre","y","abogada","manantial","corporal","agua","crepsculo","ataque","desierto","laboriosamente","angustia","afortunado","alma","encefalograma","materialidad","cosas","o","renuncia","error","menos","conejo","abada","analfabeto","remo","fugacidad","oficio","en","almcigo","vos","pan","represin","nmeros","triste","refugiado","trote","inventor","corchea","repelente","magma","recusado","patrn","explcito","paloma","sndrome","inmune","autoinmune","comodidad","ley","vietnamita","demonio","tasmania","repeler","apndice","arquitecto","columna","yugo","computador","mula","a","propsito","fantasa","alias","rayo","tenedor","deleznable","ventana","cara","anemia","corrupto"]},ru:{common:["-","","",""," ",""," ","","",""],words:[""," ","","",""," ","","","","","","","",""," ","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","lorem","ipsum","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]}};return prefs.define("lorem.defaultLang","en",'Default language of generated dummy text. Currently, <code>en</code>		and <code>ru</code> are supported, but users can add their own syntaxes		see <a href="http://docs.emmet.io/abbreviations/lorem-ipsum/">docs</a>.'),prefs.define("lorem.omitCommonPart",!1,"Omit commonly used part (e.g. Lorem ipsum dolor sit amet) from generated text."),{addLang:function(lang,data){"string"==typeof data?data={words:data.split(" ").filter(function(item){return!!item})}:Array.isArray(data)&&(data={words:data}),langs[lang]=data},preprocessor:function(tree){var match,re=/^(?:lorem|lipsum)([a-z]{2})?(\d*)$/i,allowCommon=!prefs.get("lorem.omitCommonPart");tree.findAll(function(node){if(node._name&&(match=node._name.match(re))){var wordCound=match[2]||30,lang=match[1]||prefs.get("lorem.defaultLang")||"en";node._name="",node.data("forceNameResolving",node.isRepeating()||node.attributeList().length),node.data("pasteOverwrites",!0),node.data("paste",function(i){return paragraph(lang,wordCound,!i&&allowCommon)})}})}}})},{"../assets/preferences":7}],31:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function AbbreviationNode(){this.parent=null,this.children=[],this._attributes=[],this.abbreviation="",this.counter=1,this._name=null,this._text="",this.repeatCount=1,this.hasImplicitRepeat=!1,this._data={},this.start="",this.end="",this.content="",this.padding=""}function stripped(str){return str.substring(1,str.length-1)}function parseAbbreviation(abbr){abbr=utils.trim(abbr);for(var ch,multiplier,root=new AbbreviationNode,context=root.addChild(),stream=stringStream.create(abbr),loopProtector=1e3,addChild=function(child){context.addChild(child)},consumeAbbr=function(){stream.start=stream.pos,stream.eatWhile(function(c){if("["==c||"{"==c){if(stream.skipToPair(c,pairs[c]))return stream.backUp(1),!0;throw new Error('Invalid abbreviation: mo matching "'+pairs[c]+'" found for character at '+stream.pos)}if("+"==c){stream.next();var isMarker=stream.eol()||~"+>^*".indexOf(stream.peek());return stream.backUp(1),isMarker}return"("!=c&&isAllowedChar(c)})};!stream.eol()&&--loopProtector>0;)switch(ch=stream.peek()){case"(":if(stream.start=stream.pos,!stream.skipToPair("(",")"))throw new Error('Invalid abbreviation: mo matching ")" found for character at '+stream.pos);var inner=parseAbbreviation(stripped(stream.current()));(multiplier=stream.match(/^\*(\d+)?/,!0))&&context._setRepeat(multiplier[1]),inner.children.forEach(addChild);break;case">":context=context.addChild(),stream.next();break;case"+":context=context.parent.addChild(),stream.next();break;case"^":var parent=context.parent||context;context=(parent.parent||parent).addChild(),stream.next();break;default:consumeAbbr(),context.setAbbreviation(stream.current()),stream.start=stream.pos}if(1>loopProtector)throw new Error("Endless loop detected");return root}function splitAttributes(attrSet){attrSet=utils.trim(attrSet);for(var ch,parts=[],stream=stringStream(attrSet);ch=stream.next();)if(" "==ch){for(parts.push(utils.trim(stream.current()));" "==stream.peek();)stream.next();stream.start=stream.pos}else if(('"'==ch||"'"==ch)&&!stream.skipString(ch))throw new Error("Invalid attribute set");return parts.push(utils.trim(stream.current())),parts}function unquote(str){var ch=str.charAt(0);if('"'==ch||"'"==ch){str=str.substr(1);var last=str.charAt(str.length-1);last===ch&&(str=str.substr(0,str.length-1))}return str}function extractAttributes(attrSet){var reAttrName=/^[\w\-:\$@]+\.?$/;return splitAttributes(attrSet).map(function(attr){if(reAttrName.test(attr)){var value="";return"."==attr.charAt(attr.length-1)&&(attr=attr.substr(0,attr.length-1),value=attr),{name:attr,value:value}}if(~attr.indexOf("=")){var parts=attr.split("=");return{name:parts.shift(),value:unquote(parts.join("="))}}return{name:DEFAULT_ATTR_NAME,value:unquote(attr)}})}function parseAttributes(abbr){for(var result=[],attrMap={"#":"id",".":"class"},nameEnd=null,stream=stringStream.create(abbr);!stream.eol();)switch(stream.peek()){case"#":case".":null===nameEnd&&(nameEnd=stream.pos);var attrName=attrMap[stream.peek()];stream.next(),stream.start=stream.pos,stream.eatWhile(reWord),result.push({name:attrName,value:stream.current()});break;case"[":if(null===nameEnd&&(nameEnd=stream.pos),stream.start=stream.pos,!stream.skipToPair("[","]"))throw new Error("Invalid attribute set definition");result=result.concat(extractAttributes(stripped(stream.current())));break;default:stream.next()}return result.length?{element:abbr.substring(0,nameEnd),attributes:optimizeAttributes(result)}:null}function optimizeAttributes(attrs){attrs=attrs.map(function(attr){return utils.clone(attr)});var lookup={};return attrs.filter(function(attr){if(!(attr.name in lookup))return lookup[attr.name]=attr;var la=lookup[attr.name];return"class"==attr.name.toLowerCase()?la.value+=(la.value.length?" ":"")+attr.value:(la.value=attr.value,la.isImplied=!!attr.isImplied),!1})}function extractText(abbr){if(!~abbr.indexOf("{"))return null;for(var stream=stringStream.create(abbr);!stream.eol();)switch(stream.peek()){case"[":case"(":stream.skipToPair(stream.peek(),pairs[stream.peek()]);break;case"{":return stream.start=stream.pos,stream.skipToPair("{","}"),{element:abbr.substring(0,stream.start),text:stripped(stream.current())};default:stream.next()}}function unroll(node){for(var j,child,maxCount,i=node.children.length-1;i>=0;i--)if(child=node.children[i],child.isRepeating())for(maxCount=j=child.repeatCount,child.repeatCount=1,child.updateProperty("counter",1),child.updateProperty("maxCount",maxCount);--j>0;)child.parent.addChild(child.clone(),i+1).updateProperty("counter",j+1).updateProperty("maxCount",maxCount);return node.children.forEach(unroll),node}function squash(node){for(var i=node.children.length-1;i>=0;i--){var n=node.children[i];n.isGroup()?n.replace(squash(n).children):n.isEmpty()&&n.remove()}return node.children.forEach(squash),node}function isAllowedChar(ch){var charCode=ch.charCodeAt(0),specialChars="#.*:$-_!@|%";return charCode>64&&91>charCode||charCode>96&&123>charCode||charCode>47&&58>charCode||-1!=specialChars.indexOf(ch)}var tabStops=require("../assets/tabStops"),profile=require("../assets/profile"),filters=require("../filter/main"),utils=require("../utils/common"),abbreviationUtils=require("../utils/abbreviation"),stringStream=require("../assets/stringStream"),lorem=require("../generator/lorem"),procPastedContent=require("./processor/pastedContent"),procTagName=require("./processor/tagName"),procResourceMatcher=require("./processor/resourceMatcher"),procAttributes=require("./processor/attributes"),procHref=require("./processor/href"),reValidName=/^[\w\-\$\:@\!%]+\+?$/i,reWord=/[\w\-:\$@]/,DEFAULT_ATTR_NAME="%default",pairs={"[":"]","(":")","{":"}"},spliceFn=Array.prototype.splice,preprocessors=[],postprocessors=[],outputProcessors=[];return AbbreviationNode.prototype={addChild:function(child,position){return child=child||new AbbreviationNode,child.parent=this,"undefined"==typeof position?this.children.push(child):this.children.splice(position,0,child),child},clone:function(){var node=new AbbreviationNode,attrs=["abbreviation","counter","_name","_text","repeatCount","hasImplicitRepeat","start","end","content","padding"];return attrs.forEach(function(a){node[a]=this[a]},this),node._attributes=this._attributes.map(function(attr){return utils.extend({},attr)}),node._data=utils.extend({},this._data),node.children=this.children.map(function(child){return child=child.clone(),child.parent=node,child}),node},remove:function(){if(this.parent){var ix=this.parent.children.indexOf(this);~ix&&this.parent.children.splice(ix,1)}return this},replace:function(){var parent=this.parent,ix=parent.children.indexOf(this),items=utils.flatten(arguments);spliceFn.apply(parent.children,[ix,1].concat(items)),items.forEach(function(item){item.parent=parent})},updateProperty:function(name,value){return this[name]=value,this.children.forEach(function(child){child.updateProperty(name,value)}),this},find:function(fn){return this.findAll(fn,{amount:1})[0]},findAll:function(fn,state){if(state=utils.extend({amount:0,found:0},state||{}),"function"!=typeof fn){var elemName=fn.toLowerCase();fn=function(item){return item.name().toLowerCase()==elemName}}var result=[];return this.children.forEach(function(child){fn(child)&&(result.push(child),state.found++,state.amount&&state.found>=state.amount)||(result=result.concat(child.findAll(fn)))}),result.filter(function(item){return!!item})},data:function(name,value){return 2==arguments.length&&(this._data[name]=value),this._data[name]},name:function(){return this._name},attributeList:function(){return optimizeAttributes(this._attributes.slice(0))},attribute:function(name,value){if(2==arguments.length){if(null===value){var vals=this._attributes.filter(function(attr){return attr.name===name}),that=this;return void vals.forEach(function(attr){var ix=that._attributes.indexOf(attr);~ix&&that._attributes.splice(ix,1)})}var attrNames=this._attributes.map(function(attr){return attr.name}),ix=attrNames.indexOf(name.toLowerCase());~ix?this._attributes[ix].value=value:this._attributes.push({name:name,value:value})}return(utils.find(this.attributeList(),function(attr){return attr.name==name})||{}).value},index:function(){return this.parent?this.parent.children.indexOf(this):-1},_setRepeat:function(count){count?this.repeatCount=parseInt(count,10)||1:this.hasImplicitRepeat=!0},setAbbreviation:function(abbr){abbr=abbr||"";var that=this;abbr=abbr.replace(/\*(\d+)?$/,function(str,repeatCount){return that._setRepeat(repeatCount),""}),this.abbreviation=abbr;var abbrText=extractText(abbr);abbrText&&(abbr=abbrText.element,this.content=this._text=abbrText.text);var abbrAttrs=parseAttributes(abbr);if(abbrAttrs&&(abbr=abbrAttrs.element,this._attributes=abbrAttrs.attributes),this._name=abbr,this._name&&!reValidName.test(this._name))throw new Error("Invalid abbreviation")},valueOf:function(){var start=this.start,end=this.end,content=this.content,node=this;outputProcessors.forEach(function(fn){start=fn(start,node,"start"),content=fn(content,node,"content"),end=fn(end,node,"end")});var innerContent=this.children.map(function(child){return child.valueOf()}).join("");return content=abbreviationUtils.insertChildContent(content,innerContent,{keepVariable:!1}),start+utils.padString(content,this.padding)+end},toString:function(){return this.valueOf()},hasEmptyChildren:function(){return!!utils.find(this.children,function(child){return child.isEmpty()})},hasImplicitName:function(){return!this._name&&!this.isTextNode()},isGroup:function(){return!this.abbreviation},isEmpty:function(){return!this.abbreviation&&!this.children.length},isRepeating:function(){return this.repeatCount>1||this.hasImplicitRepeat},isTextNode:function(){return!this.name()&&!this.attributeList().length},isElement:function(){return!this.isEmpty()&&!this.isTextNode()},deepestChild:function(){if(!this.children.length)return null;for(var deepestChild=this;deepestChild.children.length;)deepestChild=deepestChild.children[deepestChild.children.length-1];return deepestChild}},outputProcessors.push(function(text,node){return utils.replaceCounter(text,node.counter,node.maxCount)}),outputProcessors.push(tabStops.abbrOutputProcessor.bind(tabStops)),[lorem,procResourceMatcher,procAttributes,procPastedContent,procTagName,procHref].forEach(function(mod){mod.preprocessor&&preprocessors.push(mod.preprocessor.bind(mod)),mod.postprocessor&&postprocessors.push(mod.postprocessor.bind(mod))}),{DEFAULT_ATTR_NAME:DEFAULT_ATTR_NAME,parse:function(abbr,options){options=options||{};var tree=parseAbbreviation(abbr),that=this;if(options.contextNode){tree._name=options.contextNode.name;var attrLookup={};tree._attributes.forEach(function(attr){attrLookup[attr.name]=attr}),options.contextNode.attributes.forEach(function(attr){attr.name in attrLookup?attrLookup[attr.name].value=attr.value:(attr=utils.clone(attr),tree._attributes.push(attr),attrLookup[attr.name]=attr)})}return preprocessors.forEach(function(fn){fn(tree,options,that)}),"counter"in options&&tree.updateProperty("counter",options.counter),tree=squash(unroll(tree)),postprocessors.forEach(function(fn){fn(tree,options,that)}),tree},expand:function(abbr,options){if(!abbr)return"";if("string"==typeof options)throw new Error("Deprecated use of `expand` method: `options` must be object");options=options||{},options.syntax||(options.syntax=utils.defaultSyntax());var p=profile.get(options.profile,options.syntax);tabStops.resetTabstopIndex();var data=filters.extract(abbr),outputTree=this.parse(data[0],options),filtersList=filters.composeList(options.syntax,p,data[1]);return filters.apply(outputTree,filtersList,p),outputTree.valueOf()},AbbreviationNode:AbbreviationNode,addPreprocessor:function(fn){~preprocessors.indexOf(fn)||preprocessors.push(fn)},removeFilter:function(fn){var ix=preprocessors.indexOf(fn);~ix&&preprocessors.splice(ix,1)},addPostprocessor:function(fn){~postprocessors.indexOf(fn)||postprocessors.push(fn)},removePostprocessor:function(fn){var ix=postprocessors.indexOf(fn);~ix&&postprocessors.splice(ix,1)},addOutputProcessor:function(fn){~outputProcessors.indexOf(fn)||outputProcessors.push(fn)},removeOutputProcessor:function(fn){var ix=outputProcessors.indexOf(fn);
~ix&&outputProcessors.splice(ix,1)},isAllowedChar:function(ch){return ch=String(ch),isAllowedChar(ch)||~">+^[](){}".indexOf(ch)}}})},{"../assets/profile":8,"../assets/stringStream":11,"../assets/tabStops":12,"../filter/main":25,"../generator/lorem":30,"../utils/abbreviation":41,"../utils/common":43,"./processor/attributes":33,"./processor/href":34,"./processor/pastedContent":35,"./processor/resourceMatcher":36,"./processor/tagName":37}],32:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(){function isNameChar(c,cc){return cc=cc||c.charCodeAt(0),cc>=97&&122>=cc||cc>=65&&90>=cc||cc>=1024&&1279>=cc||"&"===c||"_"===c||"<"===c||">"===c||"="===c||"-"===c}function isDigit(c,cc){return cc=cc||c.charCodeAt(0),cc>=48&&57>=cc}function tokener(value,type){session.tokens.push({value:value,type:type||value,start:null,end:null})}function getPosInfo(w){for(var errPos=w.chnum,source=w.source.replace(/\r\n?/g,"\n"),part=w.source.substring(0,errPos+1).replace(/\r\n?/g,"\n"),lines=part.split("\n"),ch=(lines[lines.length-1]||"").length,fullLine=source.split("\n")[lines.length-1]||"",chunkSize=100,offset=Math.max(0,ch-chunkSize),formattedLine=fullLine.substr(offset,2*chunkSize)+"\n",i=0;ch-offset-1>i;i++)formattedLine+="-";return formattedLine+="^",{line:lines.length,ch:ch,text:fullLine,hint:formattedLine}}function raiseError(message){var err=error(message),errObj=new Error(err.message,"",err.line);throw errObj.line=err.line,errObj.ch=err.ch,errObj.name=err.name,errObj.hint=err.hint,errObj}function error(m){{var info=getPosInfo(walker);session.tokens}session.tokens=null;var message="CSS parsing error at line "+info.line+", char "+info.ch+": "+m;return message+="\n"+info.hint,{name:"ParseError",message:message,hint:info.hint,line:info.line,ch:info.ch}}function white(){for(var c=walker.ch,token="";" "===c||"	"===c;)token+=c,c=walker.nextChar();tokener(token,"white")}function comment(){var cnext,w=walker,c=w.ch,token=c;if(cnext=w.nextChar(),"/"===cnext)for(;c&&"\n"!==cnext&&"\r"!==cnext;)token+=cnext,c=cnext,cnext=w.nextChar();else{if("*"!==cnext)return tokener(token,token);for(;c&&("*"!==c||"/"!==cnext);)token+=cnext,c=cnext,cnext=w.nextChar()}token+=cnext,w.nextChar(),tokener(token,"comment")}function eatString(){var cnext,w=walker,c=w.ch,q=c,token=c;for(c=w.nextChar();c!==q;)"\n"===c?(cnext=w.nextChar(),"\\"===cnext?token+=c+cnext:raiseError("Unterminated string")):token+="\\"===c?c+w.nextChar():c,c=w.nextChar();return token+=c}function str(){var token=eatString();walker.nextChar(),tokener(token,"string")}function brace(){var w=walker,c=w.ch,depth=1,token=c,stop=!1;for(c=w.nextChar();c&&!stop;)"("===c?depth++:")"===c?(depth--,depth||(stop=!0)):'"'===c||"'"===c?c=eatString():""===c&&raiseError("Unterminated brace"),token+=c,c=w.nextChar();tokener(token,"brace")}function identifier(pre){var c=walker.ch,token=pre?pre+c:c;c=walker.nextChar();for(var cc=c.charCodeAt(0);isNameChar(c,cc)||isDigit(c,cc);)token+=c,c=walker.nextChar(),cc=c.charCodeAt(0);tokener(token,"identifier")}function num(){var nondigit,w=walker,c=w.ch,token=c,point="."===token;if(c=w.nextChar(),nondigit=!isDigit(c),point&&nondigit)return tokener(token,".");if("-"===token&&nondigit)return identifier("-");for(;""!==c&&(isDigit(c)||!point&&"."===c);)"."===c&&(point=!0),token+=c,c=w.nextChar();tokener(token,"number")}function op(){var w=walker,c=w.ch,token=c,next=w.nextChar();return"="===next&&isOp(token,!0)?(token+=next,tokener(token,"match"),void w.nextChar()):void tokener(token,token)}function tokenize(){var ch=walker.ch;return" "===ch||"	"===ch?white():"/"===ch?comment():'"'===ch||"'"===ch?str():"("===ch?brace():"-"===ch||"."===ch||isDigit(ch)?num():isNameChar(ch)?identifier():isOp(ch)?op():"\r"===ch?("\n"===walker.peek()&&(ch+=walker.nextChar()),tokener(ch,"line"),void walker.nextChar()):"\n"===ch?(tokener(ch,"line"),void walker.nextChar()):void raiseError("Unrecognized character '"+ch+"'")}var session={tokens:null},walker={init:function(source){this.source=source,this.ch="",this.chnum=-1,this.nextChar()},nextChar:function(){return this.ch=this.source.charAt(++this.chnum)},peek:function(){return this.source.charAt(this.chnum+1)}},isOp=function(){for(var opsa="{}[]()+*=.,;:>~|\\%$#@^!".split(""),opsmatcha="*^|$~".split(""),ops={},opsmatch={},i=0;i<opsa.length;i+=1)ops[opsa[i]]=!0;for(i=0;i<opsmatcha.length;i+=1)opsmatch[opsmatcha[i]]=!0;return function(ch,matchattr){return matchattr?ch in opsmatch:ch in ops}}();return{lex:function(source){if(walker.init(source),session.tokens=[],source)for(;""!==walker.ch;)tokenize();else session.tokens.push(this.white());var tokens=session.tokens;return session.tokens=null,tokens},parse:function(source){for(var token,tokens=this.lex(source),pos=0,i=0,il=tokens.length;il>i;i++)token=tokens[i],token.start=pos,token.end=pos+=token.value.length;return tokens},white:function(){return{value:"",type:"white",start:0,end:0}},toSource:function(toks){for(var i=0,max=toks.length,src="";max>i;i++)src+=toks[i].value;return src}}})},{}],33:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function resolveDefaultAttrs(node,parser){node.children.forEach(function(item){var attrList=item.attributeList(),defaultAttrValue=item.attribute(parser.DEFAULT_ATTR_NAME);if("undefined"!=typeof defaultAttrValue){if(item.attribute(parser.DEFAULT_ATTR_NAME,null),attrList.length){var defaultAttr=utils.find(attrList,findDefault)||utils.find(attrList,findImplied)||utils.find(attrList,findEmpty);if(defaultAttr){var oldVal=item.attribute(defaultAttr.name),newVal=utils.replaceUnescapedSymbol(oldVal,"|",defaultAttrValue);oldVal==newVal&&(newVal=defaultAttrValue),item.attribute(defaultAttr.name,newVal)}}}else attrList.forEach(function(attr){attr.isImplied&&item.attribute(attr.name,null)});resolveDefaultAttrs(item,parser)})}var utils=require("../../utils/common"),findDefault=function(attr){return attr.isDefault},findImplied=function(attr){return attr.isImplied},findEmpty=function(attr){return!attr.value};return{preprocessor:function(tree,options,parser){resolveDefaultAttrs(tree,parser)}}})},{"../../utils/common":43}],34:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){var prefs=require("../../assets/preferences"),utils=require("../../utils/common"),pc=require("./pastedContent");return prefs.define("href.autodetect",!0,"Enables or disables automatic URL recognition when wrapping		text with <code>&lt;a&gt;</code> tag. With this option enabled,		if wrapped text matches URL or e-mail pattern it will be automatically		inserted into <code>href</code> attribute."),prefs.define("href.urlPattern","^(?:(?:https?|ftp|file)://|www\\.|ftp\\.)(?:\\([-A-Z0-9+&@#/%=~_|$?!:,.]*\\)|[-A-Z0-9+&@#/%=~_|$?!:,.])*(?:\\([-A-Z0-9+&@#/%=~_|$?!:,.]*\\)|[A-Z0-9+&@#/%=~_|$])","RegExp pattern to match wrapped URLs. Matched content will be inserts		as-is into <code>href</code> attribute, only whitespace will be trimmed."),prefs.define("href.emailPattern","^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$","RegExp pattern to match wrapped e-mails. Unlike <code>href.urlPattern</code>,		wrapped content will be prefixed with <code>mailto:</code> in <code>href</code>		attribute"),{postprocessor:function(tree,options){if(prefs.get("href.autodetect")){var reUrl=new RegExp(prefs.get("href.urlPattern"),"i"),reEmail=new RegExp(prefs.get("href.emailPattern"),"i"),reProto=/^([a-z]+:)?\/\//i;tree.findAll(function(item){if("a"==item.name().toLowerCase()&&!item.attribute("href")){var pastedContent=utils.trim(pc.pastedContent(item)||options.pastedContent);pastedContent&&(reUrl.test(pastedContent)?(reProto.test(pastedContent)||(pastedContent="http://"+pastedContent),item.attribute("href",pastedContent)):reEmail.test(pastedContent)&&item.attribute("href","mailto:"+pastedContent))}})}}}})},{"../../assets/preferences":7,"../../utils/common":43,"./pastedContent":35}],35:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function locateOutputPlaceholder(text){for(var result=[],stream=stringStream.create(text);!stream.eol();){if("\\"==stream.peek())stream.next();else if(stream.start=stream.pos,stream.match(outputPlaceholder,!0)){result.push(range.create(stream.start,outputPlaceholder));continue}stream.next()}return result}function replaceOutputPlaceholders(source,value){var ranges=locateOutputPlaceholder(source);return ranges.reverse().forEach(function(r){source=utils.replaceSubstring(source,value,r)}),source}function hasOutputPlaceholder(node){return locateOutputPlaceholder(node.content).length?!0:!!utils.find(node.attributeList(),function(attr){return!!locateOutputPlaceholder(attr.value).length})}function insertPastedContent(node,content,overwrite){var nodesWithPlaceholders=node.findAll(function(item){return hasOutputPlaceholder(item)});if(hasOutputPlaceholder(node)&&nodesWithPlaceholders.unshift(node),nodesWithPlaceholders.length)nodesWithPlaceholders.forEach(function(item){item.content=replaceOutputPlaceholders(item.content,content),item._attributes.forEach(function(attr){attr.value=replaceOutputPlaceholders(attr.value,content)})});else{var deepest=node.deepestChild()||node;deepest.content=overwrite?content:abbrUtils.insertChildContent(deepest.content,content)}}var utils=require("../../utils/common"),abbrUtils=require("../../utils/abbreviation"),stringStream=require("../../assets/stringStream"),range=require("../../assets/range"),outputPlaceholder="$#";return{pastedContent:function(item){var content=item.data("paste");return Array.isArray(content)?content[item.counter-1]:"function"==typeof content?content(item.counter-1,item.content):content?content:void 0},preprocessor:function(tree,options){if(options.pastedContent){var lines=utils.splitByLines(options.pastedContent,!0).map(utils.trim);tree.findAll(function(item){return item.hasImplicitRepeat?(item.data("paste",lines),item.repeatCount=lines.length):void 0})}},postprocessor:function(tree,options){var that=this,targets=tree.findAll(function(item){var pastedContent=that.pastedContent(item);return pastedContent&&insertPastedContent(item,pastedContent,!!item.data("pasteOverwrites")),!!pastedContent});!targets.length&&options.pastedContent&&insertPastedContent(tree,options.pastedContent)}}})},{"../../assets/range":9,"../../assets/stringStream":11,"../../utils/abbreviation":41,"../../utils/common":43}],36:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function matchResources(node,syntax,parser){node.children.slice(0).forEach(function(child){var r=resources.getMatchedResource(child,syntax);"string"==typeof r&&(r=elements.create("snippet",r)),child.data("resource",r);var elemType=elements.type(r);if("snippet"==elemType){var content=r.data,curContent=child._text||child.content;curContent&&(content=abbreviationUtils.insertChildContent(content,curContent)),child.content=content}else if("element"==elemType)child._name=r.name,Array.isArray(r.attributes)&&(child._attributes=[].concat(r.attributes,child._attributes));else if("reference"==elemType){var subtree=parser.parse(r.data,{syntax:syntax});if(child.repeatCount>1){var repeatedChildren=subtree.findAll(function(node){return node.hasImplicitRepeat});repeatedChildren.length||(repeatedChildren=subtree.children),repeatedChildren.forEach(function(node){node.repeatCount=child.repeatCount,node.hasImplicitRepeat=!1})}var deepestChild=subtree.deepestChild();deepestChild&&(child.children.forEach(function(c){deepestChild.addChild(c)}),deepestChild.content=child.content),subtree.children.forEach(function(node){child.attributeList().forEach(function(attr){node.attribute(attr.name,attr.value)})}),child.replace(subtree.children)}matchResources(child,syntax,parser)})}var resources=require("../../assets/resources"),elements=require("../../assets/elements"),utils=require("../../utils/common"),abbreviationUtils=require("../../utils/abbreviation");return{preprocessor:function(tree,options,parser){var syntax=options.syntax||utils.defaultSyntax();matchResources(tree,syntax,parser)}}})},{"../../assets/elements":3,"../../assets/resources":10,"../../utils/abbreviation":41,"../../utils/common":43}],37:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function resolveNodeNames(tree){return tree.children.forEach(function(node){(node.hasImplicitName()||node.data("forceNameResolving"))&&(node._name=tagName.resolve(node.parent.name()),node.data("nameResolved",!0)),resolveNodeNames(node)}),tree}var tagName=require("../../resolver/tagName");return{postprocessor:resolveNodeNames}})},{"../../resolver/tagName":40}],38:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function inText(stream,state){function chain(parser){return state.tokenize=parser,parser(stream,state)}var ch=stream.next();if("<"==ch){if(stream.eat("!"))return stream.eat("[")?stream.match("CDATA[")?chain(inBlock("atom","]]>")):null:stream.match("--")?chain(inBlock("comment","-->")):stream.match("DOCTYPE",!0,!0)?(stream.eatWhile(/[\w\._\-]/),chain(doctype(1))):null;if(stream.eat("?"))return stream.eatWhile(/[\w\._\-]/),state.tokenize=inBlock("meta","?>"),"meta";type=stream.eat("/")?"closeTag":"openTag",stream.eatSpace(),tagName="";for(var c;c=stream.eat(/[^\s\u00a0=<>\"\'\/?]/);)tagName+=c;return state.tokenize=inTag,"tag"}if("&"==ch){var ok;return ok=stream.eat("#")?stream.eat("x")?stream.eatWhile(/[a-fA-F\d]/)&&stream.eat(";"):stream.eatWhile(/[\d]/)&&stream.eat(";"):stream.eatWhile(/[\w\.\-:]/)&&stream.eat(";"),ok?"atom":"error"}return stream.eatWhile(/[^&<]/),"text"}function inTag(stream,state){var ch=stream.next();return">"==ch||"/"==ch&&stream.eat(">")?(state.tokenize=inText,type=">"==ch?"endTag":"selfcloseTag","tag"):"="==ch?(type="equals",null):/[\'\"]/.test(ch)?(state.tokenize=inAttribute(ch),state.tokenize(stream,state)):(stream.eatWhile(/[^\s\u00a0=<>\"\'\/?]/),"word")}function inAttribute(quote){return function(stream,state){for(;!stream.eol();)if(stream.next()==quote){state.tokenize=inTag;break}return"string"}}function inBlock(style,terminator){return function(stream,state){for(;!stream.eol();){if(stream.match(terminator)){state.tokenize=inText;break}stream.next()}return style}}function doctype(depth){return function(stream,state){for(var ch;null!==(ch=stream.next());){if("<"==ch)return state.tokenize=doctype(depth+1),state.tokenize(stream,state);if(">"==ch){if(1==depth){state.tokenize=inText;break}return state.tokenize=doctype(depth-1),state.tokenize(stream,state)}}return"meta"}}function pass(){for(var i=arguments.length-1;i>=0;i--)curState.cc.push(arguments[i])}function cont(){return pass.apply(null,arguments),!0}function pushContext(tagName,startOfLine){var noIndent=Kludges.doNotIndent.hasOwnProperty(tagName)||curState.context&&curState.context.noIndent;curState.context={prev:curState.context,tagName:tagName,indent:curState.indented,startOfLine:startOfLine,noIndent:noIndent}}function popContext(){curState.context&&(curState.context=curState.context.prev)}function element(type){if("openTag"==type)return curState.tagName=tagName,cont(attributes,endtag(curState.startOfLine));if("closeTag"==type){var err=!1;return curState.context?curState.context.tagName!=tagName&&(Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())&&popContext(),err=!curState.context||curState.context.tagName!=tagName):err=!0,err&&(setStyle="error"),cont(endclosetag(err))}return cont()}function endtag(startOfLine){return function(type){return"selfcloseTag"==type||"endTag"==type&&Kludges.autoSelfClosers.hasOwnProperty(curState.tagName.toLowerCase())?(maybePopContext(curState.tagName.toLowerCase()),cont()):"endTag"==type?(maybePopContext(curState.tagName.toLowerCase()),pushContext(curState.tagName,startOfLine),cont()):cont()}}function endclosetag(err){return function(type){return err&&(setStyle="error"),"endTag"==type?(popContext(),cont()):(setStyle="error",cont(arguments.callee))}}function maybePopContext(nextTagName){for(var parentTagName;;){if(!curState.context)return;if(parentTagName=curState.context.tagName.toLowerCase(),!Kludges.contextGrabbers.hasOwnProperty(parentTagName)||!Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName))return;popContext()}}function attributes(type){return"word"==type?(setStyle="attribute",cont(attribute,attributes)):"endTag"==type||"selfcloseTag"==type?pass():(setStyle="error",cont(attributes))}function attribute(type){return"equals"==type?cont(attvalue,attributes):(Kludges.allowMissing||(setStyle="error"),"endTag"==type||"selfcloseTag"==type?pass():cont())}function attvalue(type){return"string"==type?cont(attvaluemaybe):"word"==type&&Kludges.allowUnquoted?(setStyle="string",cont()):(setStyle="error","endTag"==type||"selfCloseTag"==type?pass():cont())}function attvaluemaybe(type){return"string"==type?cont(attvaluemaybe):pass()}function startState(){return{tokenize:inText,cc:[],indented:0,startOfLine:!0,tagName:null,context:null}}function token(stream,state){if(stream.sol()&&(state.startOfLine=!0,state.indented=0),stream.eatSpace())return null;setStyle=type=tagName=null;var style=state.tokenize(stream,state);if(state.type=type,(style||type)&&"comment"!=style)for(curState=state;;){var comb=state.cc.pop()||element;if(comb(type||style))break}return state.startOfLine=!1,setStyle||style}var setStyle,stringStream=require("../assets/stringStream"),Kludges={autoSelfClosers:{},implicitlyClosed:{},contextGrabbers:{},doNotIndent:{},allowUnquoted:!0,allowMissing:!0},tagName=null,type=null,curState=null;return{parse:function(data,offset){offset=offset||0;for(var state=startState(),stream=stringStream.create(data),tokens=[];!stream.eol();)tokens.push({type:token(stream,state),start:stream.start+offset,end:stream.pos+offset}),stream.start=stream.pos;return tokens}}})},{"../assets/stringStream":11}],39:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require,exports,module){function isNumeric(ch){var code=ch&&ch.charCodeAt(0);return ch&&"."==ch||code>47&&58>code}function isSingleProperty(snippet){return snippet=utils.trim(snippet),/\/\*|\n|\r/.test(snippet)?!1:/^[a-z0-9\-]+\s*\:/i.test(snippet)?2==snippet.replace(/\$\{.+?\}/g,"").split(":").length:!1}function normalizeValue(value){"-"!=value.charAt(0)||/^\-[\.\d]/.test(value)||(value=value.replace(/^\-+/,""));var ch=value.charAt(0);return"#"==ch?normalizeHexColor(value):"$"==ch?utils.escapeText(value):getKeyword(value)}function normalizeHexColor(value){var hex=value.replace(/^#+/,"")||"0";if("t"==hex.toLowerCase())return"transparent";var opacity="";hex=hex.replace(/\.(\d+)$/,function(str){return opacity="0"+str,""});var repeat=utils.repeatString,color=null;switch(hex.length){case 1:color=repeat(hex,6);break;case 2:color=repeat(hex,3);break;case 3:color=hex.charAt(0)+hex.charAt(0)+hex.charAt(1)+hex.charAt(1)+hex.charAt(2)+hex.charAt(2);break;case 4:color=hex+hex.substr(0,2);break;case 5:color=hex+hex.charAt(0);break;default:color=hex.substr(0,6)}if(opacity)return toRgba(color,opacity);if(prefs.get("css.color.short")){var p=color.split("");p[0]==p[1]&&p[2]==p[3]&&p[4]==p[5]&&(color=p[0]+p[2]+p[4])}switch(prefs.get("css.color.case")){case"upper":color=color.toUpperCase();break;case"lower":color=color.toLowerCase()}return"#"+color}function toRgba(color,opacity){var r=parseInt(color.substr(0,2),16),g=parseInt(color.substr(2,2),16),b=parseInt(color.substr(4,2),16);return"rgba("+[r,g,b,opacity].join(", ")+")"}function getKeyword(name){var aliases=prefs.getDict("css.keywordAliases");return name in aliases?aliases[name]:name}function getUnit(name){var aliases=prefs.getDict("css.unitAliases");return name in aliases?aliases[name]:name}function isValidKeyword(keyword){return~prefs.getArray("css.keywords").indexOf(getKeyword(keyword))}function hasPrefix(property,prefix){var info=vendorPrefixes[prefix];return info||(info=utils.find(vendorPrefixes,function(data){return data.prefix==prefix})),info&&info.supports(property)}function findVendorPrefixes(property){var prefixes=ciu.resolvePrefixes(property);return prefixes||(prefixes=[],Object.keys(vendorPrefixes).forEach(function(key){hasPrefix(property,key)&&prefixes.push(vendorPrefixes[key].prefix)}),prefixes.length||(prefixes=null)),prefixes}function findInternalPrefixes(property,noAutofill){var result=[],prefixes=findVendorPrefixes(property);if(prefixes){var prefixMap={};Object.keys(vendorPrefixes).forEach(function(key){prefixMap[vendorPrefixes[key].prefix]=key}),result=prefixes.map(function(prefix){return prefixMap[prefix]})}return result.length||noAutofill||Object.keys(vendorPrefixes).forEach(function(prefix){vendorPrefixes[prefix].obsolete||result.push(prefix)}),result}function addPrefix(name,obj){"string"==typeof obj&&(obj={prefix:obj}),vendorPrefixes[name]=utils.extend({},prefixObj,obj)}function getSyntaxPreference(name,syntax){if(syntax){"styl"==syntax&&(syntax="stylus");var val=prefs.get(syntax+"."+name);if("undefined"!=typeof val)return val}return prefs.get("css."+name)}function formatProperty(property,syntax){var ix=property.indexOf(":");return property=property.substring(0,ix).replace(/\s+$/,"")+getSyntaxPreference("valueSeparator",syntax)+utils.trim(property.substring(ix+1)),property.replace(/\s*;\s*$/,getSyntaxPreference("propertyEnd",syntax))}function transformSnippet(snippet,isImportant,syntax){return"string"!=typeof snippet&&(snippet=snippet.data),isSingleProperty(snippet)?(isImportant&&(~snippet.indexOf(";")?snippet=snippet.split(";").join(" !important;"):snippet+=" !important"),formatProperty(snippet,syntax)):snippet}function getProperties(key){var list=prefs.getArray(key),addon=prefs.getArray(key+"Addon");return addon&&addon.forEach(function(prop){"-"==prop.charAt(0)?list=utils.without(list,prop.substr(1)):("+"==prop.charAt(0)&&(prop=prop.substr(1)),list.push(prop))}),list}function resolvePrefixedValues(snippetObj,isImportant,syntax){var prefixes=[],lookup={},parts=cssEditTree.findParts(snippetObj.value);return parts.reverse(),parts.forEach(function(p){var partValue=p.substring(snippetObj.value);(findVendorPrefixes(partValue)||[]).forEach(function(prefix){lookup[prefix]||(lookup[prefix]=snippetObj.value,prefixes.push(prefix)),lookup[prefix]=utils.replaceSubstring(lookup[prefix],"-"+prefix+"-"+partValue,p)})}),prefixes.map(function(prefix){return transformSnippet(snippetObj.name+":"+lookup[prefix],isImportant,syntax)})}var prefs=require("../assets/preferences"),resources=require("../assets/resources"),stringStream=require("../assets/stringStream"),ciu=require("../assets/caniuse"),utils=require("../utils/common"),template=require("../utils/template"),cssEditTree=require("../editTree/css"),prefixObj={prefix:"emmet",obsolete:!1,transformName:function(name){return"-"+this.prefix+"-"+name},properties:function(){return getProperties("css."+this.prefix+"Properties")||[]},supports:function(name){return~this.properties().indexOf(name)}},vendorPrefixes={},defaultValue="${1};";prefs.define("css.valueSeparator",": ","Defines a symbol that should be placed between CSS property and value when expanding CSS abbreviations."),prefs.define("css.propertyEnd",";","Defines a symbol that should be placed at the end of CSS property  when expanding CSS abbreviations."),prefs.define("stylus.valueSeparator"," ","Defines a symbol that should be placed between CSS property and value when expanding CSS abbreviations in Stylus dialect."),prefs.define("stylus.propertyEnd","","Defines a symbol that should be placed at the end of CSS property  when expanding CSS abbreviations in Stylus dialect."),prefs.define("sass.propertyEnd","","Defines a symbol that should be placed at the end of CSS property  when expanding CSS abbreviations in SASS dialect."),prefs.define("css.syntaxes","css, less, sass, scss, stylus, styl","List of syntaxes that should be treated as CSS dialects."),prefs.define("css.autoInsertVendorPrefixes",!0,"Automatically generate vendor-prefixed copies of expanded CSS property. By default, Emmet will generate vendor-prefixed properties only when you put dash before abbreviation (e.g. <code>-bxsh</code>). With this option enabled, you dont need dashes before abbreviations: Emmet will produce vendor-prefixed properties for you."),prefs.define("less.autoInsertVendorPrefixes",!1,"Same as <code>css.autoInsertVendorPrefixes</code> but for LESS syntax"),prefs.define("scss.autoInsertVendorPrefixes",!1,"Same as <code>css.autoInsertVendorPrefixes</code> but for SCSS syntax"),prefs.define("sass.autoInsertVendorPrefixes",!1,"Same as <code>css.autoInsertVendorPrefixes</code> but for SASS syntax"),prefs.define("stylus.autoInsertVendorPrefixes",!1,"Same as <code>css.autoInsertVendorPrefixes</code> but for Stylus syntax");var descTemplate=template("A comma-separated list of CSS properties that may have <code><%= vendor %></code> vendor prefix. This list is used to generate a list of prefixed properties when expanding <code>-property</code> abbreviations. Empty list means that all possible CSS values may have <code><%= vendor %></code> prefix."),descAddonTemplate=template("A comma-separated list of <em>additional</em> CSS properties for <code>css.<%= vendor %>Preperties</code> preference. You should use this list if you want to add or remove a few CSS properties to original set. To add a new property, simply write its name, to remove it, precede property with hyphen.<br>For example, to add <em>foo</em> property and remove <em>border-radius</em> one, the preference value will look like this: <code>foo, -border-radius</code>."),props={webkit:"animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius",moz:"animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius",ms:"accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, wrap-flow, wrap-margin, wrap-through, writing-mode",o:"dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style"};return Object.keys(props).forEach(function(k){prefs.define("css."+k+"Properties",props[k],descTemplate({vendor:k})),prefs.define("css."+k+"PropertiesAddon","",descAddonTemplate({vendor:k}))}),prefs.define("css.unitlessProperties","z-index, line-height, opacity, font-weight, zoom","The list of properties whose values must not contain units."),prefs.define("css.intUnit","px","Default unit for integer values"),prefs.define("css.floatUnit","em","Default unit for float values"),prefs.define("css.keywords","auto, inherit, all","A comma-separated list of valid keywords that can be used in CSS abbreviations."),prefs.define("css.keywordAliases","a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent","A comma-separated list of keyword aliases, used in CSS abbreviation. Each alias should be defined as <code>alias:keyword_name</code>."),prefs.define("css.unitAliases","e:em, p:%, x:ex, r:rem","A comma-separated list of unit aliases, used in CSS abbreviation. Each alias should be defined as <code>alias:unit_value</code>."),prefs.define("css.color.short",!0,"Should color values like <code>#ffffff</code> be shortened to <code>#fff</code> after abbreviation with color was expanded."),prefs.define("css.color.case","keep","Letter case of color values generated by abbreviations with color (like <code>c#0</code>). Possible values are <code>upper</code>, <code>lower</code> and <code>keep</code>."),prefs.define("css.fuzzySearch",!0,"Enable fuzzy search among CSS snippet names. When enabled, every <em>unknown</em> snippet will be scored against available snippet names (not values or CSS properties!). The match with best score will be used to resolve snippet value. For example, with this preference enabled, the following abbreviations are equal: <code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == <code>oh</code>"),prefs.define("css.fuzzySearchMinScore",.3,"The minium score (from 0 to 1) that fuzzy-matched abbreviation should achive. Lower values may produce many false-positive matches, higher values may reduce possible matches."),prefs.define("css.alignVendor",!1,"If set to <code>true</code>, all generated vendor-prefixed properties will be aligned by real property name."),addPrefix("w",{prefix:"webkit"}),addPrefix("m",{prefix:"moz"}),addPrefix("s",{prefix:"ms"}),addPrefix("o",{prefix:"o"}),module=module||{},module.exports={addPrefix:addPrefix,supportsPrefix:hasPrefix,resolve:function(node,syntax){var cssSyntaxes=prefs.getArray("css.syntaxes");
return cssSyntaxes&&~cssSyntaxes.indexOf(syntax)&&node.isElement()?this.expandToSnippet(node.abbreviation,syntax):null},prefixed:function(property,prefix){return hasPrefix(property,prefix)?"-"+prefix+"-"+property:property},listPrefixes:function(){return vendorPrefixes.map(function(obj){return obj.prefix})},getPrefix:function(name){return vendorPrefixes[name]},removePrefix:function(name){name in vendorPrefixes&&delete vendorPrefixes[name]},extractPrefixes:function(abbr){if("-"!=abbr.charAt(0))return{property:abbr,prefixes:null};for(var ch,i=1,il=abbr.length,prefixes=[];il>i;){if(ch=abbr.charAt(i),"-"==ch){i++;break}if(!(ch in vendorPrefixes)){prefixes.length=0,i=1;break}prefixes.push(ch),i++}return i==il-1&&(i=1,prefixes.length=1),{property:abbr.substring(i),prefixes:prefixes.length?prefixes:"all"}},findValuesInAbbreviation:function(abbr,syntax){syntax=syntax||"css";for(var ch,i=0,il=abbr.length,value="";il>i;){if(ch=abbr.charAt(i),isNumeric(ch)||"#"==ch||"$"==ch||"-"==ch&&isNumeric(abbr.charAt(i+1))){value=abbr.substring(i);break}i++}for(var property=abbr.substring(0,abbr.length-value.length),keywords=[];~property.indexOf("-")&&!resources.findSnippet(syntax,property);){var parts=property.split("-"),lastPart=parts.pop();if(!isValidKeyword(lastPart))break;keywords.unshift(lastPart),property=parts.join("-")}return keywords.join("-")+value},parseValues:function(str){for(var stream=stringStream.create(str),values=[],ch=null;ch=stream.next();)"$"==ch?(stream.match(/^[^\$]+/,!0),values.push(stream.current())):"#"==ch?(stream.match(/^t|[0-9a-f]+(\.\d+)?/i,!0),values.push(stream.current())):"-"==ch?((isValidKeyword(utils.last(values))||stream.start&&isNumeric(str.charAt(stream.start-1)))&&(stream.start=stream.pos),stream.match(/^\-?[0-9]*(\.[0-9]+)?[a-z%\.]*/,!0),values.push(stream.current())):(stream.match(/^[0-9]*(\.[0-9]*)?[a-z%]*/,!0),values.push(stream.current())),stream.start=stream.pos;return values.filter(function(item){return!!item}).map(normalizeValue)},extractValues:function(abbr){var abbrValues=this.findValuesInAbbreviation(abbr);return abbrValues?{property:abbr.substring(0,abbr.length-abbrValues.length).replace(/-$/,""),values:this.parseValues(abbrValues)}:{property:abbr,values:null}},normalizeValue:function(value,property){property=(property||"").toLowerCase();var unitlessProps=prefs.getArray("css.unitlessProperties");return value.replace(/^(\-?[0-9\.]+)([a-z]*)$/,function(str,val,unit){return unit||"0"!=val&&!~unitlessProps.indexOf(property)?unit?val+getUnit(unit):val.replace(/\.$/,"")+prefs.get(~val.indexOf(".")?"css.floatUnit":"css.intUnit"):val})},expand:function(abbr,value,syntax){syntax=syntax||"css";var autoInsertPrefixes=prefs.get(syntax+".autoInsertVendorPrefixes"),isImportant=/^(.+)\!$/.test(abbr);isImportant&&(abbr=RegExp.$1);var snippet=resources.findSnippet(syntax,abbr);if(snippet&&!autoInsertPrefixes)return transformSnippet(snippet,isImportant,syntax);var prefixData=this.extractPrefixes(abbr),valuesData=this.extractValues(prefixData.property),abbrData=utils.extend(prefixData,valuesData);if(snippet?abbrData.values=null:snippet=resources.findSnippet(syntax,abbrData.property),!snippet&&prefs.get("css.fuzzySearch")&&(snippet=resources.fuzzyFindSnippet(syntax,abbrData.property,parseFloat(prefs.get("css.fuzzySearchMinScore")))),snippet)"string"!=typeof snippet&&(snippet=snippet.data);else{if(!abbrData.property)return null;snippet=abbrData.property+":"+defaultValue}if(!isSingleProperty(snippet))return snippet;var snippetObj=this.splitSnippet(snippet),result=[];!value&&abbrData.values&&(value=abbrData.values.map(function(val){return this.normalizeValue(val,snippetObj.name)},this).join(" ")+";"),snippetObj.value=value||snippetObj.value;var propName,prefixes="all"==abbrData.prefixes||!abbrData.prefixes&&autoInsertPrefixes?findInternalPrefixes(snippetObj.name,autoInsertPrefixes&&"all"!=abbrData.prefixes):abbrData.prefixes,names=[];if((prefixes||[]).forEach(function(p){p in vendorPrefixes&&(propName=vendorPrefixes[p].transformName(snippetObj.name),names.push(propName),result.push(transformSnippet(propName+":"+snippetObj.value,isImportant,syntax)))}),result.push(transformSnippet(snippetObj.name+":"+snippetObj.value,isImportant,syntax)),names.push(snippetObj.name),result=resolvePrefixedValues(snippetObj,isImportant,syntax).concat(result),prefs.get("css.alignVendor")){var pads=utils.getStringsPads(names);result=result.map(function(prop,i){return pads[i]+prop})}return result},expandToSnippet:function(abbr,syntax){var snippet=this.expand(abbr,null,syntax);return null===snippet?null:Array.isArray(snippet)?snippet.join("\n"):"string"!=typeof snippet?snippet.data:snippet+""},splitSnippet:function(snippet){if(snippet=utils.trim(snippet),-1==snippet.indexOf(":"))return{name:snippet,value:defaultValue};var pair=snippet.split(":");return{name:utils.trim(pair.shift()),value:utils.trim(pair.join(":")).replace(/^(\$\{0\}|\$0)(\s*;?)$/,"${1}$2")}},getSyntaxPreference:getSyntaxPreference,transformSnippet:transformSnippet,vendorPrefixes:findVendorPrefixes},module.exports})},{"../assets/caniuse":2,"../assets/preferences":7,"../assets/resources":10,"../assets/stringStream":11,"../editTree/css":15,"../utils/common":43,"../utils/template":45}],40:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){var utils=require("../utils/common"),elementTypes={empty:[],blockLevel:"address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6".split(","),inlineLevel:"a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var".split(",")},elementMap={p:"span",ul:"li",ol:"li",table:"tr",tr:"td",tbody:"tr",thead:"tr",tfoot:"tr",colgroup:"col",select:"option",optgroup:"option",audio:"source",video:"source",object:"param",map:"area"};return{resolve:function(name){return name=(name||"").toLowerCase(),name in elementMap?this.getMapping(name):this.isInlineLevel(name)?"span":"div"},getMapping:function(name){return elementMap[name.toLowerCase()]},isInlineLevel:function(name){return this.isTypeOf(name,"inlineLevel")},isBlockLevel:function(name){return this.isTypeOf(name,"blockLevel")},isEmptyElement:function(name){return this.isTypeOf(name,"empty")},isTypeOf:function(name,type){return~elementTypes[type].indexOf(name)},addMapping:function(parent,child){elementMap[parent]=child},removeMapping:function(parent){parent in elementMap&&delete elementMap[parent]},addElementToCollection:function(name,collection){elementTypes[collection]||(elementTypes[collection]=[]);var col=this.getCollection(collection);~col.indexOf(name)||col.push(name)},removeElementFromCollection:function(name,collection){collection in elementTypes&&(elementTypes[collection]=utils.without(this.getCollection(collection),name))},getCollection:function(name){return elementTypes[name]}}})},{"../utils/common":43}],41:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){var elements=require("../assets/elements"),tabStops=require("../assets/tabStops"),utils=require("../utils/common"),tagName=require("../resolver/tagName");return{isUnary:function(node){if(node.children.length||node._text||this.isSnippet(node))return!1;var r=node.data("resource");return r&&r.is_empty},isInline:function(node){return node.isTextNode()||!node.name()||tagName.isInlineLevel(node.name())},isBlock:function(node){return this.isSnippet(node)||!this.isInline(node)},isSnippet:function(node){return elements.is(node.data("resource"),"snippet")},hasTagsInContent:function(node){return utils.matchesTag(node.content)},hasBlockChildren:function(node){return this.hasTagsInContent(node)&&this.isBlock(node)||node.children.some(function(child){return this.isBlock(child)},this)},insertChildContent:function(text,childContent,options){options=utils.extend({keepVariable:!0,appendIfNoChild:!0},options||{});var childVariableReplaced=!1;return text=tabStops.replaceVariables(text,function(variable,name,data){var output=variable;return"child"==name&&(output=utils.padString(childContent,utils.getLinePaddingFromPosition(text,data.start)),childVariableReplaced=!0,options.keepVariable&&(output+=variable)),output}),!childVariableReplaced&&options.appendIfNoChild&&(text+=childContent),text}}})},{"../assets/elements":3,"../assets/tabStops":12,"../resolver/tagName":40,"../utils/common":43}],42:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){var utils=require("./common"),stringStream=(require("../assets/range"),require("../assets/stringStream")),reHasComment=/\/\*|\/\//;return{strip:function(content){if(!reHasComment.test(content))return content;for(var ch,ch2,stream=stringStream(content),replaceRanges=[];ch=stream.next();)if("/"===ch){if(ch2=stream.peek(),"*"===ch2)stream.start=stream.pos-1,stream.skipTo("*/")?stream.pos+=2:stream.skipToEnd(),replaceRanges.push([stream.start,stream.pos]);else if("/"===ch2){for(stream.start=stream.pos-1;(ch2=stream.next())&&"\n"!==ch2&&"\r"!=ch2;);replaceRanges.push([stream.start,stream.pos])}}else stream.skipQuoted();return utils.replaceWith(content,replaceRanges," ")}}})},{"../assets/range":9,"../assets/stringStream":11,"./common":43}],43:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){var range=require("../assets/range"),caretPlaceholder="${0}";return{reTag:/<\/?[\w:\-]+(?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*\s*(\/?)>$/,defaultSyntax:function(){return"html"},defaultProfile:function(){return"plain"},endsWithTag:function(str){return this.reTag.test(str)},isNumeric:function(ch){return"string"==typeof ch&&(ch=ch.charCodeAt(0)),ch&&ch>47&&58>ch},trim:function(){return String.prototype.trim?function(text){return text?text.trim():""}:function(text){return(text||"").replace(/^\s+|\s+$/g,"")}}(),splitByLines:function(text,removeEmpty){var nl="\n",lines=(text||"").replace(/\r\n/g,"\n").replace(/\n\r/g,"\n").replace(/\r/g,"\n").replace(/\n/g,nl).split(nl);return removeEmpty&&(lines=lines.filter(function(line){return line.length&&!!this.trim(line)},this)),lines},repeatString:function(str,howMany){for(var out="";howMany--;)out+=str;return out},getStringsPads:function(strings){var lengths=strings.map(function(s){return"string"==typeof s?s.length:+s}),max=lengths.reduce(function(prev,cur){return"undefined"==typeof prev?cur:Math.max(prev,cur)});return lengths.map(function(l){var pad=max-l;return pad?this.repeatString(" ",pad):""},this)},padString:function(text,pad){var result=[],lines=this.splitByLines(text),nl="\n";result.push(lines[0]);for(var j=1;j<lines.length;j++)result.push(nl+pad+lines[j]);return result.join("")},zeroPadString:function(str,pad){for(var padding="",il=str.length;pad>il++;)padding+="0";return padding+str},unindentString:function(text,pad){for(var line,lines=this.splitByLines(text),pl=pad.length,i=0,il=lines.length;il>i;i++)line=lines[i],line.substr(0,pl)===pad&&(lines[i]=line.substr(pl));return lines.join("\n")},replaceUnescapedSymbol:function(str,symbol,replace){for(var i=0,il=str.length,sl=symbol.length,matchCount=0;il>i;)if("\\"==str.charAt(i))i+=sl+1;else if(str.substr(i,sl)==symbol){var curSl=sl;matchCount++;var newValue=replace;if("function"==typeof replace){var replaceData=replace(str,symbol,i,matchCount);replaceData?(curSl=replaceData[0].length,newValue=replaceData[1]):newValue=!1}if(newValue===!1){i++;continue}str=str.substring(0,i)+newValue+str.substring(i+curSl),il=str.length,i+=newValue.length}else i++;return str},replaceCounter:function(str,value,total){var symbol="$";str=String(str),value=String(value),/^\-?\d+$/.test(value)&&(value=+value);var that=this;return this.replaceUnescapedSymbol(str,symbol,function(str,symbol,pos){if("{"==str.charAt(pos+1)||that.isNumeric(str.charAt(pos+1)))return!1;for(var j=pos+1;"$"==str.charAt(j)&&"{"!=str.charAt(j+1);)j++;var m,pad=j-pos,base=0,decrement=!1;return(m=str.substr(j).match(/^@(\-?)(\d*)/))&&(j+=m[0].length,m[1]&&(decrement=!0),base=parseInt(m[2]||1,10)-1),decrement&&total&&"number"==typeof value&&(value=total-value+1),value+=base,[str.substring(pos,j),that.zeroPadString(value+"",pad)]})},matchesTag:function(str){return this.reTag.test(str||"")},escapeText:function(text){return text.replace(/([\$\\])/g,"\\$1")},unescapeText:function(text){return text.replace(/\\(.)/g,"$1")},getCaretPlaceholder:function(){return"function"==typeof caretPlaceholder?caretPlaceholder.apply(this,arguments):caretPlaceholder},setCaretPlaceholder:function(value){caretPlaceholder=value},getLinePadding:function(line){return(line.match(/^(\s+)/)||[""])[0]},getLinePaddingFromPosition:function(content,pos){var lineRange=this.findNewlineBounds(content,pos);return this.getLinePadding(lineRange.substring(content))},escapeForRegexp:function(str){var specials=new RegExp("[.*+?|()\\[\\]{}\\\\]","g");return str.replace(specials,"\\$&")},prettifyNumber:function(num,fraction){return num.toFixed("undefined"==typeof fraction?2:fraction).replace(/\.?0+$/,"")},replaceSubstring:function(str,value,start,end){return"object"==typeof start&&"end"in start&&(end=start.end,start=start.start),"string"==typeof end&&(end=start+end.length),"undefined"==typeof end&&(end=start),0>start||start>str.length?str:str.substring(0,start)+value+str.substring(end)},replaceWith:function(content,ranges,ch,noRepeat){if(ranges.length){var offset=0,fragments=[];ranges.forEach(function(r){var repl=noRepeat?ch:this.repeatString(ch,r[1]-r[0]);fragments.push(content.substring(offset,r[0]),repl),offset=r[1]},this),content=fragments.join("")+content.substring(offset)}return content},narrowToNonSpace:function(text,start,end){for(var rng=range.create(start,end),reSpace=/[\s\n\r\u00a0]/;rng.start<rng.end&&reSpace.test(text.charAt(rng.start));)rng.start++;for(;rng.end>rng.start;)if(rng.end--,!reSpace.test(text.charAt(rng.end))){rng.end++;break}return rng},findNewlineBounds:function(text,from){for(var ch,len=text.length,start=0,end=len-1,i=from-1;i>0;i--)if(ch=text.charAt(i),"\n"==ch||"\r"==ch){start=i+1;break}for(var j=from;len>j;j++)if(ch=text.charAt(j),"\n"==ch||"\r"==ch){end=j;break}return range.create(start,end-start)},deepMerge:function(){var options,name,src,copy,copyIsArray,clone,target=arguments[0]||{},i=1,length=arguments.length;for("object"!=typeof target&&"function"!=typeof target&&(target={});length>i;i++)if(null!==(options=arguments[i]))for(name in options)src=target[name],copy=options[name],target!==copy&&(copy&&("object"==typeof copy||(copyIsArray=Array.isArray(copy)))?(copyIsArray?(copyIsArray=!1,clone=src&&Array.isArray(src)?src:[]):clone=src&&"object"==typeof src?src:{},target[name]=this.deepMerge(clone,copy)):void 0!==copy&&(target[name]=copy));return target},parseJSON:function(str){if("object"==typeof str)return str;try{return JSON.parse(str)}catch(e){return{}}},unique:function(arr,comparator){var lookup=[];return arr.filter(function(item){var val=comparator?comparator(item):item;return lookup.indexOf(val)<0?(lookup.push(val),!0):void 0})},pick:function(obj){var result={},keys=this.toArray(arguments,1);return Object.keys(obj).forEach(function(key){~keys.indexOf(key)&&(result[key]=obj[key])}),result},find:function(arr,comparator,ctx){var result;return ctx&&(comparator=comparator.bind(ctx)),Array.isArray(arr)?arr.some(function(item,i){return comparator(item,i)?result=item:void 0}):Object.keys(arr).some(function(key,i){return comparator(arr[key],i)?result=arr[key]:void 0}),result},toArray:function(obj,sliceIx){return Array.isArray(obj)&&!sliceIx?obj:Array.prototype.slice.call(obj,sliceIx||0)},extend:function(obj){for(var a,i=1,il=arguments.length;il>i;i++)a=arguments[i],a&&Object.keys(a).forEach(function(key){obj[key]=a[key]});return obj},defaults:function(obj){for(var a,i=1,il=arguments.length;il>i;i++)a=arguments[i],a&&Object.keys(a).forEach(function(key){key in obj||(obj[key]=a[key])});return obj},flatten:function(arr,out){out=out||[];var self=this;return self.toArray(arr).forEach(function(item){Array.isArray(item)?self.flatten(item,out):out.push(item)}),out},clone:function(obj){return Array.isArray(obj)?obj.slice(0):this.extend({},obj)},without:function(arr){return this.toArray(arguments,1).forEach(function(item){for(var ix;~(ix=arr.indexOf(item));)arr.splice(ix,1)}),arr},last:function(arr){return arr[arr.length-1]}}})},{"../assets/range":9}],44:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function isQuote(ch){return'"'==ch||"'"==ch}function getId(){return idCounter=(idCounter+1)%maxId,"s"+idCounter}function CSSSection(rng,source){this.id=getId(),this.parent=null,this.nextSibling=null,this.previousSibling=null,this._source=source,this._name=null,this._content=null,this._data={},!rng&&source&&(rng=range(0,source)),this.range=rng,this.children=[]}var utils=require("./common"),commentsUtils=require("./comments"),range=require("../assets/range"),stringStream=require("../assets/stringStream"),htmlMatcher=(require("../parser/css"),require("../assets/htmlMatcher")),xmlEditTree=require("../editTree/xml"),idCounter=1,maxId=1e6,reSpaceTrim=/^(\s*).+?(\s*)$/,reSpace=/\s/g;return CSSSection.prototype={addChild:function(section){section instanceof CSSSection||(section=new CSSSection(section));var lastChild=utils.last(this.children);return lastChild&&(lastChild.nextSibling=section,section.previousSibling=lastChild),section.parent=this,this.children.push(section),section},root:function(){var root=this;do if(!root.parent)return root;while(root=root.parent);return root},source:function(){return this._source||this.root()._source},name:function(){if(null===this._name){var range=this.nameRange();range&&(this._name=range.substring(this.source()))}return this._name},nameRange:function(){return this.range&&"_selectorEnd"in this.range?range.create2(this.range.start,this.range._selectorEnd):void 0},matchDeep:function(pos){if(!this.range.inside(pos))return null;for(var m,i=0,il=this.children.length;il>i;i++)if(m=this.children[i].matchDeep(pos))return m;return this.parent?this:null},allRanges:function(){var out=[];return this.parent&&out.push(this.range),this.children.forEach(function(child){out=out.concat(child.allRanges())}),out},data:function(key,value){return"undefined"!=typeof value&&(this._data[key]=value),this._data[key]},stringify:function(indent){indent=indent||"";var out="";return this.children.forEach(function(item){out+=indent+item.name().replace(/\n/g,"\\n")+"\n",out+=item.stringify(indent+"--")}),out},content:function(){if(null!==this._content)return this._content;if(!(this.range&&"_contentStart"in this.range))return"";var r=range.create2(this.range._contentStart+1,this.range.end-1),source=this.source(),start=r.start,out="";return this.children.forEach(function(child){out+=source.substring(start,child.range.start),start=child.range.end}),out+=source.substring(start,r.end),this._content=utils.trim(out)}},{findAllRules:function(content){content=this.sanitize(content);for(var matchedRanges,ch,stream=stringStream(content),ranges=[],self=this,saveRule=function(r){var selRange=self.extractSelector(content,r.start),rule=range.create2(selRange.start,r.end);rule._selectorEnd=selRange.end,rule._contentStart=r.start,ranges.push(rule)};ch=stream.next();)if(isQuote(ch)){if(!stream.skipString(ch))break}else"{"==ch&&(matchedRanges=this.matchBracesRanges(content,stream.pos-1),matchedRanges.forEach(saveRule),matchedRanges.length)&&(stream.pos=utils.last(matchedRanges).end);return ranges.sort(function(a,b){return a.start-b.start})},matchBracesRanges:function(content,pos,sanitize){sanitize&&(content=this.sanitize(content));var stream=stringStream(content);stream.start=stream.pos=pos;for(var ch,stack=[],ranges=[];ch=stream.next();)if("{"==ch)stack.push(stream.pos-1);else if("}"==ch){if(!stack.length)throw"Invalid source structure (check for curly braces)";if(ranges.push(range.create2(stack.pop(),stream.pos)),!stack.length)return ranges}else stream.skipQuoted();return ranges},extractSelector:function(content,pos,sanitize){sanitize&&(content=this.sanitize(content));for(var ch,skipString=function(){var quote=content.charAt(pos);if('"'==quote||"'"==quote){for(;--pos>=0&&(content.charAt(pos)!=quote||"\\"==content.charAt(pos-1)););return!0}return!1},endPos=pos;--pos>=0;)if(!skipString())if(ch=content.charAt(pos),")"!=ch){if("{"==ch||"}"==ch||";"==ch){pos++;break}}else for(;--pos>=0&&(skipString()||"("!=content.charAt(pos)););0>pos&&(pos=0);var selector=content.substring(pos,endPos),m=selector.replace(reSpace," ").match(reSpaceTrim);return m&&(pos+=m[1].length,endPos-=m[2].length),range.create2(pos,endPos)},matchEnclosingRule:function(content,pos){"string"==typeof content&&(content=this.findAllRules(content));var rules=content.filter(function(r){return r.inside(pos)});return utils.last(rules)},locateRule:function(content,pos,isBackward){var offset=0,subrange=this.styleTagRange(content,pos);subrange&&(offset=subrange.start,pos-=subrange.start,content=subrange.substring(content));var rules=this.findAllRules(content),ctxRule=this.matchEnclosingRule(rules,pos);if(ctxRule)return ctxRule.shift(offset);for(var i=0,il=rules.length;il>i;i++)if(rules[i].start>pos)return rules[isBackward?i-1:i].shift(offset)},sanitize:function(content){content=commentsUtils.strip(content);for(var ch,ch2,stream=stringStream(content),replaceRanges=[];ch=stream.next();)if(isQuote(ch))stream.skipString(ch);else if(("#"===ch||"@"===ch)&&(ch2=stream.peek(),"{"===ch2)){if(stream.start=stream.pos-1,!stream.skipTo("}"))throw"Invalid string interpolation at "+stream.start;stream.pos+=1,replaceRanges.push([stream.start,stream.pos])}return utils.replaceWith(content,replaceRanges,"a")},sectionTree:function(content){var root=new CSSSection(null,content),rules=this.findAllRules(content),insert=function(range,ctx){for(;ctx&&ctx.range;){if(ctx.range.contains(range))return ctx.addChild(range);ctx=ctx.parent}return root.addChild(range)},ctx=root;return rules.forEach(function(r){ctx=insert(r,ctx)}),root},nestedSectionsInRule:function(rule){var offset=rule.valueRange(!0).start,nestedSections=this.findAllRules(rule.valueRange().substring(rule.source));return nestedSections.forEach(function(section){section.start+=offset,section.end+=offset,section._selectorEnd+=offset,section._contentStart+=offset}),nestedSections},styleTagRange:function(content,pos){var tag=htmlMatcher.tag(content,pos);return tag&&"style"==tag.open.name.toLowerCase()&&tag.innerRange.cmp(pos,"lte","gte")&&tag.innerRange},styleAttrRange:function(content,pos){var tree=xmlEditTree.parseFromPosition(content,pos,!0);if(tree){var attr=tree.itemFromPosition(pos,!0);return attr&&"style"==attr.name().toLowerCase()&&attr.valueRange(!0).cmp(pos,"lte","gte")&&attr.valueRange(!0)}},CSSSection:CSSSection}})},{"../assets/htmlMatcher":5,"../assets/range":9,"../assets/stringStream":11,"../editTree/xml":16,"../parser/css":32,"./comments":42,"./common":43}],45:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function parseArgs(str){for(var args=[],stream=stringStream(str);!stream.eol();)","==stream.peek()&&(args.push(utils.trim(stream.current())),stream.next(),stream.start=stream.pos),stream.next();return args.push(utils.trim(stream.current())),args.filter(function(a){return!!a})}function parseFunctionCall(str){for(var args,fnName=null,stream=stringStream(str);!stream.eol();){if("("==stream.peek()){fnName=stream.current(),stream.start=stream.pos,stream.skipToPair("(",")",!0),args=stream.current(),args=parseArgs(args.substring(1,args.length-1));break}stream.next()}return fnName&&{name:fnName,args:args}}function evalArg(arg,context){if(/^['"]/.test(arg))return arg.replace(/^(['"])(.+?)\1$/,"$2");if(!isNaN(+arg))return+arg;if(arg){for(var parts=arg.split("."),prop=context;parts.length;)prop=prop[parts.shift()];return prop}}function process(template,context){return template.replace(/<%[=\-](.+?)%>/g,function(str,match){match=utils.trim(match);var fn=parseFunctionCall(match);if(fn){var fnArgs=fn.args.map(function(arg){return evalArg(arg,context)});return context[fn.name].apply(context,fnArgs)}return evalArg(match,context)})}var stringStream=require("../assets/stringStream"),utils=require("./common");return function(template,context){return context?process(template,context):function(context){return process(template,context)}}})},{"../assets/stringStream":11,"./common":43}],46:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(require){function inherits(parent,protoProps,staticProps){var child;return child=protoProps&&protoProps.hasOwnProperty("constructor")?protoProps.constructor:function(){parent.apply(this,arguments)},utils.extend(child,parent),ctor.prototype=parent.prototype,child.prototype=new ctor,protoProps&&utils.extend(child.prototype,protoProps),staticProps&&utils.extend(child,staticProps),child.prototype.constructor=child,child.__super__=parent.prototype,child}var utils=require("../utils/common"),ctor=function(){};return{extend:function(protoProps,classProps){var child=inherits(this,protoProps,classProps);return child.extend=this.extend,protoProps.hasOwnProperty("toString")&&(child.prototype.toString=protoProps.toString),child}}})},{"../utils/common":43}],47:[function(require,module,exports){if("object"==typeof module&&"function"!=typeof define)var define=function(factory){module.exports=factory(require,exports,module)};define(function(){return{score:function(string,abbreviation,fuzziness){if(string==abbreviation)return 1;if(""==abbreviation)return 0;for(var start_of_string_bonus,abbreviation_score,final_score,character_score,index_in_string,c,index_c_lowercase,index_c_uppercase,min_index,total_character_score=0,abbreviation_length=abbreviation.length,string_length=string.length,fuzzies=1,i=0;abbreviation_length>i;++i){if(c=abbreviation.charAt(i),index_c_lowercase=string.indexOf(c.toLowerCase()),index_c_uppercase=string.indexOf(c.toUpperCase()),min_index=Math.min(index_c_lowercase,index_c_uppercase),index_in_string=min_index>-1?min_index:Math.max(index_c_lowercase,index_c_uppercase),-1===index_in_string){if(fuzziness){fuzzies+=1-fuzziness;continue}return 0}character_score=.1,string[index_in_string]===c&&(character_score+=.1),0===index_in_string?(character_score+=.6,0===i&&(start_of_string_bonus=1)):" "===string.charAt(index_in_string-1)&&(character_score+=.8),string=string.substring(index_in_string+1,string_length),total_character_score+=character_score}return abbreviation_score=total_character_score/abbreviation_length,final_score=(abbreviation_score*(abbreviation_length/string_length)+abbreviation_score)/2,final_score/=fuzzies,start_of_string_bonus&&1>final_score+.15&&(final_score+=.15),final_score}}})},{}]},{},[1]);(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
'use strict';

exports.Parser = require('./lib/tree_construction/parser');
exports.SimpleApiParser = require('./lib/simple_api/simple_api_parser');
exports.TreeSerializer =
exports.Serializer = require('./lib/serialization/serializer');
exports.JsDomParser = require('./lib/jsdom/jsdom_parser');

exports.TreeAdapters = {
    default: require('./lib/tree_adapters/default'),
    htmlparser2: require('./lib/tree_adapters/htmlparser2')
};

},{"./lib/jsdom/jsdom_parser":7,"./lib/serialization/serializer":9,"./lib/simple_api/simple_api_parser":10,"./lib/tree_adapters/default":15,"./lib/tree_adapters/htmlparser2":16,"./lib/tree_construction/parser":20}],3:[function(require,module,exports){
'use strict';

var Tokenizer = require('../tokenization/tokenizer'),
    HTML = require('./html');

//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES,
    ATTRS = HTML.ATTRS;


//MIME types
var MIME_TYPES = {
    TEXT_HTML: 'text/html',
    APPLICATION_XML: 'application/xhtml+xml'
};

//Attributes
var DEFINITION_URL_ATTR = 'definitionurl',
    ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL',
    SVG_ATTRS_ADJUSTMENT_MAP = {
        'attributename': 'attributeName',
        'attributetype': 'attributeType',
        'basefrequency': 'baseFrequency',
        'baseprofile': 'baseProfile',
        'calcmode': 'calcMode',
        'clippathunits': 'clipPathUnits',
        'contentscripttype': 'contentScriptType',
        'contentstyletype': 'contentStyleType',
        'diffuseconstant': 'diffuseConstant',
        'edgemode': 'edgeMode',
        'externalresourcesrequired': 'externalResourcesRequired',
        'filterres': 'filterRes',
        'filterunits': 'filterUnits',
        'glyphref': 'glyphRef',
        'gradienttransform': 'gradientTransform',
        'gradientunits': 'gradientUnits',
        'kernelmatrix': 'kernelMatrix',
        'kernelunitlength': 'kernelUnitLength',
        'keypoints': 'keyPoints',
        'keysplines': 'keySplines',
        'keytimes': 'keyTimes',
        'lengthadjust': 'lengthAdjust',
        'limitingconeangle': 'limitingConeAngle',
        'markerheight': 'markerHeight',
        'markerunits': 'markerUnits',
        'markerwidth': 'markerWidth',
        'maskcontentunits': 'maskContentUnits',
        'maskunits': 'maskUnits',
        'numoctaves': 'numOctaves',
        'pathlength': 'pathLength',
        'patterncontentunits': 'patternContentUnits',
        'patterntransform': 'patternTransform',
        'patternunits': 'patternUnits',
        'pointsatx': 'pointsAtX',
        'pointsaty': 'pointsAtY',
        'pointsatz': 'pointsAtZ',
        'preservealpha': 'preserveAlpha',
        'preserveaspectratio': 'preserveAspectRatio',
        'primitiveunits': 'primitiveUnits',
        'refx': 'refX',
        'refy': 'refY',
        'repeatcount': 'repeatCount',
        'repeatdur': 'repeatDur',
        'requiredextensions': 'requiredExtensions',
        'requiredfeatures': 'requiredFeatures',
        'specularconstant': 'specularConstant',
        'specularexponent': 'specularExponent',
        'spreadmethod': 'spreadMethod',
        'startoffset': 'startOffset',
        'stddeviation': 'stdDeviation',
        'stitchtiles': 'stitchTiles',
        'surfacescale': 'surfaceScale',
        'systemlanguage': 'systemLanguage',
        'tablevalues': 'tableValues',
        'targetx': 'targetX',
        'targety': 'targetY',
        'textlength': 'textLength',
        'viewbox': 'viewBox',
        'viewtarget': 'viewTarget',
        'xchannelselector': 'xChannelSelector',
        'ychannelselector': 'yChannelSelector',
        'zoomandpan': 'zoomAndPan'
    },
    XML_ATTRS_ADJUSTMENT_MAP = {
        'xlink:actuate': {prefix: 'xlink', name: 'actuate', namespace: NS.XLINK},
        'xlink:arcrole': {prefix: 'xlink', name: 'arcrole', namespace: NS.XLINK},
        'xlink:href': {prefix: 'xlink', name: 'href', namespace: NS.XLINK},
        'xlink:role': {prefix: 'xlink', name: 'role', namespace: NS.XLINK},
        'xlink:show': {prefix: 'xlink', name: 'show', namespace: NS.XLINK},
        'xlink:title': {prefix: 'xlink', name: 'title', namespace: NS.XLINK},
        'xlink:type': {prefix: 'xlink', name: 'type', namespace: NS.XLINK},
        'xml:base': {prefix: 'xml', name: 'base', namespace: NS.XML},
        'xml:lang': {prefix: 'xml', name: 'lang', namespace: NS.XML},
        'xml:space': {prefix: 'xml', name: 'space', namespace: NS.XML},
        'xmlns': {prefix: '', name: 'xmlns', namespace: NS.XMLNS},
        'xmlns:xlink': {prefix: 'xmlns', name: 'xlink', namespace: NS.XMLNS}

    };

//SVG tag names adjustment map
var SVG_TAG_NAMES_ADJUSTMENT_MAP = {
    'altglyph': 'altGlyph',
    'altglyphdef': 'altGlyphDef',
    'altglyphitem': 'altGlyphItem',
    'animatecolor': 'animateColor',
    'animatemotion': 'animateMotion',
    'animatetransform': 'animateTransform',
    'clippath': 'clipPath',
    'feblend': 'feBlend',
    'fecolormatrix': 'feColorMatrix',
    'fecomponenttransfer': 'feComponentTransfer',
    'fecomposite': 'feComposite',
    'feconvolvematrix': 'feConvolveMatrix',
    'fediffuselighting': 'feDiffuseLighting',
    'fedisplacementmap': 'feDisplacementMap',
    'fedistantlight': 'feDistantLight',
    'feflood': 'feFlood',
    'fefunca': 'feFuncA',
    'fefuncb': 'feFuncB',
    'fefuncg': 'feFuncG',
    'fefuncr': 'feFuncR',
    'fegaussianblur': 'feGaussianBlur',
    'feimage': 'feImage',
    'femerge': 'feMerge',
    'femergenode': 'feMergeNode',
    'femorphology': 'feMorphology',
    'feoffset': 'feOffset',
    'fepointlight': 'fePointLight',
    'fespecularlighting': 'feSpecularLighting',
    'fespotlight': 'feSpotLight',
    'fetile': 'feTile',
    'feturbulence': 'feTurbulence',
    'foreignobject': 'foreignObject',
    'glyphref': 'glyphRef',
    'lineargradient': 'linearGradient',
    'radialgradient': 'radialGradient',
    'textpath': 'textPath'
};

//Tags that causes exit from foreign content
var EXITS_FOREIGN_CONTENT = {};

EXITS_FOREIGN_CONTENT[$.B] = true;
EXITS_FOREIGN_CONTENT[$.BIG] = true;
EXITS_FOREIGN_CONTENT[$.BLOCKQUOTE] = true;
EXITS_FOREIGN_CONTENT[$.BODY] = true;
EXITS_FOREIGN_CONTENT[$.BR] = true;
EXITS_FOREIGN_CONTENT[$.CENTER] = true;
EXITS_FOREIGN_CONTENT[$.CODE] = true;
EXITS_FOREIGN_CONTENT[$.DD] = true;
EXITS_FOREIGN_CONTENT[$.DIV] = true;
EXITS_FOREIGN_CONTENT[$.DL] = true;
EXITS_FOREIGN_CONTENT[$.DT] = true;
EXITS_FOREIGN_CONTENT[$.EM] = true;
EXITS_FOREIGN_CONTENT[$.EMBED] = true;
EXITS_FOREIGN_CONTENT[$.H1] = true;
EXITS_FOREIGN_CONTENT[$.H2] = true;
EXITS_FOREIGN_CONTENT[$.H3] = true;
EXITS_FOREIGN_CONTENT[$.H4] = true;
EXITS_FOREIGN_CONTENT[$.H5] = true;
EXITS_FOREIGN_CONTENT[$.H6] = true;
EXITS_FOREIGN_CONTENT[$.HEAD] = true;
EXITS_FOREIGN_CONTENT[$.HR] = true;
EXITS_FOREIGN_CONTENT[$.I] = true;
EXITS_FOREIGN_CONTENT[$.IMG] = true;
EXITS_FOREIGN_CONTENT[$.LI] = true;
EXITS_FOREIGN_CONTENT[$.LISTING] = true;
EXITS_FOREIGN_CONTENT[$.MENU] = true;
EXITS_FOREIGN_CONTENT[$.META] = true;
EXITS_FOREIGN_CONTENT[$.NOBR] = true;
EXITS_FOREIGN_CONTENT[$.OL] = true;
EXITS_FOREIGN_CONTENT[$.P] = true;
EXITS_FOREIGN_CONTENT[$.PRE] = true;
EXITS_FOREIGN_CONTENT[$.RUBY] = true;
EXITS_FOREIGN_CONTENT[$.S] = true;
EXITS_FOREIGN_CONTENT[$.SMALL] = true;
EXITS_FOREIGN_CONTENT[$.SPAN] = true;
EXITS_FOREIGN_CONTENT[$.STRONG] = true;
EXITS_FOREIGN_CONTENT[$.STRIKE] = true;
EXITS_FOREIGN_CONTENT[$.SUB] = true;
EXITS_FOREIGN_CONTENT[$.SUP] = true;
EXITS_FOREIGN_CONTENT[$.TABLE] = true;
EXITS_FOREIGN_CONTENT[$.TT] = true;
EXITS_FOREIGN_CONTENT[$.U] = true;
EXITS_FOREIGN_CONTENT[$.UL] = true;
EXITS_FOREIGN_CONTENT[$.VAR] = true;

//Check exit from foreign content
exports.causesExit = function (startTagToken) {
    var tn = startTagToken.tagName;

    if (tn === $.FONT && (Tokenizer.getTokenAttr(startTagToken, ATTRS.COLOR) !== null ||
        Tokenizer.getTokenAttr(startTagToken, ATTRS.SIZE) !== null ||
        Tokenizer.getTokenAttr(startTagToken, ATTRS.FACE) !== null)) {
        return true;
    }

    return EXITS_FOREIGN_CONTENT[tn];
};

//Token adjustments
exports.adjustTokenMathMLAttrs = function (token) {
    for (var i = 0; i < token.attrs.length; i++) {
        if (token.attrs[i].name === DEFINITION_URL_ATTR) {
            token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
            break;
        }
    }
};

exports.adjustTokenSVGAttrs = function (token) {
    for (var i = 0; i < token.attrs.length; i++) {
        var adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

        if (adjustedAttrName)
            token.attrs[i].name = adjustedAttrName;
    }
};

exports.adjustTokenXMLAttrs = function (token) {
    for (var i = 0; i < token.attrs.length; i++) {
        var adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

        if (adjustedAttrEntry) {
            token.attrs[i].prefix = adjustedAttrEntry.prefix;
            token.attrs[i].name = adjustedAttrEntry.name;
            token.attrs[i].namespace = adjustedAttrEntry.namespace;
        }
    }
};

exports.adjustTokenSVGTagName = function (token) {
    var adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];

    if (adjustedTagName)
        token.tagName = adjustedTagName;
};

//Integration points
exports.isMathMLTextIntegrationPoint = function (tn, ns) {
    return ns === NS.MATHML && (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS || tn === $.MTEXT);
};

exports.isHtmlIntegrationPoint = function (tn, ns, attrs) {
    if (ns === NS.MATHML && tn === $.ANNOTATION_XML) {
        for (var i = 0; i < attrs.length; i++) {
            if (attrs[i].name === ATTRS.ENCODING) {
                var value = attrs[i].value.toLowerCase();

                return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
            }
        }
    }

    return ns === NS.SVG && (tn === $.FOREIGN_OBJECT || tn === $.DESC || tn === $.TITLE);
};

},{"../tokenization/tokenizer":14,"./html":4}],4:[function(require,module,exports){
'use strict';

var NS = exports.NAMESPACES = {
    HTML: 'http://www.w3.org/1999/xhtml',
    MATHML: 'http://www.w3.org/1998/Math/MathML',
    SVG: 'http://www.w3.org/2000/svg',
    XLINK: 'http://www.w3.org/1999/xlink',
    XML: 'http://www.w3.org/XML/1998/namespace',
    XMLNS: 'http://www.w3.org/2000/xmlns/'
};

exports.ATTRS = {
    TYPE: 'type',
    ACTION: 'action',
    ENCODING: 'encoding',
    PROMPT: 'prompt',
    NAME: 'name',
    COLOR: 'color',
    FACE: 'face',
    SIZE: 'size'
};

var $ = exports.TAG_NAMES = {
    A: 'a',
    ADDRESS: 'address',
    ANNOTATION_XML: 'annotation-xml',
    APPLET: 'applet',
    AREA: 'area',
    ARTICLE: 'article',
    ASIDE: 'aside',

    B: 'b',
    BASE: 'base',
    BASEFONT: 'basefont',
    BGSOUND: 'bgsound',
    BIG: 'big',
    BLOCKQUOTE: 'blockquote',
    BODY: 'body',
    BR: 'br',
    BUTTON: 'button',

    CAPTION: 'caption',
    CENTER: 'center',
    CODE: 'code',
    COL: 'col',
    COLGROUP: 'colgroup',
    COMMAND: 'command',

    DD: 'dd',
    DESC: 'desc',
    DETAILS: 'details',
    DIALOG: 'dialog',
    DIR: 'dir',
    DIV: 'div',
    DL: 'dl',
    DT: 'dt',

    EM: 'em',
    EMBED: 'embed',

    FIELDSET: 'fieldset',
    FIGCAPTION: 'figcaption',
    FIGURE: 'figure',
    FONT: 'font',
    FOOTER: 'footer',
    FOREIGN_OBJECT: 'foreignObject',
    FORM: 'form',
    FRAME: 'frame',
    FRAMESET: 'frameset',

    H1: 'h1',
    H2: 'h2',
    H3: 'h3',
    H4: 'h4',
    H5: 'h5',
    H6: 'h6',
    HEAD: 'head',
    HEADER: 'header',
    HGROUP: 'hgroup',
    HR: 'hr',
    HTML: 'html',

    I: 'i',
    IMG: 'img',
    IMAGE: 'image',
    INPUT: 'input',
    IFRAME: 'iframe',
    ISINDEX: 'isindex',

    KEYGEN: 'keygen',

    LABEL: 'label',
    LI: 'li',
    LINK: 'link',
    LISTING: 'listing',

    MAIN: 'main',
    MALIGNMARK: 'malignmark',
    MARQUEE: 'marquee',
    MATH: 'math',
    MENU: 'menu',
    MENUITEM: 'menuitem',
    META: 'meta',
    MGLYPH: 'mglyph',
    MI: 'mi',
    MO: 'mo',
    MN: 'mn',
    MS: 'ms',
    MTEXT: 'mtext',

    NAV: 'nav',
    NOBR: 'nobr',
    NOFRAMES: 'noframes',
    NOEMBED: 'noembed',
    NOSCRIPT: 'noscript',

    OBJECT: 'object',
    OL: 'ol',
    OPTGROUP: 'optgroup',
    OPTION: 'option',

    P: 'p',
    PARAM: 'param',
    PLAINTEXT: 'plaintext',
    PRE: 'pre',

    RP: 'rp',
    RT: 'rt',
    RUBY: 'ruby',

    S: 's',
    SCRIPT: 'script',
    SECTION: 'section',
    SELECT: 'select',
    SOURCE: 'source',
    SMALL: 'small',
    SPAN: 'span',
    STRIKE: 'strike',
    STRONG: 'strong',
    STYLE: 'style',
    SUB: 'sub',
    SUMMARY: 'summary',
    SUP: 'sup',

    TABLE: 'table',
    TBODY: 'tbody',
    TEMPLATE: 'template',
    TEXTAREA: 'textarea',
    TFOOT: 'tfoot',
    TD: 'td',
    TH: 'th',
    THEAD: 'thead',
    TITLE: 'title',
    TR: 'tr',
    TRACK: 'track',
    TT: 'tt',

    U: 'u',
    UL: 'ul',

    SVG: 'svg',

    VAR: 'var',

    WBR: 'wbr',

    XMP: 'xmp'
};

var SPECIAL_ELEMENTS = exports.SPECIAL_ELEMENTS = {};

SPECIAL_ELEMENTS[NS.HTML] = {};
SPECIAL_ELEMENTS[NS.HTML][$.ADDRESS] = true;
SPECIAL_ELEMENTS[NS.HTML][$.APPLET] = true;
SPECIAL_ELEMENTS[NS.HTML][$.AREA] = true;
SPECIAL_ELEMENTS[NS.HTML][$.ARTICLE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.ASIDE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BASE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BASEFONT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BGSOUND] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BLOCKQUOTE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BODY] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.BUTTON] = true;
SPECIAL_ELEMENTS[NS.HTML][$.CAPTION] = true;
SPECIAL_ELEMENTS[NS.HTML][$.CENTER] = true;
SPECIAL_ELEMENTS[NS.HTML][$.COL] = true;
SPECIAL_ELEMENTS[NS.HTML][$.COLGROUP] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DD] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DETAILS] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DIR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DIV] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DL] = true;
SPECIAL_ELEMENTS[NS.HTML][$.DT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.EMBED] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FIELDSET] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FIGCAPTION] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FIGURE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FOOTER] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FORM] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FRAME] = true;
SPECIAL_ELEMENTS[NS.HTML][$.FRAMESET] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H1] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H2] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H3] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H4] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H5] = true;
SPECIAL_ELEMENTS[NS.HTML][$.H6] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HEAD] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HEADER] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HGROUP] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.HTML] = true;
SPECIAL_ELEMENTS[NS.HTML][$.IFRAME] = true;
SPECIAL_ELEMENTS[NS.HTML][$.IMG] = true;
SPECIAL_ELEMENTS[NS.HTML][$.INPUT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.ISINDEX] = true;
SPECIAL_ELEMENTS[NS.HTML][$.LI] = true;
SPECIAL_ELEMENTS[NS.HTML][$.LINK] = true;
SPECIAL_ELEMENTS[NS.HTML][$.LISTING] = true;
SPECIAL_ELEMENTS[NS.HTML][$.MAIN] = true;
SPECIAL_ELEMENTS[NS.HTML][$.MARQUEE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.MENU] = true;
SPECIAL_ELEMENTS[NS.HTML][$.MENUITEM] = true;
SPECIAL_ELEMENTS[NS.HTML][$.META] = true;
SPECIAL_ELEMENTS[NS.HTML][$.NAV] = true;
SPECIAL_ELEMENTS[NS.HTML][$.NOEMBED] = true;
SPECIAL_ELEMENTS[NS.HTML][$.NOFRAMES] = true;
SPECIAL_ELEMENTS[NS.HTML][$.NOSCRIPT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.OBJECT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.OL] = true;
SPECIAL_ELEMENTS[NS.HTML][$.P] = true;
SPECIAL_ELEMENTS[NS.HTML][$.PARAM] = true;
SPECIAL_ELEMENTS[NS.HTML][$.PLAINTEXT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.PRE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SCRIPT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SECTION] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SELECT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SOURCE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.STYLE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.SUMMARY] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TABLE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TBODY] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TD] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TEMPLATE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TEXTAREA] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TFOOT] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TH] = true;
SPECIAL_ELEMENTS[NS.HTML][$.THEAD] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TITLE] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.TRACK] = true;
SPECIAL_ELEMENTS[NS.HTML][$.UL] = true;
SPECIAL_ELEMENTS[NS.HTML][$.WBR] = true;
SPECIAL_ELEMENTS[NS.HTML][$.XMP] = true;

SPECIAL_ELEMENTS[NS.MATHML] = {};
SPECIAL_ELEMENTS[NS.MATHML][$.MI] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.MO] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.MN] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.MS] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.MTEXT] = true;
SPECIAL_ELEMENTS[NS.MATHML][$.ANNOTATION_XML] = true;

SPECIAL_ELEMENTS[NS.SVG] = {};
SPECIAL_ELEMENTS[NS.SVG][$.TITLE] = true;
SPECIAL_ELEMENTS[NS.SVG][$.FOREIGN_OBJECT] = true;
SPECIAL_ELEMENTS[NS.SVG][$.DESC] = true;

},{}],5:[function(require,module,exports){
'use strict';

exports.REPLACEMENT_CHARACTER = '\uFFFD';

exports.CODE_POINTS = {
    EOF: -1,
    NULL: 0x00,
    TABULATION: 0x09,
    CARRIAGE_RETURN: 0x0D,
    LINE_FEED: 0x0A,
    FORM_FEED: 0x0C,
    SPACE: 0x20,
    EXCLAMATION_MARK: 0x21,
    QUOTATION_MARK: 0x22,
    NUMBER_SIGN: 0x23,
    AMPERSAND: 0x26,
    APOSTROPHE: 0x27,
    HYPHEN_MINUS: 0x2D,
    SOLIDUS: 0x2F,
    DIGIT_0: 0x30,
    DIGIT_9: 0x39,
    SEMICOLON: 0x3B,
    LESS_THAN_SIGN: 0x3C,
    EQUALS_SIGN: 0x3D,
    GREATER_THAN_SIGN: 0x3E,
    QUESTION_MARK: 0x3F,
    LATIN_CAPITAL_A: 0x41,
    LATIN_CAPITAL_F: 0x46,
    LATIN_CAPITAL_X: 0x58,
    LATIN_CAPITAL_Z: 0x5A,
    GRAVE_ACCENT: 0x60,
    LATIN_SMALL_A: 0x61,
    LATIN_SMALL_F: 0x66,
    LATIN_SMALL_X: 0x78,
    LATIN_SMALL_Z: 0x7A,
    BOM: 0xFEFF,
    REPLACEMENT_CHARACTER: 0xFFFD
};

exports.CODE_POINT_SEQUENCES = {
    DASH_DASH_STRING: [0x2D, 0x2D], //--
    DOCTYPE_STRING: [0x44, 0x4F, 0x43, 0x54, 0x59, 0x50, 0x45], //DOCTYPE
    CDATA_START_STRING: [0x5B, 0x43, 0x44, 0x41, 0x54, 0x41, 0x5B], //[CDATA[
    CDATA_END_STRING: [0x5D, 0x5D, 0x3E], //]]>
    SCRIPT_STRING: [0x73, 0x63, 0x72, 0x69, 0x70, 0x74], //script
    PUBLIC_STRING: [0x50, 0x55, 0x42, 0x4C, 0x49, 0x43], //PUBLIC
    SYSTEM_STRING: [0x53, 0x59, 0x53, 0x54, 0x45, 0x4D] //SYSTEM
};

},{}],6:[function(require,module,exports){
'use strict';

exports.mergeOptions = function (defaults, options) {
    options = options || {};

    return [defaults, options].reduce(function (merged, optObj) {
        Object.keys(optObj).forEach(function (key) {
            merged[key] = optObj[key];
        });

        return merged;
    }, {});
};

},{}],7:[function(require,module,exports){
(function (process){
'use strict';

var Parser = require('../tree_construction/parser'),
    ParsingUnit = require('./parsing_unit');

//API
exports.parseDocument = function (html, treeAdapter) {
    //NOTE: this should be reentrant, so we create new parser here
    var parser = new Parser(treeAdapter),
        parsingUnit = new ParsingUnit(parser);

    //NOTE: override parser loop method
    parser._runParsingLoop = function () {
        parsingUnit.parsingLoopLock = true;

        while (!parsingUnit.suspended && !this.stopped)
            this._iterateParsingLoop();

        parsingUnit.parsingLoopLock = false;

        if (this.stopped)
            parsingUnit.callback(this.document);
    };

    //NOTE: wait while parserController will be adopted by calling code, then
    //start parsing
    process.nextTick(function () {
        parser.parse(html);
    });

    return parsingUnit;
};

exports.parseInnerHtml = function (innerHtml, contextElement, treeAdapter) {
    //NOTE: this should be reentrant, so we create new parser here
    var parser = new Parser(treeAdapter);

    return parser.parseFragment(innerHtml, contextElement);
};
}).call(this,require('_process'))
},{"../tree_construction/parser":20,"./parsing_unit":8,"_process":1}],8:[function(require,module,exports){
'use strict';

var ParsingUnit = module.exports = function (parser) {
    this.parser = parser;
    this.suspended = false;
    this.parsingLoopLock = false;
    this.callback = null;
};

ParsingUnit.prototype._stateGuard = function (suspend) {
    if (this.suspended && suspend)
        throw new Error('parse5: Parser was already suspended. Please, check your control flow logic.');

    else if (!this.suspended && !suspend)
        throw new Error('parse5: Parser was already resumed. Please, check your control flow logic.');

    return suspend;
};

ParsingUnit.prototype.suspend = function () {
    this.suspended = this._stateGuard(true);

    return this;
};

ParsingUnit.prototype.resume = function () {
    this.suspended = this._stateGuard(false);

    //NOTE: don't enter parsing loop if it is locked. Without this lock _runParsingLoop() may be called
    //while parsing loop is still running. E.g. when suspend() and resume() called synchronously.
    if (!this.parsingLoopLock)
        this.parser._runParsingLoop();

    return this;
};

ParsingUnit.prototype.documentWrite = function (html) {
    this.parser.tokenizer.preprocessor.write(html);

    return this;
};

ParsingUnit.prototype.handleScripts = function (scriptHandler) {
    this.parser.scriptHandler = scriptHandler;

    return this;
};

ParsingUnit.prototype.done = function (callback) {
    this.callback = callback;

    return this;
};

},{}],9:[function(require,module,exports){
'use strict';

var DefaultTreeAdapter = require('../tree_adapters/default'),
    Utils = require('../common/utils'),
    HTML = require('../common/html');

//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES;

//Default serializer options
var DEFAULT_OPTIONS = {encodeHtmlEntities: true};

//Escaping regexes
var AMP_REGEX = /&/g,
    NBSP_REGEX = /\u00a0/g,
    DOUBLE_QUOTE_REGEX = /"/g,
    LT_REGEX = /</g,
    GT_REGEX = />/g;

//Escape string
function escapeString(str, attrMode) {
    str = str
        .replace(AMP_REGEX, '&amp;')
        .replace(NBSP_REGEX, '&nbsp;');

    if (attrMode)
        str = str.replace(DOUBLE_QUOTE_REGEX, '&quot;');

    else {
        str = str
            .replace(LT_REGEX, '&lt;')
            .replace(GT_REGEX, '&gt;');
    }

    return str;
}


//Enquote doctype ID
function enquoteDoctypeId(id) {
    var quote = id.indexOf('"') !== -1 ? '\'' : '"';

    return quote + id + quote;
}


//Serializer
var Serializer = module.exports = function (treeAdapter, options) {
    this.treeAdapter = treeAdapter || DefaultTreeAdapter;
    this.options = Utils.mergeOptions(DEFAULT_OPTIONS, options);
};


//API
Serializer.prototype.serialize = function (node) {
    this.html = '';
    this._serializeChildNodes(node);

    return this.html;
};


//Internals
Serializer.prototype._serializeChildNodes = function (parentNode) {
    var childNodes = this.treeAdapter.getChildNodes(parentNode);

    if (childNodes) {
        for (var i = 0, cnLength = childNodes.length; i < cnLength; i++) {
            var currentNode = childNodes[i];

            if (this.treeAdapter.isElementNode(currentNode))
                this._serializeElement(currentNode);

            else if (this.treeAdapter.isTextNode(currentNode))
                this._serializeTextNode(currentNode);

            else if (this.treeAdapter.isCommentNode(currentNode))
                this._serializeCommentNode(currentNode);

            else if (this.treeAdapter.isDocumentTypeNode(currentNode))
                this._serializeDocumentTypeNode(currentNode);
        }
    }
};

Serializer.prototype._serializeElement = function (node) {
    var tn = this.treeAdapter.getTagName(node),
        ns = this.treeAdapter.getNamespaceURI(node),
        qualifiedTn = (ns === NS.HTML || ns === NS.SVG || ns === NS.MATHML) ? tn : (ns + ':' + tn);

    this.html += '<' + qualifiedTn;
    this._serializeAttributes(node);
    this.html += '>';

    if (tn !== $.AREA && tn !== $.BASE && tn !== $.BASEFONT && tn !== $.BGSOUND && tn !== $.BR && tn !== $.BR &&
        tn !== $.COL && tn !== $.EMBED && tn !== $.FRAME && tn !== $.HR && tn !== $.IMG && tn !== $.INPUT &&
        tn !== $.KEYGEN && tn !== $.LINK && tn !== $.MENUITEM && tn !== $.META && tn !== $.PARAM && tn !== $.SOURCE &&
        tn !== $.TRACK && tn !== $.WBR) {

        if (tn === $.PRE || tn === $.TEXTAREA || tn === $.LISTING) {
            var firstChild = this.treeAdapter.getFirstChild(node);

            if (firstChild && this.treeAdapter.isTextNode(firstChild)) {
                var content = this.treeAdapter.getTextNodeContent(firstChild);

                if (content[0] === '\n')
                    this.html += '\n';
            }
        }

        var childNodesHolder = tn === $.TEMPLATE && ns === NS.HTML ?
                               this.treeAdapter.getChildNodes(node)[0] :
                               node;

        this._serializeChildNodes(childNodesHolder);
        this.html += '</' + qualifiedTn + '>';
    }
};

Serializer.prototype._serializeAttributes = function (node) {
    var attrs = this.treeAdapter.getAttrList(node);

    for (var i = 0, attrsLength = attrs.length; i < attrsLength; i++) {
        var attr = attrs[i],
            value = this.options.encodeHtmlEntities ? escapeString(attr.value, true) : attr.value;

        this.html += ' ';

        if (!attr.namespace)
            this.html += attr.name;

        else if (attr.namespace === NS.XML)
            this.html += 'xml:' + attr.name;

        else if (attr.namespace === NS.XMLNS) {
            if (attr.name !== 'xmlns')
                this.html += 'xmlns:';

            this.html += attr.name;
        }

        else if (attr.namespace === NS.XLINK)
            this.html += 'xlink:' + attr.name;

        else
            this.html += attr.namespace + ':' + attr.name;

        this.html += '="' + value + '"';
    }
};

Serializer.prototype._serializeTextNode = function (node) {
    var content = this.treeAdapter.getTextNodeContent(node),
        parent = this.treeAdapter.getParentNode(node),
        parentTn = void 0;

    if(parent && this.treeAdapter.isElementNode(parent))
        parentTn = this.treeAdapter.getTagName(parent);

    if (parentTn === $.STYLE || parentTn === $.SCRIPT || parentTn === $.XMP || parentTn === $.IFRAME ||
        parentTn === $.NOEMBED || parentTn === $.NOFRAMES || parentTn === $.PLAINTEXT || parentTn === $.NOSCRIPT) {
        this.html += content;
    }

    else
        this.html += this.options.encodeHtmlEntities ? escapeString(content, false) : content;
};

Serializer.prototype._serializeCommentNode = function (node) {
    this.html += '<!--' + this.treeAdapter.getCommentNodeContent(node) + '-->';
};

Serializer.prototype._serializeDocumentTypeNode = function (node) {
    var name = this.treeAdapter.getDocumentTypeNodeName(node),
        publicId = this.treeAdapter.getDocumentTypeNodePublicId(node),
        systemId = this.treeAdapter.getDocumentTypeNodeSystemId(node);

    this.html += '<!DOCTYPE ' + name;

    if (publicId !== null)
        this.html += ' PUBLIC ' + enquoteDoctypeId(publicId);

    else if (systemId !== null)
        this.html += ' SYSTEM';

    if (systemId !== null)
        this.html += ' ' + enquoteDoctypeId(systemId);


    this.html += '>';
};

},{"../common/html":4,"../common/utils":6,"../tree_adapters/default":15}],10:[function(require,module,exports){
'use strict';

var Tokenizer = require('../tokenization/tokenizer'),
    TokenizerProxy = require('./tokenizer_proxy');

//Skipping handler
function skip() {
    //NOTE: do nothing =)
}

//SimpleApiParser
var SimpleApiParser = module.exports = function (handlers) {
    this.handlers = {
        doctype: handlers.doctype || skip,
        startTag: handlers.startTag || skip,
        endTag: handlers.endTag || skip,
        text: handlers.text || skip,
        comment: handlers.comment || skip
    };
};

//API
SimpleApiParser.prototype.parse = function (html) {
    var token = null;

    this._reset(html);

    do {
        token = this.tokenizerProxy.getNextToken();

        if (token.type === Tokenizer.CHARACTER_TOKEN ||
            token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN ||
            token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
            this.pendingText = (this.pendingText || '') + token.chars;
        }

        else {
            this._emitPendingText();
            this._handleToken(token);
        }
    } while (token.type !== Tokenizer.EOF_TOKEN)
};

//Internals
SimpleApiParser.prototype._handleToken = function (token) {
    if (token.type === Tokenizer.START_TAG_TOKEN)
        this.handlers.startTag(token.tagName, token.attrs, token.selfClosing);

    else if (token.type === Tokenizer.END_TAG_TOKEN)
        this.handlers.endTag(token.tagName);

    else if (token.type === Tokenizer.COMMENT_TOKEN)
        this.handlers.comment(token.data);

    else if (token.type === Tokenizer.DOCTYPE_TOKEN)
        this.handlers.doctype(token.name, token.publicId, token.systemId);

};

SimpleApiParser.prototype._reset = function (html) {
    this.tokenizerProxy = new TokenizerProxy(html);
    this.pendingText = null;
};

SimpleApiParser.prototype._emitPendingText = function () {
    if (this.pendingText !== null) {
        this.handlers.text(this.pendingText);
        this.pendingText = null;
    }
};

},{"../tokenization/tokenizer":14,"./tokenizer_proxy":11}],11:[function(require,module,exports){
'use strict';

var Tokenizer = require('../tokenization/tokenizer'),
    ForeignContent = require('../common/foreign_content'),
    UNICODE = require('../common/unicode'),
    HTML = require('../common/html');

//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES;


//Tokenizer proxy
//NOTE: this proxy simulates adjustment of the Tokenizer which performed by standard parser during tree construction.
var TokenizerProxy = module.exports = function (html) {
    this.tokenizer = new Tokenizer(html);

    this.namespaceStack = [];
    this.namespaceStackTop = -1;
    this.currentNamespace = null;
    this.inForeignContent = false;
};

//API
TokenizerProxy.prototype.getNextToken = function () {
    var token = this.tokenizer.getNextToken();

    if (token.type === Tokenizer.START_TAG_TOKEN)
        this._handleStartTagToken(token);

    else if (token.type === Tokenizer.END_TAG_TOKEN)
        this._handleEndTagToken(token);

    else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN && this.inForeignContent) {
        token.type = Tokenizer.CHARACTER_TOKEN;
        token.chars = UNICODE.REPLACEMENT_CHARACTER;
    }

    return token;
};

//Namespace stack mutations
TokenizerProxy.prototype._enterNamespace = function (namespace) {
    this.namespaceStackTop++;
    this.namespaceStack.push(namespace);

    this.inForeignContent = namespace !== NS.HTML;
    this.currentNamespace = namespace;
    this.tokenizer.allowCDATA = this.inForeignContent;
};

TokenizerProxy.prototype._leaveCurrentNamespace = function () {
    this.namespaceStackTop--;
    this.namespaceStack.pop();

    this.currentNamespace = this.namespaceStack[this.namespaceStackTop];
    this.inForeignContent = this.currentNamespace !== NS.HTML;
    this.tokenizer.allowCDATA = this.inForeignContent;
};

//Token handlers
TokenizerProxy.prototype._ensureTokenizerState = function (tn) {
    if (tn === $.TEXTAREA || tn === $.TITLE)
        this.tokenizer.state = Tokenizer.RCDATA_STATE;

    else if (tn === $.PLAINTEXT)
        this.tokenizer.state = Tokenizer.PLAINTEXT_STATE;

    else if (tn === $.SCRIPT)
        this.tokenizer.state = Tokenizer.SCRIPT_DATA_STATE;

    else if (tn === $.STYLE || tn === $.IFRAME || tn === $.XMP ||
             tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT) {
        this.tokenizer.state = Tokenizer.RAWTEXT_STATE;
    }
};

TokenizerProxy.prototype._handleStartTagToken = function (token) {
    var tn = token.tagName;

    if (tn === $.SVG)
        this._enterNamespace(NS.SVG);

    else if (tn === $.MATH)
        this._enterNamespace(NS.MATHML);

    else {
        if (this.inForeignContent) {
            if (ForeignContent.causesExit(token))
                this._leaveCurrentNamespace();

            else if (ForeignContent.isMathMLTextIntegrationPoint(tn, this.currentNamespace) ||
                     ForeignContent.isHtmlIntegrationPoint(tn, this.currentNamespace, token.attrs)) {
                this._enterNamespace(NS.HTML);
            }
        }

        else
            this._ensureTokenizerState(tn);
    }
};

TokenizerProxy.prototype._handleEndTagToken = function (token) {
    var tn = token.tagName;

    if (!this.inForeignContent) {
        var previousNs = this.namespaceStack[this.namespaceStackTop - 1];

        //NOTE: check for exit from integration point
        if (ForeignContent.isMathMLTextIntegrationPoint(tn, previousNs) ||
            ForeignContent.isHtmlIntegrationPoint(tn, previousNs, token.attrs)) {
            this._leaveCurrentNamespace();
        }

        else if (tn === $.SCRIPT)
            this.tokenizer.state = Tokenizer.DATA_STATE;
    }

    else if ((tn === $.SVG && this.currentNamespace === NS.SVG) || (tn === $.MATH && this.currentNamespace === NS.MATHML))
        this._leaveCurrentNamespace();
};

},{"../common/foreign_content":3,"../common/html":4,"../common/unicode":5,"../tokenization/tokenizer":14}],12:[function(require,module,exports){
'use strict';

//NOTE: this file contains auto generated trie structure that is used for named entity references consumption
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#tokenizing-character-references and
//http://www.whatwg.org/specs/web-apps/current-work/multipage/named-character-references.html#named-character-references)
module.exports = {
    0x41: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [193]}}, c: [193]}}}}}}}}}, 0x62: {l: {0x72: {l: {0x65: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [258]}}}}}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [194]}}, c: [194]}}}}}, 0x79: {l: {0x3B: {c: [1040]}}}}}, 0x45: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [198]}}, c: [198]}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120068]}}}}}, 0x67: {l: {0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [192]}}, c: [192]}}}}}}}}}, 0x6C: {l: {0x70: {l: {0x68: {l: {0x61: {l: {0x3B: {c: [913]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [256]}}}}}}}}}, 0x4D: {l: {0x50: {l: {0x3B: {c: [38]}}, c: [38]}}}, 0x6E: {l: {0x64: {l: {0x3B: {c: [10835]}}}}}, 0x6F: {l: {0x67: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [260]}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120120]}}}}}}}, 0x70: {l: {0x70: {l: {0x6C: {l: {0x79: {l: {0x46: {l: {0x75: {l: {0x6E: {l: {0x63: {l: {0x74: {l: {0x69: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8289]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [197]}}, c: [197]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119964]}}}}}, 0x73: {l: {0x69: {l: {0x67: {l: {0x6E: {l: {0x3B: {c: [8788]}}}}}}}}}}}, 0x74: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [195]}}, c: [195]}}}}}}}}}, 0x75: {l: {0x6D: {l: {0x6C: {l: {0x3B: {c: [196]}}, c: [196]}}}}}}},
    0x61: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [225]}}, c: [225]}}}}}}}}}, 0x62: {l: {0x72: {l: {0x65: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [259]}}}}}}}}}}}, 0x63: {l: {0x3B: {c: [8766]}, 0x64: {l: {0x3B: {c: [8767]}}}, 0x45: {l: {0x3B: {c: [8766, 819]}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [226]}}, c: [226]}}}}}, 0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [180]}}, c: [180]}}}}}, 0x79: {l: {0x3B: {c: [1072]}}}}}, 0x65: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [230]}}, c: [230]}}}}}}}, 0x66: {l: {0x3B: {c: [8289]}, 0x72: {l: {0x3B: {c: [120094]}}}}}, 0x67: {l: {0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [224]}}, c: [224]}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x66: {l: {0x73: {l: {0x79: {l: {0x6D: {l: {0x3B: {c: [8501]}}}}}}}}}, 0x70: {l: {0x68: {l: {0x3B: {c: [8501]}}}}}}}, 0x70: {l: {0x68: {l: {0x61: {l: {0x3B: {c: [945]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [257]}}}}}, 0x6C: {l: {0x67: {l: {0x3B: {c: [10815]}}}}}}}, 0x70: {l: {0x3B: {c: [38]}}, c: [38]}}}, 0x6E: {l: {0x64: {l: {0x61: {l: {0x6E: {l: {0x64: {l: {0x3B: {c: [10837]}}}}}}}, 0x3B: {c: [8743]}, 0x64: {l: {0x3B: {c: [10844]}}}, 0x73: {l: {0x6C: {l: {0x6F: {l: {0x70: {l: {0x65: {l: {0x3B: {c: [10840]}}}}}}}}}}}, 0x76: {l: {0x3B: {c: [10842]}}}}}, 0x67: {l: {0x3B: {c: [8736]}, 0x65: {l: {0x3B: {c: [10660]}}}, 0x6C: {l: {0x65: {l: {0x3B: {c: [8736]}}}}}, 0x6D: {l: {0x73: {l: {0x64: {l: {0x61: {l: {0x61: {l: {0x3B: {c: [10664]}}}, 0x62: {l: {0x3B: {c: [10665]}}}, 0x63: {l: {0x3B: {c: [10666]}}}, 0x64: {l: {0x3B: {c: [10667]}}}, 0x65: {l: {0x3B: {c: [10668]}}}, 0x66: {l: {0x3B: {c: [10669]}}}, 0x67: {l: {0x3B: {c: [10670]}}}, 0x68: {l: {0x3B: {c: [10671]}}}}}, 0x3B: {c: [8737]}}}}}}}, 0x72: {l: {0x74: {l: {0x3B: {c: [8735]}, 0x76: {l: {0x62: {l: {0x3B: {c: [8894]}, 0x64: {l: {0x3B: {c: [10653]}}}}}}}}}}}, 0x73: {l: {0x70: {l: {0x68: {l: {0x3B: {c: [8738]}}}}}, 0x74: {l: {0x3B: {c: [197]}}}}}, 0x7A: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [9084]}}}}}}}}}}}}}, 0x6F: {l: {0x67: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [261]}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120146]}}}}}}}, 0x70: {l: {0x61: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10863]}}}}}}}}}, 0x3B: {c: [8776]}, 0x45: {l: {0x3B: {c: [10864]}}}, 0x65: {l: {0x3B: {c: [8778]}}}, 0x69: {l: {0x64: {l: {0x3B: {c: [8779]}}}}}, 0x6F: {l: {0x73: {l: {0x3B: {c: [39]}}}}}, 0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [8776]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8778]}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [229]}}, c: [229]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119990]}}}}}, 0x74: {l: {0x3B: {c: [42]}}}, 0x79: {l: {0x6D: {l: {0x70: {l: {0x3B: {c: [8776]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8781]}}}}}}}}}}}}}, 0x74: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [227]}}, c: [227]}}}}}}}}}, 0x75: {l: {0x6D: {l: {0x6C: {l: {0x3B: {c: [228]}}, c: [228]}}}}}, 0x77: {l: {0x63: {l: {0x6F: {l: {0x6E: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8755]}}}}}}}}}}}}}, 0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10769]}}}}}}}}}}},
    0x62: {l: {0x61: {l: {0x63: {l: {0x6B: {l: {0x63: {l: {0x6F: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [8780]}}}}}}}}}, 0x65: {l: {0x70: {l: {0x73: {l: {0x69: {l: {0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [1014]}}}}}}}}}}}}}}}, 0x70: {l: {0x72: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x3B: {c: [8245]}}}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8765]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8909]}}}}}}}}}}}}}}}, 0x72: {l: {0x76: {l: {0x65: {l: {0x65: {l: {0x3B: {c: [8893]}}}}}}}, 0x77: {l: {0x65: {l: {0x64: {l: {0x3B: {c: [8965]}, 0x67: {l: {0x65: {l: {0x3B: {c: [8965]}}}}}}}}}}}}}}}, 0x62: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [9141]}, 0x74: {l: {0x62: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [9142]}}}}}}}}}}}}}}}, 0x63: {l: {0x6F: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [8780]}}}}}}}, 0x79: {l: {0x3B: {c: [1073]}}}}}, 0x64: {l: {0x71: {l: {0x75: {l: {0x6F: {l: {0x3B: {c: [8222]}}}}}}}}}, 0x65: {l: {0x63: {l: {0x61: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8757]}, 0x65: {l: {0x3B: {c: [8757]}}}}}}}}}}}, 0x6D: {l: {0x70: {l: {0x74: {l: {0x79: {l: {0x76: {l: {0x3B: {c: [10672]}}}}}}}}}}}, 0x70: {l: {0x73: {l: {0x69: {l: {0x3B: {c: [1014]}}}}}}}, 0x72: {l: {0x6E: {l: {0x6F: {l: {0x75: {l: {0x3B: {c: [8492]}}}}}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [946]}}}, 0x68: {l: {0x3B: {c: [8502]}}}, 0x77: {l: {0x65: {l: {0x65: {l: {0x6E: {l: {0x3B: {c: [8812]}}}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120095]}}}}}, 0x69: {l: {0x67: {l: {0x63: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [8898]}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [9711]}}}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [8899]}}}}}}}, 0x6F: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10752]}}}}}}}, 0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10753]}}}}}}}}}, 0x74: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [10754]}}}}}}}}}}}}}, 0x73: {l: {0x71: {l: {0x63: {l: {0x75: {l: {0x70: {l: {0x3B: {c: [10758]}}}}}}}}}, 0x74: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [9733]}}}}}}}}}, 0x74: {l: {0x72: {l: {0x69: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x64: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x3B: {c: [9661]}}}}}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [9651]}}}}}}}}}}}}}}}}}}}}}, 0x75: {l: {0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10756]}}}}}}}}}}}, 0x76: {l: {0x65: {l: {0x65: {l: {0x3B: {c: [8897]}}}}}}}, 0x77: {l: {0x65: {l: {0x64: {l: {0x67: {l: {0x65: {l: {0x3B: {c: [8896]}}}}}}}}}}}}}}}, 0x6B: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10509]}}}}}}}}}}}, 0x6C: {l: {0x61: {l: {0x63: {l: {0x6B: {l: {0x6C: {l: {0x6F: {l: {0x7A: {l: {0x65: {l: {0x6E: {l: {0x67: {l: {0x65: {l: {0x3B: {c: [10731]}}}}}}}}}}}}}}}, 0x73: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [9642]}}}}}}}}}}}}}, 0x74: {l: {0x72: {l: {0x69: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x3B: {c: [9652]}, 0x64: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x3B: {c: [9662]}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [9666]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [9656]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6E: {l: {0x6B: {l: {0x3B: {c: [9251]}}}}}}}, 0x6B: {l: {0x31: {l: {0x32: {l: {0x3B: {c: [9618]}}}, 0x34: {l: {0x3B: {c: [9617]}}}}}, 0x33: {l: {0x34: {l: {0x3B: {c: [9619]}}}}}}}, 0x6F: {l: {0x63: {l: {0x6B: {l: {0x3B: {c: [9608]}}}}}}}}}, 0x6E: {l: {0x65: {l: {0x3B: {c: [61, 8421]}, 0x71: {l: {0x75: {l: {0x69: {l: {0x76: {l: {0x3B: {c: [8801, 8421]}}}}}}}}}}}, 0x6F: {l: {0x74: {l: {0x3B: {c: [8976]}}}}}}}, 0x4E: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10989]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120147]}}}}}, 0x74: {l: {0x3B: {c: [8869]}, 0x74: {l: {0x6F: {l: {0x6D: {l: {0x3B: {c: [8869]}}}}}}}}}, 0x77: {l: {0x74: {l: {0x69: {l: {0x65: {l: {0x3B: {c: [8904]}}}}}}}}}, 0x78: {l: {0x62: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [10697]}}}}}}}, 0x64: {l: {0x6C: {l: {0x3B: {c: [9488]}}}, 0x4C: {l: {0x3B: {c: [9557]}}}, 0x72: {l: {0x3B: {c: [9484]}}}, 0x52: {l: {0x3B: {c: [9554]}}}}}, 0x44: {l: {0x6C: {l: {0x3B: {c: [9558]}}}, 0x4C: {l: {0x3B: {c: [9559]}}}, 0x72: {l: {0x3B: {c: [9555]}}}, 0x52: {l: {0x3B: {c: [9556]}}}}}, 0x68: {l: {0x3B: {c: [9472]}, 0x64: {l: {0x3B: {c: [9516]}}}, 0x44: {l: {0x3B: {c: [9573]}}}, 0x75: {l: {0x3B: {c: [9524]}}}, 0x55: {l: {0x3B: {c: [9576]}}}}}, 0x48: {l: {0x3B: {c: [9552]}, 0x64: {l: {0x3B: {c: [9572]}}}, 0x44: {l: {0x3B: {c: [9574]}}}, 0x75: {l: {0x3B: {c: [9575]}}}, 0x55: {l: {0x3B: {c: [9577]}}}}}, 0x6D: {l: {0x69: {l: {0x6E: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8863]}}}}}}}}}}}, 0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8862]}}}}}}}}}, 0x74: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8864]}}}}}}}}}}}, 0x75: {l: {0x6C: {l: {0x3B: {c: [9496]}}}, 0x4C: {l: {0x3B: {c: [9563]}}}, 0x72: {l: {0x3B: {c: [9492]}}}, 0x52: {l: {0x3B: {c: [9560]}}}}}, 0x55: {l: {0x6C: {l: {0x3B: {c: [9564]}}}, 0x4C: {l: {0x3B: {c: [9565]}}}, 0x72: {l: {0x3B: {c: [9561]}}}, 0x52: {l: {0x3B: {c: [9562]}}}}}, 0x76: {l: {0x3B: {c: [9474]}, 0x68: {l: {0x3B: {c: [9532]}}}, 0x48: {l: {0x3B: {c: [9578]}}}, 0x6C: {l: {0x3B: {c: [9508]}}}, 0x4C: {l: {0x3B: {c: [9569]}}}, 0x72: {l: {0x3B: {c: [9500]}}}, 0x52: {l: {0x3B: {c: [9566]}}}}}, 0x56: {l: {0x3B: {c: [9553]}, 0x68: {l: {0x3B: {c: [9579]}}}, 0x48: {l: {0x3B: {c: [9580]}}}, 0x6C: {l: {0x3B: {c: [9570]}}}, 0x4C: {l: {0x3B: {c: [9571]}}}, 0x72: {l: {0x3B: {c: [9567]}}}, 0x52: {l: {0x3B: {c: [9568]}}}}}}}}}, 0x70: {l: {0x72: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x3B: {c: [8245]}}}}}}}}}}}, 0x72: {l: {0x65: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [728]}}}}}}}, 0x76: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [166]}}, c: [166]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119991]}}}}}, 0x65: {l: {0x6D: {l: {0x69: {l: {0x3B: {c: [8271]}}}}}}}, 0x69: {l: {0x6D: {l: {0x3B: {c: [8765]}, 0x65: {l: {0x3B: {c: [8909]}}}}}}}, 0x6F: {l: {0x6C: {l: {0x62: {l: {0x3B: {c: [10693]}}}, 0x3B: {c: [92]}, 0x68: {l: {0x73: {l: {0x75: {l: {0x62: {l: {0x3B: {c: [10184]}}}}}}}}}}}}}}}, 0x75: {l: {0x6C: {l: {0x6C: {l: {0x3B: {c: [8226]}, 0x65: {l: {0x74: {l: {0x3B: {c: [8226]}}}}}}}}}, 0x6D: {l: {0x70: {l: {0x3B: {c: [8782]}, 0x45: {l: {0x3B: {c: [10926]}}}, 0x65: {l: {0x3B: {c: [8783]}, 0x71: {l: {0x3B: {c: [8783]}}}}}}}}}}}}},
    0x42: {l: {0x61: {l: {0x63: {l: {0x6B: {l: {0x73: {l: {0x6C: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8726]}}}}}}}}}}}}}}}, 0x72: {l: {0x76: {l: {0x3B: {c: [10983]}}}, 0x77: {l: {0x65: {l: {0x64: {l: {0x3B: {c: [8966]}}}}}}}}}}}, 0x63: {l: {0x79: {l: {0x3B: {c: [1041]}}}}}, 0x65: {l: {0x63: {l: {0x61: {l: {0x75: {l: {0x73: {l: {0x65: {l: {0x3B: {c: [8757]}}}}}}}}}}}, 0x72: {l: {0x6E: {l: {0x6F: {l: {0x75: {l: {0x6C: {l: {0x6C: {l: {0x69: {l: {0x73: {l: {0x3B: {c: [8492]}}}}}}}}}}}}}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [914]}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120069]}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120121]}}}}}}}, 0x72: {l: {0x65: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [728]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8492]}}}}}}}, 0x75: {l: {0x6D: {l: {0x70: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [8782]}}}}}}}}}}}}},
    0x43: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [262]}}}}}}}}}, 0x70: {l: {0x3B: {c: [8914]}, 0x69: {l: {0x74: {l: {0x61: {l: {0x6C: {l: {0x44: {l: {0x69: {l: {0x66: {l: {0x66: {l: {0x65: {l: {0x72: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x69: {l: {0x61: {l: {0x6C: {l: {0x44: {l: {0x3B: {c: [8517]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x79: {l: {0x6C: {l: {0x65: {l: {0x79: {l: {0x73: {l: {0x3B: {c: [8493]}}}}}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [268]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [199]}}, c: [199]}}}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [264]}}}}}}}, 0x6F: {l: {0x6E: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8752]}}}}}}}}}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [266]}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x6C: {l: {0x61: {l: {0x3B: {c: [184]}}}}}}}}}}}, 0x6E: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [183]}}}}}}}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [8493]}}}}}, 0x48: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1063]}}}}}}}, 0x68: {l: {0x69: {l: {0x3B: {c: [935]}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x6C: {l: {0x65: {l: {0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8857]}}}}}}}, 0x4D: {l: {0x69: {l: {0x6E: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8854]}}}}}}}}}}}, 0x50: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8853]}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8855]}}}}}}}}}}}}}}}}}}}}}, 0x6C: {l: {0x6F: {l: {0x63: {l: {0x6B: {l: {0x77: {l: {0x69: {l: {0x73: {l: {0x65: {l: {0x43: {l: {0x6F: {l: {0x6E: {l: {0x74: {l: {0x6F: {l: {0x75: {l: {0x72: {l: {0x49: {l: {0x6E: {l: {0x74: {l: {0x65: {l: {0x67: {l: {0x72: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8754]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x65: {l: {0x43: {l: {0x75: {l: {0x72: {l: {0x6C: {l: {0x79: {l: {0x44: {l: {0x6F: {l: {0x75: {l: {0x62: {l: {0x6C: {l: {0x65: {l: {0x51: {l: {0x75: {l: {0x6F: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [8221]}}}}}}}}}}}}}}}}}}}}}}}, 0x51: {l: {0x75: {l: {0x6F: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [8217]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8759]}, 0x65: {l: {0x3B: {c: [10868]}}}}}}}}}, 0x6E: {l: {0x67: {l: {0x72: {l: {0x75: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8801]}}}}}}}}}}}}}, 0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8751]}}}}}}}, 0x74: {l: {0x6F: {l: {0x75: {l: {0x72: {l: {0x49: {l: {0x6E: {l: {0x74: {l: {0x65: {l: {0x67: {l: {0x72: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8750]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [8450]}}}, 0x72: {l: {0x6F: {l: {0x64: {l: {0x75: {l: {0x63: {l: {0x74: {l: {0x3B: {c: [8720]}}}}}}}}}}}}}}}, 0x75: {l: {0x6E: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x43: {l: {0x6C: {l: {0x6F: {l: {0x63: {l: {0x6B: {l: {0x77: {l: {0x69: {l: {0x73: {l: {0x65: {l: {0x43: {l: {0x6F: {l: {0x6E: {l: {0x74: {l: {0x6F: {l: {0x75: {l: {0x72: {l: {0x49: {l: {0x6E: {l: {0x74: {l: {0x65: {l: {0x67: {l: {0x72: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8755]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x4F: {l: {0x50: {l: {0x59: {l: {0x3B: {c: [169]}}, c: [169]}}}}}, 0x72: {l: {0x6F: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [10799]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119966]}}}}}}}, 0x75: {l: {0x70: {l: {0x43: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [8781]}}}}}}}, 0x3B: {c: [8915]}}}}}}},
    0x63: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [263]}}}}}}}}}, 0x70: {l: {0x61: {l: {0x6E: {l: {0x64: {l: {0x3B: {c: [10820]}}}}}}}, 0x62: {l: {0x72: {l: {0x63: {l: {0x75: {l: {0x70: {l: {0x3B: {c: [10825]}}}}}}}}}}}, 0x63: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10827]}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [10823]}}}}}}}, 0x3B: {c: [8745]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10816]}}}}}}}, 0x73: {l: {0x3B: {c: [8745, 65024]}}}}}, 0x72: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8257]}}}}}, 0x6F: {l: {0x6E: {l: {0x3B: {c: [711]}}}}}}}}}, 0x63: {l: {0x61: {l: {0x70: {l: {0x73: {l: {0x3B: {c: [10829]}}}}}, 0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [269]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [231]}}, c: [231]}}}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [265]}}}}}}}, 0x75: {l: {0x70: {l: {0x73: {l: {0x3B: {c: [10828]}, 0x73: {l: {0x6D: {l: {0x3B: {c: [10832]}}}}}}}}}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [267]}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [184]}}, c: [184]}}}}}, 0x6D: {l: {0x70: {l: {0x74: {l: {0x79: {l: {0x76: {l: {0x3B: {c: [10674]}}}}}}}}}}}, 0x6E: {l: {0x74: {l: {0x3B: {c: [162]}, 0x65: {l: {0x72: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [183]}}}}}}}}}}}}, c: [162]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120096]}}}}}, 0x68: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1095]}}}}}, 0x65: {l: {0x63: {l: {0x6B: {l: {0x3B: {c: [10003]}, 0x6D: {l: {0x61: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [10003]}}}}}}}}}}}}}}}, 0x69: {l: {0x3B: {c: [967]}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [710]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8791]}}}}}, 0x6C: {l: {0x65: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [8634]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [8635]}}}}}}}}}}}}}}}}}}}}}, 0x64: {l: {0x61: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [8859]}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [8858]}}}}}}}}}, 0x64: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8861]}}}}}}}}}, 0x52: {l: {0x3B: {c: [174]}}}, 0x53: {l: {0x3B: {c: [9416]}}}}}}}}}}}, 0x3B: {c: [9675]}, 0x45: {l: {0x3B: {c: [10691]}}}, 0x65: {l: {0x3B: {c: [8791]}}}, 0x66: {l: {0x6E: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10768]}}}}}}}}}}}, 0x6D: {l: {0x69: {l: {0x64: {l: {0x3B: {c: [10991]}}}}}}}, 0x73: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10690]}}}}}}}}}}}}}, 0x6C: {l: {0x75: {l: {0x62: {l: {0x73: {l: {0x3B: {c: [9827]}, 0x75: {l: {0x69: {l: {0x74: {l: {0x3B: {c: [9827]}}}}}}}}}}}}}}}, 0x6F: {l: {0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [58]}, 0x65: {l: {0x3B: {c: [8788]}, 0x71: {l: {0x3B: {c: [8788]}}}}}}}}}}}, 0x6D: {l: {0x6D: {l: {0x61: {l: {0x3B: {c: [44]}, 0x74: {l: {0x3B: {c: [64]}}}}}}}, 0x70: {l: {0x3B: {c: [8705]}, 0x66: {l: {0x6E: {l: {0x3B: {c: [8728]}}}}}, 0x6C: {l: {0x65: {l: {0x6D: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8705]}}}}}}}}}, 0x78: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8450]}}}}}}}}}}}}}}}, 0x6E: {l: {0x67: {l: {0x3B: {c: [8773]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10861]}}}}}}}}}, 0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8750]}}}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120148]}}}, 0x72: {l: {0x6F: {l: {0x64: {l: {0x3B: {c: [8720]}}}}}}}, 0x79: {l: {0x3B: {c: [169]}, 0x73: {l: {0x72: {l: {0x3B: {c: [8471]}}}}}}, c: [169]}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8629]}}}}}}}, 0x6F: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [10007]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119992]}}}}}, 0x75: {l: {0x62: {l: {0x3B: {c: [10959]}, 0x65: {l: {0x3B: {c: [10961]}}}}}, 0x70: {l: {0x3B: {c: [10960]}, 0x65: {l: {0x3B: {c: [10962]}}}}}}}}}, 0x74: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8943]}}}}}}}}}, 0x75: {l: {0x64: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6C: {l: {0x3B: {c: [10552]}}}, 0x72: {l: {0x3B: {c: [10549]}}}}}}}}}}}, 0x65: {l: {0x70: {l: {0x72: {l: {0x3B: {c: [8926]}}}}}, 0x73: {l: {0x63: {l: {0x3B: {c: [8927]}}}}}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8630]}, 0x70: {l: {0x3B: {c: [10557]}}}}}}}}}}}, 0x70: {l: {0x62: {l: {0x72: {l: {0x63: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10824]}}}}}}}}}}}, 0x63: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10822]}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [10826]}}}}}}}, 0x3B: {c: [8746]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8845]}}}}}}}, 0x6F: {l: {0x72: {l: {0x3B: {c: [10821]}}}}}, 0x73: {l: {0x3B: {c: [8746, 65024]}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8631]}, 0x6D: {l: {0x3B: {c: [10556]}}}}}}}}}, 0x6C: {l: {0x79: {l: {0x65: {l: {0x71: {l: {0x70: {l: {0x72: {l: {0x65: {l: {0x63: {l: {0x3B: {c: [8926]}}}}}}}}}, 0x73: {l: {0x75: {l: {0x63: {l: {0x63: {l: {0x3B: {c: [8927]}}}}}}}}}}}}}, 0x76: {l: {0x65: {l: {0x65: {l: {0x3B: {c: [8910]}}}}}}}, 0x77: {l: {0x65: {l: {0x64: {l: {0x67: {l: {0x65: {l: {0x3B: {c: [8911]}}}}}}}}}}}}}}}, 0x72: {l: {0x65: {l: {0x6E: {l: {0x3B: {c: [164]}}, c: [164]}}}}}, 0x76: {l: {0x65: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [8630]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [8631]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x76: {l: {0x65: {l: {0x65: {l: {0x3B: {c: [8910]}}}}}}}, 0x77: {l: {0x65: {l: {0x64: {l: {0x3B: {c: [8911]}}}}}}}}}, 0x77: {l: {0x63: {l: {0x6F: {l: {0x6E: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8754]}}}}}}}}}}}}}, 0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8753]}}}}}}}}}, 0x79: {l: {0x6C: {l: {0x63: {l: {0x74: {l: {0x79: {l: {0x3B: {c: [9005]}}}}}}}}}}}}},
    0x64: {l: {0x61: {l: {0x67: {l: {0x67: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8224]}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x74: {l: {0x68: {l: {0x3B: {c: [8504]}}}}}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8595]}}}}}, 0x73: {l: {0x68: {l: {0x3B: {c: [8208]}, 0x76: {l: {0x3B: {c: [8867]}}}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8659]}}}}}}}, 0x62: {l: {0x6B: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10511]}}}}}}}}}}}, 0x6C: {l: {0x61: {l: {0x63: {l: {0x3B: {c: [733]}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [271]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1076]}}}}}, 0x64: {l: {0x61: {l: {0x67: {l: {0x67: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8225]}}}}}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8650]}}}}}}}, 0x3B: {c: [8518]}, 0x6F: {l: {0x74: {l: {0x73: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [10871]}}}}}}}}}}}}}, 0x65: {l: {0x67: {l: {0x3B: {c: [176]}}, c: [176]}, 0x6C: {l: {0x74: {l: {0x61: {l: {0x3B: {c: [948]}}}}}}}, 0x6D: {l: {0x70: {l: {0x74: {l: {0x79: {l: {0x76: {l: {0x3B: {c: [10673]}}}}}}}}}}}}}, 0x66: {l: {0x69: {l: {0x73: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [10623]}}}}}}}}}, 0x72: {l: {0x3B: {c: [120097]}}}}}, 0x48: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10597]}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x6C: {l: {0x3B: {c: [8643]}}}, 0x72: {l: {0x3B: {c: [8642]}}}}}}}}}, 0x69: {l: {0x61: {l: {0x6D: {l: {0x3B: {c: [8900]}, 0x6F: {l: {0x6E: {l: {0x64: {l: {0x3B: {c: [8900]}, 0x73: {l: {0x75: {l: {0x69: {l: {0x74: {l: {0x3B: {c: [9830]}}}}}}}}}}}}}}}, 0x73: {l: {0x3B: {c: [9830]}}}}}}}, 0x65: {l: {0x3B: {c: [168]}}}, 0x67: {l: {0x61: {l: {0x6D: {l: {0x6D: {l: {0x61: {l: {0x3B: {c: [989]}}}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6E: {l: {0x3B: {c: [8946]}}}}}}}, 0x76: {l: {0x3B: {c: [247]}, 0x69: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [247]}, 0x6F: {l: {0x6E: {l: {0x74: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8903]}}}}}}}}}}}}}}}}, c: [247]}}}}}, 0x6F: {l: {0x6E: {l: {0x78: {l: {0x3B: {c: [8903]}}}}}}}}}}}, 0x6A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1106]}}}}}}}, 0x6C: {l: {0x63: {l: {0x6F: {l: {0x72: {l: {0x6E: {l: {0x3B: {c: [8990]}}}}}}}, 0x72: {l: {0x6F: {l: {0x70: {l: {0x3B: {c: [8973]}}}}}}}}}}}, 0x6F: {l: {0x6C: {l: {0x6C: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [36]}}}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120149]}}}}}, 0x74: {l: {0x3B: {c: [729]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8784]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8785]}}}}}}}}}}}, 0x6D: {l: {0x69: {l: {0x6E: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8760]}}}}}}}}}}}, 0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8724]}}}}}}}}}, 0x73: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [8865]}}}}}}}}}}}}}}}, 0x75: {l: {0x62: {l: {0x6C: {l: {0x65: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x77: {l: {0x65: {l: {0x64: {l: {0x67: {l: {0x65: {l: {0x3B: {c: [8966]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x77: {l: {0x6E: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8595]}}}}}}}}}}}, 0x64: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x73: {l: {0x3B: {c: [8650]}}}}}}}}}}}}}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x70: {l: {0x6F: {l: {0x6F: {l: {0x6E: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [8643]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [8642]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x62: {l: {0x6B: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10512]}}}}}}}}}}}}}, 0x63: {l: {0x6F: {l: {0x72: {l: {0x6E: {l: {0x3B: {c: [8991]}}}}}}}, 0x72: {l: {0x6F: {l: {0x70: {l: {0x3B: {c: [8972]}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119993]}}}, 0x79: {l: {0x3B: {c: [1109]}}}}}, 0x6F: {l: {0x6C: {l: {0x3B: {c: [10742]}}}}}, 0x74: {l: {0x72: {l: {0x6F: {l: {0x6B: {l: {0x3B: {c: [273]}}}}}}}}}}}, 0x74: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8945]}}}}}}}, 0x72: {l: {0x69: {l: {0x3B: {c: [9663]}, 0x66: {l: {0x3B: {c: [9662]}}}}}}}}}, 0x75: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8693]}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10607]}}}}}}}}}, 0x77: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x3B: {c: [10662]}}}}}}}}}}}}}, 0x7A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1119]}}}}}, 0x69: {l: {0x67: {l: {0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10239]}}}}}}}}}}}}}}}}},
    0x44: {l: {0x61: {l: {0x67: {l: {0x67: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8225]}}}}}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8609]}}}}}, 0x73: {l: {0x68: {l: {0x76: {l: {0x3B: {c: [10980]}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [270]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1044]}}}}}, 0x44: {l: {0x3B: {c: [8517]}, 0x6F: {l: {0x74: {l: {0x72: {l: {0x61: {l: {0x68: {l: {0x64: {l: {0x3B: {c: [10513]}}}}}}}}}}}}}}}, 0x65: {l: {0x6C: {l: {0x3B: {c: [8711]}, 0x74: {l: {0x61: {l: {0x3B: {c: [916]}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120071]}}}}}, 0x69: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x69: {l: {0x74: {l: {0x69: {l: {0x63: {l: {0x61: {l: {0x6C: {l: {0x41: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [180]}}}}}}}}}}}, 0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [729]}}}, 0x75: {l: {0x62: {l: {0x6C: {l: {0x65: {l: {0x41: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [733]}}}}}}}}}}}}}}}}}}}}}}}, 0x47: {l: {0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [96]}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [732]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6D: {l: {0x6F: {l: {0x6E: {l: {0x64: {l: {0x3B: {c: [8900]}}}}}}}}}}}, 0x66: {l: {0x66: {l: {0x65: {l: {0x72: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x69: {l: {0x61: {l: {0x6C: {l: {0x44: {l: {0x3B: {c: [8518]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x4A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1026]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120123]}}}}}, 0x74: {l: {0x3B: {c: [168]}, 0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8412]}}}}}}}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8784]}}}}}}}}}}}}}, 0x75: {l: {0x62: {l: {0x6C: {l: {0x65: {l: {0x43: {l: {0x6F: {l: {0x6E: {l: {0x74: {l: {0x6F: {l: {0x75: {l: {0x72: {l: {0x49: {l: {0x6E: {l: {0x74: {l: {0x65: {l: {0x67: {l: {0x72: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8751]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [168]}}}, 0x77: {l: {0x6E: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8659]}}}}}}}}}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8656]}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8660]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x65: {l: {0x65: {l: {0x3B: {c: [10980]}}}}}}}}}}}}}, 0x6F: {l: {0x6E: {l: {0x67: {l: {0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10232]}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10234]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10233]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8658]}}}}}}}}}}}, 0x54: {l: {0x65: {l: {0x65: {l: {0x3B: {c: [8872]}}}}}}}}}}}}}}}}}, 0x55: {l: {0x70: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8657]}}}}}}}}}}}, 0x44: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8661]}}}}}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x72: {l: {0x74: {l: {0x69: {l: {0x63: {l: {0x61: {l: {0x6C: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8741]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x77: {l: {0x6E: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10515]}}}}}}}, 0x3B: {c: [8595]}, 0x55: {l: {0x70: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8693]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8659]}}}}}}}}}}}, 0x42: {l: {0x72: {l: {0x65: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [785]}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10576]}}}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x65: {l: {0x65: {l: {0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10590]}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10582]}}}}}}}, 0x3B: {c: [8637]}}}}}}}}}}}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x54: {l: {0x65: {l: {0x65: {l: {0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10591]}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10583]}}}}}}}, 0x3B: {c: [8641]}}}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x65: {l: {0x65: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8615]}}}}}}}}}}}, 0x3B: {c: [8868]}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119967]}}}}}, 0x74: {l: {0x72: {l: {0x6F: {l: {0x6B: {l: {0x3B: {c: [272]}}}}}}}}}}}, 0x53: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1029]}}}}}}}, 0x5A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1039]}}}}}}}}},
    0x45: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [201]}}, c: [201]}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [282]}}}}}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [202]}}, c: [202]}}}}}, 0x79: {l: {0x3B: {c: [1069]}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [278]}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120072]}}}}}, 0x67: {l: {0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [200]}}, c: [200]}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x6D: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8712]}}}}}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [274]}}}}}}}, 0x70: {l: {0x74: {l: {0x79: {l: {0x53: {l: {0x6D: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x53: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [9723]}}}}}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x72: {l: {0x79: {l: {0x53: {l: {0x6D: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x53: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [9643]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x4E: {l: {0x47: {l: {0x3B: {c: [330]}}}}}, 0x6F: {l: {0x67: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [280]}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120124]}}}}}}}, 0x70: {l: {0x73: {l: {0x69: {l: {0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [917]}}}}}}}}}}}}}, 0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [10869]}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8770]}}}}}}}}}}}}}}}, 0x69: {l: {0x6C: {l: {0x69: {l: {0x62: {l: {0x72: {l: {0x69: {l: {0x75: {l: {0x6D: {l: {0x3B: {c: [8652]}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8496]}}}}}, 0x69: {l: {0x6D: {l: {0x3B: {c: [10867]}}}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [919]}}}}}, 0x54: {l: {0x48: {l: {0x3B: {c: [208]}}, c: [208]}}}, 0x75: {l: {0x6D: {l: {0x6C: {l: {0x3B: {c: [203]}}, c: [203]}}}}}, 0x78: {l: {0x69: {l: {0x73: {l: {0x74: {l: {0x73: {l: {0x3B: {c: [8707]}}}}}}}}}, 0x70: {l: {0x6F: {l: {0x6E: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x69: {l: {0x61: {l: {0x6C: {l: {0x45: {l: {0x3B: {c: [8519]}}}}}}}}}}}}}}}}}}}}}}}}},
    0x65: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [233]}}, c: [233]}}}}}}}, 0x73: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [10862]}}}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [283]}}}}}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [234]}}, c: [234]}, 0x3B: {c: [8790]}}}}}, 0x6F: {l: {0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8789]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1101]}}}}}, 0x44: {l: {0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10871]}}}}}}}, 0x6F: {l: {0x74: {l: {0x3B: {c: [8785]}}}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [279]}}}}}}}, 0x65: {l: {0x3B: {c: [8519]}}}, 0x66: {l: {0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8786]}}}}}}}, 0x72: {l: {0x3B: {c: [120098]}}}}}, 0x67: {l: {0x3B: {c: [10906]}, 0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [232]}}, c: [232]}}}}}}}, 0x73: {l: {0x3B: {c: [10902]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10904]}}}}}}}}}}}, 0x6C: {l: {0x3B: {c: [10905]}, 0x69: {l: {0x6E: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x73: {l: {0x3B: {c: [9191]}}}}}}}}}}}}}, 0x6C: {l: {0x3B: {c: [8467]}}}, 0x73: {l: {0x3B: {c: [10901]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10903]}}}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [275]}}}}}}}, 0x70: {l: {0x74: {l: {0x79: {l: {0x3B: {c: [8709]}, 0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8709]}}}}}}}, 0x76: {l: {0x3B: {c: [8709]}}}}}}}}}, 0x73: {l: {0x70: {l: {0x31: {l: {0x33: {l: {0x3B: {c: [8196]}}}, 0x34: {l: {0x3B: {c: [8197]}}}}}, 0x3B: {c: [8195]}}}}}}}, 0x6E: {l: {0x67: {l: {0x3B: {c: [331]}}}, 0x73: {l: {0x70: {l: {0x3B: {c: [8194]}}}}}}}, 0x6F: {l: {0x67: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [281]}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120150]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8917]}, 0x73: {l: {0x6C: {l: {0x3B: {c: [10723]}}}}}}}}}, 0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10865]}}}}}}}, 0x73: {l: {0x69: {l: {0x3B: {c: [949]}, 0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [949]}}}}}}}, 0x76: {l: {0x3B: {c: [1013]}}}}}}}}}, 0x71: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [8790]}}}}}}}, 0x6F: {l: {0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8789]}}}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8770]}}}}}, 0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x67: {l: {0x74: {l: {0x72: {l: {0x3B: {c: [10902]}}}}}}}, 0x6C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [10901]}}}}}}}}}}}}}}}}}}}, 0x75: {l: {0x61: {l: {0x6C: {l: {0x73: {l: {0x3B: {c: [61]}}}}}}}, 0x65: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [8799]}}}}}}}, 0x69: {l: {0x76: {l: {0x3B: {c: [8801]}, 0x44: {l: {0x44: {l: {0x3B: {c: [10872]}}}}}}}}}}}, 0x76: {l: {0x70: {l: {0x61: {l: {0x72: {l: {0x73: {l: {0x6C: {l: {0x3B: {c: [10725]}}}}}}}}}}}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10609]}}}}}}}, 0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8787]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8495]}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8784]}}}}}}}, 0x69: {l: {0x6D: {l: {0x3B: {c: [8770]}}}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [951]}}}, 0x68: {l: {0x3B: {c: [240]}}, c: [240]}}}, 0x75: {l: {0x6D: {l: {0x6C: {l: {0x3B: {c: [235]}}, c: [235]}}}, 0x72: {l: {0x6F: {l: {0x3B: {c: [8364]}}}}}}}, 0x78: {l: {0x63: {l: {0x6C: {l: {0x3B: {c: [33]}}}}}, 0x69: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [8707]}}}}}}}, 0x70: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x61: {l: {0x74: {l: {0x69: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8496]}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x6E: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x69: {l: {0x61: {l: {0x6C: {l: {0x65: {l: {0x3B: {c: [8519]}}}}}}}}}}}}}}}}}}}}}}}}},
    0x66: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x69: {l: {0x6E: {l: {0x67: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x73: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [8786]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x63: {l: {0x79: {l: {0x3B: {c: [1092]}}}}}, 0x65: {l: {0x6D: {l: {0x61: {l: {0x6C: {l: {0x65: {l: {0x3B: {c: [9792]}}}}}}}}}}}, 0x66: {l: {0x69: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [64259]}}}}}}}}}, 0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [64256]}}}}}, 0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [64260]}}}}}}}}}, 0x72: {l: {0x3B: {c: [120099]}}}}}, 0x69: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [64257]}}}}}}}}}, 0x6A: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [102, 106]}}}}}}}}}, 0x6C: {l: {0x61: {l: {0x74: {l: {0x3B: {c: [9837]}}}}}, 0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [64258]}}}}}}}, 0x74: {l: {0x6E: {l: {0x73: {l: {0x3B: {c: [9649]}}}}}}}}}, 0x6E: {l: {0x6F: {l: {0x66: {l: {0x3B: {c: [402]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120151]}}}}}, 0x72: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x3B: {c: [8704]}}}}}}}, 0x6B: {l: {0x3B: {c: [8916]}, 0x76: {l: {0x3B: {c: [10969]}}}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x74: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10765]}}}}}}}}}}}}}}}, 0x72: {l: {0x61: {l: {0x63: {l: {0x31: {l: {0x32: {l: {0x3B: {c: [189]}}, c: [189]}, 0x33: {l: {0x3B: {c: [8531]}}}, 0x34: {l: {0x3B: {c: [188]}}, c: [188]}, 0x35: {l: {0x3B: {c: [8533]}}}, 0x36: {l: {0x3B: {c: [8537]}}}, 0x38: {l: {0x3B: {c: [8539]}}}}}, 0x32: {l: {0x33: {l: {0x3B: {c: [8532]}}}, 0x35: {l: {0x3B: {c: [8534]}}}}}, 0x33: {l: {0x34: {l: {0x3B: {c: [190]}}, c: [190]}, 0x35: {l: {0x3B: {c: [8535]}}}, 0x38: {l: {0x3B: {c: [8540]}}}}}, 0x34: {l: {0x35: {l: {0x3B: {c: [8536]}}}}}, 0x35: {l: {0x36: {l: {0x3B: {c: [8538]}}}, 0x38: {l: {0x3B: {c: [8541]}}}}}, 0x37: {l: {0x38: {l: {0x3B: {c: [8542]}}}}}}}, 0x73: {l: {0x6C: {l: {0x3B: {c: [8260]}}}}}}}, 0x6F: {l: {0x77: {l: {0x6E: {l: {0x3B: {c: [8994]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119995]}}}}}}}}},
    0x46: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1060]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120073]}}}}}, 0x69: {l: {0x6C: {l: {0x6C: {l: {0x65: {l: {0x64: {l: {0x53: {l: {0x6D: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x53: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [9724]}}}}}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x72: {l: {0x79: {l: {0x53: {l: {0x6D: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x53: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [9642]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120125]}}}}}, 0x72: {l: {0x41: {l: {0x6C: {l: {0x6C: {l: {0x3B: {c: [8704]}}}}}}}}}, 0x75: {l: {0x72: {l: {0x69: {l: {0x65: {l: {0x72: {l: {0x74: {l: {0x72: {l: {0x66: {l: {0x3B: {c: [8497]}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8497]}}}}}}}}},
    0x67: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [501]}}}}}}}}}, 0x6D: {l: {0x6D: {l: {0x61: {l: {0x3B: {c: [947]}, 0x64: {l: {0x3B: {c: [989]}}}}}}}}}, 0x70: {l: {0x3B: {c: [10886]}}}}}, 0x62: {l: {0x72: {l: {0x65: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [287]}}}}}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [285]}}}}}}}, 0x79: {l: {0x3B: {c: [1075]}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [289]}}}}}}}, 0x65: {l: {0x3B: {c: [8805]}, 0x6C: {l: {0x3B: {c: [8923]}}}, 0x71: {l: {0x3B: {c: [8805]}, 0x71: {l: {0x3B: {c: [8807]}}}, 0x73: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10878]}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x63: {l: {0x3B: {c: [10921]}}}}}, 0x3B: {c: [10878]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10880]}, 0x6F: {l: {0x3B: {c: [10882]}, 0x6C: {l: {0x3B: {c: [10884]}}}}}}}}}}}, 0x6C: {l: {0x3B: {c: [8923, 65024]}, 0x65: {l: {0x73: {l: {0x3B: {c: [10900]}}}}}}}}}}}, 0x45: {l: {0x3B: {c: [8807]}, 0x6C: {l: {0x3B: {c: [10892]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120100]}}}}}, 0x67: {l: {0x3B: {c: [8811]}, 0x67: {l: {0x3B: {c: [8921]}}}}}, 0x69: {l: {0x6D: {l: {0x65: {l: {0x6C: {l: {0x3B: {c: [8503]}}}}}}}}}, 0x6A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1107]}}}}}}}, 0x6C: {l: {0x61: {l: {0x3B: {c: [10917]}}}, 0x3B: {c: [8823]}, 0x45: {l: {0x3B: {c: [10898]}}}, 0x6A: {l: {0x3B: {c: [10916]}}}}}, 0x6E: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10890]}, 0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [10890]}}}}}}}}}}}}}, 0x65: {l: {0x3B: {c: [10888]}, 0x71: {l: {0x3B: {c: [10888]}, 0x71: {l: {0x3B: {c: [8809]}}}}}}}, 0x45: {l: {0x3B: {c: [8809]}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8935]}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120152]}}}}}}}, 0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [96]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8458]}}}}}, 0x69: {l: {0x6D: {l: {0x3B: {c: [8819]}, 0x65: {l: {0x3B: {c: [10894]}}}, 0x6C: {l: {0x3B: {c: [10896]}}}}}}}}}, 0x74: {l: {0x63: {l: {0x63: {l: {0x3B: {c: [10919]}}}, 0x69: {l: {0x72: {l: {0x3B: {c: [10874]}}}}}}}, 0x3B: {c: [62]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8919]}}}}}}}, 0x6C: {l: {0x50: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10645]}}}}}}}}}, 0x71: {l: {0x75: {l: {0x65: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [10876]}}}}}}}}}}}, 0x72: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [10886]}}}}}}}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [10616]}}}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8919]}}}}}}}, 0x65: {l: {0x71: {l: {0x6C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [8923]}}}}}}}}}, 0x71: {l: {0x6C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [10892]}}}}}}}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [8823]}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8819]}}}}}}}}}}, c: [62]}, 0x76: {l: {0x65: {l: {0x72: {l: {0x74: {l: {0x6E: {l: {0x65: {l: {0x71: {l: {0x71: {l: {0x3B: {c: [8809, 65024]}}}}}}}}}}}}}}}, 0x6E: {l: {0x45: {l: {0x3B: {c: [8809, 65024]}}}}}}}}},
    0x47: {l: {0x61: {l: {0x6D: {l: {0x6D: {l: {0x61: {l: {0x3B: {c: [915]}, 0x64: {l: {0x3B: {c: [988]}}}}}}}}}}}, 0x62: {l: {0x72: {l: {0x65: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [286]}}}}}}}}}}}, 0x63: {l: {0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [290]}}}}}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [284]}}}}}}}, 0x79: {l: {0x3B: {c: [1043]}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [288]}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120074]}}}}}, 0x67: {l: {0x3B: {c: [8921]}}}, 0x4A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1027]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120126]}}}}}}}, 0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8805]}, 0x4C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [8923]}}}}}}}}}}}}}}}}}}}, 0x46: {l: {0x75: {l: {0x6C: {l: {0x6C: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8807]}}}}}}}}}}}}}}}}}}}, 0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [10914]}}}}}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [8823]}}}}}}}}}, 0x53: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [10878]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8819]}}}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119970]}}}}}}}, 0x54: {l: {0x3B: {c: [62]}}, c: [62]}, 0x74: {l: {0x3B: {c: [8811]}}}}},
    0x48: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x6B: {l: {0x3B: {c: [711]}}}}}}}, 0x74: {l: {0x3B: {c: [94]}}}}}, 0x41: {l: {0x52: {l: {0x44: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1066]}}}}}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [292]}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [8460]}}}}}, 0x69: {l: {0x6C: {l: {0x62: {l: {0x65: {l: {0x72: {l: {0x74: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8459]}}}}}}}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [8461]}}}}}, 0x72: {l: {0x69: {l: {0x7A: {l: {0x6F: {l: {0x6E: {l: {0x74: {l: {0x61: {l: {0x6C: {l: {0x4C: {l: {0x69: {l: {0x6E: {l: {0x65: {l: {0x3B: {c: [9472]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8459]}}}}}, 0x74: {l: {0x72: {l: {0x6F: {l: {0x6B: {l: {0x3B: {c: [294]}}}}}}}}}}}, 0x75: {l: {0x6D: {l: {0x70: {l: {0x44: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x48: {l: {0x75: {l: {0x6D: {l: {0x70: {l: {0x3B: {c: [8782]}}}}}}}}}}}}}}}}}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8783]}}}}}}}}}}}}}}}}}}},
    0x68: {l: {0x61: {l: {0x69: {l: {0x72: {l: {0x73: {l: {0x70: {l: {0x3B: {c: [8202]}}}}}}}}}, 0x6C: {l: {0x66: {l: {0x3B: {c: [189]}}}}}, 0x6D: {l: {0x69: {l: {0x6C: {l: {0x74: {l: {0x3B: {c: [8459]}}}}}}}}}, 0x72: {l: {0x64: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1098]}}}}}}}, 0x72: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10568]}}}}}}}, 0x3B: {c: [8596]}, 0x77: {l: {0x3B: {c: [8621]}}}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8660]}}}}}}}, 0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8463]}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [293]}}}}}}}}}, 0x65: {l: {0x61: {l: {0x72: {l: {0x74: {l: {0x73: {l: {0x3B: {c: [9829]}, 0x75: {l: {0x69: {l: {0x74: {l: {0x3B: {c: [9829]}}}}}}}}}}}}}}}, 0x6C: {l: {0x6C: {l: {0x69: {l: {0x70: {l: {0x3B: {c: [8230]}}}}}}}}}, 0x72: {l: {0x63: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8889]}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120101]}}}}}, 0x6B: {l: {0x73: {l: {0x65: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10533]}}}}}}}}}}}, 0x77: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10534]}}}}}}}}}}}}}}}, 0x6F: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8703]}}}}}}}, 0x6D: {l: {0x74: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [8763]}}}}}}}}}, 0x6F: {l: {0x6B: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8617]}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8618]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120153]}}}}}, 0x72: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8213]}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119997]}}}}}, 0x6C: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8463]}}}}}}}}}, 0x74: {l: {0x72: {l: {0x6F: {l: {0x6B: {l: {0x3B: {c: [295]}}}}}}}}}}}, 0x79: {l: {0x62: {l: {0x75: {l: {0x6C: {l: {0x6C: {l: {0x3B: {c: [8259]}}}}}}}}}, 0x70: {l: {0x68: {l: {0x65: {l: {0x6E: {l: {0x3B: {c: [8208]}}}}}}}}}}}}},
    0x49: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [205]}}, c: [205]}}}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [206]}}, c: [206]}}}}}, 0x79: {l: {0x3B: {c: [1048]}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [304]}}}}}}}, 0x45: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1045]}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [8465]}}}}}, 0x67: {l: {0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [204]}}, c: [204]}}}}}}}}}, 0x4A: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [306]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [298]}}}}}, 0x67: {l: {0x69: {l: {0x6E: {l: {0x61: {l: {0x72: {l: {0x79: {l: {0x49: {l: {0x3B: {c: [8520]}}}}}}}}}}}}}}}}}, 0x3B: {c: [8465]}, 0x70: {l: {0x6C: {l: {0x69: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8658]}}}}}}}}}}}}}, 0x6E: {l: {0x74: {l: {0x3B: {c: [8748]}, 0x65: {l: {0x67: {l: {0x72: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8747]}}}}}}}}}, 0x72: {l: {0x73: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x69: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8898]}}}}}}}}}}}}}}}}}}}}}, 0x76: {l: {0x69: {l: {0x73: {l: {0x69: {l: {0x62: {l: {0x6C: {l: {0x65: {l: {0x43: {l: {0x6F: {l: {0x6D: {l: {0x6D: {l: {0x61: {l: {0x3B: {c: [8291]}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8290]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x4F: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1025]}}}}}}}, 0x6F: {l: {0x67: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [302]}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120128]}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [921]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8464]}}}}}}}, 0x74: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [296]}}}}}}}}}}}, 0x75: {l: {0x6B: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1030]}}}}}}}, 0x6D: {l: {0x6C: {l: {0x3B: {c: [207]}}, c: [207]}}}}}}},
    0x69: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [237]}}, c: [237]}}}}}}}}}, 0x63: {l: {0x3B: {c: [8291]}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [238]}}, c: [238]}}}}}, 0x79: {l: {0x3B: {c: [1080]}}}}}, 0x65: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1077]}}}}}, 0x78: {l: {0x63: {l: {0x6C: {l: {0x3B: {c: [161]}}, c: [161]}}}}}}}, 0x66: {l: {0x66: {l: {0x3B: {c: [8660]}}}, 0x72: {l: {0x3B: {c: [120102]}}}}}, 0x67: {l: {0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [236]}}, c: [236]}}}}}}}}}, 0x69: {l: {0x3B: {c: [8520]}, 0x69: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10764]}}}}}}}, 0x6E: {l: {0x74: {l: {0x3B: {c: [8749]}}}}}}}, 0x6E: {l: {0x66: {l: {0x69: {l: {0x6E: {l: {0x3B: {c: [10716]}}}}}}}}}, 0x6F: {l: {0x74: {l: {0x61: {l: {0x3B: {c: [8489]}}}}}}}}}, 0x6A: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [307]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [299]}}}}}, 0x67: {l: {0x65: {l: {0x3B: {c: [8465]}}}, 0x6C: {l: {0x69: {l: {0x6E: {l: {0x65: {l: {0x3B: {c: [8464]}}}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x74: {l: {0x3B: {c: [8465]}}}}}}}}}}}, 0x74: {l: {0x68: {l: {0x3B: {c: [305]}}}}}}}, 0x6F: {l: {0x66: {l: {0x3B: {c: [8887]}}}}}, 0x70: {l: {0x65: {l: {0x64: {l: {0x3B: {c: [437]}}}}}}}}}, 0x6E: {l: {0x63: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [8453]}}}}}}}}}, 0x3B: {c: [8712]}, 0x66: {l: {0x69: {l: {0x6E: {l: {0x3B: {c: [8734]}, 0x74: {l: {0x69: {l: {0x65: {l: {0x3B: {c: [10717]}}}}}}}}}}}}}, 0x6F: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [305]}}}}}}}}}, 0x74: {l: {0x63: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8890]}}}}}}}, 0x3B: {c: [8747]}, 0x65: {l: {0x67: {l: {0x65: {l: {0x72: {l: {0x73: {l: {0x3B: {c: [8484]}}}}}}}}}, 0x72: {l: {0x63: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8890]}}}}}}}}}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x68: {l: {0x6B: {l: {0x3B: {c: [10775]}}}}}}}}}}}, 0x70: {l: {0x72: {l: {0x6F: {l: {0x64: {l: {0x3B: {c: [10812]}}}}}}}}}}}}}, 0x6F: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1105]}}}}}, 0x67: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [303]}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120154]}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [953]}}}}}}}, 0x70: {l: {0x72: {l: {0x6F: {l: {0x64: {l: {0x3B: {c: [10812]}}}}}}}}}, 0x71: {l: {0x75: {l: {0x65: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [191]}}, c: [191]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119998]}}}}}, 0x69: {l: {0x6E: {l: {0x3B: {c: [8712]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8949]}}}}}}}, 0x45: {l: {0x3B: {c: [8953]}}}, 0x73: {l: {0x3B: {c: [8948]}, 0x76: {l: {0x3B: {c: [8947]}}}}}, 0x76: {l: {0x3B: {c: [8712]}}}}}}}}}, 0x74: {l: {0x3B: {c: [8290]}, 0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [297]}}}}}}}}}}}, 0x75: {l: {0x6B: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1110]}}}}}}}, 0x6D: {l: {0x6C: {l: {0x3B: {c: [239]}}, c: [239]}}}}}}},
    0x4A: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [308]}}}}}}}, 0x79: {l: {0x3B: {c: [1049]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120077]}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120129]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119973]}}}}}, 0x65: {l: {0x72: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1032]}}}}}}}}}}}, 0x75: {l: {0x6B: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1028]}}}}}}}}}}},
    0x6A: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [309]}}}}}}}, 0x79: {l: {0x3B: {c: [1081]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120103]}}}}}, 0x6D: {l: {0x61: {l: {0x74: {l: {0x68: {l: {0x3B: {c: [567]}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120155]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119999]}}}}}, 0x65: {l: {0x72: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1112]}}}}}}}}}}}, 0x75: {l: {0x6B: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1108]}}}}}}}}}}},
    0x4B: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x61: {l: {0x3B: {c: [922]}}}}}}}}}, 0x63: {l: {0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [310]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1050]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120078]}}}}}, 0x48: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1061]}}}}}}}, 0x4A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1036]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120130]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119974]}}}}}}}}},
    0x6B: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x61: {l: {0x3B: {c: [954]}, 0x76: {l: {0x3B: {c: [1008]}}}}}}}}}}}, 0x63: {l: {0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [311]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1082]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120104]}}}}}, 0x67: {l: {0x72: {l: {0x65: {l: {0x65: {l: {0x6E: {l: {0x3B: {c: [312]}}}}}}}}}}}, 0x68: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1093]}}}}}}}, 0x6A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1116]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120156]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120000]}}}}}}}}},
    0x6C: {l: {0x41: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8666]}}}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8656]}}}}}, 0x74: {l: {0x61: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [10523]}}}}}}}}}}}, 0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [314]}}}}}}}}}, 0x65: {l: {0x6D: {l: {0x70: {l: {0x74: {l: {0x79: {l: {0x76: {l: {0x3B: {c: [10676]}}}}}}}}}}}}}, 0x67: {l: {0x72: {l: {0x61: {l: {0x6E: {l: {0x3B: {c: [8466]}}}}}}}}}, 0x6D: {l: {0x62: {l: {0x64: {l: {0x61: {l: {0x3B: {c: [955]}}}}}}}}}, 0x6E: {l: {0x67: {l: {0x3B: {c: [10216]}, 0x64: {l: {0x3B: {c: [10641]}}}, 0x6C: {l: {0x65: {l: {0x3B: {c: [10216]}}}}}}}}}, 0x70: {l: {0x3B: {c: [10885]}}}, 0x71: {l: {0x75: {l: {0x6F: {l: {0x3B: {c: [171]}}, c: [171]}}}}}, 0x72: {l: {0x72: {l: {0x62: {l: {0x3B: {c: [8676]}, 0x66: {l: {0x73: {l: {0x3B: {c: [10527]}}}}}}}, 0x3B: {c: [8592]}, 0x66: {l: {0x73: {l: {0x3B: {c: [10525]}}}}}, 0x68: {l: {0x6B: {l: {0x3B: {c: [8617]}}}}}, 0x6C: {l: {0x70: {l: {0x3B: {c: [8619]}}}}}, 0x70: {l: {0x6C: {l: {0x3B: {c: [10553]}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [10611]}}}}}}}, 0x74: {l: {0x6C: {l: {0x3B: {c: [8610]}}}}}}}}}, 0x74: {l: {0x61: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [10521]}}}}}}}, 0x3B: {c: [10923]}, 0x65: {l: {0x3B: {c: [10925]}, 0x73: {l: {0x3B: {c: [10925, 65024]}}}}}}}}}, 0x62: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10508]}}}}}}}, 0x62: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [10098]}}}}}}}, 0x72: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [123]}}}, 0x6B: {l: {0x3B: {c: [91]}}}}}}}, 0x6B: {l: {0x65: {l: {0x3B: {c: [10635]}}}, 0x73: {l: {0x6C: {l: {0x64: {l: {0x3B: {c: [10639]}}}, 0x75: {l: {0x3B: {c: [10637]}}}}}}}}}}}}}, 0x42: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10510]}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [318]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [316]}}}}}}}, 0x69: {l: {0x6C: {l: {0x3B: {c: [8968]}}}}}}}, 0x75: {l: {0x62: {l: {0x3B: {c: [123]}}}}}, 0x79: {l: {0x3B: {c: [1083]}}}}}, 0x64: {l: {0x63: {l: {0x61: {l: {0x3B: {c: [10550]}}}}}, 0x71: {l: {0x75: {l: {0x6F: {l: {0x3B: {c: [8220]}, 0x72: {l: {0x3B: {c: [8222]}}}}}}}}}, 0x72: {l: {0x64: {l: {0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10599]}}}}}}}}}, 0x75: {l: {0x73: {l: {0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10571]}}}}}}}}}}}}}, 0x73: {l: {0x68: {l: {0x3B: {c: [8626]}}}}}}}, 0x65: {l: {0x3B: {c: [8804]}, 0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8592]}, 0x74: {l: {0x61: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [8610]}}}}}}}}}}}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x70: {l: {0x6F: {l: {0x6F: {l: {0x6E: {l: {0x64: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x3B: {c: [8637]}}}}}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [8636]}}}}}}}}}}}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x73: {l: {0x3B: {c: [8647]}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8596]}, 0x73: {l: {0x3B: {c: [8646]}}}}}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x70: {l: {0x6F: {l: {0x6F: {l: {0x6E: {l: {0x73: {l: {0x3B: {c: [8651]}}}}}}}}}}}}}}}}}, 0x73: {l: {0x71: {l: {0x75: {l: {0x69: {l: {0x67: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8621]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x74: {l: {0x68: {l: {0x72: {l: {0x65: {l: {0x65: {l: {0x74: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8907]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x67: {l: {0x3B: {c: [8922]}}}, 0x71: {l: {0x3B: {c: [8804]}, 0x71: {l: {0x3B: {c: [8806]}}}, 0x73: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10877]}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x63: {l: {0x3B: {c: [10920]}}}}}, 0x3B: {c: [10877]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10879]}, 0x6F: {l: {0x3B: {c: [10881]}, 0x72: {l: {0x3B: {c: [10883]}}}}}}}}}}}, 0x67: {l: {0x3B: {c: [8922, 65024]}, 0x65: {l: {0x73: {l: {0x3B: {c: [10899]}}}}}}}, 0x73: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [10885]}}}}}}}}}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8918]}}}}}}}, 0x65: {l: {0x71: {l: {0x67: {l: {0x74: {l: {0x72: {l: {0x3B: {c: [8922]}}}}}}}, 0x71: {l: {0x67: {l: {0x74: {l: {0x72: {l: {0x3B: {c: [10891]}}}}}}}}}}}}}, 0x67: {l: {0x74: {l: {0x72: {l: {0x3B: {c: [8822]}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8818]}}}}}}}}}}}}}, 0x45: {l: {0x3B: {c: [8806]}, 0x67: {l: {0x3B: {c: [10891]}}}}}, 0x66: {l: {0x69: {l: {0x73: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [10620]}}}}}}}}}, 0x6C: {l: {0x6F: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [8970]}}}}}}}}}, 0x72: {l: {0x3B: {c: [120105]}}}}}, 0x67: {l: {0x3B: {c: [8822]}, 0x45: {l: {0x3B: {c: [10897]}}}}}, 0x48: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10594]}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x64: {l: {0x3B: {c: [8637]}}}, 0x75: {l: {0x3B: {c: [8636]}, 0x6C: {l: {0x3B: {c: [10602]}}}}}}}}}, 0x62: {l: {0x6C: {l: {0x6B: {l: {0x3B: {c: [9604]}}}}}}}}}, 0x6A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1113]}}}}}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8647]}}}}}}}, 0x3B: {c: [8810]}, 0x63: {l: {0x6F: {l: {0x72: {l: {0x6E: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8990]}}}}}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x64: {l: {0x3B: {c: [10603]}}}}}}}}}, 0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [9722]}}}}}}}}}, 0x6D: {l: {0x69: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [320]}}}}}}}}}, 0x6F: {l: {0x75: {l: {0x73: {l: {0x74: {l: {0x61: {l: {0x63: {l: {0x68: {l: {0x65: {l: {0x3B: {c: [9136]}}}}}}}}}, 0x3B: {c: [9136]}}}}}}}}}}}, 0x6E: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10889]}, 0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [10889]}}}}}}}}}}}}}, 0x65: {l: {0x3B: {c: [10887]}, 0x71: {l: {0x3B: {c: [10887]}, 0x71: {l: {0x3B: {c: [8808]}}}}}}}, 0x45: {l: {0x3B: {c: [8808]}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8934]}}}}}}}}}, 0x6F: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [10220]}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8701]}}}}}}}, 0x62: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [10214]}}}}}}}, 0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10229]}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10231]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x70: {l: {0x73: {l: {0x74: {l: {0x6F: {l: {0x3B: {c: [10236]}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10230]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [8619]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [8620]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10629]}}}}}, 0x66: {l: {0x3B: {c: [120157]}}}, 0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10797]}}}}}}}}}, 0x74: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [10804]}}}}}}}}}}}, 0x77: {l: {0x61: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [8727]}}}}}}}, 0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [95]}}}}}}}}}, 0x7A: {l: {0x3B: {c: [9674]}, 0x65: {l: {0x6E: {l: {0x67: {l: {0x65: {l: {0x3B: {c: [9674]}}}}}}}}}, 0x66: {l: {0x3B: {c: [10731]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [40]}, 0x6C: {l: {0x74: {l: {0x3B: {c: [10643]}}}}}}}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8646]}}}}}}}, 0x63: {l: {0x6F: {l: {0x72: {l: {0x6E: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8991]}}}}}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8651]}, 0x64: {l: {0x3B: {c: [10605]}}}}}}}}}, 0x6D: {l: {0x3B: {c: [8206]}}}, 0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [8895]}}}}}}}}}, 0x73: {l: {0x61: {l: {0x71: {l: {0x75: {l: {0x6F: {l: {0x3B: {c: [8249]}}}}}}}}}, 0x63: {l: {0x72: {l: {0x3B: {c: [120001]}}}}}, 0x68: {l: {0x3B: {c: [8624]}}}, 0x69: {l: {0x6D: {l: {0x3B: {c: [8818]}, 0x65: {l: {0x3B: {c: [10893]}}}, 0x67: {l: {0x3B: {c: [10895]}}}}}}}, 0x71: {l: {0x62: {l: {0x3B: {c: [91]}}}, 0x75: {l: {0x6F: {l: {0x3B: {c: [8216]}, 0x72: {l: {0x3B: {c: [8218]}}}}}}}}}, 0x74: {l: {0x72: {l: {0x6F: {l: {0x6B: {l: {0x3B: {c: [322]}}}}}}}}}}}, 0x74: {l: {0x63: {l: {0x63: {l: {0x3B: {c: [10918]}}}, 0x69: {l: {0x72: {l: {0x3B: {c: [10873]}}}}}}}, 0x3B: {c: [60]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8918]}}}}}}}, 0x68: {l: {0x72: {l: {0x65: {l: {0x65: {l: {0x3B: {c: [8907]}}}}}}}}}, 0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8905]}}}}}}}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10614]}}}}}}}}}, 0x71: {l: {0x75: {l: {0x65: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [10875]}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x3B: {c: [9667]}, 0x65: {l: {0x3B: {c: [8884]}}}, 0x66: {l: {0x3B: {c: [9666]}}}}}, 0x50: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10646]}}}}}}}}}}, c: [60]}, 0x75: {l: {0x72: {l: {0x64: {l: {0x73: {l: {0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10570]}}}}}}}}}}}, 0x75: {l: {0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10598]}}}}}}}}}}}}}, 0x76: {l: {0x65: {l: {0x72: {l: {0x74: {l: {0x6E: {l: {0x65: {l: {0x71: {l: {0x71: {l: {0x3B: {c: [8808, 65024]}}}}}}}}}}}}}}}, 0x6E: {l: {0x45: {l: {0x3B: {c: [8808, 65024]}}}}}}}}},
    0x4C: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [313]}}}}}}}}}, 0x6D: {l: {0x62: {l: {0x64: {l: {0x61: {l: {0x3B: {c: [923]}}}}}}}}}, 0x6E: {l: {0x67: {l: {0x3B: {c: [10218]}}}}}, 0x70: {l: {0x6C: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x74: {l: {0x72: {l: {0x66: {l: {0x3B: {c: [8466]}}}}}}}}}}}}}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8606]}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [317]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [315]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1051]}}}}}, 0x65: {l: {0x66: {l: {0x74: {l: {0x41: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x42: {l: {0x72: {l: {0x61: {l: {0x63: {l: {0x6B: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [10216]}}}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8676]}}}}}}}, 0x3B: {c: [8592]}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8646]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8656]}}}}}}}}}}}, 0x43: {l: {0x65: {l: {0x69: {l: {0x6C: {l: {0x69: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [8968]}}}}}}}}}}}}}}}, 0x44: {l: {0x6F: {l: {0x75: {l: {0x62: {l: {0x6C: {l: {0x65: {l: {0x42: {l: {0x72: {l: {0x61: {l: {0x63: {l: {0x6B: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [10214]}}}}}}}}}}}}}}}}}}}}}}}, 0x77: {l: {0x6E: {l: {0x54: {l: {0x65: {l: {0x65: {l: {0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10593]}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10585]}}}}}}}, 0x3B: {c: [8643]}}}}}}}}}}}}}}}}}}}}}, 0x46: {l: {0x6C: {l: {0x6F: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [8970]}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8596]}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10574]}}}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8660]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x65: {l: {0x65: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8612]}}}}}}}}}}}, 0x3B: {c: [8867]}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10586]}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10703]}}}}}}}, 0x3B: {c: [8882]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8884]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x55: {l: {0x70: {l: {0x44: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10577]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x65: {l: {0x65: {l: {0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10592]}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10584]}}}}}}}, 0x3B: {c: [8639]}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10578]}}}}}}}, 0x3B: {c: [8636]}}}}}}}}}}}}}}}}}, 0x73: {l: {0x73: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8922]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x46: {l: {0x75: {l: {0x6C: {l: {0x6C: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8806]}}}}}}}}}}}}}}}}}}}, 0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8822]}}}}}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [10913]}}}}}}}}}, 0x53: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [10877]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8818]}}}}}}}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120079]}}}}}, 0x4A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1033]}}}}}}}, 0x6C: {l: {0x3B: {c: [8920]}, 0x65: {l: {0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8666]}}}}}}}}}}}}}}}}}}}, 0x6D: {l: {0x69: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [319]}}}}}}}}}}}, 0x6F: {l: {0x6E: {l: {0x67: {l: {0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10229]}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10231]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10232]}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10234]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10230]}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [10233]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120131]}}}}}, 0x77: {l: {0x65: {l: {0x72: {l: {0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8601]}}}}}}}}}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8600]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8466]}}}}}, 0x68: {l: {0x3B: {c: [8624]}}}, 0x74: {l: {0x72: {l: {0x6F: {l: {0x6B: {l: {0x3B: {c: [321]}}}}}}}}}}}, 0x54: {l: {0x3B: {c: [60]}}, c: [60]}, 0x74: {l: {0x3B: {c: [8810]}}}}},
    0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [175]}}, c: [175]}}}, 0x6C: {l: {0x65: {l: {0x3B: {c: [9794]}}}, 0x74: {l: {0x3B: {c: [10016]}, 0x65: {l: {0x73: {l: {0x65: {l: {0x3B: {c: [10016]}}}}}}}}}}}, 0x70: {l: {0x3B: {c: [8614]}, 0x73: {l: {0x74: {l: {0x6F: {l: {0x3B: {c: [8614]}, 0x64: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x3B: {c: [8615]}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [8612]}}}}}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [8613]}}}}}}}}}}}}}, 0x72: {l: {0x6B: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [9646]}}}}}}}}}}}, 0x63: {l: {0x6F: {l: {0x6D: {l: {0x6D: {l: {0x61: {l: {0x3B: {c: [10793]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1084]}}}}}, 0x64: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8212]}}}}}}}}}, 0x44: {l: {0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8762]}}}}}}}}}, 0x65: {l: {0x61: {l: {0x73: {l: {0x75: {l: {0x72: {l: {0x65: {l: {0x64: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x3B: {c: [8737]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120106]}}}}}, 0x68: {l: {0x6F: {l: {0x3B: {c: [8487]}}}}}, 0x69: {l: {0x63: {l: {0x72: {l: {0x6F: {l: {0x3B: {c: [181]}}, c: [181]}}}}}, 0x64: {l: {0x61: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [42]}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10992]}}}}}}}, 0x3B: {c: [8739]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [183]}}, c: [183]}}}}}}}, 0x6E: {l: {0x75: {l: {0x73: {l: {0x62: {l: {0x3B: {c: [8863]}}}, 0x3B: {c: [8722]}, 0x64: {l: {0x3B: {c: [8760]}, 0x75: {l: {0x3B: {c: [10794]}}}}}}}}}}}}}, 0x6C: {l: {0x63: {l: {0x70: {l: {0x3B: {c: [10971]}}}}}, 0x64: {l: {0x72: {l: {0x3B: {c: [8230]}}}}}}}, 0x6E: {l: {0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8723]}}}}}}}}}}}, 0x6F: {l: {0x64: {l: {0x65: {l: {0x6C: {l: {0x73: {l: {0x3B: {c: [8871]}}}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120158]}}}}}}}, 0x70: {l: {0x3B: {c: [8723]}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120002]}}}}}, 0x74: {l: {0x70: {l: {0x6F: {l: {0x73: {l: {0x3B: {c: [8766]}}}}}}}}}}}, 0x75: {l: {0x3B: {c: [956]}, 0x6C: {l: {0x74: {l: {0x69: {l: {0x6D: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [8888]}}}}}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [8888]}}}}}}}}}}},
    0x4D: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10501]}}}}}, 0x63: {l: {0x79: {l: {0x3B: {c: [1052]}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x75: {l: {0x6D: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8287]}}}}}}}}}}}}}}}}}}}, 0x6C: {l: {0x6C: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x72: {l: {0x66: {l: {0x3B: {c: [8499]}}}}}}}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120080]}}}}}, 0x69: {l: {0x6E: {l: {0x75: {l: {0x73: {l: {0x50: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8723]}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120132]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8499]}}}}}}}, 0x75: {l: {0x3B: {c: [924]}}}}},
    0x6E: {l: {0x61: {l: {0x62: {l: {0x6C: {l: {0x61: {l: {0x3B: {c: [8711]}}}}}}}, 0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [324]}}}}}}}}}, 0x6E: {l: {0x67: {l: {0x3B: {c: [8736, 8402]}}}}}, 0x70: {l: {0x3B: {c: [8777]}, 0x45: {l: {0x3B: {c: [10864, 824]}}}, 0x69: {l: {0x64: {l: {0x3B: {c: [8779, 824]}}}}}, 0x6F: {l: {0x73: {l: {0x3B: {c: [329]}}}}}, 0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [8777]}}}}}}}}}}}, 0x74: {l: {0x75: {l: {0x72: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [9838]}, 0x73: {l: {0x3B: {c: [8469]}}}}}}}, 0x3B: {c: [9838]}}}}}}}}}, 0x62: {l: {0x73: {l: {0x70: {l: {0x3B: {c: [160]}}, c: [160]}}}, 0x75: {l: {0x6D: {l: {0x70: {l: {0x3B: {c: [8782, 824]}, 0x65: {l: {0x3B: {c: [8783, 824]}}}}}}}}}}}, 0x63: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10819]}}}, 0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [328]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [326]}}}}}}}}}, 0x6F: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [8775]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10861, 824]}}}}}}}}}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [10818]}}}}}, 0x79: {l: {0x3B: {c: [1085]}}}}}, 0x64: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8211]}}}}}}}}}, 0x65: {l: {0x61: {l: {0x72: {l: {0x68: {l: {0x6B: {l: {0x3B: {c: [10532]}}}}}, 0x72: {l: {0x3B: {c: [8599]}, 0x6F: {l: {0x77: {l: {0x3B: {c: [8599]}}}}}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8663]}}}}}}}, 0x3B: {c: [8800]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8784, 824]}}}}}}}, 0x71: {l: {0x75: {l: {0x69: {l: {0x76: {l: {0x3B: {c: [8802]}}}}}}}}}, 0x73: {l: {0x65: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10536]}}}}}}}, 0x69: {l: {0x6D: {l: {0x3B: {c: [8770, 824]}}}}}}}, 0x78: {l: {0x69: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [8708]}, 0x73: {l: {0x3B: {c: [8708]}}}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120107]}}}}}, 0x67: {l: {0x45: {l: {0x3B: {c: [8807, 824]}}}, 0x65: {l: {0x3B: {c: [8817]}, 0x71: {l: {0x3B: {c: [8817]}, 0x71: {l: {0x3B: {c: [8807, 824]}}}, 0x73: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10878, 824]}}}}}}}}}}}}}, 0x73: {l: {0x3B: {c: [10878, 824]}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8821]}}}}}}}, 0x74: {l: {0x3B: {c: [8815]}, 0x72: {l: {0x3B: {c: [8815]}}}}}}}, 0x47: {l: {0x67: {l: {0x3B: {c: [8921, 824]}}}, 0x74: {l: {0x3B: {c: [8811, 8402]}, 0x76: {l: {0x3B: {c: [8811, 824]}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8622]}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8654]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10994]}}}}}}}}}, 0x69: {l: {0x3B: {c: [8715]}, 0x73: {l: {0x3B: {c: [8956]}, 0x64: {l: {0x3B: {c: [8954]}}}}}, 0x76: {l: {0x3B: {c: [8715]}}}}}, 0x6A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1114]}}}}}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8602]}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8653]}}}}}}}, 0x64: {l: {0x72: {l: {0x3B: {c: [8229]}}}}}, 0x45: {l: {0x3B: {c: [8806, 824]}}}, 0x65: {l: {0x3B: {c: [8816]}, 0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8602]}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8622]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x71: {l: {0x3B: {c: [8816]}, 0x71: {l: {0x3B: {c: [8806, 824]}}}, 0x73: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10877, 824]}}}}}}}}}}}}}, 0x73: {l: {0x3B: {c: [10877, 824]}, 0x73: {l: {0x3B: {c: [8814]}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8820]}}}}}}}, 0x74: {l: {0x3B: {c: [8814]}, 0x72: {l: {0x69: {l: {0x3B: {c: [8938]}, 0x65: {l: {0x3B: {c: [8940]}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8653]}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8654]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6C: {l: {0x3B: {c: [8920, 824]}}}, 0x74: {l: {0x3B: {c: [8810, 8402]}, 0x76: {l: {0x3B: {c: [8810, 824]}}}}}}}, 0x6D: {l: {0x69: {l: {0x64: {l: {0x3B: {c: [8740]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120159]}}}}}, 0x74: {l: {0x3B: {c: [172]}, 0x69: {l: {0x6E: {l: {0x3B: {c: [8713]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8949, 824]}}}}}}}, 0x45: {l: {0x3B: {c: [8953, 824]}}}, 0x76: {l: {0x61: {l: {0x3B: {c: [8713]}}}, 0x62: {l: {0x3B: {c: [8951]}}}, 0x63: {l: {0x3B: {c: [8950]}}}}}}}}}, 0x6E: {l: {0x69: {l: {0x3B: {c: [8716]}, 0x76: {l: {0x61: {l: {0x3B: {c: [8716]}}}, 0x62: {l: {0x3B: {c: [8958]}}}, 0x63: {l: {0x3B: {c: [8957]}}}}}}}}}}, c: [172]}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x65: {l: {0x6C: {l: {0x3B: {c: [8742]}}}}}}}}}}}, 0x3B: {c: [8742]}, 0x73: {l: {0x6C: {l: {0x3B: {c: [11005, 8421]}}}}}, 0x74: {l: {0x3B: {c: [8706, 824]}}}}}}}, 0x6F: {l: {0x6C: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10772]}}}}}}}}}}}, 0x72: {l: {0x3B: {c: [8832]}, 0x63: {l: {0x75: {l: {0x65: {l: {0x3B: {c: [8928]}}}}}}}, 0x65: {l: {0x63: {l: {0x3B: {c: [8832]}, 0x65: {l: {0x71: {l: {0x3B: {c: [10927, 824]}}}}}}}, 0x3B: {c: [10927, 824]}}}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [10547, 824]}}}, 0x3B: {c: [8603]}, 0x77: {l: {0x3B: {c: [8605, 824]}}}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8655]}}}}}}}, 0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8603]}}}}}}}}}}}}}}}}}}}, 0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [8939]}, 0x65: {l: {0x3B: {c: [8941]}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8655]}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x3B: {c: [8833]}, 0x63: {l: {0x75: {l: {0x65: {l: {0x3B: {c: [8929]}}}}}}}, 0x65: {l: {0x3B: {c: [10928, 824]}}}, 0x72: {l: {0x3B: {c: [120003]}}}}}, 0x68: {l: {0x6F: {l: {0x72: {l: {0x74: {l: {0x6D: {l: {0x69: {l: {0x64: {l: {0x3B: {c: [8740]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x65: {l: {0x6C: {l: {0x3B: {c: [8742]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x69: {l: {0x6D: {l: {0x3B: {c: [8769]}, 0x65: {l: {0x3B: {c: [8772]}, 0x71: {l: {0x3B: {c: [8772]}}}}}}}}}, 0x6D: {l: {0x69: {l: {0x64: {l: {0x3B: {c: [8740]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8742]}}}}}}}, 0x71: {l: {0x73: {l: {0x75: {l: {0x62: {l: {0x65: {l: {0x3B: {c: [8930]}}}}}, 0x70: {l: {0x65: {l: {0x3B: {c: [8931]}}}}}}}}}}}, 0x75: {l: {0x62: {l: {0x3B: {c: [8836]}, 0x45: {l: {0x3B: {c: [10949, 824]}}}, 0x65: {l: {0x3B: {c: [8840]}}}, 0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8834, 8402]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8840]}, 0x71: {l: {0x3B: {c: [10949, 824]}}}}}}}}}}}}}}}, 0x63: {l: {0x63: {l: {0x3B: {c: [8833]}, 0x65: {l: {0x71: {l: {0x3B: {c: [10928, 824]}}}}}}}}}, 0x70: {l: {0x3B: {c: [8837]}, 0x45: {l: {0x3B: {c: [10950, 824]}}}, 0x65: {l: {0x3B: {c: [8841]}}}, 0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8835, 8402]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8841]}, 0x71: {l: {0x3B: {c: [10950, 824]}}}}}}}}}}}}}}}}}}}, 0x74: {l: {0x67: {l: {0x6C: {l: {0x3B: {c: [8825]}}}}}, 0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [241]}}, c: [241]}}}}}}}, 0x6C: {l: {0x67: {l: {0x3B: {c: [8824]}}}}}, 0x72: {l: {0x69: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [8938]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8940]}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [8939]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8941]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x75: {l: {0x3B: {c: [957]}, 0x6D: {l: {0x3B: {c: [35]}, 0x65: {l: {0x72: {l: {0x6F: {l: {0x3B: {c: [8470]}}}}}}}, 0x73: {l: {0x70: {l: {0x3B: {c: [8199]}}}}}}}}}, 0x76: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [8781, 8402]}}}}}, 0x64: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8876]}}}}}}}}}, 0x44: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8877]}}}}}}}}}, 0x67: {l: {0x65: {l: {0x3B: {c: [8805, 8402]}}}, 0x74: {l: {0x3B: {c: [62, 8402]}}}}}, 0x48: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10500]}}}}}}}}}, 0x69: {l: {0x6E: {l: {0x66: {l: {0x69: {l: {0x6E: {l: {0x3B: {c: [10718]}}}}}}}}}}}, 0x6C: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10498]}}}}}}}, 0x65: {l: {0x3B: {c: [8804, 8402]}}}, 0x74: {l: {0x3B: {c: [60, 8402]}, 0x72: {l: {0x69: {l: {0x65: {l: {0x3B: {c: [8884, 8402]}}}}}}}}}}}, 0x72: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10499]}}}}}}}, 0x74: {l: {0x72: {l: {0x69: {l: {0x65: {l: {0x3B: {c: [8885, 8402]}}}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8764, 8402]}}}}}}}}}, 0x56: {l: {0x64: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8878]}}}}}}}}}, 0x44: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8879]}}}}}}}}}}}, 0x77: {l: {0x61: {l: {0x72: {l: {0x68: {l: {0x6B: {l: {0x3B: {c: [10531]}}}}}, 0x72: {l: {0x3B: {c: [8598]}, 0x6F: {l: {0x77: {l: {0x3B: {c: [8598]}}}}}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8662]}}}}}}}, 0x6E: {l: {0x65: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10535]}}}}}}}}}}}}},
    0x4E: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [323]}}}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [327]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [325]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1053]}}}}}, 0x65: {l: {0x67: {l: {0x61: {l: {0x74: {l: {0x69: {l: {0x76: {l: {0x65: {l: {0x4D: {l: {0x65: {l: {0x64: {l: {0x69: {l: {0x75: {l: {0x6D: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8203]}}}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x68: {l: {0x69: {l: {0x63: {l: {0x6B: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8203]}}}}}}}}}}}}}}}, 0x6E: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8203]}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x72: {l: {0x79: {l: {0x54: {l: {0x68: {l: {0x69: {l: {0x6E: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8203]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x74: {l: {0x65: {l: {0x64: {l: {0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8811]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x4C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [8810]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x77: {l: {0x4C: {l: {0x69: {l: {0x6E: {l: {0x65: {l: {0x3B: {c: [10]}}}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120081]}}}}}, 0x4A: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1034]}}}}}}}, 0x6F: {l: {0x42: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x6B: {l: {0x3B: {c: [8288]}}}}}}}}}}}, 0x6E: {l: {0x42: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x6B: {l: {0x69: {l: {0x6E: {l: {0x67: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [160]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [8469]}}}}}, 0x74: {l: {0x3B: {c: [10988]}, 0x43: {l: {0x6F: {l: {0x6E: {l: {0x67: {l: {0x72: {l: {0x75: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8802]}}}}}}}}}}}}}}}}}, 0x75: {l: {0x70: {l: {0x43: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [8813]}}}}}}}}}}}}}, 0x44: {l: {0x6F: {l: {0x75: {l: {0x62: {l: {0x6C: {l: {0x65: {l: {0x56: {l: {0x65: {l: {0x72: {l: {0x74: {l: {0x69: {l: {0x63: {l: {0x61: {l: {0x6C: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8742]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x45: {l: {0x6C: {l: {0x65: {l: {0x6D: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8713]}}}}}}}}}}}}}, 0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8800]}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8770, 824]}}}}}}}}}}}}}}}}}}}, 0x78: {l: {0x69: {l: {0x73: {l: {0x74: {l: {0x73: {l: {0x3B: {c: [8708]}}}}}}}}}}}}}, 0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8815]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8817]}}}}}}}}}}}, 0x46: {l: {0x75: {l: {0x6C: {l: {0x6C: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8807, 824]}}}}}}}}}}}}}}}}}}}, 0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8811, 824]}}}}}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [8825]}}}}}}}}}, 0x53: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [10878, 824]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8821]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x48: {l: {0x75: {l: {0x6D: {l: {0x70: {l: {0x44: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x48: {l: {0x75: {l: {0x6D: {l: {0x70: {l: {0x3B: {c: [8782, 824]}}}}}}}}}}}}}}}}}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8783, 824]}}}}}}}}}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x54: {l: {0x72: {l: {0x69: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10703, 824]}}}}}}}, 0x3B: {c: [8938]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8940]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x73: {l: {0x3B: {c: [8814]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8816]}}}}}}}}}}}, 0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [8824]}}}}}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [8810, 824]}}}}}}}}}, 0x53: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [10877, 824]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8820]}}}}}}}}}}}}}}}}}}}, 0x4E: {l: {0x65: {l: {0x73: {l: {0x74: {l: {0x65: {l: {0x64: {l: {0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x47: {l: {0x72: {l: {0x65: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x3B: {c: [10914, 824]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x4C: {l: {0x65: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [10913, 824]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x50: {l: {0x72: {l: {0x65: {l: {0x63: {l: {0x65: {l: {0x64: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8832]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [10927, 824]}}}}}}}}}}}, 0x53: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8928]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x52: {l: {0x65: {l: {0x76: {l: {0x65: {l: {0x72: {l: {0x73: {l: {0x65: {l: {0x45: {l: {0x6C: {l: {0x65: {l: {0x6D: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8716]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x54: {l: {0x72: {l: {0x69: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10704, 824]}}}}}}}, 0x3B: {c: [8939]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8941]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x53: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x53: {l: {0x75: {l: {0x62: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8847, 824]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8930]}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x65: {l: {0x72: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8848, 824]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8931]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x75: {l: {0x62: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8834, 8402]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8840]}}}}}}}}}}}}}}}}}}}, 0x63: {l: {0x63: {l: {0x65: {l: {0x65: {l: {0x64: {l: {0x73: {l: {0x3B: {c: [8833]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [10928, 824]}}}}}}}}}}}, 0x53: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8929]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8831, 824]}}}}}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x65: {l: {0x72: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8835, 8402]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8841]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8769]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8772]}}}}}}}}}}}, 0x46: {l: {0x75: {l: {0x6C: {l: {0x6C: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8775]}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8777]}}}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x72: {l: {0x74: {l: {0x69: {l: {0x63: {l: {0x61: {l: {0x6C: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8740]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119977]}}}}}}}, 0x74: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [209]}}, c: [209]}}}}}}}}}, 0x75: {l: {0x3B: {c: [925]}}}}},
    0x4F: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [211]}}, c: [211]}}}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [212]}}, c: [212]}}}}}, 0x79: {l: {0x3B: {c: [1054]}}}}}, 0x64: {l: {0x62: {l: {0x6C: {l: {0x61: {l: {0x63: {l: {0x3B: {c: [336]}}}}}}}}}}}, 0x45: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [338]}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120082]}}}}}, 0x67: {l: {0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [210]}}, c: [210]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [332]}}}}}}}, 0x65: {l: {0x67: {l: {0x61: {l: {0x3B: {c: [937]}}}}}}}, 0x69: {l: {0x63: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [927]}}}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120134]}}}}}}}, 0x70: {l: {0x65: {l: {0x6E: {l: {0x43: {l: {0x75: {l: {0x72: {l: {0x6C: {l: {0x79: {l: {0x44: {l: {0x6F: {l: {0x75: {l: {0x62: {l: {0x6C: {l: {0x65: {l: {0x51: {l: {0x75: {l: {0x6F: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [8220]}}}}}}}}}}}}}}}}}}}}}}}, 0x51: {l: {0x75: {l: {0x6F: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [8216]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x3B: {c: [10836]}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119978]}}}}}, 0x6C: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [216]}}, c: [216]}}}}}}}}}, 0x74: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [213]}}, c: [213]}}}}}, 0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [10807]}}}}}}}}}}}, 0x75: {l: {0x6D: {l: {0x6C: {l: {0x3B: {c: [214]}}, c: [214]}}}}}, 0x76: {l: {0x65: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8254]}}}}}, 0x72: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [9182]}}}, 0x6B: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [9140]}}}}}}}}}}}}}}}, 0x50: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x68: {l: {0x65: {l: {0x73: {l: {0x69: {l: {0x73: {l: {0x3B: {c: [9180]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},
    0x6F: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [243]}}, c: [243]}}}}}}}, 0x73: {l: {0x74: {l: {0x3B: {c: [8859]}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [244]}}, c: [244]}, 0x3B: {c: [8858]}}}}}, 0x79: {l: {0x3B: {c: [1086]}}}}}, 0x64: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8861]}}}}}}}, 0x62: {l: {0x6C: {l: {0x61: {l: {0x63: {l: {0x3B: {c: [337]}}}}}}}}}, 0x69: {l: {0x76: {l: {0x3B: {c: [10808]}}}}}, 0x6F: {l: {0x74: {l: {0x3B: {c: [8857]}}}}}, 0x73: {l: {0x6F: {l: {0x6C: {l: {0x64: {l: {0x3B: {c: [10684]}}}}}}}}}}}, 0x65: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [339]}}}}}}}}}, 0x66: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10687]}}}}}}}, 0x72: {l: {0x3B: {c: [120108]}}}}}, 0x67: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [731]}}}}}, 0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [242]}}, c: [242]}}}}}}}, 0x74: {l: {0x3B: {c: [10689]}}}}}, 0x68: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10677]}}}}}}}, 0x6D: {l: {0x3B: {c: [937]}}}}}, 0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8750]}}}}}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8634]}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10686]}}}}}, 0x72: {l: {0x6F: {l: {0x73: {l: {0x73: {l: {0x3B: {c: [10683]}}}}}}}}}}}, 0x69: {l: {0x6E: {l: {0x65: {l: {0x3B: {c: [8254]}}}}}}}, 0x74: {l: {0x3B: {c: [10688]}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [333]}}}}}}}, 0x65: {l: {0x67: {l: {0x61: {l: {0x3B: {c: [969]}}}}}}}, 0x69: {l: {0x63: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [959]}}}}}}}}}, 0x64: {l: {0x3B: {c: [10678]}}}, 0x6E: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8854]}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120160]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10679]}}}}}, 0x65: {l: {0x72: {l: {0x70: {l: {0x3B: {c: [10681]}}}}}}}, 0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8853]}}}}}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8635]}}}}}}}, 0x3B: {c: [8744]}, 0x64: {l: {0x3B: {c: [10845]}, 0x65: {l: {0x72: {l: {0x3B: {c: [8500]}, 0x6F: {l: {0x66: {l: {0x3B: {c: [8500]}}}}}}}}}, 0x66: {l: {0x3B: {c: [170]}}, c: [170]}, 0x6D: {l: {0x3B: {c: [186]}}, c: [186]}}}, 0x69: {l: {0x67: {l: {0x6F: {l: {0x66: {l: {0x3B: {c: [8886]}}}}}}}}}, 0x6F: {l: {0x72: {l: {0x3B: {c: [10838]}}}}}, 0x73: {l: {0x6C: {l: {0x6F: {l: {0x70: {l: {0x65: {l: {0x3B: {c: [10839]}}}}}}}}}}}, 0x76: {l: {0x3B: {c: [10843]}}}}}, 0x53: {l: {0x3B: {c: [9416]}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8500]}}}}}, 0x6C: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [248]}}, c: [248]}}}}}}}, 0x6F: {l: {0x6C: {l: {0x3B: {c: [8856]}}}}}}}, 0x74: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [245]}}, c: [245]}}}}}, 0x6D: {l: {0x65: {l: {0x73: {l: {0x61: {l: {0x73: {l: {0x3B: {c: [10806]}}}}}, 0x3B: {c: [8855]}}}}}}}}}}}, 0x75: {l: {0x6D: {l: {0x6C: {l: {0x3B: {c: [246]}}, c: [246]}}}}}, 0x76: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [9021]}}}}}}}}}}},
    0x70: {l: {0x61: {l: {0x72: {l: {0x61: {l: {0x3B: {c: [182]}, 0x6C: {l: {0x6C: {l: {0x65: {l: {0x6C: {l: {0x3B: {c: [8741]}}}}}}}}}}, c: [182]}, 0x3B: {c: [8741]}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [10995]}}}}}, 0x6C: {l: {0x3B: {c: [11005]}}}}}, 0x74: {l: {0x3B: {c: [8706]}}}}}}}, 0x63: {l: {0x79: {l: {0x3B: {c: [1087]}}}}}, 0x65: {l: {0x72: {l: {0x63: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [37]}}}}}}}, 0x69: {l: {0x6F: {l: {0x64: {l: {0x3B: {c: [46]}}}}}}}, 0x6D: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [8240]}}}}}}}, 0x70: {l: {0x3B: {c: [8869]}}}, 0x74: {l: {0x65: {l: {0x6E: {l: {0x6B: {l: {0x3B: {c: [8241]}}}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120109]}}}}}, 0x68: {l: {0x69: {l: {0x3B: {c: [966]}, 0x76: {l: {0x3B: {c: [981]}}}}}, 0x6D: {l: {0x6D: {l: {0x61: {l: {0x74: {l: {0x3B: {c: [8499]}}}}}}}}}, 0x6F: {l: {0x6E: {l: {0x65: {l: {0x3B: {c: [9742]}}}}}}}}}, 0x69: {l: {0x3B: {c: [960]}, 0x74: {l: {0x63: {l: {0x68: {l: {0x66: {l: {0x6F: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [8916]}}}}}}}}}}}}}}}, 0x76: {l: {0x3B: {c: [982]}}}}}, 0x6C: {l: {0x61: {l: {0x6E: {l: {0x63: {l: {0x6B: {l: {0x3B: {c: [8463]}, 0x68: {l: {0x3B: {c: [8462]}}}}}}}, 0x6B: {l: {0x76: {l: {0x3B: {c: [8463]}}}}}}}}}, 0x75: {l: {0x73: {l: {0x61: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10787]}}}}}}}}}, 0x62: {l: {0x3B: {c: [8862]}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10786]}}}}}}}, 0x3B: {c: [43]}, 0x64: {l: {0x6F: {l: {0x3B: {c: [8724]}}}, 0x75: {l: {0x3B: {c: [10789]}}}}}, 0x65: {l: {0x3B: {c: [10866]}}}, 0x6D: {l: {0x6E: {l: {0x3B: {c: [177]}}, c: [177]}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [10790]}}}}}}}, 0x74: {l: {0x77: {l: {0x6F: {l: {0x3B: {c: [10791]}}}}}}}}}}}}}, 0x6D: {l: {0x3B: {c: [177]}}}, 0x6F: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10773]}}}}}}}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120161]}}}}}, 0x75: {l: {0x6E: {l: {0x64: {l: {0x3B: {c: [163]}}, c: [163]}}}}}}}, 0x72: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10935]}}}}}, 0x3B: {c: [8826]}, 0x63: {l: {0x75: {l: {0x65: {l: {0x3B: {c: [8828]}}}}}}}, 0x65: {l: {0x63: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [10935]}}}}}}}}}}}}}, 0x3B: {c: [8826]}, 0x63: {l: {0x75: {l: {0x72: {l: {0x6C: {l: {0x79: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [8828]}}}}}}}}}}}}}}}, 0x65: {l: {0x71: {l: {0x3B: {c: [10927]}}}}}, 0x6E: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [10937]}}}}}}}}}}}}}, 0x65: {l: {0x71: {l: {0x71: {l: {0x3B: {c: [10933]}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8936]}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8830]}}}}}}}}}, 0x3B: {c: [10927]}}}, 0x45: {l: {0x3B: {c: [10931]}}}, 0x69: {l: {0x6D: {l: {0x65: {l: {0x3B: {c: [8242]}, 0x73: {l: {0x3B: {c: [8473]}}}}}}}}}, 0x6E: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10937]}}}}}, 0x45: {l: {0x3B: {c: [10933]}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8936]}}}}}}}}}, 0x6F: {l: {0x64: {l: {0x3B: {c: [8719]}}}, 0x66: {l: {0x61: {l: {0x6C: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [9006]}}}}}}}}}, 0x6C: {l: {0x69: {l: {0x6E: {l: {0x65: {l: {0x3B: {c: [8978]}}}}}}}}}, 0x73: {l: {0x75: {l: {0x72: {l: {0x66: {l: {0x3B: {c: [8979]}}}}}}}}}}}, 0x70: {l: {0x3B: {c: [8733]}, 0x74: {l: {0x6F: {l: {0x3B: {c: [8733]}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8830]}}}}}}}, 0x75: {l: {0x72: {l: {0x65: {l: {0x6C: {l: {0x3B: {c: [8880]}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120005]}}}}}, 0x69: {l: {0x3B: {c: [968]}}}}}, 0x75: {l: {0x6E: {l: {0x63: {l: {0x73: {l: {0x70: {l: {0x3B: {c: [8200]}}}}}}}}}}}}},
    0x50: {l: {0x61: {l: {0x72: {l: {0x74: {l: {0x69: {l: {0x61: {l: {0x6C: {l: {0x44: {l: {0x3B: {c: [8706]}}}}}}}}}}}}}}}, 0x63: {l: {0x79: {l: {0x3B: {c: [1055]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120083]}}}}}, 0x68: {l: {0x69: {l: {0x3B: {c: [934]}}}}}, 0x69: {l: {0x3B: {c: [928]}}}, 0x6C: {l: {0x75: {l: {0x73: {l: {0x4D: {l: {0x69: {l: {0x6E: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [177]}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x69: {l: {0x6E: {l: {0x63: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x70: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x65: {l: {0x3B: {c: [8460]}}}}}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [8473]}}}}}}}, 0x72: {l: {0x3B: {c: [10939]}, 0x65: {l: {0x63: {l: {0x65: {l: {0x64: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8826]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [10927]}}}}}}}}}}}, 0x53: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8828]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8830]}}}}}}}}}}}}}}}}}}}}}}}, 0x69: {l: {0x6D: {l: {0x65: {l: {0x3B: {c: [8243]}}}}}}}, 0x6F: {l: {0x64: {l: {0x75: {l: {0x63: {l: {0x74: {l: {0x3B: {c: [8719]}}}}}}}}}, 0x70: {l: {0x6F: {l: {0x72: {l: {0x74: {l: {0x69: {l: {0x6F: {l: {0x6E: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8733]}}}}}, 0x3B: {c: [8759]}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119979]}}}}}, 0x69: {l: {0x3B: {c: [936]}}}}}}},
    0x51: {l: {0x66: {l: {0x72: {l: {0x3B: {c: [120084]}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [8474]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119980]}}}}}}}, 0x55: {l: {0x4F: {l: {0x54: {l: {0x3B: {c: [34]}}, c: [34]}}}}}}},
    0x71: {l: {0x66: {l: {0x72: {l: {0x3B: {c: [120110]}}}}}, 0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10764]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120162]}}}}}}}, 0x70: {l: {0x72: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x3B: {c: [8279]}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120006]}}}}}}}, 0x75: {l: {0x61: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x6E: {l: {0x69: {l: {0x6F: {l: {0x6E: {l: {0x73: {l: {0x3B: {c: [8461]}}}}}}}}}}}}}}}, 0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10774]}}}}}}}}}}}, 0x65: {l: {0x73: {l: {0x74: {l: {0x3B: {c: [63]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8799]}}}}}}}}}}}, 0x6F: {l: {0x74: {l: {0x3B: {c: [34]}}, c: [34]}}}}}}},
    0x72: {l: {0x41: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8667]}}}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8658]}}}}}, 0x74: {l: {0x61: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [10524]}}}}}}}}}}}, 0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8765, 817]}}}, 0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [341]}}}}}}}}}, 0x64: {l: {0x69: {l: {0x63: {l: {0x3B: {c: [8730]}}}}}}}, 0x65: {l: {0x6D: {l: {0x70: {l: {0x74: {l: {0x79: {l: {0x76: {l: {0x3B: {c: [10675]}}}}}}}}}}}}}, 0x6E: {l: {0x67: {l: {0x3B: {c: [10217]}, 0x64: {l: {0x3B: {c: [10642]}}}, 0x65: {l: {0x3B: {c: [10661]}}}, 0x6C: {l: {0x65: {l: {0x3B: {c: [10217]}}}}}}}}}, 0x71: {l: {0x75: {l: {0x6F: {l: {0x3B: {c: [187]}}, c: [187]}}}}}, 0x72: {l: {0x72: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10613]}}}}}, 0x62: {l: {0x3B: {c: [8677]}, 0x66: {l: {0x73: {l: {0x3B: {c: [10528]}}}}}}}, 0x63: {l: {0x3B: {c: [10547]}}}, 0x3B: {c: [8594]}, 0x66: {l: {0x73: {l: {0x3B: {c: [10526]}}}}}, 0x68: {l: {0x6B: {l: {0x3B: {c: [8618]}}}}}, 0x6C: {l: {0x70: {l: {0x3B: {c: [8620]}}}}}, 0x70: {l: {0x6C: {l: {0x3B: {c: [10565]}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [10612]}}}}}}}, 0x74: {l: {0x6C: {l: {0x3B: {c: [8611]}}}}}, 0x77: {l: {0x3B: {c: [8605]}}}}}}}, 0x74: {l: {0x61: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [10522]}}}}}}}, 0x69: {l: {0x6F: {l: {0x3B: {c: [8758]}, 0x6E: {l: {0x61: {l: {0x6C: {l: {0x73: {l: {0x3B: {c: [8474]}}}}}}}}}}}}}}}}}, 0x62: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10509]}}}}}}}, 0x62: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [10099]}}}}}}}, 0x72: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [125]}}}, 0x6B: {l: {0x3B: {c: [93]}}}}}}}, 0x6B: {l: {0x65: {l: {0x3B: {c: [10636]}}}, 0x73: {l: {0x6C: {l: {0x64: {l: {0x3B: {c: [10638]}}}, 0x75: {l: {0x3B: {c: [10640]}}}}}}}}}}}}}, 0x42: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10511]}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [345]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [343]}}}}}}}, 0x69: {l: {0x6C: {l: {0x3B: {c: [8969]}}}}}}}, 0x75: {l: {0x62: {l: {0x3B: {c: [125]}}}}}, 0x79: {l: {0x3B: {c: [1088]}}}}}, 0x64: {l: {0x63: {l: {0x61: {l: {0x3B: {c: [10551]}}}}}, 0x6C: {l: {0x64: {l: {0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10601]}}}}}}}}}}}, 0x71: {l: {0x75: {l: {0x6F: {l: {0x3B: {c: [8221]}, 0x72: {l: {0x3B: {c: [8221]}}}}}}}}}, 0x73: {l: {0x68: {l: {0x3B: {c: [8627]}}}}}}}, 0x65: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8476]}, 0x69: {l: {0x6E: {l: {0x65: {l: {0x3B: {c: [8475]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x74: {l: {0x3B: {c: [8476]}}}}}}}}}, 0x73: {l: {0x3B: {c: [8477]}}}}}}}, 0x63: {l: {0x74: {l: {0x3B: {c: [9645]}}}}}, 0x67: {l: {0x3B: {c: [174]}}, c: [174]}}}, 0x66: {l: {0x69: {l: {0x73: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [10621]}}}}}}}}}, 0x6C: {l: {0x6F: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [8971]}}}}}}}}}, 0x72: {l: {0x3B: {c: [120111]}}}}}, 0x48: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10596]}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x64: {l: {0x3B: {c: [8641]}}}, 0x75: {l: {0x3B: {c: [8640]}, 0x6C: {l: {0x3B: {c: [10604]}}}}}}}}}, 0x6F: {l: {0x3B: {c: [961]}, 0x76: {l: {0x3B: {c: [1009]}}}}}}}, 0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8594]}, 0x74: {l: {0x61: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [8611]}}}}}}}}}}}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x70: {l: {0x6F: {l: {0x6F: {l: {0x6E: {l: {0x64: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x3B: {c: [8641]}}}}}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [8640]}}}}}}}}}}}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x73: {l: {0x3B: {c: [8644]}}}}}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x70: {l: {0x6F: {l: {0x6F: {l: {0x6E: {l: {0x73: {l: {0x3B: {c: [8652]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x73: {l: {0x3B: {c: [8649]}}}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x71: {l: {0x75: {l: {0x69: {l: {0x67: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8605]}}}}}}}}}}}}}}}}}}}}}, 0x74: {l: {0x68: {l: {0x72: {l: {0x65: {l: {0x65: {l: {0x74: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8908]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6E: {l: {0x67: {l: {0x3B: {c: [730]}}}}}, 0x73: {l: {0x69: {l: {0x6E: {l: {0x67: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x73: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [8787]}}}}}}}}}}}}}}}}}}}}}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8644]}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8652]}}}}}}}, 0x6D: {l: {0x3B: {c: [8207]}}}}}, 0x6D: {l: {0x6F: {l: {0x75: {l: {0x73: {l: {0x74: {l: {0x61: {l: {0x63: {l: {0x68: {l: {0x65: {l: {0x3B: {c: [9137]}}}}}}}}}, 0x3B: {c: [9137]}}}}}}}}}}}, 0x6E: {l: {0x6D: {l: {0x69: {l: {0x64: {l: {0x3B: {c: [10990]}}}}}}}}}, 0x6F: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [10221]}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8702]}}}}}}}, 0x62: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [10215]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10630]}}}}}, 0x66: {l: {0x3B: {c: [120163]}}}, 0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10798]}}}}}}}}}, 0x74: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [10805]}}}}}}}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [41]}, 0x67: {l: {0x74: {l: {0x3B: {c: [10644]}}}}}}}}}, 0x70: {l: {0x6F: {l: {0x6C: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10770]}}}}}}}}}}}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8649]}}}}}}}}}, 0x73: {l: {0x61: {l: {0x71: {l: {0x75: {l: {0x6F: {l: {0x3B: {c: [8250]}}}}}}}}}, 0x63: {l: {0x72: {l: {0x3B: {c: [120007]}}}}}, 0x68: {l: {0x3B: {c: [8625]}}}, 0x71: {l: {0x62: {l: {0x3B: {c: [93]}}}, 0x75: {l: {0x6F: {l: {0x3B: {c: [8217]}, 0x72: {l: {0x3B: {c: [8217]}}}}}}}}}}}, 0x74: {l: {0x68: {l: {0x72: {l: {0x65: {l: {0x65: {l: {0x3B: {c: [8908]}}}}}}}}}, 0x69: {l: {0x6D: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [8906]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x3B: {c: [9657]}, 0x65: {l: {0x3B: {c: [8885]}}}, 0x66: {l: {0x3B: {c: [9656]}}}, 0x6C: {l: {0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [10702]}}}}}}}}}}}}}}}, 0x75: {l: {0x6C: {l: {0x75: {l: {0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10600]}}}}}}}}}}}}}, 0x78: {l: {0x3B: {c: [8478]}}}}},
    0x52: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [340]}}}}}}}}}, 0x6E: {l: {0x67: {l: {0x3B: {c: [10219]}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8608]}, 0x74: {l: {0x6C: {l: {0x3B: {c: [10518]}}}}}}}}}}}, 0x42: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10512]}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [344]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [342]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1056]}}}}}, 0x65: {l: {0x3B: {c: [8476]}, 0x76: {l: {0x65: {l: {0x72: {l: {0x73: {l: {0x65: {l: {0x45: {l: {0x6C: {l: {0x65: {l: {0x6D: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [8715]}}}}}}}}}}}}}, 0x71: {l: {0x75: {l: {0x69: {l: {0x6C: {l: {0x69: {l: {0x62: {l: {0x72: {l: {0x69: {l: {0x75: {l: {0x6D: {l: {0x3B: {c: [8651]}}}}}}}}}}}}}}}}}}}}}}}, 0x55: {l: {0x70: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x69: {l: {0x6C: {l: {0x69: {l: {0x62: {l: {0x72: {l: {0x69: {l: {0x75: {l: {0x6D: {l: {0x3B: {c: [10607]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x45: {l: {0x47: {l: {0x3B: {c: [174]}}, c: [174]}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [8476]}}}}}, 0x68: {l: {0x6F: {l: {0x3B: {c: [929]}}}}}, 0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x42: {l: {0x72: {l: {0x61: {l: {0x63: {l: {0x6B: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [10217]}}}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8677]}}}}}}}, 0x3B: {c: [8594]}, 0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8644]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8658]}}}}}}}}}}}, 0x43: {l: {0x65: {l: {0x69: {l: {0x6C: {l: {0x69: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [8969]}}}}}}}}}}}}}}}, 0x44: {l: {0x6F: {l: {0x75: {l: {0x62: {l: {0x6C: {l: {0x65: {l: {0x42: {l: {0x72: {l: {0x61: {l: {0x63: {l: {0x6B: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [10215]}}}}}}}}}}}}}}}}}}}}}}}, 0x77: {l: {0x6E: {l: {0x54: {l: {0x65: {l: {0x65: {l: {0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10589]}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10581]}}}}}}}, 0x3B: {c: [8642]}}}}}}}}}}}}}}}}}}}}}, 0x46: {l: {0x6C: {l: {0x6F: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [8971]}}}}}}}}}}}, 0x54: {l: {0x65: {l: {0x65: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8614]}}}}}}}}}}}, 0x3B: {c: [8866]}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10587]}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10704]}}}}}}}, 0x3B: {c: [8883]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8885]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x55: {l: {0x70: {l: {0x44: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10575]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x65: {l: {0x65: {l: {0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10588]}}}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10580]}}}}}}}, 0x3B: {c: [8638]}}}}}}}}}}}}}}}}}, 0x56: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10579]}}}}}}}, 0x3B: {c: [8640]}}}}}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [8477]}}}}}, 0x75: {l: {0x6E: {l: {0x64: {l: {0x49: {l: {0x6D: {l: {0x70: {l: {0x6C: {l: {0x69: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [10608]}}}}}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8667]}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [8475]}}}}}, 0x68: {l: {0x3B: {c: [8625]}}}}}, 0x75: {l: {0x6C: {l: {0x65: {l: {0x44: {l: {0x65: {l: {0x6C: {l: {0x61: {l: {0x79: {l: {0x65: {l: {0x64: {l: {0x3B: {c: [10740]}}}}}}}}}}}}}}}}}}}}}}},
    0x53: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [346]}}}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [352]}}}}}}}}}, 0x3B: {c: [10940]}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [350]}}}}}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [348]}}}}}}}, 0x79: {l: {0x3B: {c: [1057]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120086]}}}}}, 0x48: {l: {0x43: {l: {0x48: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1065]}}}}}}}}}, 0x63: {l: {0x79: {l: {0x3B: {c: [1064]}}}}}}}, 0x68: {l: {0x6F: {l: {0x72: {l: {0x74: {l: {0x44: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8595]}}}}}}}}}}}}}}}}}}}, 0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8592]}}}}}}}}}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8594]}}}}}}}}}}}}}}}}}}}}}, 0x55: {l: {0x70: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8593]}}}}}}}}}}}}}}}}}}}}}}}, 0x69: {l: {0x67: {l: {0x6D: {l: {0x61: {l: {0x3B: {c: [931]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x43: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x6C: {l: {0x65: {l: {0x3B: {c: [8728]}}}}}}}}}}}}}}}}}}}}}, 0x4F: {l: {0x46: {l: {0x54: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1068]}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120138]}}}}}}}, 0x71: {l: {0x72: {l: {0x74: {l: {0x3B: {c: [8730]}}}}}, 0x75: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [9633]}, 0x49: {l: {0x6E: {l: {0x74: {l: {0x65: {l: {0x72: {l: {0x73: {l: {0x65: {l: {0x63: {l: {0x74: {l: {0x69: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8851]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x53: {l: {0x75: {l: {0x62: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8847]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8849]}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x65: {l: {0x72: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8848]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8850]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x55: {l: {0x6E: {l: {0x69: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8852]}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119982]}}}}}}}, 0x74: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8902]}}}}}}}, 0x75: {l: {0x62: {l: {0x3B: {c: [8912]}, 0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8912]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8838]}}}}}}}}}}}}}}}}}}}, 0x63: {l: {0x63: {l: {0x65: {l: {0x65: {l: {0x64: {l: {0x73: {l: {0x3B: {c: [8827]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [10928]}}}}}}}}}}}, 0x53: {l: {0x6C: {l: {0x61: {l: {0x6E: {l: {0x74: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8829]}}}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8831]}}}}}}}}}}}}}}}}}}}}}, 0x68: {l: {0x54: {l: {0x68: {l: {0x61: {l: {0x74: {l: {0x3B: {c: [8715]}}}}}}}}}}}}}, 0x6D: {l: {0x3B: {c: [8721]}}}, 0x70: {l: {0x3B: {c: [8913]}, 0x65: {l: {0x72: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8835]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8839]}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8913]}}}}}}}}}}}}},
    0x73: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [347]}}}}}}}}}}}, 0x62: {l: {0x71: {l: {0x75: {l: {0x6F: {l: {0x3B: {c: [8218]}}}}}}}}}, 0x63: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10936]}}}, 0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [353]}}}}}}}}}, 0x3B: {c: [8827]}, 0x63: {l: {0x75: {l: {0x65: {l: {0x3B: {c: [8829]}}}}}}}, 0x65: {l: {0x3B: {c: [10928]}, 0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [351]}}}}}}}}}, 0x45: {l: {0x3B: {c: [10932]}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [349]}}}}}}}, 0x6E: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10938]}}}}}, 0x45: {l: {0x3B: {c: [10934]}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8937]}}}}}}}}}, 0x70: {l: {0x6F: {l: {0x6C: {l: {0x69: {l: {0x6E: {l: {0x74: {l: {0x3B: {c: [10771]}}}}}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8831]}}}}}}}, 0x79: {l: {0x3B: {c: [1089]}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x62: {l: {0x3B: {c: [8865]}}}, 0x3B: {c: [8901]}, 0x65: {l: {0x3B: {c: [10854]}}}}}}}}}, 0x65: {l: {0x61: {l: {0x72: {l: {0x68: {l: {0x6B: {l: {0x3B: {c: [10533]}}}}}, 0x72: {l: {0x3B: {c: [8600]}, 0x6F: {l: {0x77: {l: {0x3B: {c: [8600]}}}}}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8664]}}}}}}}, 0x63: {l: {0x74: {l: {0x3B: {c: [167]}}, c: [167]}}}, 0x6D: {l: {0x69: {l: {0x3B: {c: [59]}}}}}, 0x73: {l: {0x77: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10537]}}}}}}}}}, 0x74: {l: {0x6D: {l: {0x69: {l: {0x6E: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8726]}}}}}}}}}, 0x6E: {l: {0x3B: {c: [8726]}}}}}}}, 0x78: {l: {0x74: {l: {0x3B: {c: [10038]}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120112]}, 0x6F: {l: {0x77: {l: {0x6E: {l: {0x3B: {c: [8994]}}}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x70: {l: {0x3B: {c: [9839]}}}}}}}, 0x63: {l: {0x68: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1097]}}}}}}}, 0x79: {l: {0x3B: {c: [1096]}}}}}, 0x6F: {l: {0x72: {l: {0x74: {l: {0x6D: {l: {0x69: {l: {0x64: {l: {0x3B: {c: [8739]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x65: {l: {0x6C: {l: {0x3B: {c: [8741]}}}}}}}}}}}}}}}}}}}}}}}, 0x79: {l: {0x3B: {c: [173]}}, c: [173]}}}, 0x69: {l: {0x67: {l: {0x6D: {l: {0x61: {l: {0x3B: {c: [963]}, 0x66: {l: {0x3B: {c: [962]}}}, 0x76: {l: {0x3B: {c: [962]}}}}}}}}}, 0x6D: {l: {0x3B: {c: [8764]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10858]}}}}}}}, 0x65: {l: {0x3B: {c: [8771]}, 0x71: {l: {0x3B: {c: [8771]}}}}}, 0x67: {l: {0x3B: {c: [10910]}, 0x45: {l: {0x3B: {c: [10912]}}}}}, 0x6C: {l: {0x3B: {c: [10909]}, 0x45: {l: {0x3B: {c: [10911]}}}}}, 0x6E: {l: {0x65: {l: {0x3B: {c: [8774]}}}}}, 0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10788]}}}}}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10610]}}}}}}}}}}}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8592]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x6C: {l: {0x6C: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x6D: {l: {0x69: {l: {0x6E: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8726]}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x68: {l: {0x70: {l: {0x3B: {c: [10803]}}}}}}}}}, 0x65: {l: {0x70: {l: {0x61: {l: {0x72: {l: {0x73: {l: {0x6C: {l: {0x3B: {c: [10724]}}}}}}}}}}}}}, 0x69: {l: {0x64: {l: {0x3B: {c: [8739]}}}, 0x6C: {l: {0x65: {l: {0x3B: {c: [8995]}}}}}}}, 0x74: {l: {0x3B: {c: [10922]}, 0x65: {l: {0x3B: {c: [10924]}, 0x73: {l: {0x3B: {c: [10924, 65024]}}}}}}}}}, 0x6F: {l: {0x66: {l: {0x74: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1100]}}}}}}}}}, 0x6C: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [9023]}}}}}, 0x3B: {c: [10692]}}}, 0x3B: {c: [47]}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120164]}}}}}}}, 0x70: {l: {0x61: {l: {0x64: {l: {0x65: {l: {0x73: {l: {0x3B: {c: [9824]}, 0x75: {l: {0x69: {l: {0x74: {l: {0x3B: {c: [9824]}}}}}}}}}}}}}, 0x72: {l: {0x3B: {c: [8741]}}}}}}}, 0x71: {l: {0x63: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [8851]}, 0x73: {l: {0x3B: {c: [8851, 65024]}}}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [8852]}, 0x73: {l: {0x3B: {c: [8852, 65024]}}}}}}}}}, 0x73: {l: {0x75: {l: {0x62: {l: {0x3B: {c: [8847]}, 0x65: {l: {0x3B: {c: [8849]}}}, 0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8847]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8849]}}}}}}}}}}}}}, 0x70: {l: {0x3B: {c: [8848]}, 0x65: {l: {0x3B: {c: [8850]}}}, 0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8848]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8850]}}}}}}}}}}}}}}}}}, 0x75: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [9633]}}}, 0x66: {l: {0x3B: {c: [9642]}}}}}}}, 0x3B: {c: [9633]}, 0x66: {l: {0x3B: {c: [9642]}}}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8594]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120008]}}}}}, 0x65: {l: {0x74: {l: {0x6D: {l: {0x6E: {l: {0x3B: {c: [8726]}}}}}}}}}, 0x6D: {l: {0x69: {l: {0x6C: {l: {0x65: {l: {0x3B: {c: [8995]}}}}}}}}}, 0x74: {l: {0x61: {l: {0x72: {l: {0x66: {l: {0x3B: {c: [8902]}}}}}}}}}}}, 0x74: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [9734]}, 0x66: {l: {0x3B: {c: [9733]}}}}}}}, 0x72: {l: {0x61: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x65: {l: {0x70: {l: {0x73: {l: {0x69: {l: {0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [1013]}}}}}}}}}}}}}}}, 0x70: {l: {0x68: {l: {0x69: {l: {0x3B: {c: [981]}}}}}}}}}}}}}}}}}, 0x6E: {l: {0x73: {l: {0x3B: {c: [175]}}}}}}}}}, 0x75: {l: {0x62: {l: {0x3B: {c: [8834]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10941]}}}}}}}, 0x45: {l: {0x3B: {c: [10949]}}}, 0x65: {l: {0x3B: {c: [8838]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10947]}}}}}}}}}, 0x6D: {l: {0x75: {l: {0x6C: {l: {0x74: {l: {0x3B: {c: [10945]}}}}}}}}}, 0x6E: {l: {0x45: {l: {0x3B: {c: [10955]}}}, 0x65: {l: {0x3B: {c: [8842]}}}}}, 0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10943]}}}}}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10617]}}}}}}}}}, 0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8834]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8838]}, 0x71: {l: {0x3B: {c: [10949]}}}}}}}, 0x6E: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [8842]}, 0x71: {l: {0x3B: {c: [10955]}}}}}}}}}}}}}, 0x69: {l: {0x6D: {l: {0x3B: {c: [10951]}}}}}, 0x75: {l: {0x62: {l: {0x3B: {c: [10965]}}}, 0x70: {l: {0x3B: {c: [10963]}}}}}}}}}, 0x63: {l: {0x63: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [10936]}}}}}}}}}}}}}, 0x3B: {c: [8827]}, 0x63: {l: {0x75: {l: {0x72: {l: {0x6C: {l: {0x79: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [8829]}}}}}}}}}}}}}}}, 0x65: {l: {0x71: {l: {0x3B: {c: [10928]}}}}}, 0x6E: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [10938]}}}}}}}}}}}}}, 0x65: {l: {0x71: {l: {0x71: {l: {0x3B: {c: [10934]}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8937]}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8831]}}}}}}}}}}}, 0x6D: {l: {0x3B: {c: [8721]}}}, 0x6E: {l: {0x67: {l: {0x3B: {c: [9834]}}}}}, 0x70: {l: {0x31: {l: {0x3B: {c: [185]}}, c: [185]}, 0x32: {l: {0x3B: {c: [178]}}, c: [178]}, 0x33: {l: {0x3B: {c: [179]}}, c: [179]}, 0x3B: {c: [8835]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10942]}}}}}, 0x73: {l: {0x75: {l: {0x62: {l: {0x3B: {c: [10968]}}}}}}}}}, 0x45: {l: {0x3B: {c: [10950]}}}, 0x65: {l: {0x3B: {c: [8839]}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10948]}}}}}}}}}, 0x68: {l: {0x73: {l: {0x6F: {l: {0x6C: {l: {0x3B: {c: [10185]}}}}}, 0x75: {l: {0x62: {l: {0x3B: {c: [10967]}}}}}}}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10619]}}}}}}}}}, 0x6D: {l: {0x75: {l: {0x6C: {l: {0x74: {l: {0x3B: {c: [10946]}}}}}}}}}, 0x6E: {l: {0x45: {l: {0x3B: {c: [10956]}}}, 0x65: {l: {0x3B: {c: [8843]}}}}}, 0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10944]}}}}}}}}}, 0x73: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8835]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8839]}, 0x71: {l: {0x3B: {c: [10950]}}}}}}}, 0x6E: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [8843]}, 0x71: {l: {0x3B: {c: [10956]}}}}}}}}}}}}}, 0x69: {l: {0x6D: {l: {0x3B: {c: [10952]}}}}}, 0x75: {l: {0x62: {l: {0x3B: {c: [10964]}}}, 0x70: {l: {0x3B: {c: [10966]}}}}}}}}}}}, 0x77: {l: {0x61: {l: {0x72: {l: {0x68: {l: {0x6B: {l: {0x3B: {c: [10534]}}}}}, 0x72: {l: {0x3B: {c: [8601]}, 0x6F: {l: {0x77: {l: {0x3B: {c: [8601]}}}}}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8665]}}}}}}}, 0x6E: {l: {0x77: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10538]}}}}}}}}}}}, 0x7A: {l: {0x6C: {l: {0x69: {l: {0x67: {l: {0x3B: {c: [223]}}, c: [223]}}}}}}}}},
    0x54: {l: {0x61: {l: {0x62: {l: {0x3B: {c: [9]}}}, 0x75: {l: {0x3B: {c: [932]}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [356]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [354]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1058]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120087]}}}}}, 0x68: {l: {0x65: {l: {0x72: {l: {0x65: {l: {0x66: {l: {0x6F: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [8756]}}}}}}}}}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [920]}}}}}}}, 0x69: {l: {0x63: {l: {0x6B: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8287, 8202]}}}}}}}}}}}}}}}, 0x6E: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8201]}}}}}}}}}}}}}}}}}, 0x48: {l: {0x4F: {l: {0x52: {l: {0x4E: {l: {0x3B: {c: [222]}}, c: [222]}}}}}}}, 0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8764]}, 0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8771]}}}}}}}}}}}, 0x46: {l: {0x75: {l: {0x6C: {l: {0x6C: {l: {0x45: {l: {0x71: {l: {0x75: {l: {0x61: {l: {0x6C: {l: {0x3B: {c: [8773]}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8776]}}}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120139]}}}}}}}, 0x52: {l: {0x41: {l: {0x44: {l: {0x45: {l: {0x3B: {c: [8482]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x70: {l: {0x6C: {l: {0x65: {l: {0x44: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8411]}}}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119983]}}}}}, 0x74: {l: {0x72: {l: {0x6F: {l: {0x6B: {l: {0x3B: {c: [358]}}}}}}}}}}}, 0x53: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1062]}}}}}, 0x48: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1035]}}}}}}}}}}},
    0x74: {l: {0x61: {l: {0x72: {l: {0x67: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [8982]}}}}}}}}}, 0x75: {l: {0x3B: {c: [964]}}}}}, 0x62: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [9140]}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [357]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x69: {l: {0x6C: {l: {0x3B: {c: [355]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1090]}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8411]}}}}}}}, 0x65: {l: {0x6C: {l: {0x72: {l: {0x65: {l: {0x63: {l: {0x3B: {c: [8981]}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120113]}}}}}, 0x68: {l: {0x65: {l: {0x72: {l: {0x65: {l: {0x34: {l: {0x3B: {c: [8756]}}}, 0x66: {l: {0x6F: {l: {0x72: {l: {0x65: {l: {0x3B: {c: [8756]}}}}}}}}}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [952]}, 0x73: {l: {0x79: {l: {0x6D: {l: {0x3B: {c: [977]}}}}}}}, 0x76: {l: {0x3B: {c: [977]}}}}}}}}}, 0x69: {l: {0x63: {l: {0x6B: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x72: {l: {0x6F: {l: {0x78: {l: {0x3B: {c: [8776]}}}}}}}}}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8764]}}}}}}}}}}}, 0x6E: {l: {0x73: {l: {0x70: {l: {0x3B: {c: [8201]}}}}}}}}}, 0x6B: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [8776]}}}}}, 0x73: {l: {0x69: {l: {0x6D: {l: {0x3B: {c: [8764]}}}}}}}}}, 0x6F: {l: {0x72: {l: {0x6E: {l: {0x3B: {c: [254]}}, c: [254]}}}}}}}, 0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [732]}}}}}}}, 0x6D: {l: {0x65: {l: {0x73: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10801]}}}}}, 0x3B: {c: [8864]}}}, 0x3B: {c: [215]}, 0x64: {l: {0x3B: {c: [10800]}}}}, c: [215]}}}}}, 0x6E: {l: {0x74: {l: {0x3B: {c: [8749]}}}}}}}, 0x6F: {l: {0x65: {l: {0x61: {l: {0x3B: {c: [10536]}}}}}, 0x70: {l: {0x62: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [9014]}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10993]}}}}}}}, 0x3B: {c: [8868]}, 0x66: {l: {0x3B: {c: [120165]}, 0x6F: {l: {0x72: {l: {0x6B: {l: {0x3B: {c: [10970]}}}}}}}}}}}, 0x73: {l: {0x61: {l: {0x3B: {c: [10537]}}}}}}}, 0x70: {l: {0x72: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x3B: {c: [8244]}}}}}}}}}}}, 0x72: {l: {0x61: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8482]}}}}}}}, 0x69: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x3B: {c: [9653]}, 0x64: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x3B: {c: [9663]}}}}}}}}}, 0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [9667]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8884]}}}}}}}}}}}}}, 0x71: {l: {0x3B: {c: [8796]}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [9657]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8885]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [9708]}}}}}}}, 0x65: {l: {0x3B: {c: [8796]}}}, 0x6D: {l: {0x69: {l: {0x6E: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10810]}}}}}}}}}}}, 0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10809]}}}}}}}}}, 0x73: {l: {0x62: {l: {0x3B: {c: [10701]}}}}}, 0x74: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x3B: {c: [10811]}}}}}}}}}}}, 0x70: {l: {0x65: {l: {0x7A: {l: {0x69: {l: {0x75: {l: {0x6D: {l: {0x3B: {c: [9186]}}}}}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120009]}}}, 0x79: {l: {0x3B: {c: [1094]}}}}}, 0x68: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1115]}}}}}}}, 0x74: {l: {0x72: {l: {0x6F: {l: {0x6B: {l: {0x3B: {c: [359]}}}}}}}}}}}, 0x77: {l: {0x69: {l: {0x78: {l: {0x74: {l: {0x3B: {c: [8812]}}}}}}}, 0x6F: {l: {0x68: {l: {0x65: {l: {0x61: {l: {0x64: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8606]}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8608]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},
    0x55: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [218]}}, c: [218]}}}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8607]}, 0x6F: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x3B: {c: [10569]}}}}}}}}}}}}}}}, 0x62: {l: {0x72: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1038]}}}}}, 0x65: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [364]}}}}}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [219]}}, c: [219]}}}}}, 0x79: {l: {0x3B: {c: [1059]}}}}}, 0x64: {l: {0x62: {l: {0x6C: {l: {0x61: {l: {0x63: {l: {0x3B: {c: [368]}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120088]}}}}}, 0x67: {l: {0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [217]}}, c: [217]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [362]}}}}}}}}}, 0x6E: {l: {0x64: {l: {0x65: {l: {0x72: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [95]}}}}}, 0x72: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [9183]}}}, 0x6B: {l: {0x65: {l: {0x74: {l: {0x3B: {c: [9141]}}}}}}}}}}}}}}}, 0x50: {l: {0x61: {l: {0x72: {l: {0x65: {l: {0x6E: {l: {0x74: {l: {0x68: {l: {0x65: {l: {0x73: {l: {0x69: {l: {0x73: {l: {0x3B: {c: [9181]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x69: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [8899]}, 0x50: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8846]}}}}}}}}}}}}}}}}}, 0x6F: {l: {0x67: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [370]}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120140]}}}}}}}, 0x70: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10514]}}}}}}}, 0x3B: {c: [8593]}, 0x44: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8645]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8657]}}}}}}}}}}}, 0x44: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8597]}}}}}}}}}}}}}}}}}}}, 0x64: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8661]}}}}}}}}}}}}}}}}}}}, 0x45: {l: {0x71: {l: {0x75: {l: {0x69: {l: {0x6C: {l: {0x69: {l: {0x62: {l: {0x72: {l: {0x69: {l: {0x75: {l: {0x6D: {l: {0x3B: {c: [10606]}}}}}}}}}}}}}}}}}}}}}}}, 0x70: {l: {0x65: {l: {0x72: {l: {0x4C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8598]}}}}}}}}}}}}}}}}}}}, 0x52: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8599]}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x73: {l: {0x69: {l: {0x3B: {c: [978]}, 0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [933]}}}}}}}}}}}, 0x54: {l: {0x65: {l: {0x65: {l: {0x41: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8613]}}}}}}}}}}}, 0x3B: {c: [8869]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [366]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119984]}}}}}}}, 0x74: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [360]}}}}}}}}}}}, 0x75: {l: {0x6D: {l: {0x6C: {l: {0x3B: {c: [220]}}, c: [220]}}}}}}},
    0x75: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [250]}}, c: [250]}}}}}}}, 0x72: {l: {0x72: {l: {0x3B: {c: [8593]}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8657]}}}}}}}, 0x62: {l: {0x72: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1118]}}}}}, 0x65: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [365]}}}}}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [251]}}, c: [251]}}}}}, 0x79: {l: {0x3B: {c: [1091]}}}}}, 0x64: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8645]}}}}}}}, 0x62: {l: {0x6C: {l: {0x61: {l: {0x63: {l: {0x3B: {c: [369]}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10606]}}}}}}}}}, 0x66: {l: {0x69: {l: {0x73: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [10622]}}}}}}}}}, 0x72: {l: {0x3B: {c: [120114]}}}}}, 0x67: {l: {0x72: {l: {0x61: {l: {0x76: {l: {0x65: {l: {0x3B: {c: [249]}}, c: [249]}}}}}}}}}, 0x48: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10595]}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x6C: {l: {0x3B: {c: [8639]}}}, 0x72: {l: {0x3B: {c: [8638]}}}}}}}, 0x62: {l: {0x6C: {l: {0x6B: {l: {0x3B: {c: [9600]}}}}}}}}}, 0x6C: {l: {0x63: {l: {0x6F: {l: {0x72: {l: {0x6E: {l: {0x3B: {c: [8988]}, 0x65: {l: {0x72: {l: {0x3B: {c: [8988]}}}}}}}}}}}, 0x72: {l: {0x6F: {l: {0x70: {l: {0x3B: {c: [8975]}}}}}}}}}, 0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [9720]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [363]}}}}}}}, 0x6C: {l: {0x3B: {c: [168]}}, c: [168]}}}, 0x6F: {l: {0x67: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [371]}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120166]}}}}}}}, 0x70: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8593]}}}}}}}}}}}, 0x64: {l: {0x6F: {l: {0x77: {l: {0x6E: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x3B: {c: [8597]}}}}}}}}}}}}}}}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x70: {l: {0x6F: {l: {0x6F: {l: {0x6E: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [8639]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [8638]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [8846]}}}}}}}, 0x73: {l: {0x69: {l: {0x3B: {c: [965]}, 0x68: {l: {0x3B: {c: [978]}}}, 0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [965]}}}}}}}}}}}, 0x75: {l: {0x70: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x6F: {l: {0x77: {l: {0x73: {l: {0x3B: {c: [8648]}}}}}}}}}}}}}}}}}}}, 0x72: {l: {0x63: {l: {0x6F: {l: {0x72: {l: {0x6E: {l: {0x3B: {c: [8989]}, 0x65: {l: {0x72: {l: {0x3B: {c: [8989]}}}}}}}}}}}, 0x72: {l: {0x6F: {l: {0x70: {l: {0x3B: {c: [8974]}}}}}}}}}, 0x69: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [367]}}}}}}}, 0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [9721]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120010]}}}}}}}, 0x74: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [8944]}}}}}}}, 0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [361]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x3B: {c: [9653]}, 0x66: {l: {0x3B: {c: [9652]}}}}}}}}}, 0x75: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8648]}}}}}}}, 0x6D: {l: {0x6C: {l: {0x3B: {c: [252]}}, c: [252]}}}}}, 0x77: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x3B: {c: [10663]}}}}}}}}}}}}}}},
    0x76: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x72: {l: {0x74: {l: {0x3B: {c: [10652]}}}}}}}}}, 0x72: {l: {0x65: {l: {0x70: {l: {0x73: {l: {0x69: {l: {0x6C: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [1013]}}}}}}}}}}}}}}}, 0x6B: {l: {0x61: {l: {0x70: {l: {0x70: {l: {0x61: {l: {0x3B: {c: [1008]}}}}}}}}}}}, 0x6E: {l: {0x6F: {l: {0x74: {l: {0x68: {l: {0x69: {l: {0x6E: {l: {0x67: {l: {0x3B: {c: [8709]}}}}}}}}}}}}}}}, 0x70: {l: {0x68: {l: {0x69: {l: {0x3B: {c: [981]}}}}}, 0x69: {l: {0x3B: {c: [982]}}}, 0x72: {l: {0x6F: {l: {0x70: {l: {0x74: {l: {0x6F: {l: {0x3B: {c: [8733]}}}}}}}}}}}}}, 0x72: {l: {0x3B: {c: [8597]}, 0x68: {l: {0x6F: {l: {0x3B: {c: [1009]}}}}}}}, 0x73: {l: {0x69: {l: {0x67: {l: {0x6D: {l: {0x61: {l: {0x3B: {c: [962]}}}}}}}}}, 0x75: {l: {0x62: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x6E: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [8842, 65024]}, 0x71: {l: {0x3B: {c: [10955, 65024]}}}}}}}}}}}}}}}}}, 0x70: {l: {0x73: {l: {0x65: {l: {0x74: {l: {0x6E: {l: {0x65: {l: {0x71: {l: {0x3B: {c: [8843, 65024]}, 0x71: {l: {0x3B: {c: [10956, 65024]}}}}}}}}}}}}}}}}}}}}}, 0x74: {l: {0x68: {l: {0x65: {l: {0x74: {l: {0x61: {l: {0x3B: {c: [977]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x61: {l: {0x6E: {l: {0x67: {l: {0x6C: {l: {0x65: {l: {0x6C: {l: {0x65: {l: {0x66: {l: {0x74: {l: {0x3B: {c: [8882]}}}}}}}}}, 0x72: {l: {0x69: {l: {0x67: {l: {0x68: {l: {0x74: {l: {0x3B: {c: [8883]}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8661]}}}}}}}, 0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10984]}, 0x76: {l: {0x3B: {c: [10985]}}}}}}}}}, 0x63: {l: {0x79: {l: {0x3B: {c: [1074]}}}}}, 0x64: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8866]}}}}}}}}}, 0x44: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8872]}}}}}}}}}, 0x65: {l: {0x65: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8891]}}}}}}}, 0x3B: {c: [8744]}, 0x65: {l: {0x71: {l: {0x3B: {c: [8794]}}}}}}}, 0x6C: {l: {0x6C: {l: {0x69: {l: {0x70: {l: {0x3B: {c: [8942]}}}}}}}}}, 0x72: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [124]}}}}}}}, 0x74: {l: {0x3B: {c: [124]}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120115]}}}}}, 0x6C: {l: {0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [8882]}}}}}}}}}, 0x6E: {l: {0x73: {l: {0x75: {l: {0x62: {l: {0x3B: {c: [8834, 8402]}}}, 0x70: {l: {0x3B: {c: [8835, 8402]}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120167]}}}}}}}, 0x70: {l: {0x72: {l: {0x6F: {l: {0x70: {l: {0x3B: {c: [8733]}}}}}}}}}, 0x72: {l: {0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [8883]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120011]}}}}}, 0x75: {l: {0x62: {l: {0x6E: {l: {0x45: {l: {0x3B: {c: [10955, 65024]}}}, 0x65: {l: {0x3B: {c: [8842, 65024]}}}}}}}, 0x70: {l: {0x6E: {l: {0x45: {l: {0x3B: {c: [10956, 65024]}}}, 0x65: {l: {0x3B: {c: [8843, 65024]}}}}}}}}}}}, 0x7A: {l: {0x69: {l: {0x67: {l: {0x7A: {l: {0x61: {l: {0x67: {l: {0x3B: {c: [10650]}}}}}}}}}}}}}}},
    0x56: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10987]}}}}}}}, 0x63: {l: {0x79: {l: {0x3B: {c: [1042]}}}}}, 0x64: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8873]}, 0x6C: {l: {0x3B: {c: [10982]}}}}}}}}}}}, 0x44: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8875]}}}}}}}}}, 0x65: {l: {0x65: {l: {0x3B: {c: [8897]}}}, 0x72: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8214]}}}}}}}, 0x74: {l: {0x3B: {c: [8214]}, 0x69: {l: {0x63: {l: {0x61: {l: {0x6C: {l: {0x42: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [8739]}}}}}}}, 0x4C: {l: {0x69: {l: {0x6E: {l: {0x65: {l: {0x3B: {c: [124]}}}}}}}}}, 0x53: {l: {0x65: {l: {0x70: {l: {0x61: {l: {0x72: {l: {0x61: {l: {0x74: {l: {0x6F: {l: {0x72: {l: {0x3B: {c: [10072]}}}}}}}}}}}}}}}}}}}, 0x54: {l: {0x69: {l: {0x6C: {l: {0x64: {l: {0x65: {l: {0x3B: {c: [8768]}}}}}}}}}}}}}}}}}}}}}, 0x79: {l: {0x54: {l: {0x68: {l: {0x69: {l: {0x6E: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8202]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120089]}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120141]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119985]}}}}}}}, 0x76: {l: {0x64: {l: {0x61: {l: {0x73: {l: {0x68: {l: {0x3B: {c: [8874]}}}}}}}}}}}}},
    0x57: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [372]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x67: {l: {0x65: {l: {0x3B: {c: [8896]}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120090]}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120142]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119986]}}}}}}}}},
    0x77: {l: {0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [373]}}}}}}}}}, 0x65: {l: {0x64: {l: {0x62: {l: {0x61: {l: {0x72: {l: {0x3B: {c: [10847]}}}}}}}, 0x67: {l: {0x65: {l: {0x3B: {c: [8743]}, 0x71: {l: {0x3B: {c: [8793]}}}}}}}}}, 0x69: {l: {0x65: {l: {0x72: {l: {0x70: {l: {0x3B: {c: [8472]}}}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120116]}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120168]}}}}}}}, 0x70: {l: {0x3B: {c: [8472]}}}, 0x72: {l: {0x3B: {c: [8768]}, 0x65: {l: {0x61: {l: {0x74: {l: {0x68: {l: {0x3B: {c: [8768]}}}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120012]}}}}}}}}},
    0x78: {l: {0x63: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [8898]}}}}}, 0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [9711]}}}}}}}, 0x75: {l: {0x70: {l: {0x3B: {c: [8899]}}}}}}}, 0x64: {l: {0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [9661]}}}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120117]}}}}}, 0x68: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10231]}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10234]}}}}}}}}}, 0x69: {l: {0x3B: {c: [958]}}}, 0x6C: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10229]}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10232]}}}}}}}}}, 0x6D: {l: {0x61: {l: {0x70: {l: {0x3B: {c: [10236]}}}}}}}, 0x6E: {l: {0x69: {l: {0x73: {l: {0x3B: {c: [8955]}}}}}}}, 0x6F: {l: {0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [10752]}}}}}}}, 0x70: {l: {0x66: {l: {0x3B: {c: [120169]}}}, 0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10753]}}}}}}}}}, 0x74: {l: {0x69: {l: {0x6D: {l: {0x65: {l: {0x3B: {c: [10754]}}}}}}}}}}}, 0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10230]}}}}}}}, 0x41: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [10233]}}}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120013]}}}}}, 0x71: {l: {0x63: {l: {0x75: {l: {0x70: {l: {0x3B: {c: [10758]}}}}}}}}}}}, 0x75: {l: {0x70: {l: {0x6C: {l: {0x75: {l: {0x73: {l: {0x3B: {c: [10756]}}}}}}}}}, 0x74: {l: {0x72: {l: {0x69: {l: {0x3B: {c: [9651]}}}}}}}}}, 0x76: {l: {0x65: {l: {0x65: {l: {0x3B: {c: [8897]}}}}}}}, 0x77: {l: {0x65: {l: {0x64: {l: {0x67: {l: {0x65: {l: {0x3B: {c: [8896]}}}}}}}}}}}}},
    0x58: {l: {0x66: {l: {0x72: {l: {0x3B: {c: [120091]}}}}}, 0x69: {l: {0x3B: {c: [926]}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120143]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119987]}}}}}}}}},
    0x59: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [221]}}, c: [221]}}}}}}}}}, 0x41: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1071]}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [374]}}}}}}}, 0x79: {l: {0x3B: {c: [1067]}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120092]}}}}}, 0x49: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1031]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120144]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119988]}}}}}}}, 0x55: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1070]}}}}}}}, 0x75: {l: {0x6D: {l: {0x6C: {l: {0x3B: {c: [376]}}}}}}}}},
    0x79: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [253]}}, c: [253]}}}}}, 0x79: {l: {0x3B: {c: [1103]}}}}}}}, 0x63: {l: {0x69: {l: {0x72: {l: {0x63: {l: {0x3B: {c: [375]}}}}}}}, 0x79: {l: {0x3B: {c: [1099]}}}}}, 0x65: {l: {0x6E: {l: {0x3B: {c: [165]}}, c: [165]}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120118]}}}}}, 0x69: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1111]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120170]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120014]}}}}}}}, 0x75: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1102]}}}}}, 0x6D: {l: {0x6C: {l: {0x3B: {c: [255]}}, c: [255]}}}}}}},
    0x5A: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [377]}}}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [381]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1047]}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [379]}}}}}}}, 0x65: {l: {0x72: {l: {0x6F: {l: {0x57: {l: {0x69: {l: {0x64: {l: {0x74: {l: {0x68: {l: {0x53: {l: {0x70: {l: {0x61: {l: {0x63: {l: {0x65: {l: {0x3B: {c: [8203]}}}}}}}}}}}}}}}}}}}}}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [918]}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [8488]}}}}}, 0x48: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1046]}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [8484]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [119989]}}}}}}}}},
    0x7A: {l: {0x61: {l: {0x63: {l: {0x75: {l: {0x74: {l: {0x65: {l: {0x3B: {c: [378]}}}}}}}}}}}, 0x63: {l: {0x61: {l: {0x72: {l: {0x6F: {l: {0x6E: {l: {0x3B: {c: [382]}}}}}}}}}, 0x79: {l: {0x3B: {c: [1079]}}}}}, 0x64: {l: {0x6F: {l: {0x74: {l: {0x3B: {c: [380]}}}}}}}, 0x65: {l: {0x65: {l: {0x74: {l: {0x72: {l: {0x66: {l: {0x3B: {c: [8488]}}}}}}}}}, 0x74: {l: {0x61: {l: {0x3B: {c: [950]}}}}}}}, 0x66: {l: {0x72: {l: {0x3B: {c: [120119]}}}}}, 0x68: {l: {0x63: {l: {0x79: {l: {0x3B: {c: [1078]}}}}}}}, 0x69: {l: {0x67: {l: {0x72: {l: {0x61: {l: {0x72: {l: {0x72: {l: {0x3B: {c: [8669]}}}}}}}}}}}}}, 0x6F: {l: {0x70: {l: {0x66: {l: {0x3B: {c: [120171]}}}}}}}, 0x73: {l: {0x63: {l: {0x72: {l: {0x3B: {c: [120015]}}}}}}}, 0x77: {l: {0x6A: {l: {0x3B: {c: [8205]}}}, 0x6E: {l: {0x6A: {l: {0x3B: {c: [8204]}}}}}}}}}
};
},{}],13:[function(require,module,exports){
'use strict';

var UNICODE = require('../common/unicode');

//Aliases
var $ = UNICODE.CODE_POINTS;

//Utils

//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
//this functions if they will be situated in another module due to context switch.
//Always perform inlining check before modifying this functions ('node --trace-inlining').
function isReservedCodePoint(cp) {
    return cp >= 0xD800 && cp <= 0xDFFF || cp > 0x10FFFF;
}

function isSurrogatePair(cp1, cp2) {
    return cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF;
}

function getSurrogatePairCodePoint(cp1, cp2) {
    return (cp1 - 0xD800) * 0x400 + 0x2400 + cp2;
}

//Preprocessor
//NOTE: HTML input preprocessing
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
var Preprocessor = module.exports = function (html) {
    this.write(html);

    //NOTE: one leading U+FEFF BYTE ORDER MARK character must be ignored if any are present in the input stream.
    this.pos = this.html.charCodeAt(0) === $.BOM ? 0 : -1;

    this.gapStack = [];
    this.lastGapPos = -1;
    this.skipNextNewLine = false;
};

Preprocessor.prototype.write = function (html) {
    if (this.html) {
        this.html = this.html.substring(0, this.pos + 1) +
                    html +
                    this.html.substring(this.pos + 1, this.html.length);

    }
    else
        this.html = html;


    this.lastCharPos = this.html.length - 1;
};

Preprocessor.prototype.advanceAndPeekCodePoint = function () {
    this.pos++;

    if (this.pos > this.lastCharPos)
        return $.EOF;

    var cp = this.html.charCodeAt(this.pos);

    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
    //must be ignored.
    if (this.skipNextNewLine && cp === $.LINE_FEED) {
        this.skipNextNewLine = false;
        this._addGap();
        return this.advanceAndPeekCodePoint();
    }

    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
    if (cp === $.CARRIAGE_RETURN) {
        this.skipNextNewLine = true;
        return $.LINE_FEED;
    }

    this.skipNextNewLine = false;

    //OPTIMIZATION: first perform check if the code point in the allowed range that covers most common
    //HTML input (e.g. ASCII codes) to avoid performance-cost operations for high-range code points.
    return cp >= 0xD800 ? this._processHighRangeCodePoint(cp) : cp;
};

Preprocessor.prototype._processHighRangeCodePoint = function (cp) {
    //NOTE: try to peek a surrogate pair
    if (this.pos !== this.lastCharPos) {
        var nextCp = this.html.charCodeAt(this.pos + 1);

        if (isSurrogatePair(cp, nextCp)) {
            //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
            this.pos++;
            cp = getSurrogatePairCodePoint(cp, nextCp);

            //NOTE: add gap that should be avoided during retreat
            this._addGap();
        }
    }

    if (isReservedCodePoint(cp))
        cp = $.REPLACEMENT_CHARACTER;

    return cp;
};

Preprocessor.prototype._addGap = function () {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
};

Preprocessor.prototype.retreat = function () {
    if (this.pos === this.lastGapPos) {
        this.lastGapPos = this.gapStack.pop();
        this.pos--;
    }

    this.pos--;
};

},{"../common/unicode":5}],14:[function(require,module,exports){
'use strict';

var Preprocessor = require('./preprocessor'),
    UNICODE = require('../common/unicode'),
    NAMED_ENTITY_TRIE = require('./named_entity_trie');

//Aliases
var $ = UNICODE.CODE_POINTS,
    $$ = UNICODE.CODE_POINT_SEQUENCES;

//Replacement code points for numeric entities
var NUMERIC_ENTITY_REPLACEMENTS = {
    0x00: 0xFFFD, 0x0D: 0x000D, 0x80: 0x20AC, 0x81: 0x0081, 0x82: 0x201A, 0x83: 0x0192, 0x84: 0x201E,
    0x85: 0x2026, 0x86: 0x2020, 0x87: 0x2021, 0x88: 0x02C6, 0x89: 0x2030, 0x8A: 0x0160, 0x8B: 0x2039,
    0x8C: 0x0152, 0x8D: 0x008D, 0x8E: 0x017D, 0x8F: 0x008F, 0x90: 0x0090, 0x91: 0x2018, 0x92: 0x2019,
    0x93: 0x201C, 0x94: 0x201D, 0x95: 0x2022, 0x96: 0x2013, 0x97: 0x2014, 0x98: 0x02DC, 0x99: 0x2122,
    0x9A: 0x0161, 0x9B: 0x203A, 0x9C: 0x0153, 0x9D: 0x009D, 0x9E: 0x017E, 0x9F: 0x0178
};

//States
var DATA_STATE = 'DATA_STATE',
    CHARACTER_REFERENCE_IN_DATA_STATE = 'CHARACTER_REFERENCE_IN_DATA_STATE',
    RCDATA_STATE = 'RCDATA_STATE',
    CHARACTER_REFERENCE_IN_RCDATA_STATE = 'CHARACTER_REFERENCE_IN_RCDATA_STATE',
    RAWTEXT_STATE = 'RAWTEXT_STATE',
    SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE',
    PLAINTEXT_STATE = 'PLAINTEXT_STATE',
    TAG_OPEN_STATE = 'TAG_OPEN_STATE',
    END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE',
    TAG_NAME_STATE = 'TAG_NAME_STATE',
    RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE',
    RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE',
    RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE',
    RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE',
    RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE',
    RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE',
    SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE',
    SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE',
    SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE',
    SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE',
    SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE',
    SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE',
    SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE',
    SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE',
    SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE',
    SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE',
    SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE',
    SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE',
    BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE',
    ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE',
    AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE',
    BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE',
    ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE',
    ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE',
    ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE',
    CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE = 'CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE',
    AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE',
    SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE',
    BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE',
    MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE',
    COMMENT_START_STATE = 'COMMENT_START_STATE',
    COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE',
    COMMENT_STATE = 'COMMENT_STATE',
    COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE',
    COMMENT_END_STATE = 'COMMENT_END_STATE',
    COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE',
    DOCTYPE_STATE = 'DOCTYPE_STATE',
    BEFORE_DOCTYPE_NAME_STATE = 'BEFORE_DOCTYPE_NAME_STATE',
    DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE',
    AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE',
    AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE',
    BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE',
    DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE',
    DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE',
    AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE',
    BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE',
    AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE',
    BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE',
    DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE',
    DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE',
    AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE',
    BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE',
    CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';

//Utils

//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
//this functions if they will be situated in another module due to context switch.
//Always perform inlining check before modifying this functions ('node --trace-inlining').
function isWhitespace(cp) {
    return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;
}

function isAsciiDigit(cp) {
    return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;
}

function isAsciiUpper(cp) {
    return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;
}

function isAsciiLower(cp) {
    return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;
}

function isAsciiAlphaNumeric(cp) {
    return isAsciiDigit(cp) || isAsciiUpper(cp) || isAsciiLower(cp);
}

function isDigit(cp, isHex) {
    return isAsciiDigit(cp) || (isHex && ((cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_F) ||
                                          (cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_F)));
}

function isReservedCodePoint(cp) {
    return cp >= 0xD800 && cp <= 0xDFFF || cp > 0x10FFFF;
}

function toAsciiLowerCodePoint(cp) {
    return cp + 0x0020;
}

//NOTE: String.fromCharCode() function can handle only characters from BMP subset.
//So, we need to workaround this manually.
//(see: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values)
function toChar(cp) {
    if (cp <= 0xFFFF)
        return String.fromCharCode(cp);

    cp -= 0x10000;
    return String.fromCharCode(cp >>> 10 & 0x3FF | 0xD800) + String.fromCharCode(0xDC00 | cp & 0x3FF);
}

function toAsciiLowerChar(cp) {
    return String.fromCharCode(toAsciiLowerCodePoint(cp));
}

//Tokenizer
var Tokenizer = module.exports = function (html) {
    this.preprocessor = new Preprocessor(html);

    this.tokenQueue = [];

    this.allowCDATA = false;

    this.state = DATA_STATE;
    this.returnState = '';

    this.consumptionPos = 0;

    this.tempBuff = [];
    this.additionalAllowedCp = void 0;
    this.lastStartTagName = '';

    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = null;
};

//Token types
Tokenizer.CHARACTER_TOKEN = 'CHARACTER_TOKEN';
Tokenizer.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';
Tokenizer.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';
Tokenizer.START_TAG_TOKEN = 'START_TAG_TOKEN';
Tokenizer.END_TAG_TOKEN = 'END_TAG_TOKEN';
Tokenizer.COMMENT_TOKEN = 'COMMENT_TOKEN';
Tokenizer.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';
Tokenizer.EOF_TOKEN = 'EOF_TOKEN';

//States export
Tokenizer.DATA_STATE = DATA_STATE;
Tokenizer.RCDATA_STATE = RCDATA_STATE;
Tokenizer.RAWTEXT_STATE = RAWTEXT_STATE;
Tokenizer.SCRIPT_DATA_STATE = SCRIPT_DATA_STATE;
Tokenizer.PLAINTEXT_STATE = PLAINTEXT_STATE;

//Static
Tokenizer.getTokenAttr = function (token, attrName) {
    for (var i = token.attrs.length - 1; i >= 0; i--) {
        if (token.attrs[i].name === attrName)
            return token.attrs[i].value;
    }

    return null;
};

//Get token
Tokenizer.prototype.getNextToken = function () {
    while (!this.tokenQueue.length)
        this[this.state](this._consume());

    return this.tokenQueue.shift();
};

//Consumption
Tokenizer.prototype._consume = function () {
    this.consumptionPos++;
    return this.preprocessor.advanceAndPeekCodePoint();
};

Tokenizer.prototype._unconsume = function () {
    this.consumptionPos--;
    this.preprocessor.retreat();
};

Tokenizer.prototype._unconsumeSeveral = function (count) {
    while (count--)
        this._unconsume();
};

Tokenizer.prototype._reconsumeInState = function (state) {
    this.state = state;
    this._unconsume();
};

Tokenizer.prototype._consumeSubsequentIfMatch = function (pattern, startCp, caseSensitive) {
    var rollbackPos = this.consumptionPos,
        isMatch = true,
        patternLength = pattern.length,
        patternPos = 0,
        cp = startCp,
        patternCp = void 0;

    for (; patternPos < patternLength; patternPos++) {
        if (patternPos > 0)
            cp = this._consume();

        if (cp === $.EOF) {
            isMatch = false;
            break;
        }

        patternCp = pattern[patternPos];

        if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
            isMatch = false;
            break;
        }
    }

    if (!isMatch)
        this._unconsumeSeveral(this.consumptionPos - rollbackPos);

    return isMatch;
};

//Lookahead
Tokenizer.prototype._lookahead = function () {
    var cp = this.preprocessor.advanceAndPeekCodePoint();
    this.preprocessor.retreat();

    return cp;
};

//Temp buffer
Tokenizer.prototype.isTempBufferEqualToScriptString = function () {
    if (this.tempBuff.length !== $$.SCRIPT_STRING.length)
        return false;

    for (var i = 0; i < this.tempBuff.length; i++) {
        if (this.tempBuff[i] !== $$.SCRIPT_STRING[i])
            return false;
    }

    return true;
};

//Token creation
Tokenizer.prototype.buildStartTagToken = function (tagName) {
    return {
        type: Tokenizer.START_TAG_TOKEN,
        tagName: tagName,
        selfClosing: false,
        attrs: []
    };
};

Tokenizer.prototype.buildEndTagToken = function (tagName) {
    return {
        type: Tokenizer.END_TAG_TOKEN,
        tagName: tagName,
        ignored: false,
        attrs: []
    };
};

Tokenizer.prototype._createStartTagToken = function (tagNameFirstCh) {
    this.currentToken = this.buildStartTagToken(tagNameFirstCh);
};

Tokenizer.prototype._createEndTagToken = function (tagNameFirstCh) {
    this.currentToken = this.buildEndTagToken(tagNameFirstCh);
};

Tokenizer.prototype._createCommentToken = function () {
    this.currentToken = {
        type: Tokenizer.COMMENT_TOKEN,
        data: ''
    };
};

Tokenizer.prototype._createDoctypeToken = function (doctypeNameFirstCh) {
    this.currentToken = {
        type: Tokenizer.DOCTYPE_TOKEN,
        name: doctypeNameFirstCh || '',
        forceQuirks: false,
        publicId: null,
        systemId: null
    };
};

//Tag attributes
Tokenizer.prototype._createAttr = function (attrNameFirstCh) {
    this.currentAttr = {
        name: attrNameFirstCh,
        value: ''
    };
};

Tokenizer.prototype._isDuplicateAttr = function () {
    return Tokenizer.getTokenAttr(this.currentToken, this.currentAttr.name) !== null;
};

Tokenizer.prototype._leaveAttrName = function (toState) {
    this.state = toState;

    if (!this._isDuplicateAttr())
        this.currentToken.attrs.push(this.currentAttr);
};

//Appropriate end tag token
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#appropriate-end-tag-token)
Tokenizer.prototype._isAppropriateEndTagToken = function () {
    return this.lastStartTagName === this.currentToken.tagName;
};

//Token emission
Tokenizer.prototype._emitCurrentToken = function () {
    this._emitCurrentCharacterToken();

    //NOTE: store emited start tag's tagName to determine is the following end tag token is appropriate.
    if (this.currentToken.type === Tokenizer.START_TAG_TOKEN)
        this.lastStartTagName = this.currentToken.tagName;

    this.tokenQueue.push(this.currentToken);
    this.currentToken = null;
};

Tokenizer.prototype._emitCurrentCharacterToken = function () {
    if (this.currentCharacterToken) {
        this.tokenQueue.push(this.currentCharacterToken);
        this.currentCharacterToken = null;
    }
};

Tokenizer.prototype._emitEOFToken = function () {
    this._emitCurrentCharacterToken();
    this.tokenQueue.push({type: Tokenizer.EOF_TOKEN});
};

//Characters emission

//OPTIMIZATION: specification uses only one type of character tokens (one token per character).
//This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
//If we have a sequence of characters that belong to the same group, parser can process it
//as a single solid character token.
//So, there are 3 types of character tokens in parse5:
//1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
//2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
//3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
Tokenizer.prototype._appendCharToCurrentCharacterToken = function (type, ch) {
    if (this.currentCharacterToken && this.currentCharacterToken.type !== type)
        this._emitCurrentCharacterToken();

    if (this.currentCharacterToken)
        this.currentCharacterToken.chars += ch;

    else {
        this.currentCharacterToken = {
            type: type,
            chars: ch
        };
    }
};

Tokenizer.prototype._emitCodePoint = function (cp) {
    var type = Tokenizer.CHARACTER_TOKEN;

    if (isWhitespace(cp))
        type = Tokenizer.WHITESPACE_CHARACTER_TOKEN;

    else if (cp === $.NULL)
        type = Tokenizer.NULL_CHARACTER_TOKEN;

    this._appendCharToCurrentCharacterToken(type, toChar(cp));
};

Tokenizer.prototype._emitSeveralCodePoints = function (codePoints) {
    for (var i = 0; i < codePoints.length; i++)
        this._emitCodePoint(codePoints[i]);
};

//NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
//So we can avoid additional checks here.
Tokenizer.prototype._emitChar = function (ch) {
    this._appendCharToCurrentCharacterToken(Tokenizer.CHARACTER_TOKEN, ch);
};

//Character reference tokenization
Tokenizer.prototype._consumeNumericEntity = function (isHex) {
    var digits = '',
        nextCp = void 0;

    do {
        digits += toChar(this._consume());
        nextCp = this._lookahead();
    } while (nextCp !== $.EOF && isDigit(nextCp, isHex));

    if (this._lookahead() === $.SEMICOLON)
        this._consume();

    var referencedCp = parseInt(digits, isHex ? 16 : 10),
        replacement = NUMERIC_ENTITY_REPLACEMENTS[referencedCp];

    if (replacement)
        return replacement;

    if (isReservedCodePoint(referencedCp))
        return $.REPLACEMENT_CHARACTER;

    return referencedCp;
};

Tokenizer.prototype._consumeNamedEntity = function (startCp, inAttr) {
    var referencedCodePoints = null,
        entityCodePointsCount = 0,
        cp = startCp,
        leaf = NAMED_ENTITY_TRIE[cp],
        consumedCount = 1,
        semicolonTerminated = false;

    for (; leaf && cp !== $.EOF; cp = this._consume(), consumedCount++, leaf = leaf.l && leaf.l[cp]) {
        if (leaf.c) {
            //NOTE: we have at least one named reference match. But we don't stop lookup at this point,
            //because longer matches still can be found (e.g. '&not' and '&notin;') except the case
            //then found match is terminated by semicolon.
            referencedCodePoints = leaf.c;
            entityCodePointsCount = consumedCount;

            if (cp === $.SEMICOLON) {
                semicolonTerminated = true;
                break;
            }
        }
    }

    if (referencedCodePoints) {
        if (!semicolonTerminated) {
            //NOTE: unconsume excess (e.g. 'it' in '&notit')
            this._unconsumeSeveral(consumedCount - entityCodePointsCount);

            //NOTE: If the character reference is being consumed as part of an attribute and the next character
            //is either a U+003D EQUALS SIGN character (=) or an alphanumeric ASCII character, then, for historical
            //reasons, all the characters that were matched after the U+0026 AMPERSAND character (&) must be
            //unconsumed, and nothing is returned.
            //However, if this next character is in fact a U+003D EQUALS SIGN character (=), then this is a
            //parse error, because some legacy user agents will misinterpret the markup in those cases.
            //(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#tokenizing-character-references)
            if (inAttr) {
                var nextCp = this._lookahead();

                if (nextCp === $.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp)) {
                    this._unconsumeSeveral(entityCodePointsCount);
                    return null;
                }
            }
        }

        return referencedCodePoints;
    }

    this._unconsumeSeveral(consumedCount);

    return null;
};

Tokenizer.prototype._consumeCharacterReference = function (startCp, inAttr) {
    if (isWhitespace(startCp) || startCp === $.GREATER_THAN_SIGN || startCp === $.AMPERSAND ||
        startCp === this.additionalAllowedCp || startCp === $.EOF) {
        //NOTE: not a character reference. No characters are consumed, and nothing is returned.
        this._unconsume();
        return null;
    }

    else if (startCp === $.NUMBER_SIGN) {
        //NOTE: we have a numeric entity candidate, now we should determine if it's hex or decimal
        var isHex = false,
            nextCp = this._lookahead();

        if (nextCp === $.LATIN_SMALL_X || nextCp === $.LATIN_CAPITAL_X) {
            this._consume();
            isHex = true;
        }

        nextCp = this._lookahead();

        //NOTE: if we have at least one digit this is a numeric entity for sure, so we consume it
        if (nextCp !== $.EOF && isDigit(nextCp, isHex))
            return [this._consumeNumericEntity(isHex)];

        else {
            //NOTE: otherwise this is a bogus number entity and a parse error. Unconsume the number sign
            //and the 'x'-character if appropriate.
            this._unconsumeSeveral(isHex ? 2 : 1);
            return null;
        }
    }

    else
        return this._consumeNamedEntity(startCp, inAttr);
};

//State machine
var _ = Tokenizer.prototype;

//12.2.4.1 Data state
//------------------------------------------------------------------
_[DATA_STATE] = function dataState(cp) {
    if (cp === $.AMPERSAND)
        this.state = CHARACTER_REFERENCE_IN_DATA_STATE;

    else if (cp === $.LESS_THAN_SIGN)
        this.state = TAG_OPEN_STATE;

    else if (cp === $.NULL)
        this._emitCodePoint(cp);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.2 Character reference in data state
//------------------------------------------------------------------
_[CHARACTER_REFERENCE_IN_DATA_STATE] = function characterReferenceInDataState(cp) {
    this.state = DATA_STATE;
    this.additionalAllowedCp = void 0;

    var referencedCodePoints = this._consumeCharacterReference(cp, false);

    if (referencedCodePoints)
        this._emitSeveralCodePoints(referencedCodePoints);
    else
        this._emitChar('&');
};


//12.2.4.3 RCDATA state
//------------------------------------------------------------------
_[RCDATA_STATE] = function rcdataState(cp) {
    if (cp === $.AMPERSAND)
        this.state = CHARACTER_REFERENCE_IN_RCDATA_STATE;

    else if (cp === $.LESS_THAN_SIGN)
        this.state = RCDATA_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.4 Character reference in RCDATA state
//------------------------------------------------------------------
_[CHARACTER_REFERENCE_IN_RCDATA_STATE] = function characterReferenceInRcdataState(cp) {
    this.state = RCDATA_STATE;
    this.additionalAllowedCp = void 0;

    var referencedCodePoints = this._consumeCharacterReference(cp, false);

    if (referencedCodePoints)
        this._emitSeveralCodePoints(referencedCodePoints);
    else
        this._emitChar('&');
};


//12.2.4.5 RAWTEXT state
//------------------------------------------------------------------
_[RAWTEXT_STATE] = function rawtextState(cp) {
    if (cp === $.LESS_THAN_SIGN)
        this.state = RAWTEXT_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.6 Script data state
//------------------------------------------------------------------
_[SCRIPT_DATA_STATE] = function scriptDataState(cp) {
    if (cp === $.LESS_THAN_SIGN)
        this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.7 PLAINTEXT state
//------------------------------------------------------------------
_[PLAINTEXT_STATE] = function plaintextState(cp) {
    if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._emitEOFToken();

    else
        this._emitCodePoint(cp);
};


//12.2.4.8 Tag open state
//------------------------------------------------------------------
_[TAG_OPEN_STATE] = function tagOpenState(cp) {
    if (cp === $.EXCLAMATION_MARK)
        this.state = MARKUP_DECLARATION_OPEN_STATE;

    else if (cp === $.SOLIDUS)
        this.state = END_TAG_OPEN_STATE;

    else if (isAsciiUpper(cp)) {
        this._createStartTagToken(toAsciiLowerChar(cp));
        this.state = TAG_NAME_STATE;
    }

    else if (isAsciiLower(cp)) {
        this._createStartTagToken(toChar(cp));
        this.state = TAG_NAME_STATE;
    }

    else if (cp === $.QUESTION_MARK) {
        //NOTE: call bogus comment state directly with current consumed character to avoid unnecessary reconsumption.
        this[BOGUS_COMMENT_STATE](cp);
    }

    else {
        this._emitChar('<');
        this._reconsumeInState(DATA_STATE);
    }
};


//12.2.4.9 End tag open state
//------------------------------------------------------------------
_[END_TAG_OPEN_STATE] = function endTagOpenState(cp) {
    if (isAsciiUpper(cp)) {
        this._createEndTagToken(toAsciiLowerChar(cp));
        this.state = TAG_NAME_STATE;
    }

    else if (isAsciiLower(cp)) {
        this._createEndTagToken(toChar(cp));
        this.state = TAG_NAME_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN)
        this.state = DATA_STATE;

    else if (cp === $.EOF) {
        this._reconsumeInState(DATA_STATE);
        this._emitChar('<');
        this._emitChar('/');
    }

    else {
        //NOTE: call bogus comment state directly with current consumed character to avoid unnecessary reconsumption.
        this[BOGUS_COMMENT_STATE](cp);
    }
};


//12.2.4.10 Tag name state
//------------------------------------------------------------------
_[TAG_NAME_STATE] = function tagNameState(cp) {
    if (isWhitespace(cp))
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;

    else if (cp === $.SOLIDUS)
        this.state = SELF_CLOSING_START_TAG_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (isAsciiUpper(cp))
        this.currentToken.tagName += toAsciiLowerChar(cp);

    else if (cp === $.NULL)
        this.currentToken.tagName += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this.currentToken.tagName += toChar(cp);
};


//12.2.4.11 RCDATA less-than sign state
//------------------------------------------------------------------
_[RCDATA_LESS_THAN_SIGN_STATE] = function rcdataLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = RCDATA_END_TAG_OPEN_STATE;
    }

    else {
        this._emitChar('<');
        this._reconsumeInState(RCDATA_STATE);
    }
};


//12.2.4.12 RCDATA end tag open state
//------------------------------------------------------------------
_[RCDATA_END_TAG_OPEN_STATE] = function rcdataEndTagOpenState(cp) {
    if (isAsciiUpper(cp)) {
        this._createEndTagToken(toAsciiLowerChar(cp));
        this.tempBuff.push(cp);
        this.state = RCDATA_END_TAG_NAME_STATE;
    }

    else if (isAsciiLower(cp)) {
        this._createEndTagToken(toChar(cp));
        this.tempBuff.push(cp);
        this.state = RCDATA_END_TAG_NAME_STATE;
    }

    else {
        this._emitChar('<');
        this._emitChar('/');
        this._reconsumeInState(RCDATA_STATE);
    }
};


//12.2.4.13 RCDATA end tag name state
//------------------------------------------------------------------
_[RCDATA_END_TAG_NAME_STATE] = function rcdataEndTagNameState(cp) {
    if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
    }

    else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
    }

    else {
        if (this._isAppropriateEndTagToken()) {
            if (isWhitespace(cp)) {
                this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                return;
            }

            if (cp === $.SOLIDUS) {
                this.state = SELF_CLOSING_START_TAG_STATE;
                return;
            }

            if (cp === $.GREATER_THAN_SIGN) {
                this.state = DATA_STATE;
                this._emitCurrentToken();
                return;
            }
        }

        this._emitChar('<');
        this._emitChar('/');
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(RCDATA_STATE);
    }
};


//12.2.4.14 RAWTEXT less-than sign state
//------------------------------------------------------------------
_[RAWTEXT_LESS_THAN_SIGN_STATE] = function rawtextLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = RAWTEXT_END_TAG_OPEN_STATE;
    }

    else {
        this._emitChar('<');
        this._reconsumeInState(RAWTEXT_STATE);
    }
};


//12.2.4.15 RAWTEXT end tag open state
//------------------------------------------------------------------
_[RAWTEXT_END_TAG_OPEN_STATE] = function rawtextEndTagOpenState(cp) {
    if (isAsciiUpper(cp)) {
        this._createEndTagToken(toAsciiLowerChar(cp));
        this.tempBuff.push(cp);
        this.state = RAWTEXT_END_TAG_NAME_STATE;
    }

    else if (isAsciiLower(cp)) {
        this._createEndTagToken(toChar(cp));
        this.tempBuff.push(cp);
        this.state = RAWTEXT_END_TAG_NAME_STATE;
    }

    else {
        this._emitChar('<');
        this._emitChar('/');
        this._reconsumeInState(RAWTEXT_STATE);
    }
};


//12.2.4.16 RAWTEXT end tag name state
//------------------------------------------------------------------
_[RAWTEXT_END_TAG_NAME_STATE] = function rawtextEndTagNameState(cp) {
    if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
    }

    else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
    }

    else {
        if (this._isAppropriateEndTagToken()) {
            if (isWhitespace(cp)) {
                this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                return;
            }

            if (cp === $.SOLIDUS) {
                this.state = SELF_CLOSING_START_TAG_STATE;
                return;
            }

            if (cp === $.GREATER_THAN_SIGN) {
                this._emitCurrentToken();
                this.state = DATA_STATE;
                return;
            }
        }

        this._emitChar('<');
        this._emitChar('/');
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(RAWTEXT_STATE);
    }
};


//12.2.4.17 Script data less-than sign state
//------------------------------------------------------------------
_[SCRIPT_DATA_LESS_THAN_SIGN_STATE] = function scriptDataLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
    }

    else if (cp === $.EXCLAMATION_MARK) {
        this.state = SCRIPT_DATA_ESCAPE_START_STATE;
        this._emitChar('<');
        this._emitChar('!');
    }

    else {
        this._emitChar('<');
        this._reconsumeInState(SCRIPT_DATA_STATE);
    }
};


//12.2.4.18 Script data end tag open state
//------------------------------------------------------------------
_[SCRIPT_DATA_END_TAG_OPEN_STATE] = function scriptDataEndTagOpenState(cp) {
    if (isAsciiUpper(cp)) {
        this._createEndTagToken(toAsciiLowerChar(cp));
        this.tempBuff.push(cp);
        this.state = SCRIPT_DATA_END_TAG_NAME_STATE;
    }

    else if (isAsciiLower(cp)) {
        this._createEndTagToken(toChar(cp));
        this.tempBuff.push(cp);
        this.state = SCRIPT_DATA_END_TAG_NAME_STATE;
    }

    else {
        this._emitChar('<');
        this._emitChar('/');
        this._reconsumeInState(SCRIPT_DATA_STATE);
    }
};


//12.2.4.19 Script data end tag name state
//------------------------------------------------------------------
_[SCRIPT_DATA_END_TAG_NAME_STATE] = function scriptDataEndTagNameState(cp) {
    if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
    }

    else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
    }

    else {
        if (this._isAppropriateEndTagToken()) {
            if (isWhitespace(cp)) {
                this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                return;
            }

            else if (cp === $.SOLIDUS) {
                this.state = SELF_CLOSING_START_TAG_STATE;
                return;
            }

            else if (cp === $.GREATER_THAN_SIGN) {
                this._emitCurrentToken();
                this.state = DATA_STATE;
                return;
            }
        }

        this._emitChar('<');
        this._emitChar('/');
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(SCRIPT_DATA_STATE);
    }
};


//12.2.4.20 Script data escape start state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPE_START_STATE] = function scriptDataEscapeStartState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
        this._emitChar('-');
    }

    else
        this._reconsumeInState(SCRIPT_DATA_STATE);
};


//12.2.4.21 Script data escape start dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPE_START_DASH_STATE] = function scriptDataEscapeStartDashState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
        this._emitChar('-');
    }

    else
        this._reconsumeInState(SCRIPT_DATA_STATE);
};


//12.2.4.22 Script data escaped state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_STATE] = function scriptDataEscapedState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
        this._emitChar('-');
    }

    else if (cp === $.LESS_THAN_SIGN)
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this._emitCodePoint(cp);
};


//12.2.4.23 Script data escaped dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_DASH_STATE] = function scriptDataEscapedDashState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
        this._emitChar('-');
    }

    else if (cp === $.LESS_THAN_SIGN)
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;

    else if (cp === $.NULL) {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }
};


//12.2.4.24 Script data escaped dash dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE] = function scriptDataEscapedDashDashState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this._emitChar('-');

    else if (cp === $.LESS_THAN_SIGN)
        this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = SCRIPT_DATA_STATE;
        this._emitChar('>');
    }

    else if (cp === $.NULL) {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this.state = SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }
};


//12.2.4.25 Script data escaped less-than sign state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE] = function scriptDataEscapedLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
    }

    else if (isAsciiUpper(cp)) {
        this.tempBuff = [];
        this.tempBuff.push(toAsciiLowerCodePoint(cp));
        this.state = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
        this._emitChar('<');
        this._emitCodePoint(cp);
    }

    else if (isAsciiLower(cp)) {
        this.tempBuff = [];
        this.tempBuff.push(cp);
        this.state = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
        this._emitChar('<');
        this._emitCodePoint(cp);
    }

    else {
        this._emitChar('<');
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
};


//12.2.4.26 Script data escaped end tag open state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE] = function scriptDataEscapedEndTagOpenState(cp) {
    if (isAsciiUpper(cp)) {
        this._createEndTagToken(toAsciiLowerChar(cp));
        this.tempBuff.push(cp);
        this.state = SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE;
    }

    else if (isAsciiLower(cp)) {
        this._createEndTagToken(toChar(cp));
        this.tempBuff.push(cp);
        this.state = SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE;
    }

    else {
        this._emitChar('<');
        this._emitChar('/');
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
};


//12.2.4.27 Script data escaped end tag name state
//------------------------------------------------------------------
_[SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE] = function scriptDataEscapedEndTagNameState(cp) {
    if (isAsciiUpper(cp)) {
        this.currentToken.tagName += toAsciiLowerChar(cp);
        this.tempBuff.push(cp);
    }

    else if (isAsciiLower(cp)) {
        this.currentToken.tagName += toChar(cp);
        this.tempBuff.push(cp);
    }

    else {
        if (this._isAppropriateEndTagToken()) {
            if (isWhitespace(cp)) {
                this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                return;
            }

            if (cp === $.SOLIDUS) {
                this.state = SELF_CLOSING_START_TAG_STATE;
                return;
            }

            if (cp === $.GREATER_THAN_SIGN) {
                this._emitCurrentToken();
                this.state = DATA_STATE;
                return;
            }
        }

        this._emitChar('<');
        this._emitChar('/');
        this._emitSeveralCodePoints(this.tempBuff);
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
};


//12.2.4.28 Script data double escape start state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE] = function scriptDataDoubleEscapeStartState(cp) {
    if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
        this.state = this.isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }

    else if (isAsciiUpper(cp)) {
        this.tempBuff.push(toAsciiLowerCodePoint(cp));
        this._emitCodePoint(cp);
    }

    else if (isAsciiLower(cp)) {
        this.tempBuff.push(cp);
        this._emitCodePoint(cp);
    }

    else
        this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
};


//12.2.4.29 Script data double escaped state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPED_STATE] = function scriptDataDoubleEscapedState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
        this._emitChar('-');
    }

    else if (cp === $.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChar('<');
    }

    else if (cp === $.NULL)
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this._emitCodePoint(cp);
};


//12.2.4.30 Script data double escaped dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE] = function scriptDataDoubleEscapedDashState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
        this._emitChar('-');
    }

    else if (cp === $.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChar('<');
    }

    else if (cp === $.NULL) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }
};


//12.2.4.31 Script data double escaped dash dash state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE] = function scriptDataDoubleEscapedDashDashState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this._emitChar('-');

    else if (cp === $.LESS_THAN_SIGN) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
        this._emitChar('<');
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = SCRIPT_DATA_STATE;
        this._emitChar('>');
    }

    else if (cp === $.NULL) {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitChar(UNICODE.REPLACEMENT_CHARACTER);
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
        this._emitCodePoint(cp);
    }
};


//12.2.4.32 Script data double escaped less-than sign state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE] = function scriptDataDoubleEscapedLessThanSignState(cp) {
    if (cp === $.SOLIDUS) {
        this.tempBuff = [];
        this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
        this._emitChar('/');
    }

    else
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
};


//12.2.4.33 Script data double escape end state
//------------------------------------------------------------------
_[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE] = function scriptDataDoubleEscapeEndState(cp) {
    if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
        this.state = this.isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

        this._emitCodePoint(cp);
    }

    else if (isAsciiUpper(cp)) {
        this.tempBuff.push(toAsciiLowerCodePoint(cp));
        this._emitCodePoint(cp);
    }

    else if (isAsciiLower(cp)) {
        this.tempBuff.push(cp);
        this._emitCodePoint(cp);
    }

    else
        this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
};


//12.2.4.34 Before attribute name state
//------------------------------------------------------------------
_[BEFORE_ATTRIBUTE_NAME_STATE] = function beforeAttributeNameState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.SOLIDUS)
        this.state = SELF_CLOSING_START_TAG_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (isAsciiUpper(cp)) {
        this._createAttr(toAsciiLowerChar(cp));
        this.state = ATTRIBUTE_NAME_STATE;
    }

    else if (cp === $.NULL) {
        this._createAttr(UNICODE.REPLACEMENT_CHARACTER);
        this.state = ATTRIBUTE_NAME_STATE;
    }

    else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN || cp === $.EQUALS_SIGN) {
        this._createAttr(toChar(cp));
        this.state = ATTRIBUTE_NAME_STATE;
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this._createAttr(toChar(cp));
        this.state = ATTRIBUTE_NAME_STATE;
    }
};


//12.2.4.35 Attribute name state
//------------------------------------------------------------------
_[ATTRIBUTE_NAME_STATE] = function attributeNameState(cp) {
    if (isWhitespace(cp))
        this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);

    else if (cp === $.SOLIDUS)
        this._leaveAttrName(SELF_CLOSING_START_TAG_STATE);

    else if (cp === $.EQUALS_SIGN)
        this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);

    else if (cp === $.GREATER_THAN_SIGN) {
        this._leaveAttrName(DATA_STATE);
        this._emitCurrentToken();
    }

    else if (isAsciiUpper(cp))
        this.currentAttr.name += toAsciiLowerChar(cp);

    else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN)
        this.currentAttr.name += toChar(cp);

    else if (cp === $.NULL)
        this.currentAttr.name += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this.currentAttr.name += toChar(cp);
};


//12.2.4.36 After attribute name state
//------------------------------------------------------------------
_[AFTER_ATTRIBUTE_NAME_STATE] = function afterAttributeNameState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.SOLIDUS)
        this.state = SELF_CLOSING_START_TAG_STATE;

    else if (cp === $.EQUALS_SIGN)
        this.state = BEFORE_ATTRIBUTE_VALUE_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (isAsciiUpper(cp)) {
        this._createAttr(toAsciiLowerChar(cp));
        this.state = ATTRIBUTE_NAME_STATE;
    }

    else if (cp === $.NULL) {
        this._createAttr(UNICODE.REPLACEMENT_CHARACTER);
        this.state = ATTRIBUTE_NAME_STATE;
    }

    else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN) {
        this._createAttr(toChar(cp));
        this.state = ATTRIBUTE_NAME_STATE;
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this._createAttr(toChar(cp));
        this.state = ATTRIBUTE_NAME_STATE;
    }
};


//12.2.4.37 Before attribute value state
//------------------------------------------------------------------
_[BEFORE_ATTRIBUTE_VALUE_STATE] = function beforeAttributeValueState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.QUOTATION_MARK)
        this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;

    else if (cp === $.AMPERSAND)
        this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);

    else if (cp === $.APOSTROPHE)
        this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;

    else if (cp === $.NULL) {
        this.currentAttr.value += UNICODE.REPLACEMENT_CHARACTER;
        this.state = ATTRIBUTE_VALUE_UNQUOTED_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.LESS_THAN_SIGN || cp === $.EQUALS_SIGN || cp === $.GRAVE_ACCENT) {
        this.currentAttr.value += toChar(cp);
        this.state = ATTRIBUTE_VALUE_UNQUOTED_STATE;
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else {
        this.currentAttr.value += toChar(cp);
        this.state = ATTRIBUTE_VALUE_UNQUOTED_STATE;
    }
};


//12.2.4.38 Attribute value (double-quoted) state
//------------------------------------------------------------------
_[ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE] = function attributeValueDoubleQuotedState(cp) {
    if (cp === $.QUOTATION_MARK)
        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;

    else if (cp === $.AMPERSAND) {
        this.additionalAllowedCp = $.QUOTATION_MARK;
        this.returnState = this.state;
        this.state = CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE;
    }

    else if (cp === $.NULL)
        this.currentAttr.value += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this.currentAttr.value += toChar(cp);
};


//12.2.4.39 Attribute value (single-quoted) state
//------------------------------------------------------------------
_[ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE] = function attributeValueSingleQuotedState(cp) {
    if (cp === $.APOSTROPHE)
        this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;

    else if (cp === $.AMPERSAND) {
        this.additionalAllowedCp = $.APOSTROPHE;
        this.returnState = this.state;
        this.state = CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE;
    }

    else if (cp === $.NULL)
        this.currentAttr.value += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this.currentAttr.value += toChar(cp);
};


//12.2.4.40 Attribute value (unquoted) state
//------------------------------------------------------------------
_[ATTRIBUTE_VALUE_UNQUOTED_STATE] = function attributeValueUnquotedState(cp) {
    if (isWhitespace(cp))
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;

    else if (cp === $.AMPERSAND) {
        this.additionalAllowedCp = $.GREATER_THAN_SIGN;
        this.returnState = this.state;
        this.state = CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.NULL)
        this.currentAttr.value += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN ||
             cp === $.EQUALS_SIGN || cp === $.GRAVE_ACCENT) {
        this.currentAttr.value += toChar(cp);
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this.currentAttr.value += toChar(cp);
};


//12.2.4.41 Character reference in attribute value state
//------------------------------------------------------------------
_[CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE] = function characterReferenceInAttributeValueState(cp) {
    var referencedCodePoints = this._consumeCharacterReference(cp, true);

    if (referencedCodePoints) {
        for (var i = 0; i < referencedCodePoints.length; i++)
            this.currentAttr.value += toChar(referencedCodePoints[i]);
    } else
        this.currentAttr.value += '&';

    this.state = this.returnState;
};


//12.2.4.42 After attribute value (quoted) state
//------------------------------------------------------------------
_[AFTER_ATTRIBUTE_VALUE_QUOTED_STATE] = function afterAttributeValueQuotedState(cp) {
    if (isWhitespace(cp))
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;

    else if (cp === $.SOLIDUS)
        this.state = SELF_CLOSING_START_TAG_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
};


//12.2.4.43 Self-closing start tag state
//------------------------------------------------------------------
_[SELF_CLOSING_START_TAG_STATE] = function selfClosingStartTagState(cp) {
    if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.selfClosing = true;
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EOF)
        this._reconsumeInState(DATA_STATE);

    else
        this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
};


//12.2.4.44 Bogus comment state
//------------------------------------------------------------------
_[BOGUS_COMMENT_STATE] = function bogusCommentState(cp) {
    this._createCommentToken();

    while (true) {
        if (cp === $.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            break;
        }

        else if (cp === $.EOF) {
            this._reconsumeInState(DATA_STATE);
            break;
        }

        else {
            this.currentToken.data += cp === $.NULL ? UNICODE.REPLACEMENT_CHARACTER : toChar(cp);
            cp = this._consume();
        }
    }

    this._emitCurrentToken();
};


//12.2.4.45 Markup declaration open state
//------------------------------------------------------------------
_[MARKUP_DECLARATION_OPEN_STATE] = function markupDeclarationOpenState(cp) {
    if (this._consumeSubsequentIfMatch($$.DASH_DASH_STRING, cp, true)) {
        this._createCommentToken();
        this.state = COMMENT_START_STATE;
    }

    else if (this._consumeSubsequentIfMatch($$.DOCTYPE_STRING, cp, false))
        this.state = DOCTYPE_STATE;

    else if (this.allowCDATA && this._consumeSubsequentIfMatch($$.CDATA_START_STRING, cp, true))
        this.state = CDATA_SECTION_STATE;

    else {
        //NOTE: call bogus comment state directly with current consumed character to avoid unnecessary reconsumption.
        this[BOGUS_COMMENT_STATE](cp);
    }
};


//12.2.4.46 Comment start state
//------------------------------------------------------------------
_[COMMENT_START_STATE] = function commentStartState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this.state = COMMENT_START_DASH_STATE;

    else if (cp === $.NULL) {
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.47 Comment start dash state
//------------------------------------------------------------------
_[COMMENT_START_DASH_STATE] = function commentStartDashState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this.state = COMMENT_END_STATE;

    else if (cp === $.NULL) {
        this.currentToken.data += '-';
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.data += '-';
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.48 Comment state
//------------------------------------------------------------------
_[COMMENT_STATE] = function commentState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this.state = COMMENT_END_DASH_STATE;

    else if (cp === $.NULL)
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.data += toChar(cp);
};


//12.2.4.49 Comment end dash state
//------------------------------------------------------------------
_[COMMENT_END_DASH_STATE] = function commentEndDashState(cp) {
    if (cp === $.HYPHEN_MINUS)
        this.state = COMMENT_END_STATE;

    else if (cp === $.NULL) {
        this.currentToken.data += '-';
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.data += '-';
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.50 Comment end state
//------------------------------------------------------------------
_[COMMENT_END_STATE] = function commentEndState(cp) {
    if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EXCLAMATION_MARK)
        this.state = COMMENT_END_BANG_STATE;

    else if (cp === $.HYPHEN_MINUS)
        this.currentToken.data += '-';

    else if (cp === $.NULL) {
        this.currentToken.data += '--';
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.EOF) {
        this._reconsumeInState(DATA_STATE);
        this._emitCurrentToken();
    }

    else {
        this.currentToken.data += '--';
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.51 Comment end bang state
//------------------------------------------------------------------
_[COMMENT_END_BANG_STATE] = function commentEndBangState(cp) {
    if (cp === $.HYPHEN_MINUS) {
        this.currentToken.data += '--!';
        this.state = COMMENT_END_DASH_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.NULL) {
        this.currentToken.data += '--!';
        this.currentToken.data += UNICODE.REPLACEMENT_CHARACTER;
        this.state = COMMENT_STATE;
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.data += '--!';
        this.currentToken.data += toChar(cp);
        this.state = COMMENT_STATE;
    }
};


//12.2.4.52 DOCTYPE state
//------------------------------------------------------------------
_[DOCTYPE_STATE] = function doctypeState(cp) {
    if (isWhitespace(cp))
        this.state = BEFORE_DOCTYPE_NAME_STATE;

    else if (cp === $.EOF) {
        this._createDoctypeToken();
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
};


//12.2.4.53 Before DOCTYPE name state
//------------------------------------------------------------------
_[BEFORE_DOCTYPE_NAME_STATE] = function beforeDoctypeNameState(cp) {
    if (isWhitespace(cp))
        return;

    if (isAsciiUpper(cp)) {
        this._createDoctypeToken(toAsciiLowerChar(cp));
        this.state = DOCTYPE_NAME_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this._createDoctypeToken();
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this._createDoctypeToken();
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else if (cp === $.NULL) {
        this._createDoctypeToken(UNICODE.REPLACEMENT_CHARACTER);
        this.state = DOCTYPE_NAME_STATE;
    }

    else {
        this._createDoctypeToken(toChar(cp));
        this.state = DOCTYPE_NAME_STATE;
    }
};


//12.2.4.54 DOCTYPE name state
//------------------------------------------------------------------
_[DOCTYPE_NAME_STATE] = function doctypeNameState(cp) {
    if (isWhitespace(cp))
        this.state = AFTER_DOCTYPE_NAME_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (isAsciiUpper(cp))
        this.currentToken.name += toAsciiLowerChar(cp);

    else if (cp === $.NULL)
        this.currentToken.name += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.name += toChar(cp);
};


//12.2.4.55 After DOCTYPE name state
//------------------------------------------------------------------
_[AFTER_DOCTYPE_NAME_STATE] = function afterDoctypeNameState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else if (this._consumeSubsequentIfMatch($$.PUBLIC_STRING, cp, false))
        this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;

    else if (this._consumeSubsequentIfMatch($$.SYSTEM_STRING, cp, false))
        this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;

    else {
        this.currentToken.forceQuirks = true;
        this.state = BOGUS_DOCTYPE_STATE;
    }
};


//12.2.4.56 After DOCTYPE public keyword state
//------------------------------------------------------------------
_[AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE] = function afterDoctypePublicKeywordState(cp) {
    if (isWhitespace(cp))
        this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;

    else if (cp === $.QUOTATION_MARK) {
        this.currentToken.publicId = '';
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
    }

    else if (cp === $.APOSTROPHE) {
        this.currentToken.publicId = '';
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.forceQuirks = true;
        this.state = BOGUS_DOCTYPE_STATE;
    }
};


//12.2.4.57 Before DOCTYPE public identifier state
//------------------------------------------------------------------
_[BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE] = function beforeDoctypePublicIdentifierState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.QUOTATION_MARK) {
        this.currentToken.publicId = '';
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
    }

    else if (cp === $.APOSTROPHE) {
        this.currentToken.publicId = '';
        this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.forceQuirks = true;
        this.state = BOGUS_DOCTYPE_STATE;
    }
};


//12.2.4.58 DOCTYPE public identifier (double-quoted) state
//------------------------------------------------------------------
_[DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE] = function doctypePublicIdentifierDoubleQuotedState(cp) {
    if (cp === $.QUOTATION_MARK)
        this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;

    else if (cp === $.NULL)
        this.currentToken.publicId += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.publicId += toChar(cp);
};


//12.2.4.59 DOCTYPE public identifier (single-quoted) state
//------------------------------------------------------------------
_[DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE] = function doctypePublicIdentifierSingleQuotedState(cp) {
    if (cp === $.APOSTROPHE)
        this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;

    else if (cp === $.NULL)
        this.currentToken.publicId += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.publicId += toChar(cp);
};


//12.2.4.60 After DOCTYPE public identifier state
//------------------------------------------------------------------
_[AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE] = function afterDoctypePublicIdentifierState(cp) {
    if (isWhitespace(cp))
        this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.QUOTATION_MARK) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    }

    else if (cp === $.APOSTROPHE) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.forceQuirks = true;
        this.state = BOGUS_DOCTYPE_STATE;
    }
};


//12.2.4.61 Between DOCTYPE public and system identifiers state
//------------------------------------------------------------------
_[BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE] = function betweenDoctypePublicAndSystemIdentifiersState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.QUOTATION_MARK) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    }


    else if (cp === $.APOSTROPHE) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.forceQuirks = true;
        this.state = BOGUS_DOCTYPE_STATE;
    }
};


//12.2.4.62 After DOCTYPE system keyword state
//------------------------------------------------------------------
_[AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE] = function afterDoctypeSystemKeywordState(cp) {
    if (isWhitespace(cp))
        this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;

    else if (cp === $.QUOTATION_MARK) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    }

    else if (cp === $.APOSTROPHE) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.forceQuirks = true;
        this.state = BOGUS_DOCTYPE_STATE;
    }
};


//12.2.4.63 Before DOCTYPE system identifier state
//------------------------------------------------------------------
_[BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE] = function beforeDoctypeSystemIdentifierState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.QUOTATION_MARK) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    }

    else if (cp === $.APOSTROPHE) {
        this.currentToken.systemId = '';
        this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    }

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else {
        this.currentToken.forceQuirks = true;
        this.state = BOGUS_DOCTYPE_STATE;
    }
};


//12.2.4.64 DOCTYPE system identifier (double-quoted) state
//------------------------------------------------------------------
_[DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE] = function doctypeSystemIdentifierDoubleQuotedState(cp) {
    if (cp === $.QUOTATION_MARK)
        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.NULL)
        this.currentToken.systemId += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.systemId += toChar(cp);
};


//12.2.4.65 DOCTYPE system identifier (single-quoted) state
//------------------------------------------------------------------
_[DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE] = function doctypeSystemIdentifierSingleQuotedState(cp) {
    if (cp === $.APOSTROPHE)
        this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;

    else if (cp === $.GREATER_THAN_SIGN) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.NULL)
        this.currentToken.systemId += UNICODE.REPLACEMENT_CHARACTER;

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.currentToken.systemId += toChar(cp);
};


//12.2.4.66 After DOCTYPE system identifier state
//------------------------------------------------------------------
_[AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE] = function afterDoctypeSystemIdentifierState(cp) {
    if (isWhitespace(cp))
        return;

    if (cp === $.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this.currentToken.forceQuirks = true;
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }

    else
        this.state = BOGUS_DOCTYPE_STATE;
};


//12.2.4.67 Bogus DOCTYPE state
//------------------------------------------------------------------
_[BOGUS_DOCTYPE_STATE] = function bogusDoctypeState(cp) {
    if (cp === $.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
    }

    else if (cp === $.EOF) {
        this._emitCurrentToken();
        this._reconsumeInState(DATA_STATE);
    }
};


//12.2.4.68 CDATA section state
//------------------------------------------------------------------
_[CDATA_SECTION_STATE] = function cdataSectionState(cp) {
    while (true) {
        if (cp === $.EOF) {
            this._reconsumeInState(DATA_STATE);
            break;
        }

        else if (this._consumeSubsequentIfMatch($$.CDATA_END_STRING, cp, true)) {
            this.state = DATA_STATE;
            break;
        }

        else {
            this._emitCodePoint(cp);
            cp = this._consume();
        }
    }
};

},{"../common/unicode":5,"./named_entity_trie":12,"./preprocessor":13}],15:[function(require,module,exports){
'use strict';

//Node construction
exports.createDocument = function () {
    return {
        nodeName: '#document',
        quirksMode: false,
        childNodes: []
    };
};

exports.createDocumentFragment = function () {
    return {
        nodeName: '#document-fragment',
        quirksMode: false,
        childNodes: []
    };
};

exports.createElement = function (tagName, namespaceURI, attrs) {
    return {
        nodeName: tagName,
        tagName: tagName,
        attrs: attrs,
        namespaceURI: namespaceURI,
        childNodes: [],
        parentNode: null
    };
};

exports.createCommentNode = function (data) {
    return {
        nodeName: '#comment',
        data: data,
        parentNode: null
    };
};

var createTextNode = function (value) {
    return {
        nodeName: '#text',
        value: value,
        parentNode: null
    }
};


//Tree mutation
exports.setDocumentType = function (document, name, publicId, systemId) {
    var doctypeNode = null;

    for (var i = 0; i < document.childNodes.length; i++) {
        if (document.childNodes[i].nodeName === '#documentType') {
            doctypeNode = document.childNodes[i];
            break;
        }
    }

    if (doctypeNode) {
        doctypeNode.name = name;
        doctypeNode.publicId = publicId;
        doctypeNode.systemId = systemId;
    }

    else {
        appendChild(document, {
            nodeName: '#documentType',
            name: name,
            publicId: publicId,
            systemId: systemId
        });
    }
};

exports.setQuirksMode = function (document) {
    document.quirksMode = true;
};

exports.isQuirksMode = function (document) {
    return document.quirksMode;
};

var appendChild = exports.appendChild = function (parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
};

var insertBefore = exports.insertBefore = function (parentNode, newNode, referenceNode) {
    var insertionIdx = parentNode.childNodes.indexOf(referenceNode);

    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
};

exports.detachNode = function (node) {
    if (node.parentNode) {
        var idx = node.parentNode.childNodes.indexOf(node);

        node.parentNode.childNodes.splice(idx, 1);
        node.parentNode = null;
    }
};

exports.insertText = function (parentNode, text) {
    if (parentNode.childNodes.length) {
        var prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];

        if (prevNode.nodeName === '#text') {
            prevNode.value += text;
            return;
        }
    }

    appendChild(parentNode, createTextNode(text));
};

exports.insertTextBefore = function (parentNode, text, referenceNode) {
    var prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];

    if (prevNode && prevNode.nodeName === '#text')
        prevNode.value += text;
    else
        insertBefore(parentNode, createTextNode(text), referenceNode);
};

exports.adoptAttributes = function (recipientNode, attrs) {
    var recipientAttrsMap = [];

    for (var i = 0; i < recipientNode.attrs.length; i++)
        recipientAttrsMap.push(recipientNode.attrs[i].name);

    for (var j = 0; j < attrs.length; j++) {
        if (recipientAttrsMap.indexOf(attrs[j].name) === -1)
            recipientNode.attrs.push(attrs[j]);
    }
};


//Tree traversing
exports.getFirstChild = function (node) {
    return node.childNodes[0];
};

exports.getChildNodes = function (node) {
    return node.childNodes;
};

exports.getParentNode = function (node) {
    return node.parentNode;
};

exports.getAttrList = function (node) {
    return node.attrs;
};

//Node data
exports.getTagName = function (element) {
    return element.tagName;
};

exports.getNamespaceURI = function (element) {
    return element.namespaceURI;
};

exports.getTextNodeContent = function (textNode) {
    return textNode.value;
};

exports.getCommentNodeContent = function (commentNode) {
    return commentNode.data;
};

exports.getDocumentTypeNodeName = function (doctypeNode) {
    return doctypeNode.name;
};

exports.getDocumentTypeNodePublicId = function (doctypeNode) {
    return doctypeNode.publicId;
};

exports.getDocumentTypeNodeSystemId = function (doctypeNode) {
    return doctypeNode.systemId;
};

//Node types
exports.isTextNode = function (node) {
    return node.nodeName === '#text';
};

exports.isCommentNode = function (node) {
    return node.nodeName === '#comment';
};

exports.isDocumentTypeNode = function (node) {
    return node.nodeName === '#documentType';
};

exports.isElementNode = function (node) {
    return !!node.tagName;
};

},{}],16:[function(require,module,exports){
'use strict';

//Conversion tables for DOM Level1 structure emulation
var nodeTypes = {
    element: 1,
    text: 3,
    cdata: 4,
    comment: 8
};

var nodePropertyShorthands = {
    tagName: 'name',
    childNodes: 'children',
    parentNode: 'parent',
    previousSibling: 'prev',
    nextSibling: 'next',
    nodeValue: 'data'
};

//Node
var Node = function (props) {
    for (var key in props) {
        if (props.hasOwnProperty(key))
            this[key] = props[key];
    }
};

Node.prototype = {
    get firstChild() {
        var children = this.children;
        return children && children[0] || null;
    },

    get lastChild() {
        var children = this.children;
        return children && children[children.length - 1] || null;
    },

    get nodeType() {
        return nodeTypes[this.type] || nodeTypes.element;
    }
};

Object.keys(nodePropertyShorthands).forEach(function (key) {
    var shorthand = nodePropertyShorthands[key];

    Object.defineProperty(Node.prototype, key, {
        get: function () {
            return this[shorthand] || null;
        },
        set: function (val) {
            this[shorthand] = val;
            return val;
        }
    });
});


//Node construction
exports.createDocument =
exports.createDocumentFragment = function () {
    return new Node({
        type: 'root',
        name: 'root',
        parent: null,
        prev: null,
        next: null,
        children: []
    });
};

exports.createElement = function (tagName, namespaceURI, attrs) {
    var attribs = {},
        attribsNamespace = {},
        attribsPrefix = {};

    for (var i = 0; i < attrs.length; i++) {
        var attrName = attrs[i].name;

        attribs[attrName] = attrs[i].value;
        attribsNamespace[attrName] = attrs[i].namespace;
        attribsPrefix[attrName] = attrs[i].prefix;
    }

    return new Node({
        type: tagName === 'script' || tagName === 'style' ? tagName : 'tag',
        name: tagName,
        namespace: namespaceURI,
        attribs: attribs,
        'x-attribsNamespace': attribsNamespace,
        'x-attribsPrefix': attribsPrefix,
        children: [],
        parent: null,
        prev: null,
        next: null
    });
};

exports.createCommentNode = function (data) {
    return new Node({
        type: 'comment',
        data: data,
        parent: null,
        prev: null,
        next: null
    });
};

var createTextNode = function (value) {
    return new Node({
        type: 'text',
        data: value,
        parent: null,
        prev: null,
        next: null
    });
};


//Tree mutation
exports.setDocumentType = function (document, name, publicId, systemId) {
    var data = '!DOCTYPE';

    if (name)
        data += ' ' + name;

    if (publicId)
        data += ' PUBLIC "' + publicId + '"';

    if (systemId)
        data += ' "' + systemId + '"';

    var doctypeNode = null;

    for (var i = 0; i < document.children.length; i++) {
        if (document.children[i].type === 'directive' && document.children[i].name === '!doctype') {
            doctypeNode = document.children[i];
            break;
        }
    }

    if (doctypeNode) {
        doctypeNode.data = data;
        doctypeNode['x-name'] = name;
        doctypeNode['x-publicId'] = publicId;
        doctypeNode['x-systemId'] = systemId;
    }

    else {
        appendChild(document, new Node({
            type: 'directive',
            name: '!doctype',
            data: data,
            'x-name': name,
            'x-publicId': publicId,
            'x-systemId': systemId
        }));
    }

};

exports.setQuirksMode = function (document) {
    document.quirksMode = true;
};

exports.isQuirksMode = function (document) {
    return document.quirksMode;
};

var appendChild = exports.appendChild = function (parentNode, newNode) {
    var prev = parentNode.children[parentNode.children.length - 1];

    if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
    }

    parentNode.children.push(newNode);
    newNode.parent = parentNode;
};

var insertBefore = exports.insertBefore = function (parentNode, newNode, referenceNode) {
    var insertionIdx = parentNode.children.indexOf(referenceNode),
        prev = referenceNode.prev;

    if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
    }

    referenceNode.prev = newNode;
    newNode.next = referenceNode;

    parentNode.children.splice(insertionIdx, 0, newNode);
    newNode.parent = parentNode;
};

exports.detachNode = function (node) {
    if (node.parent) {
        var idx = node.parent.children.indexOf(node),
            prev = node.prev,
            next = node.next;

        node.prev = null;
        node.next = null;

        if (prev)
            prev.next = next;

        if (next)
            next.prev = prev;

        node.parent.children.splice(idx, 1);
        node.parent = null;
    }
};

exports.insertText = function (parentNode, text) {
    var lastChild = parentNode.children[parentNode.children.length - 1];

    if (lastChild && lastChild.type === 'text')
        lastChild.data += text;
    else
        appendChild(parentNode, createTextNode(text));
};

exports.insertTextBefore = function (parentNode, text, referenceNode) {
    var prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];

    if (prevNode && prevNode.type === 'text')
        prevNode.data += text;
    else
        insertBefore(parentNode, createTextNode(text), referenceNode);
};

exports.adoptAttributes = function (recipientNode, attrs) {
    for (var i = 0; i < attrs.length; i++) {
        var attrName = attrs[i].name;

        if (typeof recipientNode.attribs[attrName] === 'undefined') {
            recipientNode.attribs[attrName] = attrs[i].value;
            recipientNode['x-attribsNamespace'][attrName] = attrs[i].namespace;
            recipientNode['x-attribsPrefix'][attrName] = attrs[i].prefix;
        }
    }
};


//Tree traversing
exports.getFirstChild = function (node) {
    return node.children[0];
};

exports.getChildNodes = function (node) {
    return node.children;
};

exports.getParentNode = function (node) {
    return node.parent;
};

exports.getAttrList = function (node) {
    var attrList = [];

    for (var name in node.attribs) {
        if (node.attribs.hasOwnProperty(name)) {
            attrList.push({
                name: name,
                value: node.attribs[name],
                namespace: node['x-attribsNamespace'][name],
                prefix: node['x-attribsPrefix'][name]
            });
        }
    }

    return attrList;
};


//Node data
exports.getTagName = function (element) {
    return element.name;
};

exports.getNamespaceURI = function (element) {
    return element.namespace;
};

exports.getTextNodeContent = function (textNode) {
    return textNode.data;
};

exports.getCommentNodeContent = function (commentNode) {
    return commentNode.data;
};

exports.getDocumentTypeNodeName = function (doctypeNode) {
    return doctypeNode['x-name'];
};

exports.getDocumentTypeNodePublicId = function (doctypeNode) {
    return doctypeNode['x-publicId'];
};

exports.getDocumentTypeNodeSystemId = function (doctypeNode) {
    return doctypeNode['x-systemId'];
};


//Node types
exports.isTextNode = function (node) {
    return node.type === 'text';
};

exports.isCommentNode = function (node) {
    return node.type === 'comment';
};

exports.isDocumentTypeNode = function (node) {
    return node.type === 'directive' && node.name === '!doctype';
};

exports.isElementNode = function (node) {
    return !!node.attribs;
};

},{}],17:[function(require,module,exports){
'use strict';

//Const
var VALID_DOCTYPE_NAME = 'html',
    QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd',
    QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
        "+//silmaril//dtd html pro v0r11 19970101//en",
        "-//advasoft ltd//dtd html 3.0 aswedit + extensions//en",
        "-//as//dtd html 3.0 aswedit + extensions//en",
        "-//ietf//dtd html 2.0 level 1//en",
        "-//ietf//dtd html 2.0 level 2//en",
        "-//ietf//dtd html 2.0 strict level 1//en",
        "-//ietf//dtd html 2.0 strict level 2//en",
        "-//ietf//dtd html 2.0 strict//en",
        "-//ietf//dtd html 2.0//en",
        "-//ietf//dtd html 2.1e//en",
        "-//ietf//dtd html 3.0//en",
        "-//ietf//dtd html 3.0//en//",
        "-//ietf//dtd html 3.2 final//en",
        "-//ietf//dtd html 3.2//en",
        "-//ietf//dtd html 3//en",
        "-//ietf//dtd html level 0//en",
        "-//ietf//dtd html level 0//en//2.0",
        "-//ietf//dtd html level 1//en",
        "-//ietf//dtd html level 1//en//2.0",
        "-//ietf//dtd html level 2//en",
        "-//ietf//dtd html level 2//en//2.0",
        "-//ietf//dtd html level 3//en",
        "-//ietf//dtd html level 3//en//3.0",
        "-//ietf//dtd html strict level 0//en",
        "-//ietf//dtd html strict level 0//en//2.0",
        "-//ietf//dtd html strict level 1//en",
        "-//ietf//dtd html strict level 1//en//2.0",
        "-//ietf//dtd html strict level 2//en",
        "-//ietf//dtd html strict level 2//en//2.0",
        "-//ietf//dtd html strict level 3//en",
        "-//ietf//dtd html strict level 3//en//3.0",
        "-//ietf//dtd html strict//en",
        "-//ietf//dtd html strict//en//2.0",
        "-//ietf//dtd html strict//en//3.0",
        "-//ietf//dtd html//en",
        "-//ietf//dtd html//en//2.0",
        "-//ietf//dtd html//en//3.0",
        "-//metrius//dtd metrius presentational//en",
        "-//microsoft//dtd internet explorer 2.0 html strict//en",
        "-//microsoft//dtd internet explorer 2.0 html//en",
        "-//microsoft//dtd internet explorer 2.0 tables//en",
        "-//microsoft//dtd internet explorer 3.0 html strict//en",
        "-//microsoft//dtd internet explorer 3.0 html//en",
        "-//microsoft//dtd internet explorer 3.0 tables//en",
        "-//netscape comm. corp.//dtd html//en",
        "-//netscape comm. corp.//dtd strict html//en",
        "-//o'reilly and associates//dtd html 2.0//en",
        "-//o'reilly and associates//dtd html extended 1.0//en",
        "-//spyglass//dtd html 2.0 extended//en",
        "-//sq//dtd html 2.0 hotmetal + extensions//en",
        "-//sun microsystems corp.//dtd hotjava html//en",
        "-//sun microsystems corp.//dtd hotjava strict html//en",
        "-//w3c//dtd html 3 1995-03-24//en",
        "-//w3c//dtd html 3.2 draft//en",
        "-//w3c//dtd html 3.2 final//en",
        "-//w3c//dtd html 3.2//en",
        "-//w3c//dtd html 3.2s draft//en",
        "-//w3c//dtd html 4.0 frameset//en",
        "-//w3c//dtd html 4.0 transitional//en",
        "-//w3c//dtd html experimental 19960712//en",
        "-//w3c//dtd html experimental 970421//en",
        "-//w3c//dtd w3 html//en",
        "-//w3o//dtd w3 html 3.0//en",
        "-//w3o//dtd w3 html 3.0//en//",
        "-//webtechs//dtd mozilla html 2.0//en",
        "-//webtechs//dtd mozilla html//en"
    ],
    QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
        '-//w3c//dtd html 4.01 frameset//',
        '-//w3c//dtd html 4.01 transitional//'
    ],
    QUIRKS_MODE_PUBLIC_IDS = [
        '-//w3o//dtd w3 html strict 3.0//en//',
        '-/w3c/dtd html 4.0 transitional/en',
        'html'
    ];

exports.isQuirks = function (name, publicId, systemId) {
    if (name !== VALID_DOCTYPE_NAME)
        return true;

    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID)
        return true;

    if (publicId !== null) {
        publicId = publicId.toLowerCase();

        if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1)
            return true;

        var prefixes = QUIRKS_MODE_PUBLIC_ID_PREFIXES;

        if (systemId === null)
            prefixes = prefixes.concat(QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES);

        for (var i = 0; i < prefixes.length; i++) {
            if (publicId.indexOf(prefixes[i]) === 0)
                return true;
        }
    }

    return false;
};

},{}],18:[function(require,module,exports){
'use strict';

//Const
var NOAH_ARK_CAPACITY = 3;

//List of formatting elements
var FormattingElementList = module.exports = function (treeAdapter) {
    this.length = 0;
    this.entries = [];
    this.treeAdapter = treeAdapter;
    this.bookmark = null;
};

//Entry types
FormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';
FormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';

//Noah Ark's condition
//OPTIMIZATION: at first we try to find possible candidates for exclusion using
//lightweight heuristics without thorough attributes check.
FormattingElementList.prototype._getNoahArkConditionCandidates = function (newElement) {
    var candidates = [];

    if (this.length >= NOAH_ARK_CAPACITY) {
        var neAttrsLength = this.treeAdapter.getAttrList(newElement).length,
            neTagName = this.treeAdapter.getTagName(newElement),
            neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);

        for (var i = this.length - 1; i >= 0; i--) {
            var entry = this.entries[i];

            if (entry.type === FormattingElementList.MARKER_ENTRY)
                break;

            var element = entry.element,
                elementAttrs = this.treeAdapter.getAttrList(element);

            if (this.treeAdapter.getTagName(element) === neTagName &&
                this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&
                elementAttrs.length === neAttrsLength) {
                candidates.push({idx: i, attrs: elementAttrs});
            }
        }
    }

    return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
};

FormattingElementList.prototype._ensureNoahArkCondition = function (newElement) {
    var candidates = this._getNoahArkConditionCandidates(newElement),
        cLength = candidates.length;

    if (cLength) {
        var neAttrs = this.treeAdapter.getAttrList(newElement),
            neAttrsLength = neAttrs.length,
            neAttrsMap = {};

        //NOTE: build attrs map for the new element so we can perform fast lookups
        for (var i = 0; i < neAttrsLength; i++) {
            var neAttr = neAttrs[i];

            neAttrsMap[neAttr.name] = neAttr.value;
        }

        for (var i = 0; i < neAttrsLength; i++) {
            for (var j = 0; j < cLength; j++) {
                var cAttr = candidates[j].attrs[i];

                if (neAttrsMap[cAttr.name] !== cAttr.value) {
                    candidates.splice(j, 1);
                    cLength--;
                }

                if (candidates.length < NOAH_ARK_CAPACITY)
                    return;
            }
        }

        //NOTE: remove bottommost candidates until Noah's Ark condition will not be met
        for (var i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
            this.entries.splice(candidates[i].idx, 1);
            this.length--;
        }
    }
};

//Mutations
FormattingElementList.prototype.insertMarker = function () {
    this.entries.push({type: FormattingElementList.MARKER_ENTRY});
    this.length++;
};

FormattingElementList.prototype.pushElement = function (element, token) {
    this._ensureNoahArkCondition(element);

    this.entries.push({
        type: FormattingElementList.ELEMENT_ENTRY,
        element: element,
        token: token
    });

    this.length++;
};

FormattingElementList.prototype.insertElementAfterBookmark = function (element, token) {
    var bookmarkIdx = this.length - 1;

    for (; bookmarkIdx >= 0; bookmarkIdx--) {
        if (this.entries[bookmarkIdx] === this.bookmark)
            break;
    }

    this.entries.splice(bookmarkIdx + 1, 0, {
        type: FormattingElementList.ELEMENT_ENTRY,
        element: element,
        token: token
    });

    this.length++;
};

FormattingElementList.prototype.removeEntry = function (entry) {
    for (var i = this.length - 1; i >= 0; i--) {
        if (this.entries[i] === entry) {
            this.entries.splice(i, 1);
            this.length--;
            break;
        }
    }
};

FormattingElementList.prototype.clearToLastMarker = function () {
    while (this.length) {
        var entry = this.entries.pop();

        this.length--;

        if (entry.type === FormattingElementList.MARKER_ENTRY)
            break;
    }
};

//Search
FormattingElementList.prototype.getElementEntryInScopeWithTagName = function (tagName) {
    for (var i = this.length - 1; i >= 0; i--) {
        var entry = this.entries[i];

        if (entry.type === FormattingElementList.MARKER_ENTRY)
            return null;

        if (this.treeAdapter.getTagName(entry.element) === tagName)
            return entry;
    }

    return null;
};

FormattingElementList.prototype.getElementEntry = function (element) {
    for (var i = this.length - 1; i >= 0; i--) {
        var entry = this.entries[i];

        if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element == element)
            return entry;
    }

    return null;
};

},{}],19:[function(require,module,exports){
'use strict';

var HTML = require('../common/html');

//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES;

//Element utils

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function isImpliedEndTagRequired(tn) {
    switch (tn.length) {
        case 1:
            return tn === $.P;

        case 2:
            return tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI;

        case 6:
            return tn === $.OPTION;

        case 8:
            return tn === $.OPTGROUP;
    }

    return false;
}

function isScopingElement(tn, ns) {
    switch (tn.length) {
        case 2:
            if (tn === $.TD || tn === $.TH)
                return ns === NS.HTML;

            else if (tn === $.MI || tn === $.MO || tn == $.MN || tn === $.MS)
                return ns === NS.MATHML;

            break;

        case 4:
            if (tn === $.HTML)
                return ns === NS.HTML;

            else if (tn === $.DESC)
                return ns === NS.SVG;

            break;

        case 5:
            if (tn === $.TABLE)
                return ns === NS.HTML;

            else if (tn === $.MTEXT)
                return ns === NS.MATHML;

            else if (tn === $.TITLE)
                return ns === NS.SVG;

            break;

        case 6:
            return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;

        case 7:
            return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;

        case 8:
            return tn === $.TEMPLATE && ns === NS.HTML;

        case 13:
            return tn === $.FOREIGN_OBJECT && ns === NS.SVG;

        case 14:
            return tn === $.ANNOTATION_XML && ns === NS.MATHML;
    }

    return false;
}

//Stack of open elements
var OpenElementStack = module.exports = function (document, treeAdapter) {
    this.stackTop = -1;
    this.items = [];
    this.current = document;
    this.currentTagName = null;
    this.currentTmplContent = null;
    this.tmplCount = 0;
    this.treeAdapter = treeAdapter;
};

//Index of element
OpenElementStack.prototype._indexOf = function (element) {
    var idx = -1;

    for (var i = this.stackTop; i >= 0; i--) {
        if (this.items[i] === element) {
            idx = i;
            break;
        }
    }
    return idx;
};

//Update current element
OpenElementStack.prototype._isInTemplate = function () {
    if (this.currentTagName !== $.TEMPLATE)
        return false;

    return this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
};

OpenElementStack.prototype._updateCurrentElement = function () {
    this.current = this.items[this.stackTop];
    this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);

    this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getChildNodes(this.current)[0] : null;
};

//Mutations
OpenElementStack.prototype.push = function (element) {
    this.items[++this.stackTop] = element;
    this._updateCurrentElement();

    if (this._isInTemplate())
        this.tmplCount++;

};

OpenElementStack.prototype.pop = function () {
    this.stackTop--;

    if (this.tmplCount > 0 && this._isInTemplate())
        this.tmplCount--;

    this._updateCurrentElement();
};

OpenElementStack.prototype.replace = function (oldElement, newElement) {
    var idx = this._indexOf(oldElement);
    this.items[idx] = newElement;

    if (idx === this.stackTop)
        this._updateCurrentElement();
};

OpenElementStack.prototype.insertAfter = function (referenceElement, newElement) {
    var insertionIdx = this._indexOf(referenceElement) + 1;

    this.items.splice(insertionIdx, 0, newElement);

    if (insertionIdx == ++this.stackTop)
        this._updateCurrentElement();
};

OpenElementStack.prototype.popUntilTagNamePopped = function (tagName) {
    while (this.stackTop > -1) {
        var tn = this.currentTagName;

        this.pop();

        if (tn === tagName)
            break;
    }
};

OpenElementStack.prototype.popUntilTemplatePopped = function () {
    while (this.stackTop > -1) {
        var tn = this.currentTagName,
            ns = this.treeAdapter.getNamespaceURI(this.current);

        this.pop();

        if (tn === $.TEMPLATE && ns === NS.HTML)
            break;
    }
};

OpenElementStack.prototype.popUntilElementPopped = function (element) {
    while (this.stackTop > -1) {
        var poppedElement = this.current;

        this.pop();

        if (poppedElement === element)
            break;
    }
};

OpenElementStack.prototype.popUntilNumberedHeaderPopped = function () {
    while (this.stackTop > -1) {
        var tn = this.currentTagName;

        this.pop();

        if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6)
            break;
    }
};

OpenElementStack.prototype.popAllUpToHtmlElement = function () {
    //NOTE: here we assume that root <html> element is always first in the open element stack, so
    //we perform this fast stack clean up.
    this.stackTop = 0;
    this._updateCurrentElement();
};

OpenElementStack.prototype.clearBackToTableContext = function () {
    while (this.currentTagName !== $.TABLE && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML)
        this.pop();
};

OpenElementStack.prototype.clearBackToTableBodyContext = function () {
    while (this.currentTagName !== $.TBODY && this.currentTagName !== $.TFOOT &&
           this.currentTagName !== $.THEAD && this.currentTagName !== $.TEMPLATE &&
           this.currentTagName !== $.HTML) {
        this.pop();
    }
};

OpenElementStack.prototype.clearBackToTableRowContext = function () {
    while (this.currentTagName !== $.TR && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML)
        this.pop();
};

OpenElementStack.prototype.remove = function (element) {
    for (var i = this.stackTop; i >= 0; i--) {
        if (this.items[i] === element) {
            this.items.splice(i, 1);
            this.stackTop--;
            this._updateCurrentElement();
            break;
        }
    }
};

//Search
OpenElementStack.prototype.tryPeekProperlyNestedBodyElement = function () {
    //Properly nested <body> element (should be second element in stack).
    var element = this.items[1];
    return element && this.treeAdapter.getTagName(element) === $.BODY ? element : null;
};

OpenElementStack.prototype.contains = function (element) {
    return this._indexOf(element) > -1;
};

OpenElementStack.prototype.getCommonAncestor = function (element) {
    var elementIdx = this._indexOf(element);

    return --elementIdx >= 0 ? this.items[elementIdx] : null;
};

OpenElementStack.prototype.isRootHtmlElementCurrent = function () {
    return this.stackTop === 0 && this.currentTagName === $.HTML;
};

//Element in scope
OpenElementStack.prototype.hasInScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]);

        if (tn === tagName)
            return true;

        var ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if (isScopingElement(tn, ns))
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasNumberedHeaderInScope = function () {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]);

        if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6)
            return true;

        if (isScopingElement(tn, this.treeAdapter.getNamespaceURI(this.items[i])))
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasInListItemScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]);

        if (tn === tagName)
            return true;

        var ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if (((tn === $.UL || tn === $.OL) && ns === NS.HTML) || isScopingElement(tn, ns))
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasInButtonScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]);

        if (tn === tagName)
            return true;

        var ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if ((tn === $.BUTTON && ns === NS.HTML) || isScopingElement(tn, ns))
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasInTableScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]);

        if (tn === tagName)
            return true;

        var ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if ((tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML) && ns === NS.HTML)
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasTableBodyContextInTableScope = function () {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]);

        if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT)
            return true;

        var ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if ((tn === $.TABLE || tn === $.HTML) && ns === NS.HTML)
            return false;
    }

    return true;
};

OpenElementStack.prototype.hasInSelectScope = function (tagName) {
    for (var i = this.stackTop; i >= 0; i--) {
        var tn = this.treeAdapter.getTagName(this.items[i]);

        if (tn === tagName)
            return true;

        var ns = this.treeAdapter.getNamespaceURI(this.items[i]);

        if (tn !== $.OPTION && tn !== $.OPTGROUP && ns === NS.HTML)
            return false;
    }

    return true;
};

//Implied end tags
OpenElementStack.prototype.generateImpliedEndTags = function () {
    while (isImpliedEndTagRequired(this.currentTagName))
        this.pop();
};

OpenElementStack.prototype.generateImpliedEndTagsWithExclusion = function (exclusionTagName) {
    while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName)
        this.pop();
};

},{"../common/html":4}],20:[function(require,module,exports){
'use strict';

var Tokenizer = require('../tokenization/tokenizer'),
    OpenElementStack = require('./open_element_stack'),
    FormattingElementList = require('./formatting_element_list'),
    Doctype = require('./doctype'),
    DefaultTreeAdapter = require('../tree_adapters/default'),
    ForeignContent = require('../common/foreign_content'),
    UNICODE = require('../common/unicode'),
    HTML = require('../common/html');

//Aliases
var $ = HTML.TAG_NAMES,
    NS = HTML.NAMESPACES,
    ATTRS = HTML.ATTRS;

//Misc constants
var SEARCHABLE_INDEX_DEFAULT_PROMPT = 'This is a searchable index. Enter search keywords: ',
    SEARCHABLE_INDEX_INPUT_NAME = 'isindex',
    HIDDEN_INPUT_TYPE = 'hidden';

//Adoption agency loops iteration count
var AA_OUTER_LOOP_ITER = 8,
    AA_INNER_LOOP_ITER = 3;

//Insertion modes
var INITIAL_MODE = 'INITIAL_MODE',
    BEFORE_HTML_MODE = 'BEFORE_HTML_MODE',
    BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE',
    IN_HEAD_MODE = 'IN_HEAD_MODE',
    AFTER_HEAD_MODE = 'AFTER_HEAD_MODE',
    IN_BODY_MODE = 'IN_BODY_MODE',
    TEXT_MODE = 'TEXT_MODE',
    IN_TABLE_MODE = 'IN_TABLE_MODE',
    IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE',
    IN_CAPTION_MODE = 'IN_CAPTION_MODE',
    IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE',
    IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE',
    IN_ROW_MODE = 'IN_ROW_MODE',
    IN_CELL_MODE = 'IN_CELL_MODE',
    IN_SELECT_MODE = 'IN_SELECT_MODE',
    IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE',
    IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE',
    AFTER_BODY_MODE = 'AFTER_BODY_MODE',
    IN_FRAMESET_MODE = 'IN_FRAMESET_MODE',
    AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE',
    AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE',
    AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';

//Insertion mode reset map
var INSERTION_MODE_RESET_MAP = {};

INSERTION_MODE_RESET_MAP[$.TR] = IN_ROW_MODE;
INSERTION_MODE_RESET_MAP[$.TBODY] =
INSERTION_MODE_RESET_MAP[$.THEAD] =
INSERTION_MODE_RESET_MAP[$.TFOOT] = IN_TABLE_BODY_MODE;
INSERTION_MODE_RESET_MAP[$.CAPTION] = IN_CAPTION_MODE;
INSERTION_MODE_RESET_MAP[$.COLGROUP] = IN_COLUMN_GROUP_MODE;
INSERTION_MODE_RESET_MAP[$.TABLE] = IN_TABLE_MODE;
INSERTION_MODE_RESET_MAP[$.BODY] = IN_BODY_MODE;
INSERTION_MODE_RESET_MAP[$.FRAMESET] = IN_FRAMESET_MODE;

//Template insertion mode switch map
var TEMPLATE_INSERTION_MODE_SWITCH_MAP = {};

TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.CAPTION] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.COLGROUP] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TBODY] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TFOOT] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.THEAD] = IN_TABLE_MODE;
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.COL] = IN_COLUMN_GROUP_MODE;
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TR] = IN_TABLE_BODY_MODE;
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TD] =
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$.TH] = IN_ROW_MODE;

//Token handlers map for insertion modes
var _ = {};

_[INITIAL_MODE] = {};
_[INITIAL_MODE][Tokenizer.CHARACTER_TOKEN] =
_[INITIAL_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenInInitialMode;
_[INITIAL_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = ignoreToken;
_[INITIAL_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[INITIAL_MODE][Tokenizer.DOCTYPE_TOKEN] = doctypeInInitialMode;
_[INITIAL_MODE][Tokenizer.START_TAG_TOKEN] =
_[INITIAL_MODE][Tokenizer.END_TAG_TOKEN] =
_[INITIAL_MODE][Tokenizer.EOF_TOKEN] = tokenInInitialMode;

_[BEFORE_HTML_MODE] = {};
_[BEFORE_HTML_MODE][Tokenizer.CHARACTER_TOKEN] =
_[BEFORE_HTML_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenBeforeHtml;
_[BEFORE_HTML_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = ignoreToken;
_[BEFORE_HTML_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[BEFORE_HTML_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[BEFORE_HTML_MODE][Tokenizer.START_TAG_TOKEN] = startTagBeforeHtml;
_[BEFORE_HTML_MODE][Tokenizer.END_TAG_TOKEN] = endTagBeforeHtml;
_[BEFORE_HTML_MODE][Tokenizer.EOF_TOKEN] = tokenBeforeHtml;

_[BEFORE_HEAD_MODE] = {};
_[BEFORE_HEAD_MODE][Tokenizer.CHARACTER_TOKEN] =
_[BEFORE_HEAD_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenBeforeHead;
_[BEFORE_HEAD_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = ignoreToken;
_[BEFORE_HEAD_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[BEFORE_HEAD_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[BEFORE_HEAD_MODE][Tokenizer.START_TAG_TOKEN] = startTagBeforeHead;
_[BEFORE_HEAD_MODE][Tokenizer.END_TAG_TOKEN] = endTagBeforeHead;
_[BEFORE_HEAD_MODE][Tokenizer.EOF_TOKEN] = tokenBeforeHead;

_[IN_HEAD_MODE] = {};
_[IN_HEAD_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_HEAD_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenInHead;
_[IN_HEAD_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_HEAD_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_HEAD_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_HEAD_MODE][Tokenizer.START_TAG_TOKEN] = startTagInHead;
_[IN_HEAD_MODE][Tokenizer.END_TAG_TOKEN] = endTagInHead;
_[IN_HEAD_MODE][Tokenizer.EOF_TOKEN] = tokenInHead;

_[AFTER_HEAD_MODE] = {};
_[AFTER_HEAD_MODE][Tokenizer.CHARACTER_TOKEN] =
_[AFTER_HEAD_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenAfterHead;
_[AFTER_HEAD_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[AFTER_HEAD_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[AFTER_HEAD_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_HEAD_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterHead;
_[AFTER_HEAD_MODE][Tokenizer.END_TAG_TOKEN] = endTagAfterHead;
_[AFTER_HEAD_MODE][Tokenizer.EOF_TOKEN] = tokenAfterHead;

_[IN_BODY_MODE] = {};
_[IN_BODY_MODE][Tokenizer.CHARACTER_TOKEN] = characterInBody;
_[IN_BODY_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_BODY_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[IN_BODY_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_BODY_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_BODY_MODE][Tokenizer.START_TAG_TOKEN] = startTagInBody;
_[IN_BODY_MODE][Tokenizer.END_TAG_TOKEN] = endTagInBody;
_[IN_BODY_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[TEXT_MODE] = {};
_[TEXT_MODE][Tokenizer.CHARACTER_TOKEN] =
_[TEXT_MODE][Tokenizer.NULL_CHARACTER_TOKEN] =
_[TEXT_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[TEXT_MODE][Tokenizer.COMMENT_TOKEN] =
_[TEXT_MODE][Tokenizer.DOCTYPE_TOKEN] =
_[TEXT_MODE][Tokenizer.START_TAG_TOKEN] = ignoreToken;
_[TEXT_MODE][Tokenizer.END_TAG_TOKEN] = endTagInText;
_[TEXT_MODE][Tokenizer.EOF_TOKEN] = eofInText;

_[IN_TABLE_MODE] = {};
_[IN_TABLE_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_TABLE_MODE][Tokenizer.NULL_CHARACTER_TOKEN] =
_[IN_TABLE_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = characterInTable;
_[IN_TABLE_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_TABLE_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_TABLE_MODE][Tokenizer.START_TAG_TOKEN] = startTagInTable;
_[IN_TABLE_MODE][Tokenizer.END_TAG_TOKEN] = endTagInTable;
_[IN_TABLE_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_TABLE_TEXT_MODE] = {};
_[IN_TABLE_TEXT_MODE][Tokenizer.CHARACTER_TOKEN] = characterInTableText;
_[IN_TABLE_TEXT_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_TABLE_TEXT_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInTableText;
_[IN_TABLE_TEXT_MODE][Tokenizer.COMMENT_TOKEN] =
_[IN_TABLE_TEXT_MODE][Tokenizer.DOCTYPE_TOKEN] =
_[IN_TABLE_TEXT_MODE][Tokenizer.START_TAG_TOKEN] =
_[IN_TABLE_TEXT_MODE][Tokenizer.END_TAG_TOKEN] =
_[IN_TABLE_TEXT_MODE][Tokenizer.EOF_TOKEN] = tokenInTableText;

_[IN_CAPTION_MODE] = {};
_[IN_CAPTION_MODE][Tokenizer.CHARACTER_TOKEN] = characterInBody;
_[IN_CAPTION_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_CAPTION_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[IN_CAPTION_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_CAPTION_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_CAPTION_MODE][Tokenizer.START_TAG_TOKEN] = startTagInCaption;
_[IN_CAPTION_MODE][Tokenizer.END_TAG_TOKEN] = endTagInCaption;
_[IN_CAPTION_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_COLUMN_GROUP_MODE] = {};
_[IN_COLUMN_GROUP_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_COLUMN_GROUP_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenInColumnGroup;
_[IN_COLUMN_GROUP_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_COLUMN_GROUP_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_COLUMN_GROUP_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_COLUMN_GROUP_MODE][Tokenizer.START_TAG_TOKEN] = startTagInColumnGroup;
_[IN_COLUMN_GROUP_MODE][Tokenizer.END_TAG_TOKEN] = endTagInColumnGroup;
_[IN_COLUMN_GROUP_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_TABLE_BODY_MODE] = {};
_[IN_TABLE_BODY_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_TABLE_BODY_MODE][Tokenizer.NULL_CHARACTER_TOKEN] =
_[IN_TABLE_BODY_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = characterInTable;
_[IN_TABLE_BODY_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_TABLE_BODY_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_TABLE_BODY_MODE][Tokenizer.START_TAG_TOKEN] = startTagInTableBody;
_[IN_TABLE_BODY_MODE][Tokenizer.END_TAG_TOKEN] = endTagInTableBody;
_[IN_TABLE_BODY_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_ROW_MODE] = {};
_[IN_ROW_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_ROW_MODE][Tokenizer.NULL_CHARACTER_TOKEN] =
_[IN_ROW_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = characterInTable;
_[IN_ROW_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_ROW_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_ROW_MODE][Tokenizer.START_TAG_TOKEN] = startTagInRow;
_[IN_ROW_MODE][Tokenizer.END_TAG_TOKEN] = endTagInRow;
_[IN_ROW_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_CELL_MODE] = {};
_[IN_CELL_MODE][Tokenizer.CHARACTER_TOKEN] = characterInBody;
_[IN_CELL_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_CELL_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[IN_CELL_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_CELL_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_CELL_MODE][Tokenizer.START_TAG_TOKEN] = startTagInCell;
_[IN_CELL_MODE][Tokenizer.END_TAG_TOKEN] = endTagInCell;
_[IN_CELL_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_SELECT_MODE] = {};
_[IN_SELECT_MODE][Tokenizer.CHARACTER_TOKEN] = insertCharacters;
_[IN_SELECT_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_SELECT_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_SELECT_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_SELECT_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_SELECT_MODE][Tokenizer.START_TAG_TOKEN] = startTagInSelect;
_[IN_SELECT_MODE][Tokenizer.END_TAG_TOKEN] = endTagInSelect;
_[IN_SELECT_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_SELECT_IN_TABLE_MODE] = {};
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.CHARACTER_TOKEN] = insertCharacters;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.START_TAG_TOKEN] = startTagInSelectInTable;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.END_TAG_TOKEN] = endTagInSelectInTable;
_[IN_SELECT_IN_TABLE_MODE][Tokenizer.EOF_TOKEN] = eofInBody;

_[IN_TEMPLATE_MODE] = {};
_[IN_TEMPLATE_MODE][Tokenizer.CHARACTER_TOKEN] = characterInBody;
_[IN_TEMPLATE_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_TEMPLATE_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[IN_TEMPLATE_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_TEMPLATE_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_TEMPLATE_MODE][Tokenizer.START_TAG_TOKEN] = startTagInTemplate;
_[IN_TEMPLATE_MODE][Tokenizer.END_TAG_TOKEN] = endTagInTemplate;
_[IN_TEMPLATE_MODE][Tokenizer.EOF_TOKEN] = eofInTemplate;

_[AFTER_BODY_MODE] = {};
_[AFTER_BODY_MODE][Tokenizer.CHARACTER_TOKEN] =
_[AFTER_BODY_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenAfterBody;
_[AFTER_BODY_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[AFTER_BODY_MODE][Tokenizer.COMMENT_TOKEN] = appendCommentToRootHtmlElement;
_[AFTER_BODY_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_BODY_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterBody;
_[AFTER_BODY_MODE][Tokenizer.END_TAG_TOKEN] = endTagAfterBody;
_[AFTER_BODY_MODE][Tokenizer.EOF_TOKEN] = stopParsing;

_[IN_FRAMESET_MODE] = {};
_[IN_FRAMESET_MODE][Tokenizer.CHARACTER_TOKEN] =
_[IN_FRAMESET_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[IN_FRAMESET_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[IN_FRAMESET_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[IN_FRAMESET_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[IN_FRAMESET_MODE][Tokenizer.START_TAG_TOKEN] = startTagInFrameset;
_[IN_FRAMESET_MODE][Tokenizer.END_TAG_TOKEN] = endTagInFrameset;
_[IN_FRAMESET_MODE][Tokenizer.EOF_TOKEN] = stopParsing;

_[AFTER_FRAMESET_MODE] = {};
_[AFTER_FRAMESET_MODE][Tokenizer.CHARACTER_TOKEN] =
_[AFTER_FRAMESET_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[AFTER_FRAMESET_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_[AFTER_FRAMESET_MODE][Tokenizer.COMMENT_TOKEN] = appendComment;
_[AFTER_FRAMESET_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_FRAMESET_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterFrameset;
_[AFTER_FRAMESET_MODE][Tokenizer.END_TAG_TOKEN] = endTagAfterFrameset;
_[AFTER_FRAMESET_MODE][Tokenizer.EOF_TOKEN] = stopParsing;

_[AFTER_AFTER_BODY_MODE] = {};
_[AFTER_AFTER_BODY_MODE][Tokenizer.CHARACTER_TOKEN] = tokenAfterAfterBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = tokenAfterAfterBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.COMMENT_TOKEN] = appendCommentToDocument;
_[AFTER_AFTER_BODY_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_AFTER_BODY_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterAfterBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.END_TAG_TOKEN] = tokenAfterAfterBody;
_[AFTER_AFTER_BODY_MODE][Tokenizer.EOF_TOKEN] = stopParsing;

_[AFTER_AFTER_FRAMESET_MODE] = {};
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.CHARACTER_TOKEN] =
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.NULL_CHARACTER_TOKEN] = ignoreToken;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.COMMENT_TOKEN] = appendCommentToDocument;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.DOCTYPE_TOKEN] = ignoreToken;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.START_TAG_TOKEN] = startTagAfterAfterFrameset;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.END_TAG_TOKEN] = ignoreToken;
_[AFTER_AFTER_FRAMESET_MODE][Tokenizer.EOF_TOKEN] = stopParsing;

//Searchable index building utils (<isindex> tag)
function getSearchableIndexFormAttrs(isindexStartTagToken) {
    var indexAction = Tokenizer.getTokenAttr(isindexStartTagToken, ATTRS.ACTION),
        attrs = [];

    if (indexAction !== null) {
        attrs.push({
            name: ATTRS.ACTION,
            value: indexAction
        });
    }

    return attrs;
}

function getSearchableIndexLabelText(isindexStartTagToken) {
    var indexPrompt = Tokenizer.getTokenAttr(isindexStartTagToken, ATTRS.PROMPT);

    return indexPrompt === null ? SEARCHABLE_INDEX_DEFAULT_PROMPT : indexPrompt;
}

function getSearchableIndexInputAttrs(isindexStartTagToken) {
    var isindexAttrs = isindexStartTagToken.attrs,
        inputAttrs = [];

    for (var i = 0; i < isindexAttrs.length; i++) {
        var name = isindexAttrs[i].name;

        if (name !== ATTRS.NAME && name !== ATTRS.ACTION && name !== ATTRS.PROMPT)
            inputAttrs.push(isindexAttrs[i]);
    }

    inputAttrs.push({
        name: ATTRS.NAME,
        value: SEARCHABLE_INDEX_INPUT_NAME
    });

    return inputAttrs;
}

//Parser
var Parser = module.exports = function (treeAdapter) {
    this.treeAdapter = treeAdapter || DefaultTreeAdapter;
    this.scriptHandler = null;
};

//API
Parser.prototype.parse = function (html) {
    var document = this.treeAdapter.createDocument();

    this._reset(html, document, null);
    this._runParsingLoop();

    return document;
};

Parser.prototype.parseFragment = function (html, fragmentContext) {
    //NOTE: use <template> element as a fragment context if context element was not provided,
    //so we will parse in "forgiving" manner
    if (!fragmentContext)
        fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);

    //NOTE: create fake element which will be used as 'document' for fragment parsing.
    //This is important for jsdom there 'document' can't be recreated, therefore
    //fragment parsing causes messing of the main `document`.
    var documentMock = this.treeAdapter.createElement('documentmock', NS.HTML, []);

    this._reset(html, documentMock, fragmentContext);

    if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE)
        this._pushTmplInsertionMode(IN_TEMPLATE_MODE);

    this._initTokenizerForFragmentParsing();
    this._insertFakeRootElement();
    this._resetInsertionMode();
    this._findFormInFragmentContext();
    this._runParsingLoop();

    var rootElement = this.treeAdapter.getFirstChild(documentMock),
        fragment = this.treeAdapter.createDocumentFragment();

    this._adoptNodes(rootElement, fragment);

    return fragment;
};

//Reset state
Parser.prototype._reset = function (html, document, fragmentContext) {
    this.tokenizer = new Tokenizer(html);

    this.stopped = false;

    this.insertionMode = INITIAL_MODE;
    this.originalInsertionMode = '';

    this.document = document;
    this.fragmentContext = fragmentContext;

    this.headElement = null;
    this.formElement = null;

    this.openElements = new OpenElementStack(this.document, this.treeAdapter);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);

    this.tmplInsertionModeStack = [];
    this.tmplInsertionModeStackTop = -1;
    this.currentTmplInsertionMode = null;

    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;

    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
};

//Parsing loop
Parser.prototype._iterateParsingLoop = function () {
    this._setupTokenizerCDATAMode();

    var token = this.tokenizer.getNextToken();

    if (this.skipNextNewLine) {
        this.skipNextNewLine = false;

        if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
            if (token.chars.length === 1)
                return;

            token.chars = token.chars.substr(1);
        }
    }

    if (this._shouldProcessTokenInForeignContent(token))
        this._processTokenInForeignContent(token);

    else
        this._processToken(token);
};

Parser.prototype._runParsingLoop = function () {
    while (!this.stopped)
        this._iterateParsingLoop();
};

//Text parsing
Parser.prototype._setupTokenizerCDATAMode = function () {
    var current = this._getAdjustedCurrentElement();

    this.tokenizer.allowCDATA = current && current !== this.document &&
                                this.treeAdapter.getNamespaceURI(current) !== NS.HTML &&
                                (!this._isHtmlIntegrationPoint(current)) &&
                                (!this._isMathMLTextIntegrationPoint(current));
};

Parser.prototype._switchToTextParsing = function (currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = TEXT_MODE;
};

//Fragment parsing
Parser.prototype._getAdjustedCurrentElement = function () {
    return this.openElements.stackTop === 0 && this.fragmentContext ?
           this.fragmentContext :
           this.openElements.current;
};

Parser.prototype._findFormInFragmentContext = function () {
    var node = this.fragmentContext;

    do {
        if (this.treeAdapter.getTagName(node) === $.FORM) {
            this.formElement = node;
            break;
        }

        node = this.treeAdapter.getParentNode(node);
    } while (node);
};

Parser.prototype._initTokenizerForFragmentParsing = function () {
    var tn = this.treeAdapter.getTagName(this.fragmentContext);

    if (tn === $.TITLE || tn === $.TEXTAREA)
        this.tokenizer.state = Tokenizer.RCDATA_STATE;

    else if (tn === $.STYLE || tn === $.XMP || tn === $.IFRAME ||
             tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT) {
        this.tokenizer.state = Tokenizer.RAWTEXT_STATE;
    }

    else if (tn === $.SCRIPT)
        this.tokenizer.state = Tokenizer.SCRIPT_DATA_STATE;

    else if (tn === $.PLAINTEXT)
        this.tokenizer.state = Tokenizer.PLAINTEXT_STATE;
};

//Tree mutation
Parser.prototype._setDocumentType = function (token) {
    this.treeAdapter.setDocumentType(this.document, token.name, token.publicId, token.systemId);
};

Parser.prototype._attachElementToTree = function (element) {
    if (this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current))
        this._fosterParentElement(element);

    else {
        var parent = this.openElements.currentTmplContent || this.openElements.current;

        this.treeAdapter.appendChild(parent, element);
    }
};

Parser.prototype._appendElement = function (token, namespaceURI) {
    var element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

    this._attachElementToTree(element);
};

Parser.prototype._insertElement = function (token, namespaceURI) {
    var element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

    this._attachElementToTree(element);
    this.openElements.push(element);
};

Parser.prototype._insertTemplate = function (token) {
    var tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs),
        content = this.treeAdapter.createDocumentFragment();

    this.treeAdapter.appendChild(tmpl, content);
    this._attachElementToTree(tmpl);
    this.openElements.push(tmpl);
};

Parser.prototype._insertFakeRootElement = function () {
    var element = this.treeAdapter.createElement($.HTML, NS.HTML, []);

    this.treeAdapter.appendChild(this.openElements.current, element);
    this.openElements.push(element);
};

Parser.prototype._appendCommentNode = function (token, parent) {
    var commentNode = this.treeAdapter.createCommentNode(token.data);

    this.treeAdapter.appendChild(parent, commentNode);
};

Parser.prototype._insertCharacters = function (token) {
    if (this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current))
        this._fosterParentText(token.chars);

    else {
        var parent = this.openElements.currentTmplContent || this.openElements.current;

        this.treeAdapter.insertText(parent, token.chars);
    }
};

Parser.prototype._adoptNodes = function (donor, recipient) {
    while (true) {
        var child = this.treeAdapter.getFirstChild(donor);

        if (!child)
            break;

        this.treeAdapter.detachNode(child);
        this.treeAdapter.appendChild(recipient, child);
    }
};

//Token processing
Parser.prototype._shouldProcessTokenInForeignContent = function (token) {
    var current = this._getAdjustedCurrentElement();

    if (!current || current === this.document)
        return false;

    var ns = this.treeAdapter.getNamespaceURI(current);

    if (ns === NS.HTML)
        return false;

    if (this.treeAdapter.getTagName(current) === $.ANNOTATION_XML && ns === NS.MATHML &&
        token.type === Tokenizer.START_TAG_TOKEN && token.tagName === $.SVG) {
        return false;
    }

    var isCharacterToken = token.type === Tokenizer.CHARACTER_TOKEN ||
                           token.type === Tokenizer.NULL_CHARACTER_TOKEN ||
                           token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN,
        isMathMLTextStartTag = token.type === Tokenizer.START_TAG_TOKEN &&
                               token.tagName !== $.MGLYPH &&
                               token.tagName !== $.MALIGNMARK;

    if ((isMathMLTextStartTag || isCharacterToken) && this._isMathMLTextIntegrationPoint(current))
        return false;

    if ((token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) && this._isHtmlIntegrationPoint(current))
        return false;

    return token.type !== Tokenizer.EOF_TOKEN;
};

Parser.prototype._processToken = function (token) {
    _[this.insertionMode][token.type](this, token);
};

Parser.prototype._processTokenInBodyMode = function (token) {
    _[IN_BODY_MODE][token.type](this, token);
};

Parser.prototype._processTokenInForeignContent = function (token) {
    if (token.type === Tokenizer.CHARACTER_TOKEN)
        characterInForeignContent(this, token);

    else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN)
        nullCharacterInForeignContent(this, token);

    else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN)
        insertCharacters(this, token);

    else if (token.type === Tokenizer.COMMENT_TOKEN)
        appendComment(this, token);

    else if (token.type === Tokenizer.START_TAG_TOKEN)
        startTagInForeignContent(this, token);

    else if (token.type === Tokenizer.END_TAG_TOKEN)
        endTagInForeignContent(this, token);
};

Parser.prototype._processFakeStartTagWithAttrs = function (tagName, attrs) {
    var fakeToken = this.tokenizer.buildStartTagToken(tagName);

    fakeToken.attrs = attrs;
    this._processToken(fakeToken);
};

Parser.prototype._processFakeStartTag = function (tagName) {
    var fakeToken = this.tokenizer.buildStartTagToken(tagName);

    this._processToken(fakeToken);
    return fakeToken;
};

Parser.prototype._processFakeEndTag = function (tagName) {
    var fakeToken = this.tokenizer.buildEndTagToken(tagName);

    this._processToken(fakeToken);
    return fakeToken;
};

//Integration points
Parser.prototype._isMathMLTextIntegrationPoint = function (element) {
    var tn = this.treeAdapter.getTagName(element),
        ns = this.treeAdapter.getNamespaceURI(element);

    return ForeignContent.isMathMLTextIntegrationPoint(tn, ns);
};

Parser.prototype._isHtmlIntegrationPoint = function (element) {
    var tn = this.treeAdapter.getTagName(element),
        ns = this.treeAdapter.getNamespaceURI(element),
        attrs = this.treeAdapter.getAttrList(element);

    return ForeignContent.isHtmlIntegrationPoint(tn, ns, attrs);
};

//Active formatting elements reconstruction
Parser.prototype._reconstructActiveFormattingElements = function () {
    var listLength = this.activeFormattingElements.length;

    if (listLength) {
        var unopenIdx = listLength,
            entry = null;

        do {
            unopenIdx--;
            entry = this.activeFormattingElements.entries[unopenIdx];

            if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
                unopenIdx++;
                break;
            }
        } while (unopenIdx > 0);

        for (var i = unopenIdx; i < listLength; i++) {
            entry = this.activeFormattingElements.entries[i];
            this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
            entry.element = this.openElements.current;
        }
    }
};

//Close elements
Parser.prototype._closeTableCell = function () {
    if (this.openElements.hasInTableScope($.TD))
        this._processFakeEndTag($.TD);

    else
        this._processFakeEndTag($.TH);
};

Parser.prototype._closePElement = function () {
    this.openElements.generateImpliedEndTagsWithExclusion($.P);
    this.openElements.popUntilTagNamePopped($.P);
};

//Insertion modes
Parser.prototype._resetInsertionMode = function () {
    for (var i = this.openElements.stackTop, last = false; i >= 0; i--) {
        var element = this.openElements.items[i];

        if (i === 0) {
            last = true;

            if (this.fragmentContext)
                element = this.fragmentContext;
        }

        var tn = this.treeAdapter.getTagName(element),
            newInsertionMode = INSERTION_MODE_RESET_MAP[tn];

        if (newInsertionMode) {
            this.insertionMode = newInsertionMode;
            break;
        }

        else if (!last && (tn === $.TD || tn === $.TH)) {
            this.insertionMode = IN_CELL_MODE;
            break;
        }

        else if (!last && tn === $.HEAD) {
            this.insertionMode = IN_HEAD_MODE;
            break;
        }

        else if (tn === $.SELECT) {
            this._resetInsertionModeForSelect(i);
            break;
        }

        else if (tn === $.TEMPLATE) {
            this.insertionMode = this.currentTmplInsertionMode;
            break;
        }

        else if (tn === $.HTML) {
            this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
            break;
        }

        else if (last) {
            this.insertionMode = IN_BODY_MODE;
            break;
        }
    }
};

Parser.prototype._resetInsertionModeForSelect = function (selectIdx) {
    if (selectIdx > 0) {
        for (var i = selectIdx - 1; i > 0; i--) {
            var ancestor = this.openElements.items[i],
                tn = this.treeAdapter.getTagName(ancestor);

            if (tn === $.TEMPLATE)
                break;

            else if (tn === $.TABLE) {
                this.insertionMode = IN_SELECT_IN_TABLE_MODE;
                return;
            }
        }
    }

    this.insertionMode = IN_SELECT_MODE;
};

Parser.prototype._pushTmplInsertionMode = function (mode) {
    this.tmplInsertionModeStack.push(mode);
    this.tmplInsertionModeStackTop++;
    this.currentTmplInsertionMode = mode;
};

Parser.prototype._popTmplInsertionMode = function () {
    this.tmplInsertionModeStack.pop();
    this.tmplInsertionModeStackTop--;
    this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
};

//Foster parenting
Parser.prototype._isElementCausesFosterParenting = function (element) {
    var tn = this.treeAdapter.getTagName(element);

    return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn == $.THEAD || tn === $.TR;
};

Parser.prototype._findFosterParentingLocation = function () {
    var location = {
        parent: null,
        beforeElement: null
    };

    for (var i = this.openElements.stackTop; i >= 0; i--) {
        var openElement = this.openElements.items[i],
            tn = this.treeAdapter.getTagName(openElement),
            ns = this.treeAdapter.getNamespaceURI(openElement);

        if (tn === $.TEMPLATE && ns === NS.HTML) {
            location.parent = this.treeAdapter.getChildNodes(openElement)[0];
            break;
        }

        else if (tn === $.TABLE) {
            location.parent = this.treeAdapter.getParentNode(openElement);

            if (location.parent)
                location.beforeElement = openElement;
            else
                location.parent = this.openElements.items[i - 1];

            break;
        }
    }

    if (!location.parent)
        location.parent = this.openElements.items[0];

    return location;
};

Parser.prototype._fosterParentElement = function (element) {
    var location = this._findFosterParentingLocation();

    if (location.beforeElement)
        this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
    else
        this.treeAdapter.appendChild(location.parent, element);
};

Parser.prototype._fosterParentText = function (chars) {
    var location = this._findFosterParentingLocation();

    if (location.beforeElement)
        this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);
    else
        this.treeAdapter.insertText(location.parent, chars);
};

//Special elements
Parser.prototype._isSpecialElement = function (element) {
    var tn = this.treeAdapter.getTagName(element),
        ns = this.treeAdapter.getNamespaceURI(element);

    return HTML.SPECIAL_ELEMENTS[ns][tn];
};

//Adoption agency algorithm
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
//------------------------------------------------------------------

//Steps 5-8 of the algorithm
function aaObtainFormattingElementEntry(p, token) {
    var formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);

    if (formattingElementEntry) {
        if (!p.openElements.contains(formattingElementEntry.element)) {
            p.activeFormattingElements.removeEntry(formattingElementEntry);
            formattingElementEntry = null;
        }

        else if (!p.openElements.hasInScope(token.tagName))
            formattingElementEntry = null;
    }

    else
        genericEndTagInBody(p, token);

    return formattingElementEntry;
}

//Steps 9 and 10 of the algorithm
function aaObtainFurthestBlock(p, formattingElementEntry) {
    var furthestBlock = null;

    for (var i = p.openElements.stackTop; i >= 0; i--) {
        var element = p.openElements.items[i];

        if (element === formattingElementEntry.element)
            break;

        if (p._isSpecialElement(element))
            furthestBlock = element;
    }

    if (!furthestBlock) {
        p.openElements.popUntilElementPopped(formattingElementEntry.element);
        p.activeFormattingElements.removeEntry(formattingElementEntry);
    }

    return furthestBlock;
}

//Step 13 of the algorithm
function aaInnerLoop(p, furthestBlock, formattingElement) {
    var element = null,
        lastElement = furthestBlock,
        nextElement = p.openElements.getCommonAncestor(furthestBlock);

    for (var i = 0; i < AA_INNER_LOOP_ITER; i++) {
        element = nextElement;

        //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)
        nextElement = p.openElements.getCommonAncestor(element);

        var elementEntry = p.activeFormattingElements.getElementEntry(element);

        if (!elementEntry) {
            p.openElements.remove(element);
            continue;
        }

        if (element === formattingElement)
            break;

        element = aaRecreateElementFromEntry(p, elementEntry);

        if (lastElement === furthestBlock)
            p.activeFormattingElements.bookmark = elementEntry;

        p.treeAdapter.detachNode(lastElement);
        p.treeAdapter.appendChild(element, lastElement);
        lastElement = element;
    }

    return lastElement;
}

//Step 13.7 of the algorithm
function aaRecreateElementFromEntry(p, elementEntry) {
    var ns = p.treeAdapter.getNamespaceURI(elementEntry.element),
        newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);

    p.openElements.replace(elementEntry.element, newElement);
    elementEntry.element = newElement;

    return newElement;
}

//Step 14 of the algorithm
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
    if (p._isElementCausesFosterParenting(commonAncestor))
        p._fosterParentElement(lastElement);

    else {
        var tn = p.treeAdapter.getTagName(commonAncestor),
            ns = p.treeAdapter.getNamespaceURI(commonAncestor);

        if (tn === $.TEMPLATE && ns === NS.HTML)
            commonAncestor = p.treeAdapter.getChildNodes(commonAncestor)[0];

        p.treeAdapter.appendChild(commonAncestor, lastElement);
    }
}

//Steps 15-19 of the algorithm
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
    var ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element),
        token = formattingElementEntry.token,
        newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);

    p._adoptNodes(furthestBlock, newElement);
    p.treeAdapter.appendChild(furthestBlock, newElement);

    p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
    p.activeFormattingElements.removeEntry(formattingElementEntry);

    p.openElements.remove(formattingElementEntry.element);
    p.openElements.insertAfter(furthestBlock, newElement);
}

//Algorithm entry point
function callAdoptionAgency(p, token) {
    for (var i = 0; i < AA_OUTER_LOOP_ITER; i++) {
        var formattingElementEntry = aaObtainFormattingElementEntry(p, token, formattingElementEntry);

        if (!formattingElementEntry)
            break;

        var furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);

        if (!furthestBlock)
            break;

        p.activeFormattingElements.bookmark = formattingElementEntry;

        var lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element),
            commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);

        p.treeAdapter.detachNode(lastElement);
        aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
        aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
    }
}


//Generic token handlers
//------------------------------------------------------------------
function ignoreToken(p, token) {
    //NOTE: do nothing =)
}

function appendComment(p, token) {
    p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current)
}

function appendCommentToRootHtmlElement(p, token) {
    p._appendCommentNode(token, p.openElements.items[0]);
}

function appendCommentToDocument(p, token) {
    p._appendCommentNode(token, p.document);
}

function insertCharacters(p, token) {
    p._insertCharacters(token);
}

function stopParsing(p, token) {
    p.stopped = true;
}

//12.2.5.4.1 The "initial" insertion mode
//------------------------------------------------------------------
function doctypeInInitialMode(p, token) {
    p._setDocumentType(token);

    if (token.forceQuirks || Doctype.isQuirks(token.name, token.publicId, token.systemId))
        p.treeAdapter.setQuirksMode(p.document);

    p.insertionMode = BEFORE_HTML_MODE;
}

function tokenInInitialMode(p, token) {
    p.treeAdapter.setQuirksMode(p.document);
    p.insertionMode = BEFORE_HTML_MODE;
    p._processToken(token);
}


//12.2.5.4.2 The "before html" insertion mode
//------------------------------------------------------------------
function startTagBeforeHtml(p, token) {
    if (token.tagName === $.HTML) {
        p._insertElement(token, NS.HTML);
        p.insertionMode = BEFORE_HEAD_MODE;
    }

    else
        tokenBeforeHtml(p, token);
}

function endTagBeforeHtml(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR)
        tokenBeforeHtml(p, token);
}

function tokenBeforeHtml(p, token) {
    p._insertFakeRootElement();
    p.insertionMode = BEFORE_HEAD_MODE;
    p._processToken(token);
}


//12.2.5.4.3 The "before head" insertion mode
//------------------------------------------------------------------
function startTagBeforeHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.HEAD) {
        p._insertElement(token, NS.HTML);
        p.headElement = p.openElements.current;
        p.insertionMode = IN_HEAD_MODE;
    }

    else
        tokenBeforeHead(p, token);
}

function endTagBeforeHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR)
        tokenBeforeHead(p, token);
}

function tokenBeforeHead(p, token) {
    p._processFakeStartTag($.HEAD);
    p._processToken(token);
}


//12.2.5.4.4 The "in head" insertion mode
//------------------------------------------------------------------
function startTagInHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND ||
             tn === $.COMMAND || tn === $.LINK || tn === $.META) {
        p._appendElement(token, NS.HTML);
    }

    else if (tn === $.TITLE)
        p._switchToTextParsing(token, Tokenizer.RCDATA_STATE);

    //NOTE: here we assume that we always act as an interactive user agent with enabled scripting, so we parse
    //<noscript> as a rawtext.
    else if (tn === $.NOSCRIPT || tn === $.NOFRAMES || tn === $.STYLE)
        p._switchToTextParsing(token, Tokenizer.RAWTEXT_STATE);

    else if (tn === $.SCRIPT) {
        p._insertElement(token, NS.HTML);
        p.tokenizer.state = Tokenizer.SCRIPT_DATA_STATE;
        p.originalInsertionMode = p.insertionMode;
        p.insertionMode = TEXT_MODE;
    }

    else if (tn === $.TEMPLATE) {
        p._insertTemplate(token, NS.HTML);
        p.activeFormattingElements.insertMarker();
        p.framesetOk = false;
        p.insertionMode = IN_TEMPLATE_MODE;
        p._pushTmplInsertionMode(IN_TEMPLATE_MODE);
    }

    else if (tn !== $.HEAD)
        tokenInHead(p, token);
}

function endTagInHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HEAD) {
        p.openElements.pop();
        p.insertionMode = AFTER_HEAD_MODE;
    }

    else if (tn === $.BODY || tn === $.BR || tn === $.HTML)
        tokenInHead(p, token);

    else if (tn === $.TEMPLATE && p.openElements.tmplCount > 0) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTemplatePopped();
        p.activeFormattingElements.clearToLastMarker();
        p._popTmplInsertionMode();
        p._resetInsertionMode();
    }
}

function tokenInHead(p, token) {
    p._processFakeEndTag($.HEAD);
    p._processToken(token);
}


//12.2.5.4.6 The "after head" insertion mode
//------------------------------------------------------------------
function startTagAfterHead(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.BODY) {
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
        p.insertionMode = IN_BODY_MODE;
    }

    else if (tn === $.FRAMESET) {
        p._insertElement(token, NS.HTML);
        p.insertionMode = IN_FRAMESET_MODE;
    }

    else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META ||
             tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
        p.openElements.push(p.headElement);
        startTagInHead(p, token);
        p.openElements.remove(p.headElement);
    }

    else if (tn !== $.HEAD)
        tokenAfterHead(p, token);
}

function endTagAfterHead(p, token) {
    var tn = token.tagName;

    if (tn === $.BODY || tn === $.HTML || tn === $.BR)
        tokenAfterHead(p, token);

    else if (tn === $.TEMPLATE)
        endTagInHead(p, token);
}

function tokenAfterHead(p, token) {
    p._processFakeStartTag($.BODY);
    p.framesetOk = true;
    p._processToken(token);
}


//12.2.5.4.7 The "in body" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
}

function characterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
    p.framesetOk = false;
}

function htmlStartTagInBody(p, token) {
    if (p.openElements.tmplCount === 0)
        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
}

function bodyStartTagInBody(p, token) {
    var bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

    if (bodyElement && p.openElements.tmplCount === 0) {
        p.framesetOk = false;
        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
    }
}

function framesetStartTagInBody(p, token) {
    var bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

    if (p.framesetOk && bodyElement) {
        p.treeAdapter.detachNode(bodyElement);
        p.openElements.popAllUpToHtmlElement();
        p._insertElement(token, NS.HTML);
        p.insertionMode = IN_FRAMESET_MODE;
    }
}

function addressStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
}

function numberedHeaderStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    var tn = p.openElements.currentTagName;

    if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6)
        p.openElements.pop();

    p._insertElement(token, NS.HTML);
}

function preStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
    //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
    p.skipNextNewLine = true;
    p.framesetOk = false;
}

function formStartTagInBody(p, token) {
    var inTemplate = p.openElements.tmplCount > 0;

    if (!p.formElement || inTemplate) {
        if (p.openElements.hasInButtonScope($.P))
            p._closePElement();

        p._insertElement(token, NS.HTML);

        if (!inTemplate)
            p.formElement = p.openElements.current;
    }
}

function listItemStartTagInBody(p, token) {
    p.framesetOk = false;

    for (var i = p.openElements.stackTop; i >= 0; i--) {
        var element = p.openElements.items[i],
            tn = p.treeAdapter.getTagName(element);

        if ((token.tagName === $.LI && tn === $.LI) ||
            ((token.tagName === $.DD || token.tagName === $.DT) && (tn === $.DD || tn == $.DT))) {
            p._processFakeEndTag(tn);
            break;
        }

        if (tn !== $.ADDRESS && tn !== $.DIV && tn !== $.P && p._isSpecialElement(element))
            break;
    }

    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
}

function plaintextStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
    p.tokenizer.state = Tokenizer.PLAINTEXT_STATE;
}

function buttonStartTagInBody(p, token) {
    if (p.openElements.hasInScope($.BUTTON)) {
        p._processFakeEndTag($.BUTTON);
        buttonStartTagInBody(p, token);
    }

    else {
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
    }
}

function aStartTagInBody(p, token) {
    var activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($.A);

    if (activeElementEntry) {
        p._processFakeEndTag($.A);
        p.openElements.remove(activeElementEntry.element);
        p.activeFormattingElements.removeEntry(activeElementEntry);
    }

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function bStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function nobrStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    if (p.openElements.hasInScope($.NOBR)) {
        p._processFakeEndTag($.NOBR);
        p._reconstructActiveFormattingElements();
    }

    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function appletStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.activeFormattingElements.insertMarker();
    p.framesetOk = false;
}

function tableStartTagInBody(p, token) {
    if (!p.treeAdapter.isQuirksMode(p.document) && p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._insertElement(token, NS.HTML);
    p.framesetOk = false;
    p.insertionMode = IN_TABLE_MODE;
}

function areaStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS.HTML);
    p.framesetOk = false;
}

function inputStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS.HTML);

    var inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE)
        p.framesetOk = false;

}

function paramStartTagInBody(p, token) {
    p._appendElement(token, NS.HTML);
}

function hrStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._appendElement(token, NS.HTML);
    p.framesetOk = false;
}

function imageStartTagInBody(p, token) {
    token.tagName = $.IMG;
    areaStartTagInBody(p, token);
}

function isindexStartTagInBody(p, token) {
    if (!p.formElement || p.openElements.tmplCount > 0) {
        p._processFakeStartTagWithAttrs($.FORM, getSearchableIndexFormAttrs(token));
        p._processFakeStartTag($.HR);
        p._processFakeStartTag($.LABEL);
        p.treeAdapter.insertText(p.openElements.current, getSearchableIndexLabelText(token));
        p._processFakeStartTagWithAttrs($.INPUT, getSearchableIndexInputAttrs(token));
        p._processFakeEndTag($.LABEL);
        p._processFakeStartTag($.HR);
        p._processFakeEndTag($.FORM);
    }
}

function textareaStartTagInBody(p, token) {
    p._insertElement(token, NS.HTML);
    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
    //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
    p.skipNextNewLine = true;
    p.tokenizer.state = Tokenizer.RCDATA_STATE;
    p.originalInsertionMode = p.insertionMode;
    p.framesetOk = false;
    p.insertionMode = TEXT_MODE;
}

function xmpStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P))
        p._closePElement();

    p._reconstructActiveFormattingElements();
    p.framesetOk = false;
    p._switchToTextParsing(token, Tokenizer.RAWTEXT_STATE);
}

function iframeStartTagInBody(p, token) {
    p.framesetOk = false;
    p._switchToTextParsing(token, Tokenizer.RAWTEXT_STATE);
}

//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse
//<noembed> as a rawtext.
function noembedStartTagInBody(p, token) {
    p._switchToTextParsing(token, Tokenizer.RAWTEXT_STATE);
}

function selectStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
    p.framesetOk = false;

    if (p.insertionMode === IN_TABLE_MODE || p.insertionMode === IN_CAPTION_MODE ||
        p.insertionMode === IN_TABLE_BODY_MODE || p.insertionMode === IN_ROW_MODE ||
        p.insertionMode === IN_CELL_MODE) {
        p.insertionMode = IN_SELECT_IN_TABLE_MODE;
    }

    else
        p.insertionMode = IN_SELECT_MODE;
}

function optgroupStartTagInBody(p, token) {
    if (p.openElements.currentTagName === $.OPTION)
        p._processFakeEndTag($.OPTION);

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
}

function rpStartTagInBody(p, token) {
    if (p.openElements.hasInScope($.RUBY))
        p.openElements.generateImpliedEndTags();

    p._insertElement(token, NS.HTML);
}

function menuitemStartTagInBody(p, token) {
    p._appendElement(token, NS.HTML);
}

function mathStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    ForeignContent.adjustTokenMathMLAttrs(token);
    ForeignContent.adjustTokenXMLAttrs(token);

    if (token.selfClosing)
        p._appendElement(token, NS.MATHML);
    else
        p._insertElement(token, NS.MATHML);
}

function svgStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    ForeignContent.adjustTokenSVGAttrs(token);
    ForeignContent.adjustTokenXMLAttrs(token);

    if (token.selfClosing)
        p._appendElement(token, NS.SVG);
    else
        p._insertElement(token, NS.SVG);
}

function genericStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS.HTML);
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function startTagInBody(p, token) {
    var tn = token.tagName;

    switch (tn.length) {
        case 1:
            if (tn === $.I || tn === $.S || tn === $.B || tn === $.U)
                bStartTagInBody(p, token);

            else if (tn === $.P)
                addressStartTagInBody(p, token);

            else if (tn === $.A)
                aStartTagInBody(p, token);

            else
                genericStartTagInBody(p, token);

            break;

        case 2:
            if (tn === $.DL || tn === $.OL || tn === $.UL)
                addressStartTagInBody(p, token);

            else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6)
                numberedHeaderStartTagInBody(p, token);

            else if (tn === $.LI || tn === $.DD || tn === $.DT)
                listItemStartTagInBody(p, token);

            else if (tn === $.EM || tn === $.TT)
                bStartTagInBody(p, token);

            else if (tn === $.BR)
                areaStartTagInBody(p, token);

            else if (tn === $.HR)
                hrStartTagInBody(p, token);

            else if (tn === $.RP || tn === $.RT)
                rpStartTagInBody(p, token);

            else if (tn !== $.TH && tn !== $.TD && tn !== $.TR)
                genericStartTagInBody(p, token);

            break;

        case 3:
            if (tn === $.DIV || tn === $.DIR || tn === $.NAV)
                addressStartTagInBody(p, token);

            else if (tn === $.PRE)
                preStartTagInBody(p, token);

            else if (tn === $.BIG)
                bStartTagInBody(p, token);

            else if (tn === $.IMG || tn === $.WBR)
                areaStartTagInBody(p, token);

            else if (tn === $.XMP)
                xmpStartTagInBody(p, token);

            else if (tn === $.SVG)
                svgStartTagInBody(p, token);

            else if (tn !== $.COL)
                genericStartTagInBody(p, token);

            break;

        case 4:
            if (tn === $.HTML)
                htmlStartTagInBody(p, token);

            else if (tn === $.BASE || tn === $.LINK || tn === $.META)
                startTagInHead(p, token);

            else if (tn === $.BODY)
                bodyStartTagInBody(p, token);

            else if (tn === $.MAIN || tn === $.MENU)
                addressStartTagInBody(p, token);

            else if (tn === $.FORM)
                formStartTagInBody(p, token);

            else if (tn === $.CODE || tn === $.FONT)
                bStartTagInBody(p, token);

            else if (tn === $.NOBR)
                nobrStartTagInBody(p, token);

            else if (tn === $.AREA)
                areaStartTagInBody(p, token);

            else if (tn === $.MATH)
                mathStartTagInBody(p, token);

            else if (tn !== $.HEAD)
                genericStartTagInBody(p, token);

            break;

        case 5:
            if (tn === $.STYLE || tn === $.TITLE)
                startTagInHead(p, token);

            else if (tn === $.ASIDE)
                addressStartTagInBody(p, token);

            else if (tn === $.SMALL)
                bStartTagInBody(p, token);

            else if (tn === $.TABLE)
                tableStartTagInBody(p, token);

            else if (tn === $.EMBED)
                areaStartTagInBody(p, token);

            else if (tn === $.INPUT)
                inputStartTagInBody(p, token);

            else if (tn === $.PARAM || tn === $.TRACK)
                paramStartTagInBody(p, token);

            else if (tn === $.IMAGE)
                imageStartTagInBody(p, token);

            else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD)
                genericStartTagInBody(p, token);

            break;

        case 6:
            if (tn === $.SCRIPT)
                startTagInHead(p, token);

            else if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP)
                addressStartTagInBody(p, token);

            else if (tn === $.BUTTON)
                buttonStartTagInBody(p, token);

            else if (tn === $.STRIKE || tn === $.STRONG)
                bStartTagInBody(p, token);

            else if (tn === $.APPLET || tn === $.OBJECT)
                appletStartTagInBody(p, token);

            else if (tn === $.KEYGEN)
                areaStartTagInBody(p, token);

            else if (tn === $.SOURCE)
                paramStartTagInBody(p, token);

            else if (tn === $.IFRAME)
                iframeStartTagInBody(p, token);

            else if (tn === $.SELECT)
                selectStartTagInBody(p, token);

            else if (tn === $.OPTION)
                optgroupStartTagInBody(p, token);

            else
                genericStartTagInBody(p, token);

            break;

        case 7:
            if (tn === $.BGSOUND || tn === $.COMMAND)
                startTagInHead(p, token);

            else if (tn === $.DETAILS || tn === $.ADDRESS || tn === $.ARTICLE || tn === $.SECTION || tn === $.SUMMARY)
                addressStartTagInBody(p, token);

            else if (tn === $.LISTING)
                preStartTagInBody(p, token);

            else if (tn === $.MARQUEE)
                appletStartTagInBody(p, token);

            else if (tn === $.ISINDEX)
                isindexStartTagInBody(p, token);

            else if (tn === $.NOEMBED)
                noembedStartTagInBody(p, token);

            else if (tn !== $.CAPTION)
                genericStartTagInBody(p, token);

            break;

        case 8:
            if (tn === $.BASEFONT || tn === $.MENUITEM)
                menuitemStartTagInBody(p, token);

            else if (tn === $.FRAMESET)
                framesetStartTagInBody(p, token);

            else if (tn === $.FIELDSET)
                addressStartTagInBody(p, token);

            else if (tn === $.TEXTAREA)
                textareaStartTagInBody(p, token);

            else if (tn === $.TEMPLATE)
                startTagInHead(p, token);

            else if (tn === $.NOSCRIPT)
                noembedStartTagInBody(p, token);

            else if (tn === $.OPTGROUP)
                optgroupStartTagInBody(p, token);

            else if (tn !== $.COLGROUP)
                genericStartTagInBody(p, token);

            break;

        case 9:
            if (tn === $.PLAINTEXT)
                plaintextStartTagInBody(p, token);

            else
                genericStartTagInBody(p, token);

            break;

        case 10:
            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION)
                addressStartTagInBody(p, token);

            else
                genericStartTagInBody(p, token);

            break;

        default:
            genericStartTagInBody(p, token);
    }
}

function bodyEndTagInBody(p, token) {
    if (p.openElements.hasInScope($.BODY))
        p.insertionMode = AFTER_BODY_MODE;

    else
        token.ignored = true;
}

function htmlEndTagInBody(p, token) {
    var fakeToken = p._processFakeEndTag($.BODY);

    if (!fakeToken.ignored)
        p._processToken(token);
}

function addressEndTagInBody(p, token) {
    var tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
    }
}

function formEndTagInBody(p, token) {
    var inTemplate = p.openElements.tmplCount > 0,
        formElement = p.formElement;

    if (!inTemplate)
        p.formElement = null;

    if ((formElement || inTemplate) && p.openElements.hasInScope($.FORM)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.remove(formElement);
    }
}

function pEndTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($.P)) {
        p.openElements.generateImpliedEndTagsWithExclusion($.P);
        p.openElements.popUntilTagNamePopped($.P);
    }

    else {
        p._processFakeStartTag($.P);
        p._processToken(token);
    }
}

function liEndTagInBody(p, token) {
    if (p.openElements.hasInListItemScope($.LI)) {
        p.openElements.generateImpliedEndTagsWithExclusion($.LI);
        p.openElements.popUntilTagNamePopped($.LI);
    }
}

function ddEndTagInBody(p, token) {
    var tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTagsWithExclusion(tn);
        p.openElements.popUntilTagNamePopped(tn);
    }
}

function numberedHeaderEndTagInBody(p, token) {
    if (p.openElements.hasNumberedHeaderInScope()) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilNumberedHeaderPopped();
    }
}

function appletEndTagInBody(p, token) {
    var tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
    }
}

function brEndTagInBody(p, token) {
    p._processFakeStartTag($.BR);
}

function genericEndTagInBody(p, token) {
    var tn = token.tagName;

    for (var i = p.openElements.stackTop; i > 0; i--) {
        var element = p.openElements.items[i];

        if (p.treeAdapter.getTagName(element) === tn) {
            p.openElements.generateImpliedEndTagsWithExclusion(tn);
            p.openElements.popUntilElementPopped(element);
            break;
        }

        if (p._isSpecialElement(element))
            break;
    }
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function endTagInBody(p, token) {
    var tn = token.tagName;

    switch (tn.length) {
        case 1:
            if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn == $.U)
                callAdoptionAgency(p, token);

            else if (tn === $.P)
                pEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 2:
            if (tn == $.DL || tn === $.UL || tn === $.OL)
                addressEndTagInBody(p, token);

            else if (tn === $.LI)
                liEndTagInBody(p, token);

            else if (tn === $.DD || tn === $.DT)
                ddEndTagInBody(p, token);

            else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6)
                numberedHeaderEndTagInBody(p, token);

            else if (tn === $.BR)
                brEndTagInBody(p, token);

            else if (tn === $.EM || tn === $.TT)
                callAdoptionAgency(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 3:
            if (tn === $.BIG)
                callAdoptionAgency(p, token);

            else if (tn === $.DIR || tn === $.DIV || tn === $.NAV)
                addressEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 4:
            if (tn === $.BODY)
                bodyEndTagInBody(p, token);

            else if (tn === $.HTML)
                htmlEndTagInBody(p, token);

            else if (tn === $.FORM)
                formEndTagInBody(p, token);

            else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR)
                callAdoptionAgency(p, token);

            else if (tn === $.MAIN || tn === $.MENU)
                addressEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 5:
            if (tn === $.ASIDE)
                addressEndTagInBody(p, token);

            else if (tn === $.SMALL)
                callAdoptionAgency(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 6:
            if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP)
                addressEndTagInBody(p, token);

            else if (tn === $.APPLET || tn === $.OBJECT)
                appletEndTagInBody(p, token);

            else if (tn == $.STRIKE || tn === $.STRONG)
                callAdoptionAgency(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 7:
            if (tn === $.ADDRESS || tn === $.ARTICLE || tn === $.DETAILS || tn === $.SECTION || tn === $.SUMMARY)
                addressEndTagInBody(p, token);

            else if (tn === $.MARQUEE)
                appletEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 8:
            if (tn === $.FIELDSET)
                addressEndTagInBody(p, token);

            else if (tn === $.TEMPLATE)
                endTagInHead(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        case 10:
            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION)
                addressEndTagInBody(p, token);

            else
                genericEndTagInBody(p, token);

            break;

        default :
            genericEndTagInBody(p, token);
    }
}

function eofInBody(p, token) {
    if (p.tmplInsertionModeStackTop > -1)
        eofInTemplate(p, token);

    else
        p.stopped = true;
}

//12.2.5.4.8 The "text" insertion mode
//------------------------------------------------------------------
function endTagInText(p, token) {
    if (!p.fragmentContext && p.scriptHandler && token.tagName === $.SCRIPT)
        p.scriptHandler(p.document, p.openElements.current);

    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
}


function eofInText(p, token) {
    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
    p._processToken(token);
}


//12.2.5.4.9 The "in table" insertion mode
//------------------------------------------------------------------
function characterInTable(p, token) {
    var curTn = p.openElements.currentTagName;

    if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
        p.pendingCharacterTokens = [];
        p.hasNonWhitespacePendingCharacterToken = false;
        p.originalInsertionMode = p.insertionMode;
        p.insertionMode = IN_TABLE_TEXT_MODE;
        p._processToken(token);
    }

    else
        tokenInTable(p, token);
}

function captionStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p.activeFormattingElements.insertMarker();
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_CAPTION_MODE;
}

function colgroupStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_COLUMN_GROUP_MODE;
}

function colStartTagInTable(p, token) {
    p._processFakeStartTag($.COLGROUP);
    p._processToken(token);
}

function tbodyStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_TABLE_BODY_MODE;
}

function tdStartTagInTable(p, token) {
    p._processFakeStartTag($.TBODY);
    p._processToken(token);
}

function tableStartTagInTable(p, token) {
    var fakeToken = p._processFakeEndTag($.TABLE);

    //NOTE: The fake end tag token here can only be ignored in the fragment case.
    if (!fakeToken.ignored)
        p._processToken(token);
}

function inputStartTagInTable(p, token) {
    var inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE)
        p._appendElement(token, NS.HTML);

    else
        tokenInTable(p, token);
}

function formStartTagInTable(p, token) {
    if (!p.formElement && p.openElements.tmplCount === 0) {
        p._insertElement(token, NS.HTML);
        p.formElement = p.openElements.current;
        p.openElements.pop();
    }
}

function startTagInTable(p, token) {
    var tn = token.tagName;

    switch (tn.length) {
        case 2:
            if (tn === $.TD || tn === $.TH || tn === $.TR)
                tdStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 3:
            if (tn === $.COL)
                colStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 4:
            if (tn === $.FORM)
                formStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 5:
            if (tn === $.TABLE)
                tableStartTagInTable(p, token);

            else if (tn === $.STYLE)
                startTagInHead(p, token);

            else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD)
                tbodyStartTagInTable(p, token);

            else if (tn === $.INPUT)
                inputStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 6:
            if (tn === $.SCRIPT)
                startTagInHead(p, token);

            else
                tokenInTable(p, token);

            break;

        case 7:
            if (tn === $.CAPTION)
                captionStartTagInTable(p, token);

            else
                tokenInTable(p, token);

            break;

        case 8:
            if (tn === $.COLGROUP)
                colgroupStartTagInTable(p, token);

            else if (tn === $.TEMPLATE)
                startTagInHead(p, token);

            else
                tokenInTable(p, token);

            break;

        default:
            tokenInTable(p, token);
    }

}

function endTagInTable(p, token) {
    var tn = token.tagName;

    if (tn === $.TABLE) {
        if (p.openElements.hasInTableScope($.TABLE)) {
            p.openElements.popUntilTagNamePopped($.TABLE);
            p._resetInsertionMode();
        }

        else
            token.ignored = true;
    }

    else if (tn === $.TEMPLATE)
        endTagInHead(p, token);

    else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML &&
             tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
        tokenInTable(p, token);
    }
}

function tokenInTable(p, token) {
    var savedFosterParentingState = p.fosterParentingEnabled;

    p.fosterParentingEnabled = true;
    p._processTokenInBodyMode(token);
    p.fosterParentingEnabled = savedFosterParentingState;
}


//12.2.5.4.10 The "in table text" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
}

function characterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
    p.hasNonWhitespacePendingCharacterToken = true;
}

function tokenInTableText(p, token) {
    if (p.hasNonWhitespacePendingCharacterToken) {
        for (var i = 0; i < p.pendingCharacterTokens.length; i++)
            tokenInTable(p, p.pendingCharacterTokens[i]);
    }

    else {
        for (var i = 0; i < p.pendingCharacterTokens.length; i++)
            p._insertCharacters(p.pendingCharacterTokens[i]);
    }

    p.insertionMode = p.originalInsertionMode;
    p._processToken(token);
}


//12.2.5.4.11 The "in caption" insertion mode
//------------------------------------------------------------------
function startTagInCaption(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY ||
        tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
        var fakeToken = p._processFakeEndTag($.CAPTION);

        //NOTE: The fake end tag token here can only be ignored in the fragment case.
        if (!fakeToken.ignored)
            p._processToken(token);
    }

    else
        startTagInBody(p, token);
}

function endTagInCaption(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION) {
        if (p.openElements.hasInTableScope($.CAPTION)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped($.CAPTION);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_TABLE_MODE;
        }

        else
            token.ignored = true;
    }

    else if (tn === $.TABLE) {
        var fakeToken = p._processFakeEndTag($.CAPTION);

        //NOTE: The fake end tag token here can only be ignored in the fragment case.
        if (!fakeToken.ignored)
            p._processToken(token);
    }

    else if (tn !== $.BODY && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY &&
             tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
        endTagInBody(p, token);
    }
}


//12.2.5.4.12 The "in column group" insertion mode
//------------------------------------------------------------------
function startTagInColumnGroup(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.COL)
        p._appendElement(token, NS.HTML);

    else if (tn === $.TEMPLATE)
        startTagInHead(p, token);

    else
        tokenInColumnGroup(p, token);
}

function endTagInColumnGroup(p, token) {
    var tn = token.tagName;

    if (tn === $.COLGROUP) {
        if (p.openElements.currentTagName !== $.COLGROUP)
            token.ignored = true;

        else {
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
        }
    }

    else if (tn === $.TEMPLATE)
        endTagInHead(p, token);

    else if (tn !== $.COL)
        tokenInColumnGroup(p, token);
}

function tokenInColumnGroup(p, token) {
    var fakeToken = p._processFakeEndTag($.COLGROUP);

    //NOTE: The fake end tag token here can only be ignored in the fragment case.
    if (!fakeToken.ignored)
        p._processToken(token);
}

//12.2.5.4.13 The "in table body" insertion mode
//------------------------------------------------------------------
function startTagInTableBody(p, token) {
    var tn = token.tagName;

    if (tn === $.TR) {
        p.openElements.clearBackToTableBodyContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = IN_ROW_MODE;
    }

    else if (tn === $.TH || tn === $.TD) {
        p._processFakeStartTag($.TR);
        p._processToken(token);
    }

    else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP ||
             tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {

        if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p._processFakeEndTag(p.openElements.currentTagName);
            p._processToken(token);
        }
    }

    else
        startTagInTable(p, token);
}

function endTagInTableBody(p, token) {
    var tn = token.tagName;

    if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
        }
    }

    else if (tn === $.TABLE) {
        if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p._processFakeEndTag(p.openElements.currentTagName);
            p._processToken(token);
        }
    }

    else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP ||
             tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR) {
        endTagInTable(p, token);
    }
}

//12.2.5.4.14 The "in row" insertion mode
//------------------------------------------------------------------
function startTagInRow(p, token) {
    var tn = token.tagName;

    if (tn === $.TH || tn === $.TD) {
        p.openElements.clearBackToTableRowContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = IN_CELL_MODE;
        p.activeFormattingElements.insertMarker();
    }

    else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY ||
             tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
        var fakeToken = p._processFakeEndTag($.TR);

        //NOTE: The fake end tag token here can only be ignored in the fragment case.
        if (!fakeToken.ignored)
            p._processToken(token);
    }

    else
        startTagInTable(p, token);
}

function endTagInRow(p, token) {
    var tn = token.tagName;

    if (tn === $.TR) {
        if (p.openElements.hasInTableScope($.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
        }

        else
            token.ignored = true;
    }

    else if (tn === $.TABLE) {
        var fakeToken = p._processFakeEndTag($.TR);

        //NOTE: The fake end tag token here can only be ignored in the fragment case.
        if (!fakeToken.ignored)
            p._processToken(token);
    }

    else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p.openElements.hasInTableScope(tn)) {
            p._processFakeEndTag($.TR);
            p._processToken(token);
        }
    }

    else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP ||
             tn !== $.HTML && tn !== $.TD && tn !== $.TH) {
        endTagInTable(p, token);
    }
}


//12.2.5.4.15 The "in cell" insertion mode
//------------------------------------------------------------------
function startTagInCell(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY ||
        tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {

        if (p.openElements.hasInTableScope($.TD) || p.openElements.hasInTableScope($.TH)) {
            p._closeTableCell();
            p._processToken(token);
        }
    }

    else
        startTagInBody(p, token);
}

function endTagInCell(p, token) {
    var tn = token.tagName;

    if (tn === $.TD || tn === $.TH) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(tn);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_ROW_MODE;
        }
    }

    else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
        if (p.openElements.hasInTableScope(tn)) {
            p._closeTableCell();
            p._processToken(token);
        }
    }

    else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML)
        endTagInBody(p, token);
}

//12.2.5.4.16 The "in select" insertion mode
//------------------------------------------------------------------
function startTagInSelect(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.OPTION) {
        if (p.openElements.currentTagName === $.OPTION)
            p._processFakeEndTag($.OPTION);

        p._insertElement(token, NS.HTML);
    }

    else if (tn === $.OPTGROUP) {
        if (p.openElements.currentTagName === $.OPTION)
            p._processFakeEndTag($.OPTION);

        if (p.openElements.currentTagName === $.OPTGROUP)
            p._processFakeEndTag($.OPTGROUP);

        p._insertElement(token, NS.HTML);
    }

    else if (tn === $.SELECT)
        p._processFakeEndTag($.SELECT);

    else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA) {
        if (p.openElements.hasInSelectScope($.SELECT)) {
            p._processFakeEndTag($.SELECT);
            p._processToken(token);
        }
    }

    else if (tn === $.SCRIPT || tn === $.TEMPLATE)
        startTagInHead(p, token);
}

function endTagInSelect(p, token) {
    var tn = token.tagName;

    if (tn === $.OPTGROUP) {
        var prevOpenElement = p.openElements.items[p.openElements.stackTop - 1],
            prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);

        if (p.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP)
            p._processFakeEndTag($.OPTION);

        if (p.openElements.currentTagName === $.OPTGROUP)
            p.openElements.pop();
    }

    else if (tn === $.OPTION) {
        if (p.openElements.currentTagName === $.OPTION)
            p.openElements.pop();
    }

    else if (tn === $.SELECT && p.openElements.hasInSelectScope($.SELECT)) {
        p.openElements.popUntilTagNamePopped($.SELECT);
        p._resetInsertionMode();
    }

    else if (tn === $.TEMPLATE)
        endTagInHead(p, token);
}

//12.2.5.4.17 The "in select in table" insertion mode
//------------------------------------------------------------------
function startTagInSelectInTable(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT ||
        tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
        p._processFakeEndTag($.SELECT);
        p._processToken(token);
    }

    else
        startTagInSelect(p, token);
}

function endTagInSelectInTable(p, token) {
    var tn = token.tagName;

    if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT ||
        tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
        if (p.openElements.hasInTableScope(tn)) {
            p._processFakeEndTag($.SELECT);
            p._processToken(token);
        }
    }

    else
        endTagInSelect(p, token);
}

//12.2.5.4.18 The "in template" insertion mode
//------------------------------------------------------------------
function startTagInTemplate(p, token) {
    var tn = token.tagName;

    if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META ||
        tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
        startTagInHead(p, token);
    }

    else {
        var newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;

        p._popTmplInsertionMode();
        p._pushTmplInsertionMode(newInsertionMode);
        p.insertionMode = newInsertionMode;
        p._processToken(token);
    }
}

function endTagInTemplate(p, token) {
    if (token.tagName === $.TEMPLATE)
        endTagInHead(p, token);
}

function eofInTemplate(p, token) {
    if (p.openElements.tmplCount > 0) {
        p.openElements.popUntilTemplatePopped();
        p.activeFormattingElements.clearToLastMarker();
        p._popTmplInsertionMode();
        p._resetInsertionMode();
        p._processToken(token);
    }

    else
        p.stopped = true;
}


//12.2.5.4.19 The "after body" insertion mode
//------------------------------------------------------------------
function startTagAfterBody(p, token) {
    if (token.tagName === $.HTML)
        startTagInBody(p, token);

    else
        tokenAfterBody(p, token);
}

function endTagAfterBody(p, token) {
    if (token.tagName === $.HTML) {
        if (!p.fragmentContext)
            p.insertionMode = AFTER_AFTER_BODY_MODE;
    }

    else
        tokenAfterBody(p, token);
}

function tokenAfterBody(p, token) {
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

//12.2.5.4.20 The "in frameset" insertion mode
//------------------------------------------------------------------
function startTagInFrameset(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.FRAMESET)
        p._insertElement(token, NS.HTML);

    else if (tn === $.FRAME)
        p._appendElement(token, NS.HTML);

    else if (tn === $.NOFRAMES)
        startTagInHead(p, token);
}

function endTagInFrameset(p, token) {
    if (token.tagName === $.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
        p.openElements.pop();

        if (!p.fragmentContext && p.openElements.currentTagName !== $.FRAMESET)
            p.insertionMode = AFTER_FRAMESET_MODE;
    }
}

//12.2.5.4.21 The "after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterFrameset(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.NOFRAMES)
        startTagInHead(p, token);
}

function endTagAfterFrameset(p, token) {
    if (token.tagName === $.HTML)
        p.insertionMode = AFTER_AFTER_FRAMESET_MODE;
}

//12.2.5.4.22 The "after after body" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterBody(p, token) {
    if (token.tagName === $.HTML)
        startTagInBody(p, token);

    else
        tokenAfterAfterBody(p, token);
}

function tokenAfterAfterBody(p, token) {
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

//12.2.5.4.23 The "after after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterFrameset(p, token) {
    var tn = token.tagName;

    if (tn === $.HTML)
        startTagInBody(p, token);

    else if (tn === $.NOFRAMES)
        startTagInHead(p, token);
}


//12.2.5.5 The rules for parsing tokens in foreign content
//------------------------------------------------------------------
function nullCharacterInForeignContent(p, token) {
    token.chars = UNICODE.REPLACEMENT_CHARACTER;
    p._insertCharacters(token);
}

function characterInForeignContent(p, token) {
    p._insertCharacters(token);
    p.framesetOk = false;
}

function startTagInForeignContent(p, token) {
    if (ForeignContent.causesExit(token) && !p.fragmentContext) {
        while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML &&
               (!p._isMathMLTextIntegrationPoint(p.openElements.current)) &&
               (!p._isHtmlIntegrationPoint(p.openElements.current))) {
            p.openElements.pop();
        }

        p._processToken(token);
    }

    else {
        var current = p._getAdjustedCurrentElement(),
            currentNs = p.treeAdapter.getNamespaceURI(current);

        if (currentNs === NS.MATHML)
            ForeignContent.adjustTokenMathMLAttrs(token);

        else if (currentNs === NS.SVG) {
            ForeignContent.adjustTokenSVGTagName(token);
            ForeignContent.adjustTokenSVGAttrs(token);
        }

        ForeignContent.adjustTokenXMLAttrs(token);

        if (token.selfClosing)
            p._appendElement(token, currentNs);
        else
            p._insertElement(token, currentNs);
    }
}

function endTagInForeignContent(p, token) {
    for (var i = p.openElements.stackTop; i > 0; i--) {
        var element = p.openElements.items[i];

        if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
            p._processToken(token);
            break;
        }

        if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {
            p.openElements.popUntilElementPopped(element);
            break;
        }
    }
}

},{"../common/foreign_content":3,"../common/html":4,"../common/unicode":5,"../tokenization/tokenizer":14,"../tree_adapters/default":15,"./doctype":17,"./formatting_element_list":18,"./open_element_stack":19}],21:[function(require,module,exports){
Retool.IDE.HTMLParser.parse5 = require('./index');

},{"./index":2}]},{},[21]);
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());//@ sourceURL=retool-ide.js
Retool.launchIDE({assetRoot:"https://s3.amazonaws.com/retool-hosted-assets",apiHost:"",accountsHost:"",version:"1500"});